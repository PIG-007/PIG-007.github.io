<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><link rel="mask-icon" href="/%5Bobject%20Object%5D?v=2.6.2" color="#54bcff"><meta name="description" content="前言       南京大学《软件分析》课程笔记 南京大学《软件分析》课程01（Introduction）_哔哩哔哩_bilibili Tai-e (pascal-lab.net)                     一、Intermediate Representation                            1.中间语言编译">
<meta property="og:type" content="article">
<meta property="og:title" content="软件分析">
<meta property="og:url" content="http://pig-007.github.io/2023/02/01/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="PIG-007">
<meta property="og:description" content="前言       南京大学《软件分析》课程笔记 南京大学《软件分析》课程01（Introduction）_哔哩哔哩_bilibili Tai-e (pascal-lab.net)                     一、Intermediate Representation                            1.中间语言编译">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104924393.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221228171253505.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221228171835289.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221228180921880.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229182529367.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229182112639.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229195930007.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229200108674.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229200132805.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229200508572.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229201021799.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229201645109.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229201736630.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229202220689.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229202406452.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104952338.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230101356151.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230101529915.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230102820182.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230102900026.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230103138670.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230105038522.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230111227435.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230111953040.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230112722811.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230112140537.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230113741886.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230115302112.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230121324875.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230121420467.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230122517800.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230122538028.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230122557226.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230122957105.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230123059166.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230155034133.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230155541698.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230163405006.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230163808603.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230164205006.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171348741.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171409470.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171426774.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171452976.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171510996.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230170947293.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171054036.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230190653551.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230112722811.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230192724776.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230192931922.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230195310159.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230200017051.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230200156658.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105124710.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221231182008327.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221231183658759.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221231184741275.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105134416.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103115752131.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103154826254.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103164006781.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103170419300.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103173750413.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103164006781.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230104113135782.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230104123407058.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230104174021024.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230104175311848.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105227045.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230104181215325.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105112459293.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105112753506.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105113339502.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105115219367.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105115458209.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105120933460.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105122718787.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230106114548955.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230106114722837.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113100012796.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113105835279.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110307953.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110340228.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110408853.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110521314.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110536692.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110659618.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110742581.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110813614.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110813614.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113113450334.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113110940851.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113112521557.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113112947040.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113113112058.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113113906445.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113124541680.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113124706083.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105324445.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113144912366.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113145316011.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113145957855.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113150547144.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113150838229.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113151258381.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113152342466.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113152349767.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113152414219.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113152536353.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113153450361.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113155136287.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113160401076.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114103432918.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114103639748.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104116410.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104311457.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104435917.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104551016.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105245754.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105649355.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114111049511.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114111610469.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114111313810.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114111644983.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114111859758.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114112036216.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114142437257.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114143412980.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114144100365.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114150729422.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114152258172.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114153245606.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114155802247.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114155946021.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114160853754.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114161127326.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114161246125.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116104011048.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116104038107.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116104446528.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116104520952.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116112641178.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116114337394.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116114833417.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116115029573.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116114849027.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116114926158.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116115004261.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116115127433.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116120125591.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116121324230.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116123211552.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116123300983.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116140630003.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116140900865.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116141524281.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116142223691.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116153358145.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116161005808.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116175017004.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116182119855.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116182315115.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227111848832.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227144343229.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227144513373.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227145905255.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227151348799.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227152241402.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227152605132.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227152843432.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227153003163.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227153105750.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227154718912.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227161326592.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227161537640.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227162348110.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227163406069.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227163018057.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227163523979.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227165115263.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227165502792.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227170232579.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227171052291.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227171524578.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227172158603.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227172536628.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227172807051.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227172917941.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227173015546.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227173051279.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227174623063.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227174951813.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302105604591.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302111205711.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302111745720.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302111827518.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302112047551.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302113019796.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302114824189.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302141214011.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302142028418.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302143554661.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302144056744.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302144152217.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302144545841.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302145404139.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302150804549.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302152628874.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302155654514.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302161116389.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302161839478.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302163209957.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302165510010.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302165832151.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302165911690.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302170216610.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302170328419.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302170807480.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302171308228.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302171258044.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302171616516.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304114214942.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304113722316.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304114340189.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304114618338.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304114843239.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304115159940.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304120447356.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304121014989.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304120820220.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304121346571.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304122132934.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304122422841.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304143310016.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304143704679.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304144526463.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304144635715.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304150023175.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304151238672.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304151544492.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304152043659.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304152545326.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304152630082.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304153919785.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304154401211.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304155559173.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304160203485.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304160546783.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304160824947.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304161051316.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311103310452.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311105116933.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311104245405.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311104418530.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311105157450.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311105839092.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311111635015.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311112053774.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311112346195.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311112601320.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311113933344.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311141910814.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311152853949.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311153437690.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311154015447.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311113001636.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311114532642.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311154150284.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311154838944.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314102251546.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314103528905.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314104032554.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314145313166.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314145241336.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314145614781.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314193506350.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314202708702.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314203137454.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316101950460.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316102200598.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316102726071.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316103727673.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316104651630.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316113507233.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316114330648.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316121445007.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316121607565.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316121704079.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316154149995.png">
<meta property="og:image" content="http://pig-007.github.io/2023/02/AppData/Roaming/Typora/typora-user-images/image-20230316154211337.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316193520580.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316192306135.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317100320870.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317100927589.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317105418025.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317101652497.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317102104425.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317102902311.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317110045113.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317115113287.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318104624160.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318104906691.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318110806642.png">
<meta property="og:image" content="http://pig-007.github.io/2023/02/AppData/Roaming/Typora/typora-user-images/image-20230318110826465.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318111512158.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318111619066.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318111949117.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318112836799.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318113227337.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318113708808.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318114007467.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318114151787.png">
<meta property="og:image" content="http://pig-007.github.io/2023/02/AppData/Roaming/Typora/typora-user-images/image-20230318115246794.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318115926089.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318120030439.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318155627496.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318160018163.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318162255276.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318162203276.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318163010673.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318163145075.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318163231858.png">
<meta property="article:published_time" content="2023-02-01T02:25:33.000Z">
<meta property="article:modified_time" content="2023-09-11T13:35:14.868Z">
<meta property="article:author" content="PIG-007">
<meta property="article:tag" content="软件分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104924393.png"><title>软件分析 | PIG-007</title><link ref="canonical" href="http://pig-007.github.io/2023/02/01/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">Search</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">PIG-007</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">软件分析</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-02-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-09-11</span></span></div></header><div class="post-body">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>南京大学《软件分析》课程笔记</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1b7411K7P4/?spm_id_from=333.788&vd_source=1b73d83dc4431f8fc388b6891fa455ec" >南京大学《软件分析》课程01（Introduction）_哔哩哔哩_bilibili</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://tai-e.pascal-lab.net/" >Tai-e (pascal-lab.net)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="一、Intermediate-Representation"   >
          <a href="#一、Intermediate-Representation" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、Intermediate-Representation" class="headerlink" title="一、Intermediate Representation"></a>一、Intermediate Representation</h1>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104924393.png" alt="image-20230114104924393"></p>

        <h2 id="1-中间语言编译"   >
          <a href="#1-中间语言编译" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-中间语言编译" class="headerlink" title="1.中间语言编译"></a>1.中间语言编译</h2>
      
        <h3 id="1-过程"   >
          <a href="#1-过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-过程" class="headerlink" title="(1)过程"></a>(1)过程</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221228171253505.png" alt="image-20221228171253505"></p>
<ul>
<li>词法分析(<code>Lexical Analysis</code>)：从源代码到<code>Tokens</code>，检测单词是否正确</li>
<li>语法分析(<code>Syntax Analysis</code>)：从<code>Tokens</code>到<code>AST</code>，检测语法是否正确</li>
<li>语义分析(<code>Semantic Analysis</code>)：从<code>AST</code>到<code>Decorated AST</code>，检测语义或者说上下文，语境是否正确，比较复杂，一般在编程语言中不会涉及到，主要是自然语言才有的。</li>
<li>转换(<code>Translator</code>)：从<code>AST</code>到<code>IR</code>，即转换为三地址码，方便识别，最后生成机器码</li>
</ul>

        <h3 id="2-AST和IR"   >
          <a href="#2-AST和IR" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-AST和IR" class="headerlink" title="(2)AST和IR"></a>(2)<code>AST</code>和<code>IR</code></h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221228171835289.png" alt="image-20221228171835289"></p>
<p><code>IR</code>更利用静态分析，因为能够展现控制流程，语言无关性，更贴近于机器码。</p>

        <h2 id="2-Soot常见分析"   >
          <a href="#2-Soot常见分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Soot常见分析" class="headerlink" title="2.Soot常见分析"></a>2.<code>Soot</code>常见分析</h2>
      <p>从<code>JAVA</code>代码到<strong>三地址码</strong></p>

        <h3 id="For循环例子"   >
          <a href="#For循环例子" class="heading-link"><i class="fas fa-link"></i></a><a href="#For循环例子" class="headerlink" title="For循环例子"></a><code>For</code>循环例子</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForLoop3AC</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++)&#123;</span><br><span class="line">            x = x + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>转换为</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>&#123;</span><br><span class="line">	java.lang.String[] r0;</span><br><span class="line">    <span class="keyword">int</span> i1;</span><br><span class="line">    r0 := <span class="meta">@parameter0</span>: java.lang.String[]; <span class="comment">//参数类型的定义</span></span><br><span class="line">    </span><br><span class="line">    i1 = <span class="number">0</span>;		<span class="comment">//变量x</span></span><br><span class="line">    </span><br><span class="line">label1:			<span class="comment">//这里变量x和变量i被soot优化成一个变量i1了</span></span><br><span class="line">    <span class="keyword">if</span> i1 &gt;= <span class="number">10</span> goto label2;</span><br><span class="line">    </span><br><span class="line">    i1 = i1 + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    goto label1;</span><br><span class="line">   </span><br><span class="line">label2:</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="do-while以及数组例子"   >
          <a href="#do-while以及数组例子" class="heading-link"><i class="fas fa-link"></i></a><a href="#do-while以及数组例子" class="headerlink" title="do-while以及数组例子"></a><code>do-while</code>以及数组例子</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoWhileLoop3AC</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(arr[i] &lt; <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>转换为</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>&#123;</span><br><span class="line">	java.lang.String[] r0;</span><br><span class="line">    <span class="keyword">int</span>[] r1;</span><br><span class="line">    <span class="keyword">int</span> $i0,i1;</span><br><span class="line">    </span><br><span class="line">    r0 := <span class="meta">@parameter0</span>: java.lang.String[];<span class="comment">//参数类型定义</span></span><br><span class="line">    </span><br><span class="line">    r1 = newarray(<span class="keyword">int</span>)[<span class="number">10</span>]; <span class="comment">//array形式的赋值</span></span><br><span class="line">    </span><br><span class="line">    i1 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">label1:</span><br><span class="line">    i1 = i1 + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    $i0 = r1[i1]; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> $i0 &lt; <span class="number">10</span> goto label1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="函数调用例子"   >
          <a href="#函数调用例子" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数调用例子" class="headerlink" title="函数调用例子"></a>函数调用例子</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodCall3AC</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">foo</span><span class="params">(String para1, String para2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> para1 + <span class="string">&quot; &quot;</span> + para2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MethodCall3AC mc = <span class="keyword">new</span> MethodCall3AC();</span><br><span class="line">        String result = mc.foo(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>转换为</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">java.lang.<span class="function">String <span class="title">foo</span><span class="params">(java.lang.String, java.lang.String)</span></span>&#123;</span><br><span class="line">    nju.sa.example.MethodCall3AC r0;</span><br><span class="line">    java.lang.String r1,r2,$r7;</span><br><span class="line">    java.lang.StringBuilder $r3,$r4,$r5,$r6;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//参数类型和函数名</span></span><br><span class="line">    r0 := <span class="meta">@this</span>: nju.sa.examples.MethodCall3AC;</span><br><span class="line">    r1 := <span class="meta">@parameter0</span>: java.lang.String;</span><br><span class="line">    r2 := <span class="meta">@parameter1</span>: java.lang.String;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个String</span></span><br><span class="line">    $r3 = <span class="keyword">new</span> java.lang.StringBuilder;</span><br><span class="line">    specialinvoke $r3.&lt;java.lang.StringBuilder: <span class="keyword">void</span>&lt;init&gt;()&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用StringBuilder下的append,对应para1 + &quot; &quot; + para2</span></span><br><span class="line">    $r4 = virtualinvoke $r3.&lt;java.lang.StringBuilder: java.lang.<span class="function">StringBuilder <span class="title">append</span><span class="params">(java.lang.String)</span>&gt;<span class="params">(r1)</span></span>;</span><br><span class="line">    $r5 = virtualinvoke $r4.&lt;java.lang.StringBuilder: java.lang.<span class="function">StringBuilder <span class="title">append</span><span class="params">(java.lang.String)</span>&gt;<span class="params">(<span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">    $r6 = virtualinvoke $r5.&lt;java.lang.StringBuilder: java.lang.<span class="function">StringBuilder <span class="title">append</span><span class="params">(java.lang.String)</span>&gt;<span class="params">(r2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//完成之后需要toString来获取最终的变量</span></span><br><span class="line">    $r7 = virtualinvoke $r6.&lt;java.lang.StringBuilder: java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span>&gt;<span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> $r7;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>&#123;</span><br><span class="line">    java.lang.String[] r0;</span><br><span class="line">    nju.sa.examples.MethodCall3AC $r3;</span><br><span class="line">    </span><br><span class="line">    r0 := <span class="meta">@parameter0</span>: java.lang.String[];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个MethodCall3Ac</span></span><br><span class="line">    $r3 = <span class="keyword">new</span> nju.sa.examples.MethodCall3Ac;</span><br><span class="line">    specialinvoke $r3.&lt;nju.sa.examples.MethodCall3Ac: <span class="keyword">void</span> &lt;init&gt;()&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数调用</span></span><br><span class="line">    virtualinvoke $r3.&lt;nju.sa.examples.MethodCall3AC: java.lang.<span class="function">String <span class="title">foo</span><span class="params">(java.lang.String,java.lang.String)</span>&gt;<span class="params">(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里有个关于函数调用的知识点</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221228180921880.png" alt="image-20221228180921880"></p>
<p>不同<code>invoke</code>在三地址码中代表调用不同的函数，是在<code>JVM</code>虚拟机中的一种表示。</p>
<ul>
<li>在<code>&lt;method signature&gt;</code>中的<code>method signture</code>通常结构为<code>class name: return type method name(parameter1 type)</code></li>
</ul>

        <h3 id="静态变量和类"   >
          <a href="#静态变量和类" class="heading-link"><i class="fas fa-link"></i></a><a href="#静态变量和类" class="headerlink" title="静态变量和类"></a>静态变量和类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class3AC</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>转换为</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">nju</span>.<span class="title">sa</span>.<span class="title">examples</span>.<span class="title">Class3AC</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> pi;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> &lt;init&gt;()&#123;</span><br><span class="line">        nju.sa.examples.Class3AC r0;</span><br><span class="line">        </span><br><span class="line">        r0 := <span class="meta">@this</span>: nju.sa.examples.Class3AC;</span><br><span class="line">        </span><br><span class="line">        specialinvoke r0.&lt;java.lang.Object: <span class="keyword">void</span> &lt;init&gt;()&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>&#123;</span><br><span class="line">        java.lang.String[] r0;</span><br><span class="line">        </span><br><span class="line">        r0 := <span class="meta">@parameter0</span>: java.lang.String[];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态变量放在clinit函数中声明</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> &lt;clinit&gt;()&#123;</span><br><span class="line">        &lt;nju.sa.examples.Class3AC: <span class="keyword">double</span> pi&gt; = <span class="number">3.14</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="3-SSA-Static-Single-Assignment"   >
          <a href="#3-SSA-Static-Single-Assignment" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-SSA-Static-Single-Assignment" class="headerlink" title="3.SSA(Static Single Assignment)"></a>3.SSA(Static Single Assignment)</h2>
      <p>和三地址码<code>3AC</code>类似的一种表达方式，有优点也有缺点，但是大多用的是<code>3AC</code>，对于<code>SSA</code>区别如下</p>
<ul>
<li>每个定义的变量都有自己的不同名字</li>
<li>每个变量都有自己的定义</li>
</ul>
<p>比如</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229182529367.png" alt="image-20221229182529367"></p>
<p>如果有多的相同变量，则会有一个函数来判断，如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229182112639.png" alt="image-20221229182112639"></p>
<p>即<code>X2 = ∅(X0,X1) </code>会用来判断值到底是哪个</p>

        <h2 id="4-基础块-Basic-Block"   >
          <a href="#4-基础块-Basic-Block" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-基础块-Basic-Block" class="headerlink" title="4.基础块(Basic Block)"></a>4.基础块(Basic Block)</h2>
      
        <h3 id="定义："   >
          <a href="#定义：" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3>
      <ul>
<li>只有一个入口指令，入口指令为第一个指令</li>
<li>只有一个出口指令，出口指令为最后一个指令</li>
<li>一个跳转目的点应该是一个<code>BB</code>的入口指令</li>
</ul>

        <h3 id="方法："   >
          <a href="#方法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3>
      <p>如下为例子</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229195930007.png" alt="image-20221229195930007"></p>
<ul>
<li><p>首先确定程序中入口</p>
<p>即**(1)**为入口</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229200108674.png" alt="image-20221229200108674"></p>
</li>
<li><p>然后确定跳转指令的目的地址，标记为<code>leader</code>，依据指令**(4)<strong>、</strong>(10)<strong>和</strong>(11)<strong>即可确定这里即为</strong>(3)<strong>、</strong>(7)<strong>和</strong>(12)**</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229200132805.png" alt="image-20221229200132805"></p>
</li>
<li><p>跳转指令后面的指令为一个<code>leader</code>，依据指令**(4)<strong>、</strong>(10)<strong>和</strong>(11)<strong>即可确定这里即为</strong>(5)、(11)、(12)**</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229200508572.png" alt="image-20221229200508572"></p>
</li>
<li><p>依据<code>leader</code>来划分<code>BB</code>，即一个<code>BB</code>应该是由一个<code>leader</code>到下一个<code>leader</code>之间的所有指令构成，不包括下一个<code>leader</code></p>
<ul>
<li><p><code>leaders</code>： <strong>(1), (3), (5), (7), (11), (12)</strong></p>
</li>
<li><p>划分<code>BB</code>：</p>
<ul>
<li><code>BB1</code>：**(1)~(2)**</li>
<li><code>BB2</code>：**(3)~(5)**</li>
<li><code>BB3</code>：**(5)~(6)**</li>
<li><code>BB4</code>：**(7)~(10)**</li>
<li><code>BB5</code>：**(11)**</li>
<li><code>BB6</code>：**(12)**</li>
</ul>
</li>
<li><p>得到最终<code>BB</code>结构</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229201021799.png" alt="image-20221229201021799"></p>
</li>
</ul>
</li>
</ul>

        <h2 id="5-CFG-Control-Flow-Graph"   >
          <a href="#5-CFG-Control-Flow-Graph" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-CFG-Control-Flow-Graph" class="headerlink" title="5.CFG(Control Flow Graph)"></a>5.CFG(Control Flow Graph)</h2>
      
        <h3 id="定义：-1"   >
          <a href="#定义：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3>
      <ul>
<li>每个节点<code>node</code>为一个<code>BB</code></li>
<li>两个节点<code>node</code>之间只能有一条边</li>
</ul>

        <h3 id="方法：-1"   >
          <a href="#方法：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h3>
      <ul>
<li><p>首先跳转指令的跳转目的地址都修改为对应的<code>BB</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229201645109.png" alt="image-20221229201645109"></p>
</li>
<li><p>然后依据跳转指令，将对应跳转进行连边，即得到</p>
<p><code>B2-&gt;B4</code>、<code>B4-&gt;B6</code>、<code>B5-&gt;B2</code>三条边</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229201736630.png" alt="image-20221229201736630"></p>
</li>
<li><p>从程序入口到程序出口间所有的<code>BB</code>，由上至下两两添加一条边，除了包含无条件跳转的<code>BB</code>，那么得到</p>
<p><code>B1-&gt;B2</code>、<code>B2-&gt;B3</code>、<code>B3-&gt;B4</code>、<code>B4-&gt;B5</code>四条边，由于<code>B5</code>出口指令为无条件跳转，所以<code>B5-&gt;B6</code>没有边，得到如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229202220689.png" alt="image-20221229202220689"></p>
</li>
<li><p>依据边的方向，得到各个<code>BB</code>之间的前驱后继的关系</p>
</li>
<li><p>加入<code>Entry</code>和<code>Exit</code>，得到如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221229202406452.png" alt="image-20221229202406452"></p>
</li>
</ul>

        <h1 id="二、Data-Flow-Analysis-I"   >
          <a href="#二、Data-Flow-Analysis-I" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、Data-Flow-Analysis-I" class="headerlink" title="二、Data Flow Analysis I"></a>二、Data Flow Analysis I</h1>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104952338.png" alt="image-20230114104952338"></p>
<p>即数据(DATA)在CFG(Control Flow Graph)中<code>Flow</code>的过程分析</p>

        <h2 id="1-基本概念"   >
          <a href="#1-基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2>
      
        <h3 id="常见符号"   >
          <a href="#常见符号" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见符号" class="headerlink" title="常见符号"></a>常见符号</h3>
      <ul>
<li><p>抽象符号</p>
<ul>
<li><p><code>⊥</code>：未定义</p>
</li>
<li><p><code>+、-</code>：常见正负表示</p>
</li>
<li><p><code>0</code>：即零</p>
</li>
</ul>
</li>
</ul>

        <h3 id="IN-S-和OUT-S"   >
          <a href="#IN-S-和OUT-S" class="heading-link"><i class="fas fa-link"></i></a><a href="#IN-S-和OUT-S" class="headerlink" title="IN[S]和OUT[S]"></a>IN[S]和OUT[S]</h3>
      <p>一个<code>IR</code>语句的输入数据集合以及输出数据集合，如下所示</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230101356151.png" alt="image-20221230101356151"></p>
<p>然后也区分几种状况，如下所示</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230101529915.png" alt="image-20221230101529915"></p>
<ul>
<li><p>状况1：<code>IN[S2] = OUT[S1]</code>，常见流程</p>
</li>
<li><p>状况2：<code>IN[S2]、IN[S3] = OUT[S1]</code>，分支流程</p>
</li>
<li><p>状况3：<code>IN[S2] = OUT[S1] ^ OUT[S3]</code>，交汇流程</p>
<p>其中的合并操作称为<code>meet</code>操作，常见有取交集、并集之类的，需要定义</p>
</li>
</ul>

        <h3 id="分析方向"   >
          <a href="#分析方向" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析方向" class="headerlink" title="分析方向"></a>分析方向</h3>
      <ul>
<li><p><code>Forward Analysis</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230102820182.png" alt="image-20221230102820182"></p>
<p>相关公式<br>$$<br>OUT[s] = f_s(IN[s])<br>$$</p>
</li>
<li><p><code>Backward Analysis</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230102900026.png" alt="image-20221230102900026"></p>
<p>相关公式<br>$$<br>IN[s] = f_s(OUT[s])<br>$$</p>
</li>
</ul>

        <h2 id="2-BB之间的分析"   >
          <a href="#2-BB之间的分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-BB之间的分析" class="headerlink" title="2.BB之间的分析"></a>2.<code>BB</code>之间的分析</h2>
      <ul>
<li><p>在一个基本块<code>BB</code>中</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230103138670.png" alt="image-20221230103138670"></p>
<p><code>IN[s]</code>以及<code>OUT[s]</code>可以用一个循环表示<br>$$<br>IN[s_{i+1}] = OUT[s_i], for\ all\ i = 1,2, …, n-1\<br>OUT[s_i] = f_s(IN[s_{i-1}])<br>$$</p>
</li>
<li><p>同样的多个基本块<code>BB</code>中</p>
<ul>
<li>即<code>B1 -&gt; B2 -&gt; B3</code>这样的</li>
</ul>
<p>$$<br>IN[B] = IN[s_1],  OUT[B] = OUT[s_n]\<br>OUT[B] = f_B(IN[B]), f_B = f_{sn} \ ⚬ \ …\  ⚬\  f_{s2}\ ⚬\ f_{s1}<br>$$</p>
<ul>
<li><p>当然还有其它的，交汇</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230105038522.png" alt="image-20221230105038522"></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN[B] = ^p OUT[p]</span><br></pre></td></tr></table></div></figure>

<p>其中<code>^p</code>代表取所有的<code>p</code>做<code>meet</code>操作</p>
</li>
<li><p>还有分支，分支的<code>OUT[B]</code>都等于下一个的<code>IN[B.]</code></p>
</li>
</ul>
</li>
</ul>

        <h2 id="3-Reaching-Definition"   >
          <a href="#3-Reaching-Definition" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Reaching-Definition" class="headerlink" title="3.Reaching Definition"></a>3.Reaching Definition</h2>
      <p>即一个变量<code>v</code>从定义点<code>p</code>，到某一点<code>q</code>这条路径中，<code>v</code>没有再被重新定义，那么这条路径可以被当作<code>Reaching Definition</code>，如果再被重新定义了，则不能，如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230111227435.png" alt="image-20221230111227435"></p>

        <h3 id="Data-Flow-Facts"   >
          <a href="#Data-Flow-Facts" class="heading-link"><i class="fas fa-link"></i></a><a href="#Data-Flow-Facts" class="headerlink" title="Data Flow Facts"></a>Data Flow Facts</h3>
      <p>将所有定义变量的语句标记为一个<code>bit</code>向量</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230111953040.png" alt="image-20221230111953040"></p>

        <h3 id="Control-Flow"   >
          <a href="#Control-Flow" class="heading-link"><i class="fas fa-link"></i></a><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h3>
      <p>用来求<code>IN[B]</code>，例子如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230112722811.png" alt="image-20221230112722811"></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN[B] = Up  predecessor of B OUT[p]</span><br></pre></td></tr></table></div></figure>

<p>其中<code>Up</code>代表取<code>B</code>的前驱，即所有的<code>p</code>做<code>union</code>操作，即并集</p>

        <h3 id="Transfer-Function"   >
          <a href="#Transfer-Function" class="heading-link"><i class="fas fa-link"></i></a><a href="#Transfer-Function" class="headerlink" title="Transfer Function"></a>Transfer Function</h3>
      <p>即数据流分析中的转换函数的相关定义，<code>forward</code>下知道<code>IN[B]</code>用来求<code>OUT[B]</code><br>$$<br>OUT[B] = gen_B\ U\ (IN[B] - kill_B)<br>$$</p>
<ul>
<li><code>genB</code>：表示当前基本块中定义的所有变量的合集</li>
<li><code>killB</code>：表示当前基本块中定义的所有变量，并且这些变量在其他基本块中也被定义了的合集</li>
</ul>
<p>例子如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230112140537.png" alt="image-20221230112140537"></p>

        <h3 id="Algorithm"   >
          <a href="#Algorithm" class="heading-link"><i class="fas fa-link"></i></a><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230113741886.png" alt="image-20221230113741886"></p>
<p>其中对于每个<code>BB</code>的赋值，在<code>may analysis</code>中大多为空，而在<code>must analysis</code>中大多不为空，所以并没有把<code>OUT[entry] = ∅; </code>加进来</p>

        <h4 id="例子"   >
          <a href="#例子" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子" class="headerlink" title="例子"></a>例子</h4>
      <p>如下所示，初始化之后即可迭代</p>

        <h5 id="第一次迭代"   >
          <a href="#第一次迭代" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次迭代" class="headerlink" title="第一次迭代"></a>第一次迭代</h5>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230115302112.png" alt="image-20221230115302112"></p>
<ul>
<li><p><code>Entry-&gt;B1</code>：</p>
<ul>
<li><p><code>OUT[Entry] = 0000 0000</code></p>
</li>
<li><p><code>IN[B1] = Up OUT[p] = OUT[Entry] = 0000 0000</code></p>
</li>
<li><p><code>genB1 = D1 + D2 = 1100 0000 </code></p>
</li>
<li><p><code>killB1 = D5 + D7 + D4 = 0001 1010  </code></p>
</li>
<li><p><code>IN[B1] - killB1 = 0000 0000 - 0001 1010 = 0000 0000</code></p>
<p>都是0，减去之后还是0</p>
</li>
<li><p><code>OUT[B1] = genB1 U (IN[B1] - killB1) = 1100 0000 + 0000 0000 = 1100 0000</code>   </p>
</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230121324875.png" alt="image-20221230121324875"></p>
</li>
<li><p><code>B1-&gt;B2</code>：</p>
<ul>
<li><code>OUT[B1] = genB1 U (IN[B1] - killB1) = 1100 0000 + 0000 0000 = 1100 0000</code>   </li>
<li><code>IN[B2]  = Up OUT[p] = OUT[B1] + OUT[B4] = 1100 0000</code></li>
<li><code>genB2 = D3 + D4 = 0011 0000 </code></li>
<li><code>killB2 = D2 = 0100 0000  </code></li>
<li><code>IN[B2] - killB2 = 1100 0000 - 0100 0000 = 1000 0000</code></li>
<li><code>OUT[B2] = genB2 U (IN[B2] - killB2) = 0011 0000 + 1000 0000 = 1011 0000</code>   </li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230121420467.png" alt="image-20221230121420467"></p>
</li>
<li><p><code>B2-&gt;B3</code>：</p>
<ul>
<li><p><code>OUT[B2] = genB2 U (IN[B2] - killB2) = 0011 0000 + 1000 0000 = 1011 0000</code>   </p>
</li>
<li><p><code>IN[B3]  = Up OUT[p] = OUT[B2] = 1011 0000</code></p>
</li>
<li><p><code>genB3 = D7 = 0000 0010</code></p>
</li>
<li><p><code>killB3 = D1 + D5  = 1000 1000</code></p>
</li>
<li><p><code>IN[B3] - killB3 = 1011 0000 - 1000 1000 = 0011 0000</code></p>
</li>
<li><p><code>OUT[B3] = genB3 U (IN[B3] - killB3) = 0000 0010 + 0011 0000 = 0011 0010</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230122517800.png" alt="image-20221230122517800"></p>
</li>
</ul>
</li>
<li><p><code>B2-&gt;B4</code>：</p>
<ul>
<li><p><code>OUT[B2] = genB2 U (IN[B2] - killB2) = 0011 0000 + 1000 0000 = 1011 0000</code>   </p>
</li>
<li><p><code>IN[B4] = Up OUT[p] = OUT[B2] = 1011 0000 </code></p>
</li>
<li><p><code>genB4 = D5 + D6 = 0000 1100</code></p>
</li>
<li><p><code>killB4 = D1 + D7 + D8 = 1000 0011</code></p>
</li>
<li><p><code>IN[B4] - killB4 = 1011 0000 - 1000 0011 = 0011 0000</code></p>
</li>
<li><p><code>OUT[B4] = genB4 U (IN[B4] - killB4) = 0000 1100 + 0011 0000 = 0011 1100</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230122538028.png" alt="image-20221230122538028"></p>
</li>
</ul>
</li>
<li><p><code>B4、B3-&gt;B5</code></p>
<ul>
<li><p><code>OUT[B3] = genB3 U (IN[B3] - killB3) = 0000 0010 + 0011 0000 = 0011 0010</code></p>
</li>
<li><p><code>OUT[B4] = genB4 U (IN[B4] - killB4) = 0000 1100 + 0011 0000 = 0011 1100</code></p>
</li>
<li><p><code>IN[B5] = Up OUT[p] = OUT[B3] + OUT[B4] = 0011 0010 + 0011 1100 = 0011 1110</code></p>
</li>
<li><p><code>genB5 = D8 = 0000 0001</code></p>
</li>
<li><p><code>killB5 = D6 = 0000 0100</code></p>
</li>
<li><p><code>IN[B5] - killB5 = 0011 1110 - 0000 0100 = 0011 1010</code></p>
</li>
<li><p><code>OUT[B5] = genB5 U (IN[B5] - killB5) = 0000 0001 + 0011 1010 = 0011 1011</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230122557226.png" alt="image-20221230122557226"></p>
</li>
</ul>
</li>
</ul>
<p>那么由于第一次迭代之后，<code>B1、B2、B3、B4、B5</code>的<code>OUT</code>都发生改变了，所以继续迭代，所有基本块的<code>OUT</code>被本次迭代结果替换</p>

        <h5 id="第二次迭代"   >
          <a href="#第二次迭代" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次迭代" class="headerlink" title="第二次迭代"></a>第二次迭代</h5>
      <p>完成如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230122957105.png" alt="image-20221230122957105"></p>
<p>那么基本块<code>B2、B3</code>的<code>OUT</code>发生了改变，接着迭代</p>

        <h5 id="第三次迭代"   >
          <a href="#第三次迭代" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次迭代" class="headerlink" title="第三次迭代"></a>第三次迭代</h5>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230123059166.png" alt="image-20221230123059166"></p>
<p>迭代之后，所有基本块的<code>OUT</code>都没有发生改变，那么即可得到最终结果。</p>

        <h5 id="最终含义"   >
          <a href="#最终含义" class="heading-link"><i class="fas fa-link"></i></a><a href="#最终含义" class="headerlink" title="最终含义"></a>最终含义</h5>
      <p>依据最终结果，即所有基本块的<code>OUT[Bn]</code>可得，比如对于<code>OUT[B1]</code>而言，对应结果为<code>1100 0000</code>，代表<code>D1、D2</code>可以<code>Reach</code>到<code>B1</code>结束的地方，也就是说<code>D1、D2</code>所定义的变量从被定义到<code>B1</code>结束的地方都不会被改变。</p>

        <h1 id="三、Data-Flow-Analysis-Applications-II"   >
          <a href="#三、Data-Flow-Analysis-Applications-II" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、Data-Flow-Analysis-Applications-II" class="headerlink" title="三、Data Flow Analysis - Applications II"></a>三、Data Flow Analysis - Applications II</h1>
      
        <h2 id="1-Live-Variables-Analysis"   >
          <a href="#1-Live-Variables-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Live-Variables-Analysis" class="headerlink" title="1.Live Variables Analysis"></a>1.Live Variables Analysis</h2>
      <p>即存在一个变量<code>v</code>在点<code>p</code>被定义，然后程序中还存在一个变量<code>v</code>被使用的地方<code>use(v)</code>，满足从<code>p</code>到<code>use(v)</code>这条路径上，<code>v</code>没有被重新定义，那么可以称为变量<code>v</code>在点<code>p</code>到<code>use(v)</code>这条路径上是存活的，如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230155034133.png" alt="image-20221230155034133"></p>
<ul>
<li>应用</li>
</ul>
<p>比如寄存器满的状态，这时候在<code>p</code>点发现变量<code>v</code>是<code>dead</code>的，并且该变量在寄存器中，那么新的变量最好就是替换掉<code>dead</code>变量<code>v</code>。</p>

        <h3 id="Data-Flow-Facts-1"   >
          <a href="#Data-Flow-Facts-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Data-Flow-Facts-1" class="headerlink" title="Data Flow Facts"></a>Data Flow Facts</h3>
      <p>将所有变量的标记为一个<code>bit</code>向量，和之前类似，<code>1</code>表<code>alive</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230155541698.png" alt="image-20221230155541698"></p>

        <h3 id="Control-Flow-1"   >
          <a href="#Control-Flow-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Control-Flow-1" class="headerlink" title="Control Flow"></a>Control Flow</h3>
      <p>用来求<code>OUT[B]</code>的，例子如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230163405006.png" alt="image-20221230163405006"></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUT[B] = Us successor of B IN[S]</span><br></pre></td></tr></table></div></figure>

<p>其中<code>Us</code>代表取<code>B</code>的后继，即所有的<code>s</code>做<code>union</code>操作，即并集</p>

        <h3 id="Transfer-Function-1"   >
          <a href="#Transfer-Function-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Transfer-Function-1" class="headerlink" title="Transfer Function"></a>Transfer Function</h3>
      <p>由于是<code>backward</code>，所以即知道<code>OUB[B]</code>来求<code>IN[B]</code><br>$$<br>IN[B] = use_B\ U\ (OUT[B]\ -\ def_B)<br>$$</p>
<ul>
<li><p><code>useB</code>：在基本块<code>BB</code>中在重定义之前被使用的变量的合集</p>
<p>比如某个基本块<code>v = 2; k = v</code>，由于<code>v</code>是在被重定义之后被使用的，所以变量<code>v</code>不被归入到<code>useB</code>中</p>
</li>
<li><p><code>defB</code>：在基本块<code>BB</code>中被重定义或首次定义的变量的合集</p>
</li>
</ul>

        <h3 id="Algorithm-1"   >
          <a href="#Algorithm-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Algorithm-1" class="headerlink" title="Algorithm"></a>Algorithm</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230163808603.png" alt="image-20221230163808603"></p>
<p>同样进行简单初始化即可开始迭代</p>

        <h4 id="例子-1"   >
          <a href="#例子-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4>
      <p>如下所示，初始化之后即可迭代</p>

        <h5 id="第一次迭代-1"   >
          <a href="#第一次迭代-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次迭代-1" class="headerlink" title="第一次迭代"></a>第一次迭代</h5>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230164205006.png" alt="image-20221230164205006"></p>
<ul>
<li><p><code>Exit-&gt;B5</code>：</p>
<ul>
<li><code>IN[Exit] = 000 0000</code></li>
<li> <code>OUT[B5] = Us IN[s] = IN[Exit] = 000 0000</code></li>
<li><code>defB5 = z = 001 0000</code></li>
<li><code>useB5 = p = 000 1000</code></li>
<li><code>OUT[B5] - defB5 = 000 0000</code></li>
<li><code>IN[B5] = useB5 + (OUT[B5] - defB5) = 000 1000 + 000 0000 = 000 1000 </code></li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171348741.png" alt="image-20221230171348741"></p>
</li>
<li><p><code>B5-&gt;B3</code>：</p>
<ul>
<li><code>IN[B5] = useB5 + (OUT[B5] - defB5) = 000 0100 + 000 0000 = 000 1000 </code></li>
<li><code>OUT[B3] = Us IN[s] = IN[B5] = 000 1000</code></li>
<li><code>defB3 = x = 100 0000</code></li>
<li><code>useB3 = x = 100 0000</code></li>
<li><code>OUT[B3] - defB3 = 000 1000</code></li>
<li><code>IN[B3] = useB3 + (OUT[B3] - defB3) = 100 0000 + 000 1000 = 100 1000</code></li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171409470.png" alt="image-20221230171409470"></p>
</li>
<li><p><code>B5-&gt;B4</code>：</p>
<ul>
<li><code>IN[B5] = useB5 + (OUT[B5] - defB5) = 000 0100 + 000 0000 = 000 1000 </code></li>
<li><code>OUT[B4] = Us IN[s] = IN[B5] + IN[B2] = 000 1000 + 000 0000 = 000 1000 </code></li>
<li><code>defB4 = x + q = 100 0100</code>  </li>
<li><code>useB4 = y = 010 0000</code></li>
<li><code>OUT[B4] - defB4 = 000 1000</code></li>
<li><code>IN[B4] = useB4 + (OUT[B4] - defB4) = 010 0000 + 000 1000 = 010 1000</code> </li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171426774.png" alt="image-20221230171426774"></p>
</li>
<li><p><code>B4、B3-&gt;B2</code>:</p>
<ul>
<li><p><code>IN[B4] = useB4 + (OUT[B4] - defB4) = 010 0000 + 000 1000 = 010 1000</code> </p>
</li>
<li><p><code>IN[B3] = useB3 + (OUT[B3] - defB3) = 100 0000 + 000 1000 = 100 1000</code></p>
</li>
<li><p><code>OUT[B2] = Us IN[s] = IN[B3] + IN[B4] = 110 1000 </code></p>
</li>
<li><p><code>defB2 = m + y = 010 0010</code></p>
</li>
<li><p><code>useB2 = k = 000 0001</code></p>
<p>注意<code>m</code>是在被使用之前重定义了，所以不能算在<code>useB2</code>中</p>
</li>
<li><p><code>OUT[B2] - defB2 = 100 1000</code></p>
</li>
<li><p><code>IN[B2] = useB2 + (OUT[B2] - defB2) = 000 0001 + 100 1000 = 100 1001</code></p>
</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171452976.png" alt="image-20221230171452976"></p>
</li>
<li><p><code>B2-&gt;B1</code>：</p>
<ul>
<li><code>IN[B2] = userB2 + (OUT[B2] - defB2) = 000 0001 + 100 1000 = 100 1001</code></li>
<li><code>OUT[B1] = Us IN[s] = IN[B2] = 100 1001</code></li>
<li><code>defB1 = x + y = 110 0000</code></li>
<li><code>useB1 = p + q + z = 001 1100</code></li>
<li><code>OUT[B1] - defB1 = 000 1001</code></li>
<li><code>IN[B1] = useB1 + (OUT[B1] - defB1) = 001 1100 + 000 1001 = 001 1101</code></li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171510996.png" alt="image-20221230171510996"></p>
</li>
</ul>
<p>基本块<code>B1、B2、B3、B4、B5</code>的<code>IN[]</code>都发生改变，需要再次迭代，结果如下</p>

        <h5 id="第二次迭代-1"   >
          <a href="#第二次迭代-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次迭代-1" class="headerlink" title="第二次迭代"></a>第二次迭代</h5>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230170947293.png" alt="image-20221230170947293"></p>
<p>其中<code>B4</code>的<code>IN[]</code>发生改变，需要再次迭代，结果如下</p>

        <h5 id="第三次迭代-1"   >
          <a href="#第三次迭代-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次迭代-1" class="headerlink" title="第三次迭代"></a>第三次迭代</h5>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230171054036.png" alt="image-20221230171054036"></p>
<p>没有基本块的<code>IN[]</code>被改变了，那么不用迭代了</p>

        <h5 id="最终含义-1"   >
          <a href="#最终含义-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#最终含义-1" class="headerlink" title="最终含义"></a>最终含义</h5>
      <p>同样道理，依据最终结果，比如这里的<code>IN[B3]</code>为<code>100 1000</code>，那么代表在进入基本块<code>B3</code>之前，变量<code>x、p</code>是存活的，在之后的流程中会用到，其他变量在之后的流程不会用到，为<code>dead</code>变量</p>

        <h2 id="2-Available-Expressions-Analysis"   >
          <a href="#2-Available-Expressions-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Available-Expressions-Analysis" class="headerlink" title="2.Available Expressions Analysis"></a>2.Available Expressions Analysis</h2>
      <ul>
<li><p>概念</p>
<p>一个表达式<code>x op y</code>如果说在在<code>p</code>点是<code>available</code>的话，那么满足如下条件：</p>
<ul>
<li><p>所有从<code>entry</code>到<code>p</code>的路径都会计算表达式<code>x op y</code></p>
</li>
<li><p>在最后一次计算表达式<code>x op y</code>之后，到<code>p</code>之前，没有再重新定义变量<code>x</code>或者<code> y</code></p>
</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>可以将一个<code>available</code>的表达式<code>x op y</code>的计算结果，替换成上一次计算表达式<code>x op y </code>的结果，使得不再重复计算</li>
<li>用来检测全局公用的子表达式</li>
</ul>
</li>
<li><p>类型：</p>
<ul>
<li>属于是<code>must analysis</code>，一旦分析出结果，代表该结果一定正确，一定是为<code>available</code></li>
</ul>
</li>
</ul>

        <h3 id="Data-Flow-Facts-2"   >
          <a href="#Data-Flow-Facts-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#Data-Flow-Facts-2" class="headerlink" title="Data Flow Facts"></a>Data Flow Facts</h3>
      <p>和之前类似，将所有表达式都用<code>bit</code>向量表示，为1代表<code>available</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230190653551.png" alt="image-20221230190653551"></p>

        <h3 id="Control-Flow-2"   >
          <a href="#Control-Flow-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#Control-Flow-2" class="headerlink" title="Control Flow"></a>Control Flow</h3>
      <p><code>forward</code>中求<code>IN[B]</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230112722811.png" alt="image-20221230112722811"></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN[B] = ∩p predecessor of B OUT[p]</span><br></pre></td></tr></table></div></figure>

<p>即为<code>∩p</code>求基本块<code>B</code>所有前驱的<code>OUT[p]</code>的交集</p>

        <h3 id="Transfer-Function-2"   >
          <a href="#Transfer-Function-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#Transfer-Function-2" class="headerlink" title="Transfer Function"></a>Transfer Function</h3>
      <p>为<code>forward</code>，知道<code>IN[B]</code>用来求<code>OUT[B]</code><br>$$<br>OUT[B] = gen_B\ U\ (IN[B] - kill_B)<br>$$</p>
<ul>
<li><p><code>genB</code>：当前基本块中用到的表达式</p>
</li>
<li><p><code>killB</code>：所有在<code>IN[]</code>中的表达式的变量参与进基本块<code>B</code>中重新定义的表达式合集</p>
<p>比如基本块<code> a = x op y</code>，其中<code>IN[B]</code>为<code>a + b</code>，那么由于<code>IN</code>中变量<code>a</code>在基本块<code>B</code>中重新定义了，所以将<code>IN[B]</code>中关于变量<code>a</code>的表达式都加入到<code>killB</code>中</p>
</li>
</ul>

        <h3 id="Algorithm-2"   >
          <a href="#Algorithm-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#Algorithm-2" class="headerlink" title="Algorithm"></a>Algorithm</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230192724776.png" alt="image-20221230192724776"></p>
<p>这里的除了<code>entry</code>外，其他基本块都初始化为<code>top</code>，即<code>1111..111</code>，因为就算有个表达式没有找出来，那就只是代表少优化一次，不影响程序本身的运行流程</p>

        <h4 id="例子-2"   >
          <a href="#例子-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4>
      <p>如下所示，初始化之后即可开始迭代</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230192931922.png" alt="image-20221230192931922"></p>

        <h5 id="第一次迭代-2"   >
          <a href="#第一次迭代-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次迭代-2" class="headerlink" title="第一次迭代"></a>第一次迭代</h5>
      <ul>
<li><p><code>Entry-&gt;B1</code>：</p>
<ul>
<li><code>OUT[Entry] = 00000</code></li>
<li><code>IN[B1] = ∩p predecessor of B OUT[p] = OUT[Entry] = 00000</code></li>
<li><code>genB1 = p-1 = 10000</code></li>
<li><code>killB1 = 00000</code></li>
<li><code>IN[B1] - killB1 = 00000</code></li>
<li><code>OUT[B1] = genB1 + (IN[B1] - killB1) = 10000</code></li>
</ul>
</li>
<li><p><code>B1-&gt;B2</code>：</p>
<ul>
<li><code>OUT[B1] = 10000 </code></li>
<li><code>IN[B2] = ∩p predecessor of B OUT[p] = OUT[B1] ∩ OUT[B4] = 10000 ∩ 11111 = 10000</code></li>
<li><code>genB2 = z/5和e^7*x = 01010</code></li>
<li><code>killB2 = p-1 = 10000</code></li>
<li><code>IN[B2] - killB2 = 00000</code></li>
<li><code>OUT[B2] = genB2 + (IN[B2] - killB2) = 01010</code></li>
</ul>
</li>
<li><p><code>B2-&gt;B3</code>：</p>
<ul>
<li><p><code>OUT[B2] = 01010</code></p>
</li>
<li><p><code>IN[B3] = ∩p predecessor of B OUT[p] = OUT[B2] = 01010</code></p>
</li>
<li><p><code>genB3 = y+3 = 00001</code></p>
</li>
<li><p><code>killB3 = 01000</code></p>
<p>其中<code>z</code>在<code>IN[B3]</code>中有表达式<code>z/5</code>用到，那么需要将对应表达式加入到<code>killB3</code>集合中</p>
</li>
<li><p><code>IN[B3] - killB3 = 00010</code></p>
</li>
<li><p><code>OUT[B3] = genB3 + (IN[B3] - killB3) = 00011</code></p>
</li>
</ul>
</li>
<li><p><code>B2-&gt;B4</code>：</p>
<ul>
<li><code>OUT[B2] = 01010</code></li>
<li><code>IN[B4] = ∩p predecessor of B OUT[p] = OUT[B2] = 01010</code></li>
<li><code>genB4 = 2*y和e^7*x = 00110</code></li>
<li><code>killB4 = 00010</code></li>
<li><code>IN[B4] - killB4 = 01000</code></li>
<li><code>OUT[B4] = genB3 + (IN[B4] - killB4) = 01110</code></li>
</ul>
</li>
<li><p><code>B3、B4-&gt;B5</code>：</p>
<ul>
<li><code>OUT[B3] = 00011</code></li>
<li><code>OUT[B4] = 01110</code></li>
<li><code>IN[B5] = ∩p predecessor of B OUT[p] = OUT[B4] ∩ OUT[B3] = 00010</code></li>
<li><code>genB5 = e^7*x和z/5 = 01010</code></li>
<li><code>killB5 = 00000</code></li>
<li><code>IN[B5] - killB5 = 00010</code></li>
<li><code>OUT[B5] = genB5 + (IN[B5] - killB5) = 01010</code></li>
</ul>
</li>
</ul>
<p>基本块<code>B1、B2、B3、B4、B5</code>的<code>OUT[]</code>都发生改变，需要再次遍历</p>

        <h5 id="第二次迭代-2"   >
          <a href="#第二次迭代-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次迭代-2" class="headerlink" title="第二次迭代"></a>第二次迭代</h5>
      <p>同理可得，结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230195310159.png" alt="image-20221230195310159"></p>
<p>没有基本块的<code>OUT[]</code>发生改变，可为最终结果</p>

        <h5 id="最终含义-2"   >
          <a href="#最终含义-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#最终含义-2" class="headerlink" title="最终含义"></a>最终含义</h5>
      <p>依据最终结果，拿基本块<code>B2</code>而言，对于表达式<code>e^7*x</code>是<code>available</code>的，那么在程序第一次经过<code>B2</code>时，由于表达式<code>e^7*x</code>还没被计算，那么先计算，然后保存。当通过循环第二次经过<code>B2</code>时，其表达式<code>e^7*x</code>就可以被直接替换为上一次表达式的值，在这里也就是在基本块<code>B4</code>中得到的值，其他的同理可得。</p>

        <h2 id="3-Data-Flow-Analysis总结"   >
          <a href="#3-Data-Flow-Analysis总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Data-Flow-Analysis总结" class="headerlink" title="3.Data Flow Analysis总结"></a>3.Data Flow Analysis总结</h2>
      
        <h3 id="异同"   >
          <a href="#异同" class="heading-link"><i class="fas fa-link"></i></a><a href="#异同" class="headerlink" title="异同"></a>异同</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230200017051.png" alt="image-20221230200017051"></p>

        <h3 id="需要掌握的"   >
          <a href="#需要掌握的" class="heading-link"><i class="fas fa-link"></i></a><a href="#需要掌握的" class="headerlink" title="需要掌握的"></a>需要掌握的</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221230200156658.png" alt="image-20221230200156658"></p>
<p>三种数据流分析算法、异同以及为什么迭代算法可以停止</p>
<p>停止的原因就是迭代到最后，最差的情况就是全是<code>top:1111..</code>或者全是<code>bottom:0000....</code></p>

        <h1 id="四、Data-Flow-Analysis-Foundations-I"   >
          <a href="#四、Data-Flow-Analysis-Foundations-I" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、Data-Flow-Analysis-Foundations-I" class="headerlink" title="四、Data Flow Analysis - Foundations I"></a>四、Data Flow Analysis - Foundations I</h1>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105124710.png" alt="image-20230114105124710"></p>

        <h2 id="1-偏序-Partial-Order"   >
          <a href="#1-偏序-Partial-Order" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-偏序-Partial-Order" class="headerlink" title="1.偏序(Partial Order)"></a>1.偏序(Partial Order)</h2>
      <p><code>poset</code>偏序集</p>
<p>性质：<br>$$<br>\begin{align}<br>&amp;\forall x \in P,x\subseteq x\quad &amp;(Reflexivity)\<br>&amp;\forall x,y \in P,x\subseteq y ∧ y\subseteq x =&gt;x=y\quad &amp;(Antisymmetry)\<br>&amp;\forall x,y,z\in P,x\subseteq y ∧ y\subseteq z =&gt;x \subseteq z \quad &amp;(Transitivity)<br>\end{align}<br>$$</p>

        <h2 id="2-Upper-and-Lower-Bounds"   >
          <a href="#2-Upper-and-Lower-Bounds" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Upper-and-Lower-Bounds" class="headerlink" title="2.Upper and Lower Bounds"></a>2.Upper and Lower Bounds</h2>
      <p>$$<br>u\in P,u\ is \ an \ upper\ bound\ of\ S,if\ \forall x\in S,x\subseteq u\<br>l\in P,l\ is \ an \ lower\ bound\ of\ S,if\ \forall x\in S,l\subseteq x\<br>$$</p>
<ul>
<li><p><code>lub/join(least upper bound)</code></p>
<p><code>lub</code>定义符号为<code>⊔S</code>，满足<code>⊔S ⊑ u</code>，<code>u</code>为上界</p>
</li>
<li><p><code>glb/meet(greatest lower bound)</code></p>
<p><code>glb</code>定义符号为<code>⊓S</code>，满足<code>l ⊑ ⊓S</code>，</p>
</li>
<li><p>如果<code>S ⊑ P(P,⊑)  </code>，并且<code>S</code>只有两个元素，假定为<code>S=&#123;a,b&#125;</code>，那么可得如下</p>
<ul>
<li><code>⊔S = a⊔b  (join)</code></li>
<li><code>⊓S = a⊓b  (meet)</code></li>
</ul>
</li>
<li><p>不是所有偏序集都有最大下界或者最小上界</p>
</li>
<li><p>如果一个偏序集有最大下界或者最小上界，那么一定是唯一的</p>
</li>
</ul>

        <h2 id="3-Lattice"   >
          <a href="#3-Lattice" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Lattice" class="headerlink" title="3.Lattice"></a>3.Lattice</h2>
      
        <h3 id="Lattice-格"   >
          <a href="#Lattice-格" class="heading-link"><i class="fas fa-link"></i></a><a href="#Lattice-格" class="headerlink" title="Lattice(格)"></a>Lattice(格)</h3>
      <p>如果一个偏序集中任意两个元素组成一个集合，都有最小上界和最大下界存在，那么该偏序集即为一个<code>lattice</code></p>
<p><code>P(P,⊑), ∀a,b∈P, a⊔b and a⊓b exists =&gt; P is a lattice </code></p>

        <h3 id="Semilattice-半格"   >
          <a href="#Semilattice-半格" class="heading-link"><i class="fas fa-link"></i></a><a href="#Semilattice-半格" class="headerlink" title="Semilattice(半格)"></a>Semilattice(半格)</h3>
      <p>如果一个偏序集中任意两个元素组成一个集合，最小上界和最大下界中只有一个存在，那么该偏序集即为一个<code>Semilattice</code></p>
<ul>
<li><code>join semilattic</code>：<code>a⊔b</code>存在，<code>a⊓b</code>不存在</li>
<li><code>meet semilattic</code>：<code>a⊓b</code>存在，<code>a⊔b</code>不存在</li>
</ul>

        <h3 id="Complete-Lattic-全格"   >
          <a href="#Complete-Lattic-全格" class="heading-link"><i class="fas fa-link"></i></a><a href="#Complete-Lattic-全格" class="headerlink" title="Complete Lattic(全格)"></a>Complete Lattic(全格)</h3>
      
        <h4 id="定义：-2"   >
          <a href="#定义：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h4>
      <p>如果对于一个偏序集中任意一个子集，都有最小上界和最大下界存在，那么该偏序集即为一个<code>Complete Lattice</code></p>
<p>每一个全集都有一个最大元素和最小元素</p>
<ul>
<li>最大元素<code>(a greatest element T) = ⊔P = top</code></li>
<li>最小元素<code>(a least element ⊥) = ⊓P = bottom</code></li>
</ul>

        <h4 id="性质："   >
          <a href="#性质：" class="heading-link"><i class="fas fa-link"></i></a><a href="#性质：" class="headerlink" title="性质："></a>性质：</h4>
      <p>所有有限的<code>Lattice</code>都是<code>Complete Lattic</code>，但是一个<code>Complete Lattic</code>不一定是有限的，比如<code>0-1</code>这个偏序集中所有实数(包括0,1)作为一个集合，存在边界，是一个<code>Complete Lattic</code>，但是里面的子集的元素就可以是无限的。</p>

        <h3 id="Product-Lattice"   >
          <a href="#Product-Lattice" class="heading-link"><i class="fas fa-link"></i></a><a href="#Product-Lattice" class="headerlink" title="Product Lattice"></a>Product Lattice</h3>
      <p>一个<code>Lattice</code>合集，其中所有<code>Lattice</code>都由最小上界和最大上界，那么即可称该<code>Lattice</code>合集为一个<code>Product Lattice</code></p>

        <h2 id="4-Fixed-Point"   >
          <a href="#4-Fixed-Point" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Fixed-Point" class="headerlink" title="4.Fixed-Point"></a>4.Fixed-Point</h2>
      
        <h3 id="Monotonicity-单调"   >
          <a href="#Monotonicity-单调" class="heading-link"><i class="fas fa-link"></i></a><a href="#Monotonicity-单调" class="headerlink" title="Monotonicity(单调)"></a>Monotonicity(单调)</h3>
      <p>对于一个<code>Lattice L</code>，有函数<code>f:∀x∈L,f(x)∈L</code>，假定该函数存在单调性，则<code>L</code>满足单调</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">∀x,y∈L,x⊑y =&gt; f(x)⊑f(y)</span><br></pre></td></tr></table></div></figure>

<p>🔺<strong>mark：那单调性怎么证明呢？</strong></p>

        <h3 id="Fixed-Point-Theorem-不动点理论"   >
          <a href="#Fixed-Point-Theorem-不动点理论" class="heading-link"><i class="fas fa-link"></i></a><a href="#Fixed-Point-Theorem-不动点理论" class="headerlink" title="Fixed-Point Theorem(不动点理论)"></a>Fixed-Point Theorem(不动点理论)</h3>
      <p>给定一个<code>Complete Lattice L</code>，<code>L</code>满足单调且有限，那么可以用来求不动点</p>

        <h4 id="最小不动点"   >
          <a href="#最小不动点" class="heading-link"><i class="fas fa-link"></i></a><a href="#最小不动点" class="headerlink" title="最小不动点"></a>最小不动点</h4>
      
        <h5 id="含义"   >
          <a href="#含义" class="heading-link"><i class="fas fa-link"></i></a><a href="#含义" class="headerlink" title="含义"></a>含义</h5>
      <p>$$<br>f(⊥),f(f(⊥)),…..,f^k(⊥)会达到最小不动点<br>$$</p>

        <h5 id="证明"   >
          <a href="#证明" class="heading-link"><i class="fas fa-link"></i></a><a href="#证明" class="headerlink" title="证明"></a>证明</h5>
      <ul>
<li><p>首先是存在不动点证明<br>$$<br>\begin{align}<br>&amp;\because\forall x,y\in L,x\subseteq y =&gt; f(x)\subseteq f(y)(Monntonicity)\<br>&amp;\therefore⊥\subseteq f(⊥)\<br>&amp;\therefore f(⊥)\subseteq f(f(⊥)) = f^2(⊥)\<br>&amp;\therefore ⊥\subseteq f(⊥) \subseteq f^2(⊥)\subseteq …\subseteq f^i(⊥)\<br>&amp;\because L\ is\ finite\<br>&amp;\therefore f^{Fix} = f^k(⊥) = f^{k+1}(⊥)<br>\end{align}<br>$$</p>
</li>
<li><p>然后是证明求得的不动点是最小不动点，还是不太理解提到的数学归纳法，既然从<code>⊥</code>开始做<code>f</code>，那么到某个<code>k</code>就必定存在不动点，那么将<code>x</code>也做<code>k</code>个<code>f</code>不就好了吗。</p>
<p>假定存在其他的不动点<code>x</code>，那么有<code>x = f(x),⊥⊑x</code><br>$$<br>\begin{align}<br>&amp;\because\forall x,y\in L,x\subseteq y =&gt; f(x)\subseteq f(y)(Monntonicity)\<br>&amp;\therefore f(⊥)\subseteq f(x)\<br>&amp;\therefore f^2(⊥)\subseteq f^2(x)…f^i(x)\subseteq f^i(x)\<br>&amp;\because \exist k,f^k(⊥) =  f^{Fix}\<br>&amp;\therefore f^{Fix} = f^k(⊥) \subseteq f^k(x)=x\<br>\end{align}<br>$$<br>那么就代表通过<code>⊥</code>求得的不动点一定是最小不动点，这里和李樾老师不一样，我也不知道能不能这么写，老师原版是数学归纳法<code>induction</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221231182008327.png" alt="image-20221231182008327"></p>
</li>
</ul>

        <h4 id="最大不动点"   >
          <a href="#最大不动点" class="heading-link"><i class="fas fa-link"></i></a><a href="#最大不动点" class="headerlink" title="最大不动点"></a>最大不动点</h4>
      
        <h5 id="含义-1"   >
          <a href="#含义-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#含义-1" class="headerlink" title="含义"></a>含义</h5>
      <p>$$<br>f(T),f(f(T)),…..,f^k(T)会达到最大不动点<br>$$</p>

        <h5 id="证明-1"   >
          <a href="#证明-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5>
      <p>证明和最小不动点证明类似</p>

        <h2 id="5-应用"   >
          <a href="#5-应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-应用" class="headerlink" title="5.应用"></a>5.应用</h2>
      <p>这里把老师上课讲的放到最后了</p>

        <h3 id="理论应用"   >
          <a href="#理论应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#理论应用" class="headerlink" title="理论应用"></a>理论应用</h3>
      <p>即依据<code>Lattice</code>的定义，将之前提到的算法中</p>
<ul>
<li><p>需要求的所有的<code>OUT/IN</code>当作一个元素<code>V(111..0000...)</code>，依据相关性质可知道该元素<code>V</code>为一个<code>Complete Lattice</code>，任意子集都有最大下界和最小上界，并且<code>finite</code><br>$$<br>&amp;OUT[B_1]&amp;OUT[B_2]&amp;…&amp;OUT[B_n]\<br>&amp;V_1 &amp;V_2&amp;…&amp;V_n<br>$$</p>
</li>
<li><p>将<code>Transfer function</code>作为刚刚提到的给定的<code>f</code>函数，其单调性需要证明，**(这里好像还没有证明)**那么每迭代一轮，就相当于对所有的<code>IN/OUT</code>做一次<code>Transfer function</code>。</p>
</li>
<li><p>将每一次迭代结果合并为一个集合<code>Xi</code>，可知该集合为一个<code>Product Lattice</code>，此外该<code>Product Lattice Xi(finite)</code>中所有元素均为一个<code>Complete Lattice</code>，那么该<code>Xi</code>也是一个<code>Complete Lattice</code>，然后加入<code>Transfer function</code>可得如下结果</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221231183658759.png" alt="image-20221231183658759"></p>
</li>
</ul>
<p>那么即可用到<code>Fixed-Point Theorem</code>(不动点)理论来求最终结果，回答如下问题</p>

        <h3 id="问题"   >
          <a href="#问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#问题" class="headerlink" title="问题"></a>问题</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20221231184741275.png" alt="image-20221231184741275"></p>
<ul>
<li>算法是否能够确保有解，可达不动点？</li>
<li>是否只有一个不动点，通过算法求解得到的不动点是否是最好的？</li>
<li>什么时候可以达到不动点？</li>
</ul>
<p>🔺<strong>mark：好像后面两个问题还没有解决</strong></p>

        <h1 id="五、Data-Flow-Analysis-Foundations-II"   >
          <a href="#五、Data-Flow-Analysis-Foundations-II" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、Data-Flow-Analysis-Foundations-II" class="headerlink" title="五、Data Flow Analysis - Foundations II"></a>五、Data Flow Analysis - Foundations II</h1>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105134416.png" alt="image-20230114105134416"></p>

        <h2 id="1-Prove-Function-F-is-Monotonic"   >
          <a href="#1-Prove-Function-F-is-Monotonic" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Prove-Function-F-is-Monotonic" class="headerlink" title="1.Prove Function F is Monotonic"></a>1.Prove Function F is Monotonic</h2>
      
        <h3 id="分析："   >
          <a href="#分析：" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3>
      <p>一般而言<code>F</code>形式为<code>OUT/IN = gen ⊓/⊔ (IN/OUT - kill)</code></p>
<p>由于对于每一个基本块<code>BB</code>而言，<code>gen</code>和<code>kill</code>都是固定的，即为单调的常数，所以这里的需要证明的就是<code>⊓/⊔</code>是否为单调的，先证明<code>⊔</code>为单调，证明方法对<code>⊓</code>同理</p>

        <h3 id="证明如下："   >
          <a href="#证明如下：" class="heading-link"><i class="fas fa-link"></i></a><a href="#证明如下：" class="headerlink" title="证明如下："></a>证明如下：</h3>
      <p><code>⊔</code>定义：求任意两个元素的最小上界</p>
<p>想要证明<code>⊔</code>为单调，即转化为证明如下结论<br>$$<br>\forall x,y,z\in L,x\subseteq y\ =&gt;\ x⊔z\subseteq y⊔z<br>$$<br>证明过程：<br>$$<br>\begin{align}<br>&amp;\therefore y⊔z\ is\ an\ least\ upper\ bound\ of\  y\<br>&amp;\therefore y\subseteq y⊔z\<br>&amp;\because x\subseteq y\<br>&amp;\therefore x\subseteq y⊔z\ =&gt;\ y⊔z\ is\ an\ upper\  bound\ of\ x  \<br>&amp;\because x⊔z\ is\ an\ least\ upper\ bound\ of\ x\<br>&amp;\therefore x⊔z\subseteq y⊔z<br>\end{align}<br>$$<br>证毕</p>
<p>那么即可得到对于每一个基本块的<code>Function F</code>是单调的，由于每次迭代的时候的<code>f</code>即代表对每一个基本块做<code>Function F</code>，所以<code>f</code>也是单调的。</p>

        <h2 id="2-Time-Complexity"   >
          <a href="#2-Time-Complexity" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Time-Complexity" class="headerlink" title="2.Time Complexity"></a>2.Time Complexity</h2>
      <p>即什么时候到达不动点</p>
<ul>
<li><p>偏序集高度<code>h</code>定义，从<code>Top</code>到<code>Bottom</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103115752131.png" alt="image-20230103115752131"></p>
</li>
</ul>
<p>那么一个算法中有个<code>k</code>个<code>node</code>，最坏情况就是，每次迭代，只有一个<code>node</code>的一个<code>bit</code>从<code>0-&gt;1</code>。而<code>bit</code>的数量其实就是偏序集的高度<code>h</code>，从而得到最坏的情况就是迭代<code>h*k</code>次，从而把所有<code>node</code>的所有<code>bit</code>都从<code>0-&gt;1</code>，时间复杂度即为<code>h*k</code>。</p>

        <h2 id="3-May-and-Must-Analyses-a-Lattice-View"   >
          <a href="#3-May-and-Must-Analyses-a-Lattice-View" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-May-and-Must-Analyses-a-Lattice-View" class="headerlink" title="3.May and Must Analyses,a Lattice View"></a>3.May and Must Analyses,a Lattice View</h2>
      <p>将一个<code>Lattice</code>抽象称一个图形，如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103154826254.png" alt="image-20230103154826254"></p>
<p><code>May Analysis/Must Analysis</code>基本都是从<code>unsafe-&gt;safe</code>的过程，也就是<code>safe-approximation</code>主要就是如下的图</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103164006781.png" alt="image-20230103164006781"></p>
<ul>
<li><code>May</code>：<ul>
<li>从<code>Bottom-&gt;Top</code>，从不准确到准确，达到<code>Least Fixed Point</code>。</li>
<li>比如<code>Reaching Definition</code>，<code>unSafe</code>就是<code>No definitions can reach</code>到<code>safe</code>，也就是<code>All definitions may reach</code>的过程。 </li>
</ul>
</li>
<li><code>Must</code>：<ul>
<li>从<code>Top-&gt;Bottom</code>，也是从不准确到准确，达到<code>Greatest Fixed Point</code>。</li>
<li>比如<code>Expressions available</code>，它的<code>safe</code>就必须是<code>No expressions are available</code>。因为误报了一个<code>expression</code>是<code>available</code>的话，那么整个程序优化之后就会出错，所以它的<code>safe</code>只能是<code>No expressions are available</code>，然后即可推得其他的。</li>
</ul>
</li>
</ul>
<p>大概是懂了，但是如果再来设计一个算法，是依据什么原则或者什么方法来将它设计成<code>Must</code>还是<code>May</code>呢。</p>
<p>比如活跃变量分析，其应用通常是用来提高寄存器利用率的，用来求<code>dead</code>变量的，就算求不出来<code>dead</code>变量，其实对程序实际的运行结果并不会造成影响，所以应该设计成<code>May</code>。<strong>但是能不能设计成<code>Must</code>呢？</strong>设计成<code>Must</code>是会出错，还是会导致优化程度不够高呢，好像是后者把。</p>

        <h2 id="4-How-Precise-Is-Our-Solution"   >
          <a href="#4-How-Precise-Is-Our-Solution" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-How-Precise-Is-Our-Solution" class="headerlink" title="4.How Precise Is Our Solution"></a>4.How Precise Is Our Solution</h2>
      
        <h3 id="Meet-Over-All-Paths-Solution-MOP"   >
          <a href="#Meet-Over-All-Paths-Solution-MOP" class="heading-link"><i class="fas fa-link"></i></a><a href="#Meet-Over-All-Paths-Solution-MOP" class="headerlink" title="Meet-Over-All-Paths Solution(MOP)"></a>Meet-Over-All-Paths Solution(MOP)</h3>
      <p>即所有从<code>Entry</code>到该某点<code>Si</code>的<code>Path</code>的一些运算</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103170419300.png" alt="image-20230103170419300"></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOP[Si] = ⊔/⊓  Fp(OUT[Entry])</span><br></pre></td></tr></table></div></figure>

<p>其中<code>Fp</code>代表从<code>Entry</code>到<code>Si</code>某条路径的所有<code>Transfer funstion</code>的一个集合函数。比如有一条路径为<code>Entry-&gt;S1-&gt;S2-&gt;...-&gt;Si</code>，那么整条路径从<code>Entry-&gt;Si-1</code>可得<code>OUT[Si-1] = Fp(OUT[Entry])</code></p>
<p><code>MOP[Si]</code>即求所有路径（当然不同路径的<code>Si-1</code>可能不同）到<code>Si</code>的一个<code>meet/join</code>，也就是将不同路径的<code>OUT[Si-1]</code>做一个<code>meet/join</code>操作。</p>
<p>有些<code>Path</code>在实际的动态运行过程中可能不存在，但是在静态分析时会将之归入进来计算。</p>

        <h3 id="MOP-vs-Ours-Iterative-Algorithm"   >
          <a href="#MOP-vs-Ours-Iterative-Algorithm" class="heading-link"><i class="fas fa-link"></i></a><a href="#MOP-vs-Ours-Iterative-Algorithm" class="headerlink" title="MOP vs Ours(Iterative Algorithm)"></a>MOP vs Ours(Iterative Algorithm)</h3>
      <p>假定如下情况</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103173750413.png" alt="image-20230103173750413"></p>
<p>依据定义可分别得到对应的结果<br>$$<br>\begin{align}<br>&amp;Ours[S4]=IN[S4]=f_{s3}(f_{s1}(OUT[Entry])⊔f_{s2}(OUT[Entry]))\<br>&amp;MOP[S4]=IN[S4]=f_{s3}(f_{s1}(OUT[Entry]))⊔f_{s3}(f_{s2}(OUT[Entry]))<br>\end{align}<br>$$<br>其中<code>fs1(OUT[Entry])</code>和<code>fs2(OUT[Entry])</code>是一样的，那么将之抽象为<code>x</code>和<code>y</code>，<code>fs3</code>抽象为<code>F</code>可得简化后的结果</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ours = F(x⊔y)</span><br><span class="line">MOP  = F(x)⊔F(y)</span><br></pre></td></tr></table></div></figure>

<p>证明一下两者的关系<br>$$<br>\begin{align}<br>&amp;\therefore x\subseteq x⊔y\ and\ y\subseteq x⊔y\<br>&amp;\because ∀x,y\in L,x\subseteq y =&gt; F(x)\subseteq F(y)(Monotonic)\<br>&amp;\therefore F(x)\subseteq F(x⊔y)\ and\ F(x)\subseteq F(x⊔y)\<br>&amp;\therefore F(x⊔y)\ is\ an\ upper\ bound\ of\ F(x)\ and\ F(y)\<br>&amp;\because F(x)⊔F(y)\ is\ an\ least\ upper\ bound\ of\ F(x)\ and F(y)\<br>&amp;\therefore F(x)⊔F(y)\subseteq F(x⊔y)\<br>&amp;\therefore MOP\subseteq Ours<br>\end{align}<br>$$<br>又因为如下关系图</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230103164006781.png" alt="image-20230103164006781"></p>
<p>在<code>may analysis</code>中，越接近上界越不准确，所以<code>Ours</code>比<code>MOP</code>更加不准确</p>
<p>但是如果满足<code>Transfer function F </code>是<code>distributive</code>（可分配的），即分配律，那么可得<code>F(x⊔y) = F(x)⊔F(y)</code>的，那么<code>MOP=Ours</code>。即当<code>Transfer function</code>是可分配的，即代表<code>MOP</code>其实是等价于<code>Ours</code>的。</p>
<p><strong>有个结论：</strong></p>
<p><code>Bit-vector or Gen/Kill problems (set union/intersection for join/meet) are distributive</code></p>
<p>就是前面提到的关于<code>Bit-Vector</code>方法定义的，或者是<code>Gen/Kill</code>定义的<code>Transfer function</code>都是可以分配的</p>

        <h2 id="5-Constant-Propagation"   >
          <a href="#5-Constant-Propagation" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Constant-Propagation" class="headerlink" title="5.Constant Propagation"></a>5.Constant Propagation</h2>
      <p>使用的是<code>MOP</code></p>

        <h3 id="Data-Flow-Facts-3"   >
          <a href="#Data-Flow-Facts-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#Data-Flow-Facts-3" class="headerlink" title="Data Flow Facts"></a>Data Flow Facts</h3>
      <p>将所有的变量是否为常量都表达为一个组合<code>pairs</code>，即<code>(x,v)</code>，也就是当前经过<code>node</code>之后的<code>OUT</code>中该变量<code>x</code>的值<code>v</code></p>

        <h3 id="Control-Flow-3"   >
          <a href="#Control-Flow-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#Control-Flow-3" class="headerlink" title="Control Flow"></a>Control Flow</h3>
      <p>和<code>Expression Analysis</code>一样，应该是<code>Must</code>的，因为<code>safe</code>的时候，应该是所有变量都不是常量，对应在<code>Bottom</code>，也就是<code>NAC(Not an constant)</code>。而由于是组合键值<code>pair</code>形式，所以<code>Top</code>应该是<code>undefine</code>，也就是<code>UNDEF</code>形式，最终如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230104113135782.png" alt="image-20230104113135782"></p>
<p>然后需要设计一下<code>Meet</code>操作，表达式同样类似</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN[B] = ⊓p predecessor of B OUT[p]</span><br></pre></td></tr></table></div></figure>

<p>一个变量<code>v</code>与另一个进来的值对应的无非如下几种情况</p>
<ul>
<li><p><code>v ⊓ UNDEF = v</code></p>
<p>没定义的碰见另一个，当然直接相当于另一个了</p>
</li>
<li><p><code>v ⊓ NAC = NAC</code></p>
<p>既然已经确定不是常量，那么无论另一边值是啥，该变量必定不是常量了</p>
</li>
<li><p><code>v ⊓ constant</code></p>
<ul>
<li><p><code>c ⊓ c = c</code></p>
<p>两边均为常量才是常量</p>
</li>
<li><p><code>c1 ⊓ c2 = NAC</code></p>
<p>两边值不同就不是常量了</p>
</li>
<li><p><code>UNDEF ⊓ c = c</code>(和前面一样)</p>
</li>
<li><p><code>NAC ⊓ c = NAC</code>(和前面一样)</p>
</li>
</ul>
</li>
</ul>

        <h3 id="Transfer-Function-3"   >
          <a href="#Transfer-Function-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#Transfer-Function-3" class="headerlink" title="Transfer Function"></a>Transfer Function</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F: OUT[s] = gen⊔(IN[s] - &#123;(x, _)&#125;)</span><br></pre></td></tr></table></div></figure>

<p>即需要去掉所有其他<code>node</code>中关于变量<code>x</code>的键值对<code>pair</code>，然后加上当前生成的变量键值对<code>pair</code>。</p>
<p>使用函数<code>val(x)</code>来求对应<code>x</code>的值，然后对应不同的<code>statement</code>有如下情况</p>
<ul>
<li><code>s : x = constant;</code></li>
<li><code>s : x = y;</code></li>
<li><code>s : x = y op z;</code><ul>
<li><code>f(y,z) = val(y) op val(z) //val(y)和val(z)都是常量时</code></li>
<li><code>f(y,z) = NAC   //val(y)或者val(z)有一个是NAC时</code></li>
<li><code>f(y,z) = UNDEF  //其他情况</code></li>
</ul>
</li>
</ul>
<p> 是一个<code>Nondistributivity</code>，例子如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230104123407058.png" alt="image-20230104123407058"></p>

        <h3 id="Worklist-Algorithm"   >
          <a href="#Worklist-Algorithm" class="heading-link"><i class="fas fa-link"></i></a><a href="#Worklist-Algorithm" class="headerlink" title="Worklist Algorithm"></a>Worklist Algorithm</h3>
      <p>一个<code>Iterative Algorithm</code>的优化算法</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230104174021024.png" alt="image-20230104174021024"></p>
<p><code>Iterative Algorithm</code>只要变化了一个，其他的都会重新计算，而<code>Worklist Algorithm</code>是只计算当前轮次变化的<code>OUT[B]</code>以及后续的<code>OUT[B]</code>，相当于用空间换取时间。</p>
<p>原因就是一个<code>Transfer function</code>，<code>IN[]</code>没有变，那么<code>OUT[]</code>肯定也是没有变。</p>
<p>主要是图中黄色的部分，相比于<code>Iterative Algorithm</code>是有些改变的。</p>

        <h2 id="Foundations总结"   >
          <a href="#Foundations总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#Foundations总结" class="headerlink" title="Foundations总结"></a>Foundations总结</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230104175311848.png" alt="image-20230104175311848"></p>
<p><code>Iterative algorithm</code>、<code>Lattice</code>定义、不动点理论、<code>may/must</code>分析、<code>MOP</code>和<code>Iterative algorithm</code>的异同比较、常量分析、<code>Worklist algorithm</code></p>

        <h1 id="六、Interprocedural-Analysis"   >
          <a href="#六、Interprocedural-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、Interprocedural-Analysis" class="headerlink" title="六、Interprocedural Analysis"></a>六、Interprocedural Analysis</h1>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105227045.png" alt="image-20230114105227045"></p>
<p>之前学的都是过程内分析<code>intraprocedural analysis</code>，接下来要学习过程间分析<code>Interprocedural Analysis</code>，即函数调用的相关分析</p>

        <h2 id="1-Motivation"   >
          <a href="#1-Motivation" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Motivation" class="headerlink" title="1.Motivation"></a>1.Motivation</h2>
      <p>如果不进行相关的<code>Interprocedural Analysis</code>，那么当遇到函数调用时，通常解决办法都是<code>safe-approximation</code>，也就是将之判定为一个<code>safe</code>地方的<code>Facts</code>。比如对于<code>Constant Analysis</code>而言，就会函数调用返回的结果判定为<code>NAC</code>，更加安全。</p>

        <h3 id="一些定义："   >
          <a href="#一些定义：" class="heading-link"><i class="fas fa-link"></i></a><a href="#一些定义：" class="headerlink" title="一些定义："></a>一些定义：</h3>
      <p>如下所示，在函数之前存在相关的<code>call edges</code>，以及<code>return edges</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230104181215325.png" alt="image-20230104181215325"></p>

        <h2 id="2-Call-Graph-Construction"   >
          <a href="#2-Call-Graph-Construction" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Call-Graph-Construction" class="headerlink" title="2.Call Graph Construction"></a>2.Call Graph Construction</h2>
      
        <h3 id="定义"   >
          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义" class="headerlink" title="定义"></a>定义</h3>
      <p>调用图是程序中一个函数调用边<code>call edges</code>集合，比如如下所示，左边为程序，右边即为它的调用图</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105112459293.png" alt="image-20230105112459293"></p>

        <h3 id="面向对象语言调用图常见算法"   >
          <a href="#面向对象语言调用图常见算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向对象语言调用图常见算法" class="headerlink" title="面向对象语言调用图常见算法"></a>面向对象语言调用图常见算法</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105112753506.png" alt="image-20230105112753506"></p>

        <h2 id="3-Method-Calls-Invocations-in-Java"   >
          <a href="#3-Method-Calls-Invocations-in-Java" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Method-Calls-Invocations-in-Java" class="headerlink" title="3.Method Calls (Invocations) in Java"></a>3.Method Calls (Invocations) in Java</h2>
      <p>在<code>JAVA</code>中通常存在三种调用方法，而在<code>JAVA8</code>中还引入了<code>invokedynamic</code>，这个是特殊用途，不讨论</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105113339502.png" alt="image-20230105113339502"></p>
<p>主要是对于<code>Vitual call</code>，一个调用由于传入的对象不同，可能对应不同的方法。这个是实现<code>OO(Object-Oriented)</code>语言中多态<code>polymorphism</code>的关键点，也是静态分析中的难点。</p>

        <h3 id="Method-Dispatch-of-Vitual-Calls"   >
          <a href="#Method-Dispatch-of-Vitual-Calls" class="heading-link"><i class="fas fa-link"></i></a><a href="#Method-Dispatch-of-Vitual-Calls" class="headerlink" title="Method Dispatch of Vitual Calls"></a>Method Dispatch of Vitual Calls</h3>
      
        <h4 id="定义-1"   >
          <a href="#定义-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4>
      <p>即程序运行时动态求解<code>Vitual Calls</code>动态函数方法的过程，就叫做<code>Method Dispatch</code>，求解一般需要以下两个要素</p>
<ul>
<li>传入对象的类型</li>
<li>函数签名，<code>call site</code>不知道啥意思<ul>
<li><code>Signature = class type + method name + descriptor</code><ul>
<li><code>descriptor = return type + parameter types</code></li>
</ul>
</li>
</ul>
</li>
</ul>

        <h4 id="Dispatch-Function-Defination"   >
          <a href="#Dispatch-Function-Defination" class="heading-link"><i class="fas fa-link"></i></a><a href="#Dispatch-Function-Defination" class="headerlink" title="Dispatch Function Defination"></a>Dispatch Function Defination</h4>
      <p>依据<code>Method Dispatch</code>定义来确定对应方法定义</p>
<ul>
<li><code>c</code>：即<code>class</code>，传入对象的类型</li>
<li><code>m</code>：即函数签名</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105115219367.png" alt="image-20230105115219367"></p>
<p><code>Dispatch</code>是寻找可以调用的函数，那么可以调用的函数一定是要确保该函数是有具体的函数体的，不能是抽象的<code>non-abstract</code></p>

        <h4 id="例子-3"   >
          <a href="#例子-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105115458209.png" alt="image-20230105115458209"></p>
<ul>
<li><code>Dispatch(B,A.foo())</code>：先从<code>B</code>中找，找不到就找父类，也就是<code>A</code>，从<code>A</code>中获取到<code>foo</code>函数。</li>
<li><code>Dispathc(C,A.foo())</code>：先从<code>C</code>中找，直接找到，那么即为<code>c</code>中的<code>foo</code>函数。</li>
</ul>

        <h2 id="4-Class-Hierarchy-Analysis-CHA"   >
          <a href="#4-Class-Hierarchy-Analysis-CHA" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Class-Hierarchy-Analysis-CHA" class="headerlink" title="4.Class Hierarchy Analysis(CHA)"></a>4.Class Hierarchy Analysis(CHA)</h2>
      <ul>
<li>需要一个类的相关继承结构</li>
<li>求解一个<code>vitural call</code>依据于定义类型和传入的对象</li>
</ul>

        <h3 id="Call-Resolution-of-CHA"   >
          <a href="#Call-Resolution-of-CHA" class="heading-link"><i class="fas fa-link"></i></a><a href="#Call-Resolution-of-CHA" class="headerlink" title="Call Resolution of CHA"></a>Call Resolution of CHA</h3>
      <p>定义方法<code>Resolve(cs)</code>为具体算法分析实例</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105120933460.png" alt="image-20230105120933460"></p>
<p>其中</p>
<ul>
<li><code>cs</code> : 当前分析的语句</li>
<li><code>m </code> : 函数签名 </li>
<li><code>c^m</code> : <code>m</code>对应的类型</li>
</ul>
<p>具体分析一下</p>

        <h4 id="static-call"   >
          <a href="#static-call" class="heading-link"><i class="fas fa-link"></i></a><a href="#static-call" class="headerlink" title="static call"></a>static call</h4>
      <p>例子如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T <span class="title">foo</span><span class="params">(P p,Q q)</span></span>&#123;....&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C.foo(x,y);</span><br></pre></td></tr></table></div></figure>

<p>可得对应变量含义<br>$$<br>\begin{align}<br>&amp;cs : C.foo(x,y); &amp;//当前需要方法解析语句\<br>&amp;m : &lt;C: T\ foo(P,Q)&gt; &amp;//函数签名\<br>\end{align}<br>$$<br>直接返回了对应函数签名的<code>m</code></p>

        <h4 id="speciall-call"   >
          <a href="#speciall-call" class="heading-link"><i class="fas fa-link"></i></a><a href="#speciall-call" class="headerlink" title="speciall call"></a>speciall call</h4>
      
        <h5 id="superclass-instance-methods"   >
          <a href="#superclass-instance-methods" class="heading-link"><i class="fas fa-link"></i></a><a href="#superclass-instance-methods" class="headerlink" title="superclass instance methods"></a>superclass instance methods</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">foo</span><span class="params">(P p,Q q)</span></span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">super</span>.foo(p,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可得对应变量含义<br>$$<br>\begin{align}<br>&amp;cs:super.foo(p,q);\<br>&amp;m:&lt;B: T\ foo(P,Q)&gt;\<br>&amp;c^m:B<br>\end{align}<br>$$<br>由于是<code>super</code>，所以对应对象类型为<code>B</code>。同时需要注意的是这里不能把<code>super</code>直接替换为<code>B</code>，因为可能<code>B</code>中没有定义<code>foo</code>函数，而是在其父类中定义，如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230105122718787.png" alt="image-20230105122718787"></p>

        <h5 id="Constructors-Private-instance-mthods"   >
          <a href="#Constructors-Private-instance-mthods" class="heading-link"><i class="fas fa-link"></i></a><a href="#Constructors-Private-instance-mthods" class="headerlink" title="Constructors/Private instance mthods"></a>Constructors/Private instance mthods</h5>
      <p>这两个可以放到一起</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class C extends B&#123;</span><br><span class="line">	<span class="function">T <span class="title">foo</span><span class="params">(P p,Q q)</span></span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">this</span>.bar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">C c </span>= <span class="keyword">new</span> C();</span><br></pre></td></tr></table></div></figure>

<p>对应变量含义<br>$$<br>\begin{align}<br>&amp;cs:this.bar();\<br>&amp;m:&lt;C:T\ bar()&gt;\<br>&amp;c^m:C\<br>\<br>&amp;cs:C\ c\ =\ new\ c();\<br>&amp;m:&lt;&gt;<br>\end{align}<br>$$<br>这个可以直接找到，不细说</p>

        <h4 id="vitural-call"   >
          <a href="#vitural-call" class="heading-link"><i class="fas fa-link"></i></a><a href="#vitural-call" class="headerlink" title="vitural call"></a>vitural call</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">foo</span><span class="params">(P p,Q q)</span></span>&#123;....&#125;</span><br><span class="line">&#125;</span><br><span class="line">A a = ...;</span><br><span class="line">a.foo(x,y);</span><br></pre></td></tr></table></div></figure>

<p>对应变量含义<br>$$<br>\begin{align}<br>&amp;cs:a.foo(x,y);\<br>&amp;m:&lt;A:\ T\ foo(P,Q)&gt;\<br>&amp;c:A\<br>\end{align}<br>$$<br>其中关于该算法</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230106114548955.png" alt="image-20230106114548955"></p>
<p>需要遍历<code>c</code>的所有直接子类以及间接子类，通过<code>Dispatch</code>进行计算，将计算记过放入<code>T</code>中</p>

        <h4 id="实际例子"   >
          <a href="#实际例子" class="heading-link"><i class="fas fa-link"></i></a><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230106114722837.png" alt="image-20230106114722837"></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resolve(c.foo()) = &#123;C.foo()&#125;</span><br><span class="line">Resolve(a.foo()) = &#123;A.foo(),C.foo(),D.foo()&#125;</span><br><span class="line">Resolve(b.foo()) = &#123;A.foo(),C.foo(),D.foo()&#125;</span><br></pre></td></tr></table></div></figure>

<p>关于<code>Resolve(b.foo())</code>计算结果，前面提到<code>dispatch</code>算法，当在当前类，这里也就是<code>B</code>中没有找到对应函数<code>foo</code>定义，就会去其父类寻找，这里也就是<code>A</code>，所以实际执行进入循环体的类为<code>A</code>，那么其结果就相当于<code>Resovle(a.foo())</code>了。</p>

        <h3 id="Features-of-CHA"   >
          <a href="#Features-of-CHA" class="heading-link"><i class="fas fa-link"></i></a><a href="#Features-of-CHA" class="headerlink" title="Features of CHA"></a>Features of CHA</h3>
      
        <h4 id="Advantage"   >
          <a href="#Advantage" class="heading-link"><i class="fas fa-link"></i></a><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h4>
      <p>很快，只考虑声明类型，然后查找继承树。求解过程中忽略数据流和控制流的相关信息。</p>

        <h4 id="Disadvantage"   >
          <a href="#Disadvantage" class="heading-link"><i class="fas fa-link"></i></a><a href="#Disadvantage" class="headerlink" title="Disadvantage"></a>Disadvantage</h4>
      <p>不准确，因为忽略了数据流和控制流的相关信息</p>

        <h3 id="Algorithm-3"   >
          <a href="#Algorithm-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#Algorithm-3" class="headerlink" title="Algorithm"></a>Algorithm</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113100012796.png" alt="image-20230113100012796"></p>
<p>主要是从<code>Work list</code>中取方法后，需要先判断是否已经<code>reachable</code>了，即是否在<code>RM</code>中</p>

        <h4 id="例子-4"   >
          <a href="#例子-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113105835279.png" alt="image-20230113105835279"></p>
<ul>
<li><p>首先初始化如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110307953.png" alt="image-20230422110307953"></p>
</li>
<li><p><code>WL=[A.main()],RM=[],CG=[]</code></p>
<ul>
<li><p>从<code>WL</code>取出<code>A.main()</code>，不属于<code>RM</code>，则放入<code>RM</code>，<code>RM=[A.main()]</code></p>
</li>
<li><p><code>A.main</code>的<code>call site</code>为<code>A.foo()</code></p>
</li>
<li><p>求解<code>Resolve(A.foo())</code>，利用之前的提到的<code>Resolve</code>算法，求解得到<code>A.foo()</code>，放入<code>WL</code>中，并且相关边放入<code>CG</code></p>
</li>
<li><p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110340228.png" alt="image-20230422110340228"></p>
</li>
</ul>
</li>
<li><p><code>WL=[A.foo()],RM=[A.main()],CG=[A.main().A.foo()-&gt;A.foo()]</code></p>
<ul>
<li><p><code>RM=[A.main(),A.foo()]</code></p>
</li>
<li><p><code>Resolve(cs of A.foo()) = Resolve(a.bar()) = A.bar()+B.bar()+C.bar()</code>，<code>A.foo().a.bar()-&gt;[A.bar,B.bar,C.bar()]</code>放入<code>CG</code></p>
</li>
<li><p><code>WL=[A.bar(),B.bar(),C.bar()]</code></p>
</li>
<li><p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110408853.png" alt="image-20230422110408853"></p>
</li>
</ul>
</li>
<li><p><code>WL=[A.bar(),B.bar(),C.bar()],RM=[A.main(),A.foo()],CG=[A.main().A.foo()-&gt;A.foo(),A.foo().a.bar()-&gt;&#123;A.bar(),B.bar(),C.bar()&#125;]</code></p>
<ul>
<li><p><code>RM=[A.main(),A.foo(),A.bar()]</code></p>
</li>
<li><p><code>Resolve(cs of A.bar()) = Resolve(c.bar()) = C.bar()</code>，<code>A.bar().c.bar()-&gt;C.bar()</code>放入<code>CG</code></p>
</li>
<li><p><code>WL=[B.bar(),C.bar(),C.bar()]</code></p>
</li>
<li><p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110521314.png" alt="image-20230422110521314"></p>
</li>
</ul>
</li>
<li><p><code>WL=[B.bar(),C.bar(),C.bar()],RM=[A.main(),A.foo(),A.bar()],CG=[A.main().A.foo()-&gt;A.foo(),A.foo().a.bar()-&gt;&#123;A.bar(),B.bar(),C.bar()&#125;,A.bar().c.bar()-&gt;C.bar()]</code></p>
<ul>
<li><p><code>RM=[A.main(),A.foo(),A.bar(),B.bar()]</code></p>
</li>
<li><p><code>Resolve(cs of B.bar()) = Resolve() = []</code></p>
</li>
<li><p><code>WL=[C.bar,C.bar()]</code></p>
</li>
<li><p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110536692.png" alt="image-20230422110536692"></p>
</li>
</ul>
</li>
<li><p><code>WL=[C.bar(),C.bar()],RM=[A.main(),A.foo(),A.bar(),B.bar()],CG=[...]</code></p>
<ul>
<li><p><code>RM=[A.main(),A.foo(),A.bar(),B.bar(),C.bar()]</code></p>
</li>
<li><p><code>Resolve(cs of C.bar()) = Resolve(A.foo()) = A.foo()</code>，<code>C.bar().A.foo()-&gt;A.foo()</code>放入<code>CG</code></p>
</li>
<li><p><code>WL=[C.bar().A.foo()]</code></p>
</li>
<li><p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110659618.png" alt="image-20230422110659618"></p>
</li>
</ul>
</li>
<li><p><code>WL=[C.bar(),A.foo()],RM=[A.main(),A.foo(),A.bar(),B.bar(),C.bar()],CG=[A.main().A.foo()-&gt;A.foo(),A.foo().a.bar()-&gt;&#123;A.bar(),B.bar(),C.bar()&#125;,A.bar().c.bar()-&gt;C.bar(),C.bar().A.foo()-&gt;A.foo()]</code></p>
<ul>
<li><p><code>C.bar()</code>在<code>RM</code>中，跳过，从<code>WL</code>中移除<code>C.bar()</code></p>
</li>
<li><p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110742581.png" alt="image-20230422110742581"></p>
</li>
</ul>
</li>
<li><p><code>WL=[A.foo()],RM=[A.main(),A.foo(),A.bar(),B.bar(),C.bar()],CG=[...]</code></p>
<ul>
<li><p><code>A.foo()</code>在<code>RM</code>中，跳过，从<code>WL</code>中移除<code>A.foo()</code></p>
</li>
<li><p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110813614.png" alt="image-20230422110813614"></p>
</li>
</ul>
</li>
<li><p><code>WL=[],RM=[A.main(),A.foo(),A.bar(),B.bar(),C.bar()],CG=[...]</code></p>
<ul>
<li><p><code>WL</code>为空，算法结束。</p>
</li>
<li><p>最终结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230422110813614.png"></p>
</li>
</ul>
</li>
</ul>
<p>其中<code>CG</code>的表达形式不知道怎么写合适，就只能大概写一下</p>

        <h2 id="5-Interprocedural-Control-Flow-Graph"   >
          <a href="#5-Interprocedural-Control-Flow-Graph" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Interprocedural-Control-Flow-Graph" class="headerlink" title="5.Interprocedural Control-Flow Graph"></a>5.Interprocedural Control-Flow Graph</h2>
      <ul>
<li>CGF：展示的是方法之间的调用关系</li>
<li>ICFG：展示的是整个程序的调用关系<ul>
<li><code>ICFG = CFGs + call&amp;return edges</code><ul>
<li><code>call edges</code> : 即调用边，<code>call site</code>到对应函数入口点</li>
<li><code>return edges</code> : 即函数返回点到该函数的被调用点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113113450334.png" alt="image-20230113113450334"></p>

        <h2 id="6-Interprocedural-Data-Flow-Analysis"   >
          <a href="#6-Interprocedural-Data-Flow-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Interprocedural-Data-Flow-Analysis" class="headerlink" title="6.Interprocedural Data-Flow Analysis"></a>6.Interprocedural Data-Flow Analysis</h2>
      <p>其实相对于<code>Intraprocedural Data-Flow Analysis</code>，会多<code>call transfer function</code>和<code>return transfer function</code>。即数据进入函数前的转化函数以及回来的时候的转化函数</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113110940851.png" alt="image-20230113110940851"></p>

        <h3 id="Interprocedural-Constant-Propagation"   >
          <a href="#Interprocedural-Constant-Propagation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Interprocedural-Constant-Propagation" class="headerlink" title="Interprocedural Constant Propagation"></a>Interprocedural Constant Propagation</h3>
      <p>主要是<code>Node transfer</code>，即如下情况，即为一个<code>Node transfer</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113112521557.png" alt="image-20230113112521557"></p>

        <h4 id="实例"   >
          <a href="#实例" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例" class="headerlink" title="实例"></a>实例</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113112947040.png" alt="image-20230113112947040"></p>
<p>其中打问号的边叫做<code>call-to-return edge</code>，是用来传递本函数变量的，即该函数内部的变量，即这里的<code>a</code>，如果没有的话，就会导致本函数变量的传播经过调用函数绕一大圈才能回来。如下所示，本函数变量<code>a</code>就需要经过<code>addOne</code>传播才能回来，很影响效率。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113113112058.png" alt="image-20230113113112058"></p>
<p>注意在传播过程的<code>Node transfer</code>时，需要<code>kill</code>掉返回覆盖的变量，比如这里就是<code>b</code>，这样在后面<code>call-to-return edge</code>和<code>return edge</code>进行<code>join</code>操作才会正确，如果不<code>kill</code>掉，就容易出现如下结果</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113113906445.png" alt="image-20230113113906445"></p>
<p>没有<code>kill</code>掉时，即从<code>b=ten()</code>这条<code>call-to-return edge</code>流下来的<code>b</code>为7，而从<code>return edge</code>流出来的<code>b</code>为10，依据之前常量传播的<code>Control Flow</code></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN[B] = ⊓p predecessor of B OUT[p]</span><br></pre></td></tr></table></div></figure>

<p>就会导致<code>b</code>的值为<code>NAC</code>，这是不准确的，其结果应该是被覆盖的那个值。</p>

        <h4 id="类比Intraprocedural-Constant-Propagation"   >
          <a href="#类比Intraprocedural-Constant-Propagation" class="heading-link"><i class="fas fa-link"></i></a><a href="#类比Intraprocedural-Constant-Propagation" class="headerlink" title="类比Intraprocedural Constant Propagation"></a>类比Intraprocedural Constant Propagation</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113124541680.png" alt="image-20230113124541680"></p>
<p>碰到函数调用就会产生<code>NAC</code>，不准确</p>

        <h2 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113124706083.png" alt="image-20230113124706083"></p>
<p>怎么通过类继承关系来创建调用图、过程间的控制流以及数据流分析的相关概念、过程间的常量分析</p>

        <h1 id="七、Pointer-Analysis"   >
          <a href="#七、Pointer-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#七、Pointer-Analysis" class="headerlink" title="七、Pointer Analysis"></a>七、Pointer Analysis</h1>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105324445.png" alt="image-20230114105324445"></p>

        <h2 id="1-Motivation-1"   >
          <a href="#1-Motivation-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Motivation-1" class="headerlink" title="1.Motivation"></a>1.Motivation</h2>
      <p>在常规的<code>CHA</code>方法中，由于一个方法调用可能指向多个方法，那么在遍历这些方法的时候，返回的值都有可能不同，然后再做<code>join</code>操作时，就有可能出问题。</p>
<p>比如如下的<code>Constant Propagation </code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113144912366.png" alt="image-20230113144912366"></p>
<p>由于声明的类型为<code>Number</code>，调用<code>get</code>时有三个子类，那么就会有三个方法需要进行遍历，最后进行<code>join</code>时就会导致<code>X=NAC</code>。但是实际上，其实只会调用到<code>One.get()</code>方法，只会返回1，导致<code>CHA</code>不准确，那么就用到<code>Pointer analysis</code>，更加准确</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113145316011.png" alt="image-20230113145316011"></p>

        <h2 id="2-Introduction-to-Pointer-Analysis"   >
          <a href="#2-Introduction-to-Pointer-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Introduction-to-Pointer-Analysis" class="headerlink" title="2.Introduction to Pointer Analysis"></a>2.Introduction to Pointer Analysis</h2>
      <p>指针分析是属于<code>may-analysis</code>，有很多年历史，包括现今指针分析还有很多问题没有被完善解决，所以还是有很多这方面的研究应用</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113145957855.png" alt="image-20230113145957855"></p>

        <h3 id="例子-5"   >
          <a href="#例子-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3>
      <p>相关的一些表达方式如下，指针分析即一个程序作为输入，通过分析之后，得到一个指向关系表。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113150547144.png" alt="image-20230113150547144"></p>

        <h3 id="应用"   >
          <a href="#应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用" class="headerlink" title="应用"></a>应用</h3>
      <p>应用很多，特别基础</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113150838229.png" alt="image-20230113150838229"></p>

        <h2 id="3-Key-Factors-of-Pointer-Analysis"   >
          <a href="#3-Key-Factors-of-Pointer-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Key-Factors-of-Pointer-Analysis" class="headerlink" title="3.Key Factors of Pointer Analysis"></a>3.Key Factors of Pointer Analysis</h2>
      <p>指针分析中主要的一些讨论点，问题以及相关的处理方法，这些处理方法都有各自的优缺点，主要关注于分析的准确度<code>precision</code>以及效率<code>efficiency</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113151258381.png" alt="image-20230113151258381"></p>

        <h3 id="Heap-Abstraction"   >
          <a href="#Heap-Abstraction" class="heading-link"><i class="fas fa-link"></i></a><a href="#Heap-Abstraction" class="headerlink" title="Heap Abstraction"></a>Heap Abstraction</h3>
      <p>堆内存相信大家都很熟悉了，而在静态分析里面，由于堆是动态创建的，程序没有跑起来之前，不好确定程序究竟创建了多少个对象，而在有循环或者递归什么的时候，就更多了。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113152342466.png" alt="image-20230113152342466"></p>
<p>那么为了在静态分析中，确保分析过程能够停止下来，就不能在分析过程创建<code>infinite</code>个对象，就需要一种技术来对它进行抽象限制。</p>
<p>比较直观的一个例子就是把多个相同的对象都抽象成一个对象，如下所示</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113152349767.png" alt="image-20230113152349767"></p>
<p>相关的抽象技术也是很复杂，很多</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113152414219.png" alt="image-20230113152414219"></p>

        <h4 id="Allocation-Site-Abstraction"   >
          <a href="#Allocation-Site-Abstraction" class="heading-link"><i class="fas fa-link"></i></a><a href="#Allocation-Site-Abstraction" class="headerlink" title="Allocation-Site Abstraction"></a>Allocation-Site Abstraction</h4>
      <p>这个就是<code>Heap Abstraction</code>中一种技术，<code>Allocation-Site Abstraction</code>创建的抽象技术</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113152536353.png" alt="image-20230113152536353"></p>
<p>比如这里的<code>O2</code>是代表程序中第二行创建对象语句，实际上由于循环有三次，所以会创建三个对象，但是基于<code>Alloction-Site Abstraction</code>，可以将这三个对象都抽象成一个对象<code>O2</code>。</p>
<p>由于一个程序中对象创建点肯定是有限的，那么抽象对象也肯定会是有限的，能够<code>terminate</code>。</p>

        <h3 id="Context-sentivity"   >
          <a href="#Context-sentivity" class="heading-link"><i class="fas fa-link"></i></a><a href="#Context-sentivity" class="headerlink" title="Context sentivity"></a>Context sentivity</h3>
      <p>一个方法被调用时依据传进来的参数不同，肯定也会对应不同的输出，所以针对同一个方法分析时，上下文敏感<code>Context sentivity</code>和上下文不敏感<code>Context insensitive</code>就是两种分析方法了，如下感觉图解很清楚。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113153450361.png" alt="image-20230113153450361"></p>
<p>会从<code>Context Insentivity</code>开始学习。对<code>JAVA</code>语言来说，<code>Context sentivity</code>提升是很明显的。</p>

        <h3 id="Flow-Insentivity"   >
          <a href="#Flow-Insentivity" class="heading-link"><i class="fas fa-link"></i></a><a href="#Flow-Insentivity" class="headerlink" title="Flow Insentivity"></a>Flow Insentivity</h3>
      <p>之前学习的基本都是<code>Flow Sentivity</code>，即会依照程序的执行顺序，一步一步进行分析。但是<code>Flow Insentivity</code>则不会，它相当于将之揉杂在一起，不管程序的执行顺序。相关例子如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113155136287.png" alt="image-20230113155136287"></p>
<ul>
<li><code>Flow Sentivity</code> : 每一条语句的指向关系<code>map</code>都会随着该语句的执行做出相应的改变，开销比较大，每一点都需要进行维护，速度会慢很多。</li>
<li><code>Flow Insentivity</code> : 相当于把一个变量的所有可能的指向关系<code>map</code>都会全部列出来，不管语句的相关执行顺序，会导致一些精度的缺失。</li>
</ul>
<p>对于<code>Java</code>而言，现今还没有相关的研究明显证明<code>Flow sentivity</code>比<code>Flow Insentivity</code>精度更好，所以现今大多都是针对<code>JAVA</code>的分析都是基于<code>Flow Insentivity</code> ，因为更简单更快。</p>
<p>但是对于<code>C</code>语言而言，<code>Flow sentivity</code>是会更好的。</p>

        <h3 id="Analysis-Scope"   >
          <a href="#Analysis-Scope" class="heading-link"><i class="fas fa-link"></i></a><a href="#Analysis-Scope" class="headerlink" title="Analysis Scope"></a>Analysis Scope</h3>
      <p>分析的范围，通常是两种，即<code>Whole-Program</code>全程序和<code>Demand-driven</code>需求驱动</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230113160401076.png" alt="image-20230113160401076"></p>
<ul>
<li><code>Whole-Program</code> : 即整个程序所有变量的指向关系都会分析出来。更加简单全面，比较主流。</li>
<li><code>Demand-driven</code> : 即需要哪一部分就分析哪一部分，这里就好比需要分析<code>z.bar()</code>，那就只需要<code>z</code>的指向关系了。相比<code>Whole-Program</code>，有时候其效率其实也差不多，所以大多选择<code>Whole-Program</code>。</li>
</ul>

        <h2 id="4-Pointers-in-Java"   >
          <a href="#4-Pointers-in-Java" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Pointers-in-Java" class="headerlink" title="4.Pointers in Java"></a>4.Pointers in Java</h2>
      
        <h3 id="关注的指针类型"   >
          <a href="#关注的指针类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#关注的指针类型" class="headerlink" title="关注的指针类型"></a>关注的指针类型</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114103432918.png" alt="image-20230114103432918"></p>
<p>基本只关注其中两种指针，即<code>local variable</code>，这个其实和<code>Static field</code>差不多。</p>
<p>另一个就是<code>Instance field</code>即类中的成员属性指针，这个和<code>Array element</code>基本归为一类，但是在处理的时候需要对<code>Array element</code>一些抽象，不关注其中的索引，而只关注其保存的指针，如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114103639748.png" alt="image-20230114103639748"></p>
<p>将索引抽象成一个，因为在实际的程序中，索引很难判断出来，尤其在循环中，索引大多都是一些变量什么的，所以不好进行判断，那么就抽象成一个就好了。</p>

        <h3 id="关注的指针语句"   >
          <a href="#关注的指针语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#关注的指针语句" class="headerlink" title="关注的指针语句"></a>关注的指针语句</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104116410.png" alt="image-20230114104116410"></p>
<p>有两个需要特殊说明一下</p>
<ul>
<li><p><code>Store</code> : 有时候可能会有很复杂的语句，比如<code>x.f.g.h = y </code>，但是将之转换为三地址码，就比较简便了</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104311457.png" alt="image-20230114104311457"></p>
</li>
<li><p><code>Call</code> : <code>JAVA</code>中存在三种类型的<code>Call</code>，但是我们关注于处理<code>Vitural call</code>的情况，这个比较复杂，这个会处理其他也会处理了。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104435917.png" alt="aaa"></p>
</li>
</ul>

        <h2 id="总结-1"   >
          <a href="#总结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114104551016.png" alt="image-20230114104551016"></p>
<p>理解指针分析，影响指针分析的几种要素，以及在分析过程中需要处理分析的对象。</p>

        <h1 id="八、Pointer-Analysis-Foundations-I"   >
          <a href="#八、Pointer-Analysis-Foundations-I" class="heading-link"><i class="fas fa-link"></i></a><a href="#八、Pointer-Analysis-Foundations-I" class="headerlink" title="八、Pointer Analysis Foundations (I)"></a>八、Pointer Analysis Foundations (I)</h1>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105245754.png" alt="image-20230114105245754"></p>

        <h2 id="相关概念定义"   >
          <a href="#相关概念定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关概念定义" class="headerlink" title="相关概念定义"></a>相关概念定义</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114105649355.png" alt="image-20230114105649355"></p>
<p><code>pt</code>就相当于一个<code>map</code>，<code>key-&gt;value</code>。<code>pt(p)</code>即变量<code>p</code>指向的对象的集合，比如<code>x = new T()</code>，则<code>pt(x)</code>就代表<code>x</code>指向的对象集合，因为我们用的是<code>Flow Insentivity</code>这个技术，所以是<code>pt(x)</code>是一个集合。</p>

        <h2 id="1-Rules"   >
          <a href="#1-Rules" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Rules" class="headerlink" title="1.Rules"></a>1.Rules</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114111049511.png" alt="image-20230114111049511"></p>
<p>即横线上面的为前提条件<code>premises</code>，当前提条件满足，则可以推导出结论<code>conclusion</code>。</p>

        <h3 id="Rule-New"   >
          <a href="#Rule-New" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule-New" class="headerlink" title="Rule : New"></a>Rule : New</h3>
      <p>无条件得到</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114111610469.png" alt="image-20230114111610469"></p>

        <h3 id="Rule-Assign"   >
          <a href="#Rule-Assign" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule-Assign" class="headerlink" title="Rule : Assign"></a>Rule : Assign</h3>
      <p>比如一条语句为<code>x=y</code>，如果<code>premises</code>满足<code>O𝑖 ∈ pt(y)</code>，那么即可推导出<code>conclusion</code>为<code>O𝑖 ∈ pt(x)</code>，如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114111313810.png" alt="image-20230114111313810"></p>
<p>即将<code>pt(y)</code>集合中的对象<code>Oi</code>加入到<code>pt(x)</code>这个集合中</p>

        <h3 id="Rule-Store"   >
          <a href="#Rule-Store" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule-Store" class="headerlink" title="Rule : Store"></a>Rule : Store</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114111644983.png" alt="image-20230114111644983"></p>
<p>需要理解一个<code>pt(Oi*f)</code>的含义，即某个<strong>对象成员</strong>指向的<strong>对象</strong>的合集。</p>

        <h3 id="Rule-Load"   >
          <a href="#Rule-Load" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule-Load" class="headerlink" title="Rule : Load"></a>Rule : Load</h3>
      <p>和前面差不多</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114111859758.png" alt="image-20230114111859758"></p>

        <h3 id="总结-2"   >
          <a href="#总结-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114112036216.png" alt="image-20230114112036216"></p>
<p>其实就是形式化表达了这些语句，方便后续推导</p>

        <h2 id="2-How-to-Implement-Pointer-Analysis"   >
          <a href="#2-How-to-Implement-Pointer-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-How-to-Implement-Pointer-Analysis" class="headerlink" title="2.How to Implement Pointer Analysis"></a>2.How to Implement Pointer Analysis</h2>
      <p>指针分析关键点就是如果在一个指针发生变化时，如何将变化传递给和该指针有关的其他指针。</p>
<p>使用图来传播指针，传输给该指针的后继。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114142437257.png" alt="image-20230114142437257"></p>

        <h3 id="Pointer-Flow-Graph-PFG"   >
          <a href="#Pointer-Flow-Graph-PFG" class="heading-link"><i class="fas fa-link"></i></a><a href="#Pointer-Flow-Graph-PFG" class="headerlink" title="Pointer Flow Graph(PFG)"></a>Pointer Flow Graph(PFG)</h3>
      
        <h4 id="概念"   >
          <a href="#概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念" class="headerlink" title="概念"></a>概念</h4>
      <ul>
<li><p><code>Nodes</code></p>
<p><code>Pointer = V ⋃ (O × F)</code>，即节点<code>n</code>表示一个指针变量，或者说一个抽象对象的一个<code>field</code>。</p>
</li>
<li><p><code>Edges</code></p>
<p><code>Pointer × Pointer</code>，某条边<code>x-&gt;y</code>，代表<code>x</code>指向的对象<code>pt(x)</code>也**可能<code>may</code>**会流向<code>y</code>指向的对象<code>pt(y)</code>。</p>
</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114143412980.png" alt="image-20230114143412980"></p>
<p>节点<code>n</code>即相关的变量，边<code>edge</code>即流向关系。</p>

        <h4 id="实例-1"   >
          <a href="#实例-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4>
      <p>如下图所示，感觉还是挺清楚的</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114144100365.png" alt="image-20230114144100365"></p>
<p>需要注意的是，<code>c.f</code>需要表示成<code>Oi.f</code>才行，才是一个真正的指针。</p>
<p>那么指针分析就变成在指针图<code>PFG</code>上分析指针集传播过程的问题了。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114150729422.png" alt="image-20230114150729422"></p>

        <h3 id="Propagate-points-to-information-on-PFG"   >
          <a href="#Propagate-points-to-information-on-PFG" class="heading-link"><i class="fas fa-link"></i></a><a href="#Propagate-points-to-information-on-PFG" class="headerlink" title="Propagate points-to information on PFG"></a>Propagate points-to information on PFG</h3>
      <p>在上述建图的过程中，其实也涉及到指针传播的相关信息，并不是说在建立<code>PFG</code>时不考虑传播信息。比如说在构建<code>c.f=a</code>时，我们需要先知道的是<code>c</code>的指针流向，即<code>Oi</code>。传播和构建是相辅相成的，动态构建的。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114152258172.png" alt="image-20230114152258172"></p>

        <h2 id="3-Pointer-Analysis-Algorithms"   >
          <a href="#3-Pointer-Analysis-Algorithms" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Pointer-Analysis-Algorithms" class="headerlink" title="3.Pointer Analysis: Algorithms"></a>3.Pointer Analysis: Algorithms</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114153245606.png" alt="image-20230114153245606"></p>
<p>其中<code>S</code>即为输入程序语句的合集，<code>PFG</code>就是指针流向图，比较需要关注的就是<code>WL</code>以及其中的数据含义</p>
<ul>
<li><p><code>Worklist</code></p>
<p>存储需要被处理的<code>pair</code>，其中每个<code>pair</code>形式大概为<code>&lt;n,pts&gt;</code>，代表说<code>pts</code>这个对象集合需要被传播到指针<code>n</code>指向的对象集合<code>pt(n)</code>中。</p>
<p>比如一个<code>Worklist</code>为<code>[&lt;x,&#123;Oi&#125;&gt;,&lt;y,&#123;Oj,Ok&#125;&gt;,&lt;Oj.f,&#123;Ol&#125;...&gt;</code>，表示</p>
<ul>
<li><code>&#123;Oi&#125;</code>需要传播到<code>pt(x)</code></li>
<li><code>&#123;Oj,Ok&#125;</code>需要传播到<code>pt(y)</code></li>
<li><code>&#123;Ol&#125;</code>需要传播到<code>pt(Oj.f)</code></li>
<li>…..</li>
</ul>
</li>
</ul>

        <h3 id="Handling-of-New-and-Assign"   >
          <a href="#Handling-of-New-and-Assign" class="heading-link"><i class="fas fa-link"></i></a><a href="#Handling-of-New-and-Assign" class="headerlink" title="Handling of New and Assign"></a>Handling of New and Assign</h3>
      <p>算法的前部分是用来处理<code>New</code>和<code>Assign</code>的</p>

        <h4 id="Initialize"   >
          <a href="#Initialize" class="heading-link"><i class="fas fa-link"></i></a><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h4>
      <p>首先进行相关的初始化</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114155802247.png" alt="image-20230114155802247"></p>
<p>遍历所有<code>New</code>和<code>Assign</code>语句</p>
<ul>
<li><p><code>New</code>语句即将相关<code>pair</code>添加到<code>WL</code>中</p>
</li>
<li><p><code>Assign</code>即需要在<code>PFG</code>中添加相关传播关系的边<code>edge</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114155946021.png" alt="image-20230114155946021"></p>
<ul>
<li>如果<code>s-&gt;t</code>这条边在<code>edge</code>中存在则说明有边了，不需要添加了，否则就添加到<code>PFG</code>中</li>
<li>添加完成之后，还需要判断<code>pt(s)</code>是不是空的，如果不是空的则需要将对应<code>pt(s)</code>传播到<code>t</code>指向的对象集中，所以需要将它加入到<code>WL</code>进行后续分析工作</li>
</ul>
</li>
</ul>

        <h4 id="Propagate"   >
          <a href="#Propagate" class="heading-link"><i class="fas fa-link"></i></a><a href="#Propagate" class="headerlink" title="Propagate"></a>Propagate</h4>
      <p>在初始化之后，就需要遍历<code>WL</code>进行传播了</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114160853754.png" alt="image-20230114160853754"></p>
<ul>
<li><p>首先从<code>WL</code>中取出</p>
</li>
<li><p>在<code>pts</code>中找到<code>pt(n)</code>中不存在的对象集<code>Δ</code>，因为在<code>pts</code>中存在的对象，在<code>pt(n)</code>中也可能存在，所以需要去掉之后再进行合并操作，避免重复。相关例子如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114161127326.png" alt="image-20230114161127326"></p>
<p>注：最开始其实所有指针的对象集<code>pt(x)</code>都是空的，那么为什么需要去重呢，这个后面会讲到。应该是在动态的创建<code>PFG</code>过程中，<code>pt(x)</code>会不断更新，也会重复被计算。如果不去重的话，其后继中已经被传播的部分就可能再次被传播，从而做了无用功，影响效率。</p>
</li>
<li><p>然后就是传播<code>Propagate(n,Δ)</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230114161246125.png" alt="image-20230114161246125"></p>
<ul>
<li>如果<code>pts</code>不为空，就并入到<code>pt(n)</code>中，这个就是实际的传播过去了。</li>
<li>但是传播到<code>pt(n)</code>不够，还需要传播到<code>n</code>可以流向的其他所有节点。所以需要遍历<code>PFG</code>中所有的<code>n-&gt;s</code>，将<code>&lt;s,pts&gt;</code>加入到<code>WL</code>中等待后续处理</li>
</ul>
</li>
</ul>

        <h5 id="Differential-Propagation"   >
          <a href="#Differential-Propagation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Differential-Propagation" class="headerlink" title="Differential Propagation"></a>Differential Propagation</h5>
      <p>这里就是解释了为什么需要差异传播<code>Differential Propagation</code>去重，即避免已经被传播过的信息再被传播造成无用功。</p>
<p>比如如下情况</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116104011048.png" alt="image-20230116104011048"></p>
<p>假设<code>a</code>先传播，结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116104038107.png" alt="image-20230116104038107"></p>
<p>那么<code>b</code>再进行传播，此时<code>c</code>就相当于<code>n</code>，那么<code>pts=&#123;O1,O3,O5&#125;</code>，<code>pt(n)=&#123;O1,O2,O3&#125;</code>，如果不进行差异传播则过程如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116104446528.png" alt="image-20230116104446528"></p>
<p>导致<code>&#123;O1,O3&#125;</code>被重复传播</p>
<p>如果进行差异传播则过程如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116104520952.png" alt="image-20230116104520952"></p>
<p>这样已经被传播过的就不会再被进行计算传播了。</p>
<p>不过这里有个前提，即该算法在每次传播的时候已经确保了<code>pt(n)</code>已经被传播给了<code>n</code>的所有后继。</p>

        <h3 id="Handling-of-Store-and-Load"   >
          <a href="#Handling-of-Store-and-Load" class="heading-link"><i class="fas fa-link"></i></a><a href="#Handling-of-Store-and-Load" class="headerlink" title="Handling of Store and Load"></a>Handling of Store and Load</h3>
      <p>算法循环的后半部分是用来处理<code>Store</code>和<code>Load</code>的</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116112641178.png" alt="image-20230116112641178"></p>
<p>关于<code>x</code>指向对象相关成员的所有<code>Store</code>和<code>Load</code>语句都会进行处理，需要遍历所有需要传播的对象集合，即<code>Δ</code></p>
<p>这里需要注意的是，再添加边时，不一定能够添加上。因为在处理<code>x.f=y</code>时，之前可能已经有了<code>A=x;A.f=y</code>这样的，导致在<code>PFG</code>中其实有了这样一条边，就不用再添加了。这也是在<code>AddEdge</code>中进行是否存在边判断的原因。</p>

        <h3 id="实例-2"   >
          <a href="#实例-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116114337394.png" alt="image-20230116114337394"></p>
<p>首先初始化<code>WL=[]、PFG=&#123;&#125;</code></p>

        <h4 id="New处理"   >
          <a href="#New处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#New处理" class="headerlink" title="New处理"></a>New处理</h4>
      <p>首先是<code>New</code>处理</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116114833417.png" alt="image-20230116114833417"></p>
<p>语句1和3有<code>New</code>操作，对应<code>O1</code>和<code>O3</code>，添加到<code>WL</code>中</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116115029573.png" alt="image-20230116115029573"></p>

        <h4 id="Assign处理"   >
          <a href="#Assign处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Assign处理" class="headerlink" title="Assign处理"></a>Assign处理</h4>
      <p>然后是<code>Assign</code>处理</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116114849027.png" alt="image-20230116114849027"></p>
<p>语句2和5有<code>Assign</code>操作，进行<code>AddEdge</code>操作</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116114926158.png" alt="image-20230116114926158"></p>
<p>使得<code>PFG</code>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116115004261.png" alt="image-20230116115004261"></p>
<p>由于还没进行传播操作，所以这里<code>b</code>对应的<code>pt(b)</code>和<code>c</code>对应的<code>pt(c)</code>还是空的。</p>
<p>那么在以上两种初始化操作完成后，结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116115127433.png" alt="image-20230116115127433"></p>

        <h4 id="WL处理"   >
          <a href="#WL处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#WL处理" class="headerlink" title="WL处理"></a>WL处理</h4>
      <p><code>Load</code>和<code>Store</code>是在这一部分进行迭代的</p>

        <h5 id="第一次迭代-3"   >
          <a href="#第一次迭代-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次迭代-3" class="headerlink" title="第一次迭代"></a>第一次迭代</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WL = [&lt;b,&#123;O1&#125;&gt;,&lt;c,&#123;O3&#125;&gt;];</span><br><span class="line">n = b;</span><br><span class="line">WL = [&lt;c,&#123;O3&#125;&gt;];</span><br><span class="line">pts = &#123;O3&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O3&#125; - &#123;&#125; = &#123;O3&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O3&#125;;</span><br><span class="line">	pt(b) = pt(n) = pts ⋃ pt(n) = &#123;O3&#125; ⋃ &#123;&#125; = &#123;O3&#125;;</span><br><span class="line">	b-&gt;a ∈ PFG;</span><br><span class="line">	WL += &lt;a,pts&gt;; =&gt; WL = [&lt;c,&#123;O3&#125;&gt;,&lt;a,&#123;O3&#125;&gt;];</span><br><span class="line"></span><br><span class="line">关于b的成员没有相关Load和Store，循环结束</span><br></pre></td></tr></table></div></figure>

<p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116120125591.png" alt="image-20230116120125591"></p>

        <h5 id="第二次迭代-3"   >
          <a href="#第二次迭代-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次迭代-3" class="headerlink" title="第二次迭代"></a>第二次迭代</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">WL = [&lt;c,&#123;03&#125;&gt;,&lt;a,&#123;O1&#125;&gt;];</span><br><span class="line">n = c;</span><br><span class="line">WL = [&lt;a,&#123;O1&#125;&gt;];</span><br><span class="line">pts = &#123;O3&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O3&#125; - &#123;&#125; = &#123;O3&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O3&#125;;</span><br><span class="line">	pt(c) = pt(n) = pts ⋃ pt(n) = &#123;O3&#125; ⋃ &#123;&#125; = &#123;O3&#125;;</span><br><span class="line">	c-&gt;d ∈ PFG;</span><br><span class="line">	WL += &lt;d,pts&gt;; =&gt; WL = [&lt;a,&#123;O1&#125;&gt;,&lt;d,&#123;O3&#125;&gt;];</span><br><span class="line"></span><br><span class="line">Load and Store:</span><br><span class="line">	c.f存在相关语句</span><br><span class="line">	O3 ∈ Δ = &#123;O3&#125;;</span><br><span class="line">	c.f = a:</span><br><span class="line">		a-&gt;c.f = a-&gt;O3.f ∉ PFG;</span><br><span class="line">		PFG += a-&gt;O3.f;</span><br><span class="line">		pt(a)=&#123;&#125;;</span><br><span class="line">	c.f = d:</span><br><span class="line">		d-&gt;c.f = d-&gt;O3.f ∉ PFG;</span><br><span class="line">		PFG += d-&gt;O3.f;</span><br><span class="line">		pt(d)=&#123;&#125;;</span><br></pre></td></tr></table></div></figure>

<p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116121324230.png" alt="image-20230116121324230"></p>

        <h5 id="第三次迭代-2"   >
          <a href="#第三次迭代-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次迭代-2" class="headerlink" title="第三次迭代"></a>第三次迭代</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WL = [&lt;a,&#123;O1&#125;&gt;,&lt;d,&#123;O3&#125;&gt;];</span><br><span class="line">n = a;</span><br><span class="line">WL = [&lt;d,&#123;O3&#125;&gt;];</span><br><span class="line">pts = &#123;O1&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O1&#125; - &#123;&#125; = &#123;O1&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O1&#125;;</span><br><span class="line">	pt(a) = pt(n) = pts ⋃ pt(n) = &#123;O1&#125; ⋃ &#123;&#125; = &#123;O1&#125;;</span><br><span class="line">	a-&gt;O3.f ∈ PFG;</span><br><span class="line">	WL += &lt;O3.f,pts&gt;; =&gt; WL = [&lt;d,&#123;O3&#125;&gt;,&lt;O3.f,&#123;O1&#125;&gt;];</span><br><span class="line"></span><br><span class="line">关于a的成员没有相关Load和Store，循环结束</span><br></pre></td></tr></table></div></figure>

<p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116123211552.png" alt="image-20230116123211552"></p>

        <h5 id="第四次迭代"   >
          <a href="#第四次迭代" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次迭代" class="headerlink" title="第四次迭代"></a>第四次迭代</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">WL = [&lt;d,&#123;O3&#125;&gt;,&lt;O3.f,&#123;O1&#125;&gt;];</span><br><span class="line">n = d;</span><br><span class="line">WL = [&lt;O3.f,&#123;O1&#125;&gt;];</span><br><span class="line">pts = &#123;O3&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O3&#125; - &#123;&#125; = &#123;O3&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O3&#125;;</span><br><span class="line">	pt(d) = pt(n) = pts ⋃ pt(n) = &#123;O3&#125; ⋃ &#123;&#125; = &#123;O3&#125;;</span><br><span class="line">	d-&gt;O3.f ∈ PFG;</span><br><span class="line">	WL += &lt;O3.f,pts&gt;; =&gt; WL = [&lt;O3.f,&#123;O1&#125;&gt;,&lt;O3.f,&#123;O3&#125;&gt;];</span><br><span class="line">	</span><br><span class="line">Load and Store:</span><br><span class="line">	d.f存在相关语句</span><br><span class="line">	O3 ∈ Δ = &#123;O3&#125;;</span><br><span class="line">	e = d.f:</span><br><span class="line">		d.f-&gt;e = O3.f-&gt;e ∉ PFG;</span><br><span class="line">		PFG += O3.f-&gt;e;</span><br><span class="line">		pt(O3.f) = &#123;&#125;;</span><br></pre></td></tr></table></div></figure>

<p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116123300983.png" alt="image-20230116123300983"></p>

        <h5 id="第五次迭代"   >
          <a href="#第五次迭代" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五次迭代" class="headerlink" title="第五次迭代"></a>第五次迭代</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WL = [&lt;O3.f,&#123;O1&#125;&gt;,&lt;O3.f,&#123;O3&#125;&gt;];</span><br><span class="line">n = O3.f;</span><br><span class="line">WL = [&lt;O3.f,&#123;O3&#125;&gt;];</span><br><span class="line">pts = &#123;O1&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O1&#125; - &#123;&#125; = &#123;O1&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O1&#125;;</span><br><span class="line">	pt(O3.f) = pt(n) = pts ⋃ pt(n) = &#123;O1&#125; ⋃ &#123;&#125; = &#123;O1&#125;;</span><br><span class="line">	O3.f-&gt;e ∈ PFG;</span><br><span class="line">	WL += &lt;e,pts&gt;; =&gt; WL = [&lt;O3.f,&#123;O3&#125;&gt;,&lt;e,&#123;O1&#125;&gt;];</span><br><span class="line"></span><br><span class="line">关于O3.f的成员没有相关Load和Store，循环结束</span><br></pre></td></tr></table></div></figure>

<p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116140630003.png" alt="image-20230116140630003"></p>

        <h5 id="第六次迭代"   >
          <a href="#第六次迭代" class="heading-link"><i class="fas fa-link"></i></a><a href="#第六次迭代" class="headerlink" title="第六次迭代"></a>第六次迭代</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WL = [&lt;O3.f,&#123;O3&#125;&gt;,&lt;e,&#123;O1&#125;&gt;];</span><br><span class="line">n = O3.f;</span><br><span class="line">WL = [&lt;e,&#123;O1&#125;&gt;];</span><br><span class="line">pts = &#123;O3&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O3&#125; - &#123;O1&#125; = &#123;O3&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O3&#125;;</span><br><span class="line">	pt(O3.f) = pt(n) = pts ⋃ pt(n) = &#123;O3&#125; ⋃ &#123;O1&#125; = &#123;O1,O3&#125;;</span><br><span class="line">	O3.f-&gt;e ∈ PFG;</span><br><span class="line">	WL += &lt;e,pts&gt;; =&gt; WL = [&lt;e,&#123;O1&#125;&gt;,&lt;e,&#123;O3&#125;&gt;];</span><br><span class="line"></span><br><span class="line">关于O3.f的成员没有相关Load和Store，循环结束</span><br></pre></td></tr></table></div></figure>

<p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116140900865.png" alt="image-20230116140900865"></p>

        <h5 id="第七次迭代"   >
          <a href="#第七次迭代" class="heading-link"><i class="fas fa-link"></i></a><a href="#第七次迭代" class="headerlink" title="第七次迭代"></a>第七次迭代</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WL = [&lt;e,&#123;O1&#125;&gt;,&lt;e,&#123;O3&#125;&gt;];</span><br><span class="line">n = e;</span><br><span class="line">WL = [&lt;e,&#123;O3&#125;&gt;];</span><br><span class="line">pts = &#123;O1&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O1&#125; - &#123;&#125; = &#123;O1&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O1&#125;;</span><br><span class="line">	pt(e) = pt(n) = pts ⋃ pt(n) = &#123;O1&#125; ⋃ &#123;&#125; = &#123;O1&#125;;</span><br><span class="line">	e没有后继</span><br><span class="line"></span><br><span class="line">关于e的成员没有相关Load和Store，循环结束</span><br></pre></td></tr></table></div></figure>


        <h5 id="第八次迭代"   >
          <a href="#第八次迭代" class="heading-link"><i class="fas fa-link"></i></a><a href="#第八次迭代" class="headerlink" title="第八次迭代"></a>第八次迭代</h5>
      <p>和第七次类似</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WL = [&lt;e,&#123;O3&#125;&gt;];</span><br><span class="line">n = e;</span><br><span class="line">WL = [];</span><br><span class="line">pts = &#123;O3&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O3&#125; - &#123;O1&#125; = &#123;O3&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O3&#125;;</span><br><span class="line">	pt(e) = pt(n) = pts ⋃ pt(n) = &#123;O3&#125; ⋃ &#123;O1&#125; = &#123;O1,O3&#125;;</span><br><span class="line">	e没有后继</span><br><span class="line"></span><br><span class="line">关于e的成员没有相关Load和Store，循环结束</span><br></pre></td></tr></table></div></figure>

<p><code>WL</code>为空，算法结束，最终结果为</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116141524281.png" alt="image-20230116141524281"></p>

        <h2 id="总结-3"   >
          <a href="#总结-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116142223691.png" alt="image-20230116142223691"></p>
<p>理解指针分析的规则，<code>PFG</code>，以及对应的算法</p>

        <h1 id="九、Pointer-Analysis-Foundations-II"   >
          <a href="#九、Pointer-Analysis-Foundations-II" class="heading-link"><i class="fas fa-link"></i></a><a href="#九、Pointer-Analysis-Foundations-II" class="headerlink" title="九、Pointer Analysis Foundations (II)"></a>九、Pointer Analysis Foundations (II)</h1>
      
        <h2 id="4-Pointer-Analysis-with-Method-Calls"   >
          <a href="#4-Pointer-Analysis-with-Method-Calls" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Pointer-Analysis-with-Method-Calls" class="headerlink" title="4.Pointer Analysis with Method Calls"></a>4.Pointer Analysis with Method Calls</h2>
      <p>结合之前的<code>CHA</code>和指针分析，来做过程间的指针分析</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116153358145.png" alt="image-20230116153358145"></p>
<p>在指针分析的过程中做<code>call graph</code>，即<code>on-the-fly call graph construction</code>。</p>
<p>指针分析更加准确，在做过程间的分析时就会使得<code>call graph</code>做的更好，因为不用再依据声明的对象来寻找方法，而是直接通过指针指向的对象来获取方法，更加准确。</p>
<p>而<code>call graph</code>做的越好，其虚假边就会更少，从而指针分析就会更加准确。这两者是互相成就。</p>
<p>只会分析可达方法，不可达方法不进行指针分析，提升精度和效率。</p>

        <h3 id="Rule-Call"   >
          <a href="#Rule-Call" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule-Call" class="headerlink" title="Rule : Call"></a>Rule : Call</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116161005808.png" alt="image-20230116161005808"></p>
<p>符号含义：</p>
<ul>
<li><code>Dispatch(Oi,k) </code> : 和之前一样，通过传入对象指针和函数签名寻找函数，本类找不到找父类</li>
<li><code>M_this</code> : 函数<code>m</code>中的<code>this</code>变量</li>
<li><code>M_pj</code> : 函数<code>m</code>中的第<code>j</code>个参数</li>
<li><code>M_ret</code> : 函数<code>M</code>的返回值</li>
</ul>
<p>即相关的传递指针<br>$$<br>\begin{align}<br>&amp;O_i\in pt(x),m=Dispatch(O_i,k)\ &amp;=&gt;&amp;\ O_i\in pt(m_{this})&amp;(传递this指针,不用在PFG连边)\<br>&amp;O_u\in pt(a_j),1\leqslant j\leqslant n\ &amp;=&gt;&amp;\ O_u\in pt(m_{pj}),1\leqslant j\leqslant n&amp;(传递参数指针,需要在PFG连边)\<br>&amp;O_v\in pt(m_{ret}) &amp;=&gt;&amp;\ O_v\in pt(r)&amp;(传递ret指针,需要在PFG连边)\<br>\end{align}<br>$$<br>需要注意的是<code>this</code>传递的时候是不用在<code>PFG</code>中进行连边处理的，因为如果连边处理的话，那么<code>pt(x)</code>包含的所有对象都会流入到不同的类中，情形如下，就会多出无效的对象要处理，浪费资源。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116175017004.png" alt="image-20230116175017004"></p>

        <h3 id="Algorithms"   >
          <a href="#Algorithms" class="heading-link"><i class="fas fa-link"></i></a><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3>
      <p>相关算法</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116182119855.png" alt="image-20230116182119855"></p>
<p>相关概念已经解释很清楚了</p>

        <h4 id="AddReachable-𝑚"   >
          <a href="#AddReachable-𝑚" class="heading-link"><i class="fas fa-link"></i></a><a href="#AddReachable-𝑚" class="headerlink" title="AddReachable(𝑚)"></a>AddReachable(𝑚)</h4>
      <p>程序最开始、以及新的<code>call graph</code>边被添加时都会调用到，该方法的功能其实就是对于一个方法中所有可达语句进行相关的初始化。</p>
<p>可以看到最开始进入的方法是<code>m^entry</code>，借助是否发现新方法来对<code>WL</code>以及<code>PFG</code>进行更新。</p>
<p>对于最开始调用，即<code>m^entry</code>作为新方法传入时。和之前差不多，只是添加了一些关于是否可达的语句进来，用来进行<code>New</code>和<code>Assign</code>相关对象指针初始化、<code>WL</code>和<code>RM</code>的初始化、以及<code>PFG</code>的初始化。</p>
<p>而对于后续发现新方法，都是进行针对新方法的一些指针分析初始化，类似的。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230116182315115.png" alt="image-20230116182315115"></p>
<p>注：新方法的初始化是不能对<code>Load</code>和<code>Store</code>以及<code>Call</code>进行处理的，因为这些都需要依赖于<code>New</code>和<code>Assign</code>。</p>

        <h4 id="ProcessCall-𝑥-O𝑖"   >
          <a href="#ProcessCall-𝑥-O𝑖" class="heading-link"><i class="fas fa-link"></i></a><a href="#ProcessCall-𝑥-O𝑖" class="headerlink" title="ProcessCall(𝑥, O𝑖)"></a>ProcessCall(𝑥, O𝑖)</h4>
      <p>上述初始化之后的后续部分都差不多，只是在大循环中多了一个<code>ProcessCall</code>进行新方法的发现添加。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227111848832.png" alt="image-20230227111848832"></p>
<p>针对某个变量的<code>WL</code>的处理，都需要对所有可<code>reachable</code>的函数进行处理传递</p>

        <h4 id="Output"   >
          <a href="#Output" class="heading-link"><i class="fas fa-link"></i></a><a href="#Output" class="headerlink" title="Output"></a>Output</h4>
      <p>得到相关的指针集<code>(Points-to Relations (pt))</code>以及调用图<code>(Call Graph)</code></p>

        <h4 id="实例-3"   >
          <a href="#实例-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227144343229.png" alt="image-20230227144343229"></p>

        <h5 id="初始化"   >
          <a href="#初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5>
      <p>首先是初始化，经过<code>AddReachable(m_entry)</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227144513373.png" alt="image-20230227144513373"></p>
<p>得到如下结果</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RM = &#123;A.main()&#125;</span><br><span class="line">WL = [&lt;a,&#123;O3&#125;&gt;,&lt;b,&#123;O4&#125;&gt;]</span><br><span class="line">由于没有x=y之类的语句,没有调用到AddEdge</span><br><span class="line">CG = &#123;&#125;</span><br><span class="line">PFG = &#123;&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="WL处理-1"   >
          <a href="#WL处理-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#WL处理-1" class="headerlink" title="WL处理"></a>WL处理</h5>
      
        <h6 id="第一次迭代-4"   >
          <a href="#第一次迭代-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次迭代-4" class="headerlink" title="第一次迭代"></a>第一次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;a,&#123;O3&#125;&gt;;</span><br><span class="line">WL = [&lt;b,&#123;O4&#125;&gt;];</span><br><span class="line">RM = &#123;A.main()&#125;;</span><br><span class="line">CG = &#123;&#125;;</span><br><span class="line">PFG = &#123;&#125;;</span><br><span class="line">n = a;</span><br><span class="line">pts = &#123;O3&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O3&#125; - &#123;&#125; = &#123;O3&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O3&#125;;</span><br><span class="line">	pt(a) = pt(n) = pts ⋃ pt(n) = &#123;O3&#125; ⋃ &#123;&#125; = &#123;O3&#125;;</span><br><span class="line">	PFG = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">关于a的成员没有相关Load和Store以及call操作，循环结束</span><br></pre></td></tr></table></div></figure>

<p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227145905255.png" alt="image-20230227145905255"></p>

        <h6 id="第二次迭代-4"   >
          <a href="#第二次迭代-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次迭代-4" class="headerlink" title="第二次迭代"></a>第二次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;b,&#123;O4&#125;&gt;;</span><br><span class="line">WL = [];</span><br><span class="line">RM = &#123;A.main()&#125;;</span><br><span class="line">CG = &#123;&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = b;</span><br><span class="line">pts = &#123;O4&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O4&#125; - &#123;&#125; = &#123;O4&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O4&#125;;</span><br><span class="line">	pt(b) = pt(n) = pts ⋃ pt(n) = &#123;O4&#125; ⋃ &#123;&#125; = &#123;O4&#125;;</span><br><span class="line">	PFG没有关于b-&gt;x的流向</span><br><span class="line"></span><br><span class="line">关于a的成员没有相关Load和Store</span><br><span class="line"></span><br><span class="line">ProcessCall(x,Oi):</span><br><span class="line">	m = B.foo(A);</span><br><span class="line">	WL += &lt;B.foo/this,&#123;O4&#125;&gt;;</span><br><span class="line">	CG += &#123;5-&gt;B.foo(A)&#125;;</span><br><span class="line">	AddReachable(m):</span><br><span class="line">		RM += &#123;B.foo(A)&#125;;</span><br><span class="line">		WL += &lt;r,O11&gt;;</span><br><span class="line">		没有关于r的Load操作，退出函数</span><br><span class="line">	AddEdge:</span><br><span class="line">		PFG += &#123;a-&gt;y&#125;;</span><br><span class="line">		PFG += &#123;r-&gt;c&#125;;</span><br></pre></td></tr></table></div></figure>

<p>最终结果如下：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227151348799.png" alt="image-20230227151348799"></p>

        <h6 id="第三次迭代-3"   >
          <a href="#第三次迭代-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次迭代-3" class="headerlink" title="第三次迭代"></a>第三次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;B.foo/this,&#123;O4&#125;&gt;;</span><br><span class="line">WL = [&lt;r,&#123;O11&#125;&gt;,&lt;y,O3&gt;];</span><br><span class="line">RM = &#123;A.main(),B.foo(A)&#125;;</span><br><span class="line">CG = &#123;5-&gt;B.foo(A)&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = B.foo/this;</span><br><span class="line">pts = &#123;O4&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O4&#125; - &#123;&#125; = &#123;O4&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O4&#125;;</span><br><span class="line">	pt(B.foo/this) = pt(n) = pts ⋃ pt(n) = &#123;O4&#125; ⋃ &#123;&#125; = &#123;O4&#125;;</span><br><span class="line">	PFG没有关于B.foo/this-&gt;x的流向</span><br><span class="line"></span><br><span class="line">关于B.foo/this的成员没有相关Load和Store以及call操作，循环结束</span><br></pre></td></tr></table></div></figure>

<p>最终结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227152241402.png" alt="image-20230227152241402"></p>

        <h6 id="第四次迭代-1"   >
          <a href="#第四次迭代-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次迭代-1" class="headerlink" title="第四次迭代"></a>第四次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;r,&#123;O11&#125;&gt;;</span><br><span class="line">WL = [&lt;y,O3&gt;];</span><br><span class="line">RM = &#123;A.main(),B.foo(A)&#125;;</span><br><span class="line">CG = &#123;5-&gt;B.foo(A)&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = r;</span><br><span class="line">pts = &#123;O11&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O11&#125; - &#123;&#125; = &#123;O11&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O11&#125;;</span><br><span class="line">	pt(r) = pt(n) = pts ⋃ pt(r) = &#123;O11&#125; ⋃ &#123;&#125; = &#123;O11&#125;;</span><br><span class="line">	WL += &lt;c,&#123;O11&#125;&gt;;</span><br><span class="line"></span><br><span class="line">关于c的成员没有相关Load和Store以及call操作，循环结束</span><br></pre></td></tr></table></div></figure>

<p>结果如下:</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227152605132.png" alt="image-20230227152605132"></p>

        <h6 id="第五次迭代-1"   >
          <a href="#第五次迭代-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五次迭代-1" class="headerlink" title="第五次迭代"></a>第五次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;y,O3&gt;;</span><br><span class="line">WL = [&lt;c,&#123;O11&#125;&gt;];</span><br><span class="line">RM = &#123;A.main(),B.foo(A)&#125;;</span><br><span class="line">CG = &#123;5-&gt;B.foo(A)&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = y;</span><br><span class="line">pts = &#123;O3&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O3&#125; - &#123;&#125; = &#123;O3&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O3&#125;;</span><br><span class="line">	pt(y) = pt(n) = pts ⋃ pt(y) = &#123;O3&#125; ⋃ &#123;&#125; = &#123;O3&#125;;</span><br><span class="line">	PFG没有关于y-&gt;x的流向</span><br><span class="line"></span><br><span class="line">关于y的成员没有相关Load和Store以及call操作，循环结束</span><br></pre></td></tr></table></div></figure>

<p>结果如下：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227152843432.png" alt="image-20230227152843432"></p>

        <h6 id="第六次迭代-1"   >
          <a href="#第六次迭代-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第六次迭代-1" class="headerlink" title="第六次迭代"></a>第六次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;c,O11&gt;;</span><br><span class="line">WL = [];</span><br><span class="line">RM = &#123;A.main(),B.foo(A)&#125;;</span><br><span class="line">CG = &#123;5-&gt;B.foo(A)&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = c;</span><br><span class="line">pts = &#123;O11&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O11&#125; - &#123;&#125; = &#123;O11&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O11&#125;;</span><br><span class="line">	pt(c) = pt(n) = pts ⋃ pt(c) = &#123;O11&#125; ⋃ &#123;&#125; = &#123;O11&#125;;</span><br><span class="line">	PFG没有关于c-&gt;x的流向</span><br><span class="line"></span><br><span class="line">关于c的成员没有相关Load和Store以及call操作，循环结束</span><br></pre></td></tr></table></div></figure>

<p>结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227153003163.png" alt="image-20230227153003163"></p>
<p>至此整个算法结束，得到最终结果<code>CG</code>和<code>PFG</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227153105750.png" alt="image-20230227153105750"></p>

        <h2 id="总结-4"   >
          <a href="#总结-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227154718912.png" alt="image-20230227154718912"></p>
<p>理解对于方法调用的指针分析规则，理解过程间的指针分析算法，以及两者相互依赖的情况。</p>

        <h1 id="十、Pointer-Analysis-Context-Sensitivity-I"   >
          <a href="#十、Pointer-Analysis-Context-Sensitivity-I" class="heading-link"><i class="fas fa-link"></i></a><a href="#十、Pointer-Analysis-Context-Sensitivity-I" class="headerlink" title="十、Pointer Analysis Context Sensitivity (I)"></a>十、Pointer Analysis Context Sensitivity (I)</h1>
      
        <h2 id="Problem-of-Context-Insensitive-Pointer-Analysis"   >
          <a href="#Problem-of-Context-Insensitive-Pointer-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#Problem-of-Context-Insensitive-Pointer-Analysis" class="headerlink" title="Problem of Context-Insensitive  Pointer Analysis"></a>Problem of Context-Insensitive  Pointer Analysis</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Number n1, n2, x, y;</span><br><span class="line">    n1 = <span class="keyword">new</span> One(); <span class="comment">// O1</span></span><br><span class="line">    n2 = <span class="keyword">new</span> Two(); <span class="comment">// O2</span></span><br><span class="line">    x = id(n1);</span><br><span class="line">    y = id(n2);</span><br><span class="line">    <span class="keyword">int</span> i = x.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Number <span class="title">id</span><span class="params">(Number n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> <span class="keyword">implements</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">implements</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p><code>Context-Insensitive</code>：如果利用之前学到的指针分析进行分析的话，就会导致对于<code>id</code>函数的返回值<code>n</code>，其会包含两个对象，即<code>&#123;O1,O2&#125;</code>。从而导致<code>n-&gt;x,y</code>的流向中，会将<code>&#123;O1,O2&#125;</code>传递给<code>x,y</code>，导致<code>x,y</code>也包含两个对象，如下所示</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227161326592.png" alt="image-20230227161326592"></p>
<p>那么在后续的调用中，<code>int i = x.get();</code>这代码进行常量传播分析时，就会导致<code>i = NAC</code>，这是错误的结果，不准确。</p>
</li>
<li><p><code>Context sensitivity</code>：利用上下文敏感进行分析的话，将每一次的函数调用分为不同的情况进行分析，这样就可以得到如下精确的<code>PFG</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227161537640.png" alt="image-20230227161537640"></p>
<p>这样进行常量传播分析时就能得到精确的结果了。</p>
</li>
</ul>

        <h2 id="1-Introduction"   >
          <a href="#1-Introduction" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2>
      
        <h3 id="Imprecision-of-Context-Insensitivity-C-I"   >
          <a href="#Imprecision-of-Context-Insensitivity-C-I" class="heading-link"><i class="fas fa-link"></i></a><a href="#Imprecision-of-Context-Insensitivity-C-I" class="headerlink" title="Imprecision of Context Insensitivity (C.I.)"></a>Imprecision of Context Insensitivity (C.I.)</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227162348110.png" alt="image-20230227162348110"></p>
<p>依据之前的例子也可以看出来，一个函数每一次调用时，其上下文，数据流等可能会不同，那么其结果也可能会不同。而不敏感的分析中，这些所有的结果都会混合到一起，即混合到该函数的返回变量中，这样就会导致混合的数据流传播时污染了其他的数据流，导致虚假的一些信息。</p>

        <h3 id="Context-Sensitivity-C-S"   >
          <a href="#Context-Sensitivity-C-S" class="heading-link"><i class="fas fa-link"></i></a><a href="#Context-Sensitivity-C-S" class="headerlink" title="Context Sensitivity (C.S.)"></a>Context Sensitivity (C.S.)</h3>
      
        <h4 id="call-site-sensitivity-call-string"   >
          <a href="#call-site-sensitivity-call-string" class="heading-link"><i class="fas fa-link"></i></a><a href="#call-site-sensitivity-call-string" class="headerlink" title="call-site  sensitivity (call-string)"></a>call-site  sensitivity (call-string)</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227163406069.png" alt="image-20230227163406069"></p>
<p>比较古老以及好理解的一种方法，即某点调用时，它的上下文即为<code>Call Site</code>。比如如下的代码</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227163018057.png" alt="image-20230227163018057"></p>
<p>对于<code>id</code>方法而言有两个上下文：<code>[1]</code>和<code>[2]</code>，进行调用时就会作克隆标记，方法为<code>Cloning-Based</code>进行分析</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227163523979.png" alt="image-20230227163523979"></p>

        <h3 id="Context-Sensitive-Heap"   >
          <a href="#Context-Sensitive-Heap" class="heading-link"><i class="fas fa-link"></i></a><a href="#Context-Sensitive-Heap" class="headerlink" title="Context-Sensitive Heap"></a>Context-Sensitive Heap</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227165115263.png" alt="image-20230227165115263"></p>
<p>用以提高精度，将创建的对象依据上下文进行更加细粒的区分</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Y y = <span class="keyword">new</span> Y(<span class="number">1</span>);</span><br><span class="line">    X a = newX(y);</span><br><span class="line">    </span><br><span class="line">    y = <span class="keyword">new</span> Y(<span class="number">2</span>);</span><br><span class="line">    X b = newX(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">newX</span><span class="params">(Y y)</span> </span>&#123;</span><br><span class="line">    X x = <span class="keyword">new</span> X();</span><br><span class="line">    x.f = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>比如上述代码中，如果使用<code>C.I.</code>进行分析，那么无论什么时候调用函数<code>newX</code>，最后都只会得到一个对象<code>O_10</code>。但是如果在<code>C.S.</code>中使用该方法进行细粒化，就可以在不同的调用点对<code>O_10</code>进行区分，比如这里就可以将<code>O_10</code>分为<code>C3:O_10</code>和<code>C6:O_10</code>，类似如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227165502792.png" alt="image-20230227165502792"></p>
<p>这样就精度更高，避免数据流的混合。</p>

        <h4 id="实际例子-1"   >
          <a href="#实际例子-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#实际例子-1" class="headerlink" title="实际例子"></a>实际例子</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227170232579.png" alt="image-20230227170232579"></p>
<p>其实通过上述图片可以大概推导出来，在<code>C.S.heap</code>的技术中，主要是针对传入的上下文做一个标记，标记出不同上下文下得到的对象，这样就可以更加精确。</p>
<p><code>C.S.heap</code>要和<code>C.S.</code>共同使用才能发挥作用，<code>C.S.heap</code>和<code>C.I.</code>是不能发挥作用的，如下例子所示。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227171052291.png" alt="image-20230227171052291"></p>

        <h2 id="2-Context-Sensitive-Pointer-Analysis-Rules"   >
          <a href="#2-Context-Sensitive-Pointer-Analysis-Rules" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Context-Sensitive-Pointer-Analysis-Rules" class="headerlink" title="2.Context Sensitive Pointer Analysis: Rules"></a>2.Context Sensitive Pointer Analysis: Rules</h2>
      
        <h3 id="Domain"   >
          <a href="#Domain" class="heading-link"><i class="fas fa-link"></i></a><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227171524578.png" alt="image-20230227171524578"></p>
<p>主要加入了一个修饰符<code>c</code>，表示上下文</p>

        <h3 id="Rules"   >
          <a href="#Rules" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227172158603.png" alt="image-20230227172158603"></p>
<p>类似之前的一些规则表格</p>

        <h4 id="Rule-New-1"   >
          <a href="#Rule-New-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule-New-1" class="headerlink" title="Rule: New"></a>Rule: New</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227172536628.png" alt="image-20230227172536628"></p>
<p>这个就很容易理解了</p>

        <h4 id="Rule-Assign-1"   >
          <a href="#Rule-Assign-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule-Assign-1" class="headerlink" title="Rule: Assign"></a>Rule: Assign</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227172807051.png" alt="image-20230227172807051"></p>
<p>这个也容易理解</p>

        <h4 id="Rule-Store-1"   >
          <a href="#Rule-Store-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule-Store-1" class="headerlink" title="Rule: Store"></a>Rule: Store</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227172917941.png" alt="image-20230227172917941"></p>
<p>容易理解，就是理清楚各个变量指向对象的上下文<code>C</code>在哪里</p>

        <h4 id="Rule-Load-1"   >
          <a href="#Rule-Load-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule-Load-1" class="headerlink" title="Rule: Load"></a>Rule: Load</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227173015546.png" alt="image-20230227173015546"></p>
<p>类似的</p>

        <h4 id="小总结"   >
          <a href="#小总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227173051279.png" alt="image-20230227173051279"></p>

        <h4 id="Rule-Call-1"   >
          <a href="#Rule-Call-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule-Call-1" class="headerlink" title="Rule: Call"></a>Rule: Call</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227174623063.png" alt="image-20230227174623063"></p>
<p>当进行方法调用时，<code>Dispatch</code>求解函数，然后<code>Select</code>得到上下文之后，就可以对应进行相关变量的值，或者指针对象传递了。和之前也差不多，就是加入了相关的上下文。</p>

        <h2 id="总结-5"   >
          <a href="#总结-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230227174951813.png" alt="image-20230227174951813"></p>
<p>理解<code>context sensitivity (C.S.)</code>以及<code>context-sensitive heap (C.S. heap)</code>的相关概念，以及这些方法为什么能够提升精度。关键点就是经过相同的代码，但是其上下文可能不同，如果混合了数据流就会比较虚假，所以需要进行精确区分上下文。</p>
<p><code>C.S.</code>指针分析的规则。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302105604591.png" alt="image-20230302105604591"></p>

        <h1 id="十一、Pointer-Analysis-Context-Sensitivity-II"   >
          <a href="#十一、Pointer-Analysis-Context-Sensitivity-II" class="heading-link"><i class="fas fa-link"></i></a><a href="#十一、Pointer-Analysis-Context-Sensitivity-II" class="headerlink" title="十一、Pointer Analysis Context Sensitivity (II)"></a>十一、Pointer Analysis Context Sensitivity (II)</h1>
      <p>一些小的回顾就不说了</p>

        <h2 id="3-Context-Sensitive-Pointer-Analysis-Algorithms"   >
          <a href="#3-Context-Sensitive-Pointer-Analysis-Algorithms" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Context-Sensitive-Pointer-Analysis-Algorithms" class="headerlink" title="3.Context Sensitive Pointer Analysis: Algorithms"></a>3.Context Sensitive Pointer Analysis: Algorithms</h2>
      <p>主体框架、流程和原来的差不多，加入上下文敏感了。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302111205711.png" alt="image-20230302111205711"></p>
<p>首先是一些概念，和之前类似，加入了上下文</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302111745720.png" alt="image-20230302111745720"></p>
<p>具体例子如下</p>
<ul>
<li><p><code>RM</code></p>
<p>即<code>reachable methods</code>可达方法集合中所有方法都会有上下文，下面的就代表在<code>Ct</code>上下文下可达的方法。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302111827518.png" alt="image-20230302111827518"></p>
</li>
<li><p><code>CG</code></p>
<p>即<code>call graph</code>调用图中，如下<code>c</code>代表在调用时的上下文<br>$$<br>c:2\ \ \ \ \ \ c^t:T.foo(A,A)∈CG<br>$$<br><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302112047551.png" alt="image-20230302112047551"></p>
</li>
</ul>

        <h3 id="AddReachable-𝑐-𝑚"   >
          <a href="#AddReachable-𝑐-𝑚" class="heading-link"><i class="fas fa-link"></i></a><a href="#AddReachable-𝑐-𝑚" class="headerlink" title="AddReachable(𝑐:𝑚)"></a>AddReachable(𝑐:𝑚)</h3>
      <p>最开始进入的入口函数为<code>[]:m_entry</code>，此时没有什么上下文，所以就为<code>[]</code>，其他的和之前类似，加入上下文</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302113019796.png" alt="image-20230302113019796"></p>

        <h3 id="AddEdge-Propagate"   >
          <a href="#AddEdge-Propagate" class="heading-link"><i class="fas fa-link"></i></a><a href="#AddEdge-Propagate" class="headerlink" title="AddEdge/Propagate"></a>AddEdge/Propagate</h3>
      <p>和原先的一样，不需要怎么管</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302114824189.png" alt="image-20230302114824189"></p>
<p>因为<code>Propaget</code>传播依据现有的<code>PFG</code>进行传播，不需要管上下文。而<code>AddEdge</code>连边也是一样的，只是在<code>PFG</code>中连上两条边，并且指导后续的<code>WL</code>工作进度，不需要上下文。</p>

        <h3 id="Load-Store"   >
          <a href="#Load-Store" class="heading-link"><i class="fas fa-link"></i></a><a href="#Load-Store" class="headerlink" title="Load/Store"></a>Load/Store</h3>
      <p>主要看主体部分的<code>Load/Store</code>部分</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302141214011.png" alt="image-20230302141214011"></p>
<p>需要注意到图中用红色框起来的部分，每一个<code>c:x</code>和对应的<code>c:y</code>的上下文是一样的，这个应该也不难理解，因为传递的是指针对象集合，其包含的上下文也应该是一样的，不然可能不同的上下文导致不同的对象，其<code>field</code>也会可能发生改变。</p>

        <h3 id="ProcessCall-𝑐-𝑥-𝑐′-O𝑖"   >
          <a href="#ProcessCall-𝑐-𝑥-𝑐′-O𝑖" class="heading-link"><i class="fas fa-link"></i></a><a href="#ProcessCall-𝑐-𝑥-𝑐′-O𝑖" class="headerlink" title="ProcessCall(𝑐:𝑥, 𝑐′:O𝑖)"></a>ProcessCall(𝑐:𝑥, 𝑐′:O𝑖)</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302142028418.png" alt="image-20230302142028418"></p>
<p>加入相关上下文，以及一个<code>Select(c,l,c&#39;:Oi)</code>这样一个用来选择上下文的函数，该函数依据自己的算法设计，进行上下文的选择，比如选中多个<code>lable</code>等，用来唯一标识，这个后面会详细讲一下。</p>
<p>注：该算法大多不涉及循环处理，因为开销比较大。其他领域有这个方面的。</p>

        <h2 id="4-Context-Sensitivity-Variants"   >
          <a href="#4-Context-Sensitivity-Variants" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Context-Sensitivity-Variants" class="headerlink" title="4.Context Sensitivity Variants"></a>4.Context Sensitivity Variants</h2>
      <p>主要讲<code>Select</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302143554661.png" alt="image-20230302143554661"></p>
<p>如上所示，各种上下文都可能会被考虑到。</p>

        <h3 id="Context-Insensitivity"   >
          <a href="#Context-Insensitivity" class="heading-link"><i class="fas fa-link"></i></a><a href="#Context-Insensitivity" class="headerlink" title="Context Insensitivity"></a>Context Insensitivity</h3>
      <p>其实对于<code>C.I.</code>这个技术而言，其本质就可以当作是<code>Select</code>选择出来的上下文为空，即</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302144056744.png" alt="image-20230302144056744"></p>

        <h3 id="Call-Site-Sensitivity"   >
          <a href="#Call-Site-Sensitivity" class="heading-link"><i class="fas fa-link"></i></a><a href="#Call-Site-Sensitivity" class="headerlink" title="Call-Site Sensitivity"></a>Call-Site Sensitivity</h3>
      <p><code>Olin Shivers, 1991. “Control-Flow Analysis of Higher-Order Languages”.  Ph.D. Dissertation. Carnegie Mellon University.</code>论文提出，方法叫做<code>Call-Site Sensitivity</code> ，或者<code>call-string  Sensitivity</code>，或者<code>k-CFA(Control-Flow Analysis)</code></p>
<p>其实就是一个<code>call chain</code>调用链，</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302144152217.png" alt="image-20230302144152217"></p>
<p>即当进行<code>ProcessCall</code>的<code>Select</code>时，做的工作就是一个并集，将当前的调用点加入到之前的上下文中，形成当前新的上下文，调试程序的时候就经常可以看到，提供的例子如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302144545841.png" alt="image-20230302144545841"></p>
<p>但是这种有递归的情况中，由于每次碰到新的上下文方法，都会进行分析，所以就会导致分析出无穷无尽的调用链和对应的调用方法，那么就需要引入一个能够进行终止的方法<code>k-Call-Site Sensitivity/k-CFA</code>。</p>

        <h3 id="k-Call-Site-Sensitivity-k-CFA"   >
          <a href="#k-Call-Site-Sensitivity-k-CFA" class="heading-link"><i class="fas fa-link"></i></a><a href="#k-Call-Site-Sensitivity-k-CFA" class="headerlink" title="k-Call-Site Sensitivity/k-CFA"></a>k-Call-Site Sensitivity/k-CFA</h3>
      <p>加入一个<code>k</code>个数的限制</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302145404139.png" alt="image-20230302145404139"></p>
<p>即确保上下文个数为<code>k</code>个，如果超过了，就舍弃掉最老的上下文。</p>
<p>比如<code>k=2</code>,在<code>[2,3]</code>上下文中需要加入<code>[4]</code>，那么分析发现上下文个数超过<code>k</code>个，那么就舍弃掉<code>2</code>，新的上下文变成<code>[3,4]</code>。相当于是个缓存了。</p>

        <h4 id="实例-4"   >
          <a href="#实例-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4>
      <p>相关例子如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> <span class="keyword">implements</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">implements</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c.m();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Number <span class="title">id</span><span class="params">(Number n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Number n1,n2,x,y;</span><br><span class="line">        n1 = <span class="keyword">new</span> One();</span><br><span class="line">        n2 = <span class="keyword">new</span> Two();</span><br><span class="line">        x = <span class="keyword">this</span>.id(n1);</span><br><span class="line">        y = <span class="keyword">this</span>.id(n2);</span><br><span class="line">        x.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>省略掉<code>C.S.Heap</code>方法以及<code>m</code>函数里的<code>this</code>变量。</p>

        <h5 id="初始化-1"   >
          <a href="#初始化-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5>
      <p>首先是初始化，经过<code>AddReachable</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302150804549.png" alt="image-20230302150804549"></p>
<p>得到结果如下</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RM = &#123;[]:C.main()&#125;</span><br><span class="line">WL = [&lt;[]:c,&#123;O3&#125;&gt;]</span><br><span class="line">由于没有x=y之类的语句,没有调用到AddEdge</span><br><span class="line">CG = &#123;&#125;</span><br><span class="line">PFG = &#123;&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="WL处理-2"   >
          <a href="#WL处理-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#WL处理-2" class="headerlink" title="WL处理"></a>WL处理</h5>
      
        <h6 id="第一次迭代-5"   >
          <a href="#第一次迭代-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次迭代-5" class="headerlink" title="第一次迭代"></a>第一次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;[]:c,&#123;O3&#125;&gt;;</span><br><span class="line">WL = [];</span><br><span class="line">RM = &#123;[]:C.main()&#125;;</span><br><span class="line">CG = &#123;&#125;;</span><br><span class="line">PFG = &#123;&#125;;</span><br><span class="line">n = []:c;</span><br><span class="line">pts = &#123;O3&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O3&#125; - &#123;&#125; = &#123;O3&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O3&#125;;</span><br><span class="line">	pt([]:c) = pt(n) = pts ⋃ pt(n) = &#123;O3&#125; ⋃ &#123;&#125; = &#123;O3&#125;;</span><br><span class="line">	PFG没有关于[]:c-&gt;x的流向</span><br><span class="line"></span><br><span class="line">关于a的成员没有相关Load和Store,有函数调用</span><br><span class="line">ProcessCall(c:x,c&#x27;:Oi):</span><br><span class="line">	context_c = [];</span><br><span class="line">	m = C.m();</span><br><span class="line">	c^t = [4];</span><br><span class="line">	WL += &lt;[4]:m_this,&#123;O3&#125;&gt;;</span><br><span class="line">	CG += &#123;[]:4-&gt;[4]:C.m()&#125;;</span><br><span class="line">	AddReachable(c^t:m):</span><br><span class="line">		RM += &#123;[4]:C.m()&#125;;</span><br><span class="line">		WL += [&lt;[4]:n1,&#123;O12&#125;&gt;,&lt;[4]:n2,&#123;O13&#125;&gt;];</span><br><span class="line">		没有关于[4]:n1和[4]:n2的Load操作，退出函数</span><br><span class="line">    没有传参传返回值操作，退出函数</span><br></pre></td></tr></table></div></figure>


        <h6 id="第二次迭代-5"   >
          <a href="#第二次迭代-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次迭代-5" class="headerlink" title="第二次迭代"></a>第二次迭代</h6>
      <p>开始情况如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302152628874.png" alt="image-20230302152628874"></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;[4]:C.m_this,&#123;O3&#125;&gt;;</span><br><span class="line">WL = [&lt;[4]:n1,&#123;O12&#125;&gt;,&lt;[4]:n2,&#123;O13&#125;&gt;];</span><br><span class="line">RM = &#123;[]:C.main(),[4]:C.m()&#125;;</span><br><span class="line">CG = &#123;[]:4-&gt;[4]:C.m()&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = [4]:C.m_this;</span><br><span class="line">pts = &#123;O3&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O3&#125; - &#123;&#125; = &#123;O3&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O3&#125;;</span><br><span class="line">	pt([4]:C.m_this) = pt(n) = pts ⋃ pt(n) = &#123;O3&#125; ⋃ &#123;&#125; = &#123;O3&#125;;</span><br><span class="line">	PFG没有关于[4]:C.m_this-&gt;x的流向</span><br><span class="line"></span><br><span class="line">关于[4]:C.m_this的成员没有相关Load和Store</span><br><span class="line"></span><br><span class="line">存在[4]:C.m_this的函数调用</span><br><span class="line">ProcessCall(c:x,c&#x27;:Oi):</span><br><span class="line">	context_c = [4];</span><br><span class="line">	</span><br><span class="line">	迭代第一次</span><br><span class="line">	m = C.id(Number);</span><br><span class="line">	c^t = [14];</span><br><span class="line">	CG += &#123;[4]:14-&gt;[14]:C.id(Number)&#125;;</span><br><span class="line">	AddReachable(c^t:m):</span><br><span class="line">		RM += &#123;[14]:C.id(Number)&#125;;</span><br><span class="line">		没有新对象产生，退出函数</span><br><span class="line">	AddEdge:</span><br><span class="line">		PFG += &#123;[4]:n1-&gt;[14]:n&#125;;</span><br><span class="line">		PFG += &#123;[14]:n-&gt;[4]:x&#125;;</span><br><span class="line">	</span><br><span class="line">	迭代第二次</span><br><span class="line">	m = C.id(Number);</span><br><span class="line">	c^t = [15];</span><br><span class="line">	CG += &#123;[4]:15-&gt;[15]:c.id(Number)&#125;;</span><br><span class="line">	AddReachable(c^t:m):</span><br><span class="line">		RM += &#123;[15]:C.id(Number)&#125;;</span><br><span class="line">		没有新对象产生，退出函数</span><br><span class="line">	AddEdge:</span><br><span class="line">		PFG += &#123;[4]:n2-&gt;[15]:n&#125;;</span><br><span class="line">		PFG += &#123;[15]:n-&gt;[4]:y&#125;;</span><br></pre></td></tr></table></div></figure>

<p>结果如下：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302155654514.png" alt="image-20230302155654514"></p>
<p>后面几次迭代就是一些传播了，大致概括如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302161116389.png" alt="image-20230302161116389"></p>

        <h6 id="第三次迭代-4"   >
          <a href="#第三次迭代-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次迭代-4" class="headerlink" title="第三次迭代"></a>第三次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;[4]:n1,&#123;O12&#125;&gt;;</span><br><span class="line">WL = [&lt;[4]:n2,&#123;O13&#125;&gt;];</span><br><span class="line">RM = &#123;[]:C.main(),[4]:C.m(),[14]:C.id(Number),[15]:C.id(Number)&#125;;</span><br><span class="line">CG = &#123;[]:4-&gt;[4]:C.m(),[4]:14-&gt;[14]:C.id(Number),[4]:15-&gt;[15]:C.id(Number)&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = [4]:n1;</span><br><span class="line">pts = &#123;O12&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O12&#125; - &#123;&#125; = &#123;O12&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O12&#125;;</span><br><span class="line">	pt([4]:n1) = pt(n) = pts ⋃ pt(n) = &#123;O12&#125; ⋃ &#123;&#125; = &#123;O12&#125;;</span><br><span class="line">	WL += &lt;[14]:n,&#123;O12&#125;&gt;;</span><br><span class="line"></span><br><span class="line">关于[4]:n1的成员没有相关Load和Store以及函数调用，退出</span><br></pre></td></tr></table></div></figure>


        <h6 id="第四次迭代-2"   >
          <a href="#第四次迭代-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次迭代-2" class="headerlink" title="第四次迭代"></a>第四次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;[4]:n2,&#123;O13&#125;&gt;;</span><br><span class="line">WL = [&lt;[14]:n,&#123;O12&#125;&gt;];</span><br><span class="line">RM = &#123;[]:C.main(),[4]:C.m(),[14]:C.id(Number),[15]:C.id(Number)&#125;;</span><br><span class="line">CG = &#123;[]:4-&gt;[4]:C.m(),[4]:14-&gt;[14]:C.id(Number),[4]:15-&gt;[15]:C.id(Number)&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = [4]:n2;</span><br><span class="line">pts = &#123;O13&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O13&#125; - &#123;&#125; = &#123;O13&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O13&#125;;</span><br><span class="line">	pt([4]:n2) = pt(n) = pts ⋃ pt(n) = &#123;O13&#125; ⋃ &#123;&#125; = &#123;O13&#125;;</span><br><span class="line">	WL += &lt;[15]:n,&#123;O13&#125;&gt;;</span><br><span class="line"></span><br><span class="line">关于[4]:n2的成员没有相关Load和Store以及函数调用，退出</span><br></pre></td></tr></table></div></figure>


        <h6 id="第五次迭代-2"   >
          <a href="#第五次迭代-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五次迭代-2" class="headerlink" title="第五次迭代"></a>第五次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;[14]:n,&#123;O12&#125;&gt;;</span><br><span class="line">WL = [&lt;[15]:n,&#123;O13&#125;&gt;];</span><br><span class="line">RM = &#123;[]:C.main(),[4]:C.m(),[14]:C.id(Number),[15]:C.id(Number)&#125;;</span><br><span class="line">CG = &#123;[]:4-&gt;[4]:C.m(),[4]:14-&gt;[14]:C.id(Number),[4]:15-&gt;[15]:C.id(Number)&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = [14]:n;</span><br><span class="line">pts = &#123;O12&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O12&#125; - &#123;&#125; = &#123;O12&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O12&#125;;</span><br><span class="line">	pt([14]:n) = pt(n) = pts ⋃ pt(n) = &#123;O12&#125; ⋃ &#123;&#125; = &#123;O12&#125;;</span><br><span class="line">	WL += &lt;[4]:x,&#123;O12&#125;&gt;;</span><br><span class="line"></span><br><span class="line">关于[14]:n的成员没有相关Load和Store以及函数调用，退出</span><br></pre></td></tr></table></div></figure>


        <h6 id="第六次迭代-2"   >
          <a href="#第六次迭代-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第六次迭代-2" class="headerlink" title="第六次迭代"></a>第六次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;[15]:n,&#123;O13&#125;&gt;;</span><br><span class="line">WL = [&lt;[4]:x,&#123;O12&#125;&gt;];</span><br><span class="line">RM = &#123;[]:C.main(),[4]:C.m(),[14]:C.id(Number),[15]:C.id(Number)&#125;;</span><br><span class="line">CG = &#123;[]:4-&gt;[4]:C.m(),[4]:14-&gt;[14]:C.id(Number),[4]:15-&gt;[15]:C.id(Number)&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = [15]:n;</span><br><span class="line">pts = &#123;O13&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O13&#125; - &#123;&#125; = &#123;O13&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O13&#125;;</span><br><span class="line">	pt([15]:n) = pt(n) = pts ⋃ pt(n) = &#123;O13&#125; ⋃ &#123;&#125; = &#123;O13&#125;;</span><br><span class="line">	WL += &lt;[4]:y,&#123;O13&#125;&gt;;</span><br><span class="line"></span><br><span class="line">关于[15]:n的成员没有相关Load和Store以及函数调用，退出</span><br></pre></td></tr></table></div></figure>


        <h6 id="第七次迭代-1"   >
          <a href="#第七次迭代-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第七次迭代-1" class="headerlink" title="第七次迭代"></a>第七次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;[4]:x,&#123;O12&#125;&gt;;</span><br><span class="line">WL = [&lt;[4]:y,&#123;O13&#125;&gt;];</span><br><span class="line">RM = &#123;[]:C.main(),[4]:C.m(),[14]:C.id(Number),[15]:C.id(Number)&#125;;</span><br><span class="line">CG = &#123;[]:4-&gt;[4]:C.m(),[4]:14-&gt;[14]:C.id(Number),[4]:15-&gt;[15]:C.id(Number)&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = [4]:x;</span><br><span class="line">pts = &#123;O12&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O12&#125; - &#123;&#125; = &#123;O12&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O12&#125;;</span><br><span class="line">	pt([4]:x) = pt(n) = pts ⋃ pt(n) = &#123;O12&#125; ⋃ &#123;&#125; = &#123;O12&#125;;</span><br><span class="line">	PFG没有关于[4]:x-&gt;xxx的流向</span><br><span class="line"></span><br><span class="line">关于[4]:x的成员存在函数调用</span><br><span class="line">ProcessCall(c:x,c&#x27;:Oi):</span><br><span class="line">	context_c = [4];</span><br><span class="line">	</span><br><span class="line">	迭代第一次</span><br><span class="line">	m = One.get();</span><br><span class="line">	c^t = [16];</span><br><span class="line">	CG += &#123;[4]:16-&gt;[16]:One.get()&#125;;</span><br><span class="line">	AddReachable(c^t:m):</span><br><span class="line">		RM += &#123;[16]:One.get()&#125;;</span><br><span class="line">		没有新对象产生，退出函数</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	迭代第二次</span><br><span class="line">	m = C.id(Number);</span><br><span class="line">	c^t = [15];</span><br><span class="line">	CG += &#123;[4]:15-&gt;[15]:c.id(Number)&#125;;</span><br><span class="line">	AddReachable(c^t:m):</span><br><span class="line">		RM += &#123;[15]:C.id(Number)&#125;;</span><br><span class="line">		没有新对象产生，退出函数</span><br><span class="line">	没有传参传返回值操作，退出函数</span><br></pre></td></tr></table></div></figure>


        <h6 id="第八次迭代-1"   >
          <a href="#第八次迭代-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第八次迭代-1" class="headerlink" title="第八次迭代"></a>第八次迭代</h6>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Processing = &lt;[4]:y,&#123;O13&#125;&gt;;</span><br><span class="line">WL = [];</span><br><span class="line">RM = &#123;[]:C.main(),[4]:C.m(),[14]:C.id(Number),[15]:C.id(Number)&#125;;</span><br><span class="line">CG = &#123;[]:4-&gt;[4]:C.m(),[4]:14-&gt;[14]:C.id(Number),[4]:15-&gt;[15]:C.id(Number)&#125;;</span><br><span class="line">PFG = &#123;...&#125;;</span><br><span class="line">n = [4]:y;</span><br><span class="line">pts = &#123;O13&#125;;</span><br><span class="line">Δ = pts - pt(n) = &#123;O13&#125; - &#123;&#125; = &#123;O13&#125;;</span><br><span class="line"></span><br><span class="line">Propagate(n,Δ):</span><br><span class="line">	pts = Δ = &#123;O13&#125;;</span><br><span class="line">	pt([4]:y) = pt(n) = pts ⋃ pt(n) = &#123;O13&#125; ⋃ &#123;&#125; = &#123;O13&#125;;</span><br><span class="line">	PFG没有关于[4]:y-&gt;xxx的流向</span><br><span class="line"></span><br><span class="line">关于[4]:y的成员没有相关Load和Store以及函数调用,退出函数</span><br></pre></td></tr></table></div></figure>

<p>到此<code>WL</code>清空，算法结束，最终结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302161839478.png" alt="image-20230302161839478"></p>

        <h3 id="Object-Sensitivity"   >
          <a href="#Object-Sensitivity" class="heading-link"><i class="fas fa-link"></i></a><a href="#Object-Sensitivity" class="headerlink" title="Object Sensitivity"></a>Object Sensitivity</h3>
      <p>和之前提到的<code>K-Call-Site</code>方法类似，以对象作为上下文的参照</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302163209957.png" alt="image-20230302163209957"></p>

        <h4 id="实例-5"   >
          <a href="#实例-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302165510010.png" alt="image-20230302165510010"></p>
<p>即针对调用时的<code>this</code>对象来作为一个上下文的标识。</p>

        <h3 id="Call-Site和Object-Sensitivity对比"   >
          <a href="#Call-Site和Object-Sensitivity对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#Call-Site和Object-Sensitivity对比" class="headerlink" title="Call-Site和Object-Sensitivity对比"></a>Call-Site和Object-Sensitivity对比</h3>
      <p>这里把<code>1-Call-Site</code>和``1-Object-Sensitivity`进行一个对比，结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302165832151.png" alt="image-20230302165832151"></p>
<p>在该例子中，<code>1-Object</code>更加准确，但是另一个例子如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302165911690.png" alt="image-20230302165911690"></p>
<p><code>1-Call-Site</code>会更加准确。</p>
<p>所以在理论上，两者没有办法进行比较，但是在实际操作中，针对<code>OO</code>语言来说，<code>Object Sensitivity</code>更加好一点。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302170216610.png" alt="image-20230302170216610"></p>
<p>这个相关的一些对比如下，是两位讲课老师发表的论文，该论文提到一种更加行之有效的方法，只针对程序中一小部分内容运用<code>Object-Sensitivity</code>方法，会更加有效，不过这部分内容也需要一定的资源进行计算。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302170328419.png" alt="image-20230302170328419"></p>
<p>从运行的时间(越短越好)，调用图的边数(越少越好)，以及<code>cast</code>的转化失败可能性(越低越好)来对比，<code>object-Sensitivity</code>在<code>OO</code>语言上表现更好。</p>

        <h3 id="Type-Sensitivity"   >
          <a href="#Type-Sensitivity" class="heading-link"><i class="fas fa-link"></i></a><a href="#Type-Sensitivity" class="headerlink" title="Type Sensitivity"></a>Type Sensitivity</h3>
      <p>也有很多其他上下文挑选条件，比如<code>Type Sensitivity</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302170807480.png" alt="image-20230302170807480"></p>
<p>即在调用点所在类的类型作为筛选条件。</p>
<p>该方法的精度小于等于<code>Object-Sensitivity</code>，但是速度更快。而在实际上<code>Type-Sensitivity</code>的精度与<code>Object-Sensitivity</code>相差不是很多</p>

        <h3 id="总结对比"   >
          <a href="#总结对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302171308228.png" alt="image-20230302171308228"></p>
<p>以上三种方法针对<code>OO</code>语言，最终对比如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302171258044.png" alt="image-20230302171258044"></p>

        <h2 id="总结-6"   >
          <a href="#总结-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230302171616516.png" alt="image-20230302171616516"></p>
<p>理解上下文指针分析的算法，通常的上下文几个<code>variants</code>变种，以及不同<code>variants</code>变种之间的对比差异等等。</p>

        <h1 id="十二、Static-Program-Analysis"   >
          <a href="#十二、Static-Program-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#十二、Static-Program-Analysis" class="headerlink" title="十二、Static Program Analysis"></a>十二、Static Program Analysis</h1>
      
        <h2 id="1-Information-Flow-Security"   >
          <a href="#1-Information-Flow-Security" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Information-Flow-Security" class="headerlink" title="1.Information Flow Security"></a>1.Information Flow Security</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304114214942.png" alt="image-20230304114214942"></p>
<p>即定义程序中变量的安全等级，明确不同安全等级之间的流动策略，以及相关的访问权限策略等。</p>

        <h3 id="Information-Flow"   >
          <a href="#Information-Flow" class="heading-link"><i class="fas fa-link"></i></a><a href="#Information-Flow" class="headerlink" title="Information Flow"></a>Information Flow</h3>
      <p><code>Information Flow</code>信息流相关概念就不用太说明了</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304113722316.png" alt="image-20230304113722316"></p>

        <h3 id="Security-levels-Classes"   >
          <a href="#Security-levels-Classes" class="heading-link"><i class="fas fa-link"></i></a><a href="#Security-levels-Classes" class="headerlink" title="Security levels(Classes)"></a>Security levels(Classes)</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304114340189.png" alt="image-20230304114340189"></p>
<p>比较常见的就是<code>two-level policy</code>，低等密级和高等密级，或者一些更加复杂的</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304114618338.png" alt="image-20230304114618338"></p>

        <h3 id="Information-Flow-Policy"   >
          <a href="#Information-Flow-Policy" class="heading-link"><i class="fas fa-link"></i></a><a href="#Information-Flow-Policy" class="headerlink" title="Information Flow Policy"></a>Information Flow Policy</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304114843239.png" alt="image-20230304114843239"></p>
<p>常见的策略就是<code>Noninterference policy</code>非干涉策略，即高密级的不能流向低密级的，低密级可以流向高密级的</p>

        <h4 id="Noninterference"   >
          <a href="#Noninterference" class="heading-link"><i class="fas fa-link"></i></a><a href="#Noninterference" class="headerlink" title="Noninterference"></a>Noninterference</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304115159940.png" alt="image-20230304115159940"></p>
<p>由上述例子大概可以知道该策略的相关的信息流动规则。</p>

        <h2 id="2-Confidentiality-and-Integrity"   >
          <a href="#2-Confidentiality-and-Integrity" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Confidentiality-and-Integrity" class="headerlink" title="2.Confidentiality and Integrity"></a>2.Confidentiality and Integrity</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304120447356.png" alt="image-20230304120447356"></p>
<p>两者所防御的点不一样，一个像<code>Confidentiality</code>读保护，一个像<code>Integrity</code>写保护</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304121014989.png" alt="image-20230304121014989"></p>

        <h3 id="Integrity"   >
          <a href="#Integrity" class="heading-link"><i class="fas fa-link"></i></a><a href="#Integrity" class="headerlink" title="Integrity"></a>Integrity</h3>
      <p>保护数据的完整性</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304120820220.png" alt="image-20230304120820220"></p>
<p>即防止不可信的数据影响到本地的相关数据程序。</p>
<p>此外还有更加广泛的定义</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304121346571.png" alt="image-20230304121346571"></p>
<p>即数据的<code>Completeness</code>完整性、<code>Correctness</code>准确性、<code>Consistency</code>一致性都是在<code>Integrity</code>的定义下。</p>

        <h3 id="Confidentialityt"   >
          <a href="#Confidentialityt" class="heading-link"><i class="fas fa-link"></i></a><a href="#Confidentialityt" class="headerlink" title="Confidentialityt"></a>Confidentialityt</h3>
      <p>保护数据的保密性，即数据不被泄露。</p>

        <h2 id="3-Explicit-Flows-and-Covert-Channels"   >
          <a href="#3-Explicit-Flows-and-Covert-Channels" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Explicit-Flows-and-Covert-Channels" class="headerlink" title="3.Explicit Flows and Covert Channels"></a>3.Explicit Flows and Covert Channels</h2>
      
        <h3 id="Implicit-Flows"   >
          <a href="#Implicit-Flows" class="heading-link"><i class="fas fa-link"></i></a><a href="#Implicit-Flows" class="headerlink" title="Implicit Flows"></a>Implicit Flows</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304122132934.png" alt="image-20230304122132934"></p>
<p>可以通过判断<code>public_L</code>的值，判断出<code>secret_H</code>的信息，即<code>Implicit Flows</code>隐式流。</p>

        <h4 id="更多例子"   >
          <a href="#更多例子" class="heading-link"><i class="fas fa-link"></i></a><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304122422841.png" alt="image-20230304122422841"></p>
<p>上述的各个语句，都可以通过特定的情形判断出<code>secret_H</code>的相关信息</p>

        <h3 id="Covert-Hidden-Channels"   >
          <a href="#Covert-Hidden-Channels" class="heading-link"><i class="fas fa-link"></i></a><a href="#Covert-Hidden-Channels" class="headerlink" title="Covert/Hidden Channels"></a>Covert/Hidden Channels</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304143310016.png" alt="image-20230304143310016"></p>
<ul>
<li><code>channels</code> : 通过计算来传递信息的机制称为<code>Channels</code>信道</li>
<li><code>Covert Channels</code> : 一个主要目的不是信息传递的信道，但是该信道仍然将信息传递出来了，那么这个信道被称为<code>Covert Channels</code>隐藏信道</li>
</ul>
<p>以上提到的一些信道其实都是这里定义的<code>Covert Channels</code>，都会传递出一定的信息，有点像一些侧信道攻击。</p>

        <h3 id="Explicit-Flows"   >
          <a href="#Explicit-Flows" class="heading-link"><i class="fas fa-link"></i></a><a href="#Explicit-Flows" class="headerlink" title="Explicit Flows"></a>Explicit Flows</h3>
      <p>那么相对于<code>Implicit Flows</code>隐藏信道的就是<code>Explicit Flows</code>显式信道，会传递出更多的信息，如下例子所示。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304143704679.png" alt="image-20230304143704679"></p>

        <h2 id="4-Taint-Analysis"   >
          <a href="#4-Taint-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Taint-Analysis" class="headerlink" title="4.Taint Analysis"></a>4.Taint Analysis</h2>
      <p>针对关心的数据打上标记称为<code>Tainted data</code>，那么依据该数据的源头<code>Source</code>进行分析，尝试寻找<code>tained data</code>是否会流到某个敏感点<code>sink</code>，比如常见的<code>system</code>函数。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304144526463.png" alt="image-20230304144526463"></p>
<p>课程中老师讲到如下的一些例子，类似的。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304144635715.png" alt="image-20230304144635715"></p>

        <h3 id="Taint-and-Pointer-Analysis"   >
          <a href="#Taint-and-Pointer-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#Taint-and-Pointer-Analysis" class="headerlink" title="Taint and Pointer Analysis"></a>Taint and Pointer Analysis</h3>
      <p>可以将指针分析和污点分析相结合，<code>Tainted data</code>污点数据作为一个指针对象，<code>sources</code>作为<code>allocation sites</code>，然后用指针分析来传播<code>tainted data</code>。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304150023175.png" alt="image-20230304150023175"></p>

        <h3 id="Domains-and-Notations"   >
          <a href="#Domains-and-Notations" class="heading-link"><i class="fas fa-link"></i></a><a href="#Domains-and-Notations" class="headerlink" title="Domains and Notations"></a>Domains and Notations</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304151238672.png" alt="image-20230304151238672"></p>
<p>加入了一个污点数据定义，包含在之前的对象集合中</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304151544492.png" alt="image-20230304151544492"></p>
<p>感兴趣的创建对象点为<code>Sources</code>，敏感方法为<code>Sinks</code>，最终可以输出一个<code>pair</code>，<code>&lt;i,j,k&gt;</code>表示从<code>source_i</code>的污点数据可能会流到<code>k</code>个参数的<code>call_site_j</code>这个<code>sink</code>方法中。</p>

        <h3 id="Rules-1"   >
          <a href="#Rules-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rules-1" class="headerlink" title="Rules"></a>Rules</h3>
      
        <h4 id="Rules-Sources"   >
          <a href="#Rules-Sources" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rules-Sources" class="headerlink" title="Rules:Sources"></a>Rules:Sources</h4>
      <p>处理<code>Sources</code>的方法</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304152043659.png" alt="image-20230304152043659"></p>
<p>即在指针分析的<code>call</code>时，某个调用点会调用到属于<code>Sources</code>的方法<code>m</code>，那么就会创建一个<code>t_l</code>污点数据放入该方法返回值的指针集<code>pt(r)</code>里面。</p>

        <h4 id="Rules-Propagate"   >
          <a href="#Rules-Propagate" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rules-Propagate" class="headerlink" title="Rules:Propagate"></a>Rules:Propagate</h4>
      <p>传播的过程和指针分析类似，因为污点数据其实就是一个对象集合。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304152545326.png" alt="image-20230304152545326"></p>

        <h4 id="Rules-sink"   >
          <a href="#Rules-sink" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rules-sink" class="headerlink" title="Rules:sink"></a>Rules:sink</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304152630082.png" alt="image-20230304152630082"></p>
<p>当某个点调用到属于<code>Sinks</code>的方法时，如果方法调用参数中包含污点数据，那么就会将一个<code>pair&lt;j,l,i&gt;</code>加入到<code>TaintFlows</code>中方便后面进行输出。</p>

        <h3 id="实例-6"   >
          <a href="#实例-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304153919785.png" alt="image-20230304153919785"></p>
<p>首先是污点分析的<code>tainted data</code>的创建，这里就是<code>t3</code>加入到<code>pt(pw)</code>，然后就会随着<code>pt(pw)</code>一直流动到<code>s</code>中，直到调用到<code>sink</code>点时，检测到传入的参数中包含<code>pt(pw)</code>这个<code>tainted data</code>，就可以加入到<code>TaintFlows</code>了。</p>
<p>其中<code>&lt;3,7,0&gt;</code>代表在<code>3</code>处的<code>tainted data</code>会流向到<code>7</code>处的<code>sink</code>，参数位置为第<code>0</code>个参数。</p>

        <h2 id="总结-7"   >
          <a href="#总结-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304154401211.png" alt="image-20230304154401211"></p>
<p>信息流安全的概念，信息的完整性和保密性，显式和隐式的信道，以及污点分析的相关使用。</p>

        <h1 id="十三、Datalog-Based-Program-Analysis"   >
          <a href="#十三、Datalog-Based-Program-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#十三、Datalog-Based-Program-Analysis" class="headerlink" title="十三、Datalog-Based Program Analysis"></a>十三、Datalog-Based Program Analysis</h1>
      <p>基于<code>Datalog</code>来进行程序分析</p>

        <h2 id="1-Motivation-2"   >
          <a href="#1-Motivation-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Motivation-2" class="headerlink" title="1.Motivation"></a>1.Motivation</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304155559173.png" alt="image-20230304155559173"></p>
<ul>
<li><p><code>Imperative</code>命令式语言</p>
<p>告诉计算机怎么做，类似<code>C</code>语言</p>
</li>
<li><p><code>Declarative</code>声明式语言</p>
<p>告诉计算机要做什么，类似<code>SQL</code>语言</p>
</li>
</ul>

        <h3 id="Pointer-Analysis-Imperative-Implementation"   >
          <a href="#Pointer-Analysis-Imperative-Implementation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Pointer-Analysis-Imperative-Implementation" class="headerlink" title="Pointer Analysis, Imperative  Implementation"></a>Pointer Analysis, Imperative  Implementation</h3>
      <ul>
<li><code>worklist</code>：<ul>
<li><code>Array/list</code>？</li>
<li>先进先出吗？</li>
</ul>
</li>
<li><code>points-to set(pt)</code>：<ul>
<li><code>Hash/vector</code>？</li>
</ul>
</li>
<li><code>PFG nodes</code>：<ul>
<li>变量和节点的关联</li>
</ul>
</li>
<li><code>variables and relevant statements</code>变量和相关语句的关联</li>
</ul>

        <h3 id="Pointer-Analysis-Declarative-Implementation-via-Datalog"   >
          <a href="#Pointer-Analysis-Declarative-Implementation-via-Datalog" class="heading-link"><i class="fas fa-link"></i></a><a href="#Pointer-Analysis-Declarative-Implementation-via-Datalog" class="headerlink" title="Pointer Analysis, Declarative  Implementation (via Datalog)"></a>Pointer Analysis, Declarative  Implementation (via Datalog)</h3>
      <p>通过<code>Datalog</code>来实现指针分析比较好实现</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304160203485.png" alt="image-20230304160203485"></p>

        <h2 id="2-Introduction-to-Datalog"   >
          <a href="#2-Introduction-to-Datalog" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Introduction-to-Datalog" class="headerlink" title="2.Introduction to Datalog"></a>2.Introduction to Datalog</h2>
      <p><code>Datalog = Data + Logic</code></p>
<p>最开始是从数据查询语言发展而来</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304160546783.png" alt="image-20230304160546783"></p>

        <h3 id="Predicates-Data"   >
          <a href="#Predicates-Data" class="heading-link"><i class="fas fa-link"></i></a><a href="#Predicates-Data" class="headerlink" title="Predicates(Data)"></a>Predicates(Data)</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304160824947.png" alt="image-20230304160824947"></p>
<p>这张表中，<code>Predicates</code>谓词即为<code>Age</code>，某个<code>Statements</code>在表中即为<code>fact</code>，不在就不是<code>fact</code>。</p>

        <h3 id="Atoms"   >
          <a href="#Atoms" class="heading-link"><i class="fas fa-link"></i></a><a href="#Atoms" class="headerlink" title="Atoms"></a>Atoms</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230304161051316.png" alt="image-20230304161051316"></p>
<p><code>Atoms</code>在<code>Datalog</code>语言中是最小的语句，形式如同<code>Age(&quot;Xiaoming&quot;,18)</code></p>

        <h4 id="relational-atom"   >
          <a href="#relational-atom" class="heading-link"><i class="fas fa-link"></i></a><a href="#relational-atom" class="headerlink" title="relational atom"></a>relational atom</h4>
      <p>形如<code>P(X1,X2,…,Xn)</code>被称为关系型<code>Atoms</code>，比如<code>Age(“Xiaoming”,18)</code>，代表一种关系。</p>

        <h3 id="Rules-2"   >
          <a href="#Rules-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rules-2" class="headerlink" title="Rules"></a>Rules</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311103310452.png" alt="image-20230311103310452"></p>
<p>感觉就是通过数据<code>Facts</code>，然后给定规则<code>Rules</code>，最后得到一个结果<code>Datalog program</code></p>

        <h3 id="EDB-and-IDB-Predicates"   >
          <a href="#EDB-and-IDB-Predicates" class="heading-link"><i class="fas fa-link"></i></a><a href="#EDB-and-IDB-Predicates" class="headerlink" title="EDB and IDB Predicates"></a>EDB and IDB Predicates</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311105116933.png" alt="image-20230311105116933"></p>
<p>这里不是很懂这两个数据库的概念，后面再来看看把，其中<code>EDB</code>是不能修改的。</p>

        <h3 id="Logical-Or"   >
          <a href="#Logical-Or" class="heading-link"><i class="fas fa-link"></i></a><a href="#Logical-Or" class="headerlink" title="Logical Or"></a>Logical Or</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311104245405.png" alt="image-20230311104245405"></p>
<p>逻辑<code>or</code>的操作符为<code>;</code>，运算优先级小于逻辑<code>and</code>。</p>

        <h3 id="Negation"   >
          <a href="#Negation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Negation" class="headerlink" title="Negation"></a>Negation</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311104418530.png" alt="image-20230311104418530"></p>
<p>逻辑非的运算符<code>!</code>，类似的。</p>

        <h3 id="Recursion"   >
          <a href="#Recursion" class="heading-link"><i class="fas fa-link"></i></a><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3>
      <p>递归的性质</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311105157450.png" alt="image-20230311105157450"></p>
<p>即某个<code>IDB</code>某些数据加上一些东西也可以推导出该<code>IDB</code>的某些数据，就有一个递归在里面。</p>
<p>正是有了递归使得<code>Datalog</code>变得更加丰富，不再像只是简单查询的类似<code>SQL</code>的语言。</p>

        <h3 id="Rule-Safety"   >
          <a href="#Rule-Safety" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule-Safety" class="headerlink" title="Rule Safety"></a>Rule Safety</h3>
      <p>在<code>Datalog</code>中的<code>rule</code>存在<code>safe</code>的概念</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311105839092.png" alt="image-20230311105839092"></p>
<p>比如上述图片提到的例子，<code>x&gt;y</code>中的<code>x</code>是无穷的，<code>!C(x,y)</code>的元素也是无穷的，这样的就是<code>unsafe</code>的。</p>
<p>一个<code>safe Rule</code>中的所有变量都只能出现在<code>non-negated</code>，即不是否定<code>!</code>的关系<code>Atom</code>中。</p>
<p>在<code>Datalog</code>中只有<code>safe rule</code>可被允许。</p>

        <h3 id="Recursion-and-Negation"   >
          <a href="#Recursion-and-Negation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Recursion-and-Negation" class="headerlink" title="Recursion and Negation"></a>Recursion and Negation</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311111635015.png" alt="image-20230311111635015"></p>
<p>这种没有意义的规则是不能写的，没有含义，<code>Datalog</code>也不会允许。</p>

        <h3 id="Execution-of-Datalog-Programs"   >
          <a href="#Execution-of-Datalog-Programs" class="heading-link"><i class="fas fa-link"></i></a><a href="#Execution-of-Datalog-Programs" class="headerlink" title="Execution of Datalog Programs"></a>Execution of Datalog Programs</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311112053774.png" alt="image-20230311112053774"></p>
<p>不同的语言引擎其规则大同小异</p>
<p><code>Datalog</code>具有单调性，其<code>Facts</code>只会单调递增，并且<code>Datalog</code>程序一定会终止，因为其<code>Monotonicity</code>单调性以及<code>safe rulety</code>。</p>

        <h2 id="3-Pointer-Analysis-via-Datalog"   >
          <a href="#3-Pointer-Analysis-via-Datalog" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Pointer-Analysis-via-Datalog" class="headerlink" title="3.Pointer Analysis via Datalog"></a>3.Pointer Analysis via Datalog</h2>
      
        <h3 id="相关概念"   >
          <a href="#相关概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3>
      
        <h4 id="EDB"   >
          <a href="#EDB" class="heading-link"><i class="fas fa-link"></i></a><a href="#EDB" class="headerlink" title="EDB"></a>EDB</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311112346195.png" alt="image-20230311112346195"></p>
<ul>
<li><code>EDB</code>：能直接从程序中得到的关系数据库，比如<code>New、Assign</code>等等</li>
<li><code>IDB</code>：最终的指针分析结果</li>
<li><code>Rules</code>：指针分析设定的规则</li>
</ul>
<p>比如如下的情况</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311112601320.png" alt="image-20230311112601320"></p>

        <h4 id="Rules-3"   >
          <a href="#Rules-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rules-3" class="headerlink" title="Rules"></a>Rules</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311113933344.png" alt="image-20230311113933344"></p>
<p>基本都是一一对应的，对应理解就好</p>

        <h4 id="Call"   >
          <a href="#Call" class="heading-link"><i class="fas fa-link"></i></a><a href="#Call" class="headerlink" title="Call"></a>Call</h4>
      <p>分为几个部分一一对应</p>

        <h5 id="one"   >
          <a href="#one" class="heading-link"><i class="fas fa-link"></i></a><a href="#one" class="headerlink" title="one"></a>one</h5>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311141910814.png" alt="image-20230311141910814"></p>
<ul>
<li><code>VCall(l:S,x:V,k:M)</code> : 代表<code>l</code>语句下调用<code>x.k(..)</code></li>
<li><code>Dispatch(o:O,k:M,m:M)</code> : 和之前一样的，找到对应函数<code>m</code></li>
<li><code>ThisVar(m:M,this:V)</code> : 代表获取<code>this</code>变量</li>
<li><code>Reachable(m:M)</code> : 代表添加可达方法<code>m</code></li>
<li><code>CallGraph(l:S,m:M)</code> : 代表 <code>l</code>语句调用到函数<code>m</code>，正常的<code>CG</code></li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Oi∈ pt(x),m = Dispatch(Oi, k) ---&gt; Oi∈ pt(M_this)</span><br></pre></td></tr></table></div></figure>

<p>即该条件转化为<code>Datalog</code>为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VarPointsTo(this, o),Reachable(m),CallGraph(l, m) &lt;-VCall(l, x, k),VarPointsTo(x, o),Dispatch(o, k, m),ThisVar(m, this).</span><br></pre></td></tr></table></div></figure>


        <h5 id="two"   >
          <a href="#two" class="heading-link"><i class="fas fa-link"></i></a><a href="#two" class="headerlink" title="two"></a>two</h5>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311152853949.png" alt="image-20230311152853949"></p>
<ul>
<li><code>Argument(l:S,i:N,ai:V)</code> : 代表实参，即调用点的实参表示，调用点<code>l</code>的<code>ai</code>参数</li>
<li><code>Parameter(m:M,i:N,pi:V)</code> : 代表函数中的形参，函数中的<code>pi</code>参数。</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ou∈pt(aj),1≤j≤n  ---&gt; Ou∈pt(m_pj),1≤j≤n</span><br></pre></td></tr></table></div></figure>

<p>对应参数的传递，转化为<code>Datalog</code>即为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VarPointsTo(pi,o) &lt;- CallGraph(l,m),Argument(l, i,ai),Parameter(m,i,pi),VarPointsTo(ai,o).</span><br></pre></td></tr></table></div></figure>


        <h5 id="three"   >
          <a href="#three" class="heading-link"><i class="fas fa-link"></i></a><a href="#three" class="headerlink" title="three"></a>three</h5>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311153437690.png" alt="image-20230311153437690"></p>
<ul>
<li><code>MethodReturn(m:M,ret:V)</code> : 代表返回值，即函数<code>m</code>中的返回值<code>ret</code></li>
<li><code>CallReturn(l:S,r:V)</code> : 代表调用点<code>l</code>接收返回值到<code>r</code></li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ov∈pt(m_ret)  ---&gt;  Ov∈pt(r)</span><br></pre></td></tr></table></div></figure>

<p>对应返回值的传递，转化为<code>Datalog</code>即为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VarPointsTo(r, o) &lt;- CallGraph(l, m),MethodReturn(m, ret),VarPointsTo(ret, o),CallReturn(l, r).</span><br></pre></td></tr></table></div></figure>

<p>最终结果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311154015447.png" alt="aaaaa"></p>

        <h3 id="实例-7"   >
          <a href="#实例-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3>
      
        <h4 id="EDB-1"   >
          <a href="#EDB-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#EDB-1" class="headerlink" title="EDB"></a>EDB</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311113001636.png" alt="image-20230311113001636"></p>
<p>依据上述的例子能大概推导出相关的<code>EDB</code>了。</p>

        <h4 id="Rules-4"   >
          <a href="#Rules-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rules-4" class="headerlink" title="Rules"></a>Rules</h4>
      <p>依据规则进行一一解析即可求得</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311114532642.png" alt="image-20230311114532642"></p>

        <h4 id="Whole-Program-Pointer-Analysis"   >
          <a href="#Whole-Program-Pointer-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#Whole-Program-Pointer-Analysis" class="headerlink" title="Whole-Program Pointer Analysis"></a>Whole-Program Pointer Analysis</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311154150284.png" alt="image-20230311154150284"></p>
<p>处理<code>New</code>方法时，会限定在<code>reachable</code>方法中</p>

        <h2 id="4-Taint-Analysis-via-Datalog"   >
          <a href="#4-Taint-Analysis-via-Datalog" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Taint-Analysis-via-Datalog" class="headerlink" title="4.Taint Analysis via Datalog"></a>4.Taint Analysis via Datalog</h2>
      
        <h3 id="相关概念-1"   >
          <a href="#相关概念-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230311154838944.png" alt="image-20230311154838944"></p>
<p>主要是<code>Taint(l:S,t:T)</code>的解释，把所有的污点数据产生点<code>call site</code>，即<code>l:S</code>关联到产生的污点数据<code>tainted data</code>，即<code>t:T</code>。<code>TaintFlow</code>差不多是相同的。</p>

        <h4 id="source-sink"   >
          <a href="#source-sink" class="heading-link"><i class="fas fa-link"></i></a><a href="#source-sink" class="headerlink" title="source/sink"></a>source/sink</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314102251546.png" alt="image-20230314102251546"></p>
<p>同样是一一对应的关系，即在指针分析中加入这个污点分析即可。</p>

        <h3 id="优缺点"   >
          <a href="#优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314103528905.png" alt="image-20230314103528905"></p>

        <h4 id="优点Pros"   >
          <a href="#优点Pros" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点Pros" class="headerlink" title="优点Pros"></a>优点Pros</h4>
      <p>比较整洁，容易实现，更容易基于现成的引擎优化进行改造</p>

        <h4 id="缺点Cons"   >
          <a href="#缺点Cons" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点Cons" class="headerlink" title="缺点Cons"></a>缺点Cons</h4>
      <p>因为<code>Datalog</code>的一些限制，导致其表达方式比较少，某些逻辑可能不能表达到位，比如一些<code>for-all</code>的情况等。此外<code>Datalog</code>因为大多基于一些引擎，导致其不能很好地控制性能。</p>

        <h2 id="总结-8"   >
          <a href="#总结-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314104032554.png" alt="image-20230314104032554"></p>
<p>了解<code>Datalog</code>语言，学会通过<code>Datalog</code>实现指针分析、污点分析。</p>

        <h1 id="十四、CFL-Reachability-and-IFDS"   >
          <a href="#十四、CFL-Reachability-and-IFDS" class="heading-link"><i class="fas fa-link"></i></a><a href="#十四、CFL-Reachability-and-IFDS" class="headerlink" title="十四、CFL-Reachability and IFDS"></a>十四、CFL-Reachability and IFDS</h1>
      
        <h2 id="1-Feasible-and-Realizable-Paths"   >
          <a href="#1-Feasible-and-Realizable-Paths" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Feasible-and-Realizable-Paths" class="headerlink" title="1.Feasible and Realizable Paths"></a>1.Feasible and Realizable Paths</h2>
      
        <h3 id="Infeasible-Paths"   >
          <a href="#Infeasible-Paths" class="heading-link"><i class="fas fa-link"></i></a><a href="#Infeasible-Paths" class="headerlink" title="Infeasible Paths:"></a>Infeasible Paths:</h3>
      <p><code>CFG</code>中在程序运行起来并不执行的路径</p>

        <h3 id="Realizable-Paths"   >
          <a href="#Realizable-Paths" class="heading-link"><i class="fas fa-link"></i></a><a href="#Realizable-Paths" class="headerlink" title="Realizable Paths:"></a>Realizable Paths:</h3>
      <p><code>call</code>和<code>return</code>相匹配的路径，即分析的时候不会依据函数传递到其他的变量，如下的调用点<code>1</code>和调用点<code>2</code>。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314145313166.png" alt="image-20230314145313166"></p>
<p>但是<code>Readlizabale path</code>其实也可能不被执行，因为可能该<code>Readlizabale path</code>的调用点是在<code>Infeasible Paths</code>中。另外<code>unrealizable paths</code>一定不会被执行。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314145241336.png" alt="image-20230314145241336"></p>

        <h2 id="2-CFL-Reachability"   >
          <a href="#2-CFL-Reachability" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-CFL-Reachability" class="headerlink" title="2.CFL-Reachability"></a>2.CFL-Reachability</h2>
      <p>一条<code>A</code>到<code>B</code>的路径中所有的边都有一个<code>label</code>，这个<code>lable</code>只能由确定的规则<code>context-free language</code>来定义</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314145614781.png" alt="image-20230314145614781"></p>
<ul>
<li><p><code>context-free language</code> : 遵循<code>context-free grammar(CFG)</code>的语言</p>
</li>
<li><p><code>context-free grammar(CFG)</code> : </p>
<p>有点不理解，<code>Mark</code>一下</p>
</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314193506350.png" alt="image-20230314193506350"></p>
<p>感觉就是一个加了标签的括号匹配算法，满足这个情况即是<code>realizable</code></p>

        <h2 id="3-Overview-of-IFDS"   >
          <a href="#3-Overview-of-IFDS" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Overview-of-IFDS" class="headerlink" title="3.Overview of IFDS"></a>3.Overview of IFDS</h2>
      
        <h3 id="概念-1"   >
          <a href="#概念-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314202708702.png" alt="image-20230314202708702"></p>
<p>在过程间数据流分析中，如果一个<code>f</code>是可分配<code>distributive</code>，并且其<code>domains</code>是<code>finite</code>的，那么就可以用<code>IFDS</code></p>

        <h3 id="Meet-Over-All-Realizable-Paths-MRP"   >
          <a href="#Meet-Over-All-Realizable-Paths-MRP" class="heading-link"><i class="fas fa-link"></i></a><a href="#Meet-Over-All-Realizable-Paths-MRP" class="headerlink" title="Meet-Over-All-Realizable-Paths (MRP)"></a>Meet-Over-All-Realizable-Paths (MRP)</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230314203137454.png" alt="image-20230314203137454"></p>
<p>即在<code>realizable paths</code>上做<code>MOP</code>分析，更加准确</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316101950460.png" alt="image-20230316101950460"></p>
<p>这里属实听得不太懂</p>

        <h3 id="Supergraph"   >
          <a href="#Supergraph" class="heading-link"><i class="fas fa-link"></i></a><a href="#Supergraph" class="headerlink" title="Supergraph"></a>Supergraph</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316102200598.png" alt="image-20230316102200598"></p>
<ul>
<li><code>G* = (N* , E*)</code> : 即每个函数都有自己的<code>FG(flowgraph)</code>，这里的例子即为<code>G_main/G_p</code>，而<code>G_main</code>加上<code>G_p</code>一起组成了整个程序的<code>G*</code>。</li>
<li>每个函数的<code>FG</code>中都会有<code>s_p</code>入口，以及<code>e_p</code>出口。此外对于函数调用的实现用<code>call_p/ret_p</code>来体现。</li>
</ul>

        <h4 id="G"   >
          <a href="#G" class="heading-link"><i class="fas fa-link"></i></a><a href="#G" class="headerlink" title="G*"></a>G*</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316102726071.png" alt="image-20230316102726071"></p>
<p>在每个程序调用中都有三种不同的边</p>
<ul>
<li><code>call-to-return-site edge</code> : 图中紫色的边，<code>Call_p-&gt;Ret_P</code>，在当前函数中。</li>
<li><code>call-to-start edge</code> : 图中绿色的边，<code>Call_p-&gt;S_p</code>，在不同函数中</li>
<li><code>exit-to-return-site edge</code> : 图中深蓝色的边，<code>e_p-&gt;Ret_p</code>，在函数返回时跳转到调用点</li>
</ul>

        <h4 id="Design-Flow-Functions"   >
          <a href="#Design-Flow-Functions" class="heading-link"><i class="fas fa-link"></i></a><a href="#Design-Flow-Functions" class="headerlink" title="Design Flow Functions"></a>Design Flow Functions</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316103727673.png" alt="image-20230316103727673"></p>
<ul>
<li><code>N*</code> : 程序中在没有实际运行前可能没有被初始化的变量</li>
<li><code>λ e_param.e_body</code> : 想想成一个匿名函数，<code>λ</code>为函数名，<code>e_param</code>为函数参数，<code>e_body</code>为函数体，相关的例子如上。</li>
</ul>

        <h5 id="例子-6"   >
          <a href="#例子-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子-6" class="headerlink" title="例子"></a>例子</h5>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316104651630.png" alt="image-20230316104651630"></p>
<ul>
<li><p>首先将未被初始化的变量加入集合<code>S</code> : <code>λ S.&#123;x,g&#125;</code></p>
</li>
<li><p><code>x=0 -&gt; Call_p</code> : 代表<code>x</code>被初始化了，那么需要从集合<code>s</code>中减去<code>x</code>，即为<code>λ S.S-&#123;x&#125;</code></p>
</li>
<li><p><code>Call_p -&gt; S_p</code> : 发生了函数调用，相关参数的值发生传递，即将集合<code>s</code>中所有<code>x</code>替换成<code>a</code>，即为<code>λ S.S</code></p>
</li>
<li><p><code>a=a-g -&gt; Call_p</code> : 当<code>a</code>或者<code>g</code>任意一个变量没有被初始化，那么<code>a</code>就没有被初始化，那么就将<code>a</code>并入到集合<code>s</code>，即为<code>S ∪ &#123;a&#125; </code>。反之，<code>a/g</code>都被初始化了，就代表<code>a</code>也会被初始化，那么就需要从集合<code>s</code>中减去<code>a</code>，即为<code>S - &#123;a&#125;</code></p>
</li>
<li><p><code>Call_p -&gt; Ret_p</code> : </p>
<p>主要考虑两个情况</p>
<ul>
<li>在函数中被初始化了，那么传回来的<code>S</code>中就不会包含<code>g</code>，<code>S-&#123;g&#125;</code>也不包含<code>g</code>，两者相合不包含<code>g</code>，准确</li>
<li>在函数中没有被初始化，那么传回来的<code>S</code>中包含<code>g</code>，<code>S-&#123;g&#125;</code>不包含<code>g</code>，两者相合包含<code>g</code>，准确</li>
</ul>
<p>同样的如果不是<code>S-&#123;g&#125;</code>，那么情况如下</p>
<ul>
<li>在函数中被初始化了，那么传回来的<code>S</code>中就不会包含<code>g</code>，<code>S</code>包含<code>g</code>，两者相合包含<code>g</code>，不准确</li>
<li>在函数中没有被初始化，那么传回来的<code>S</code>中包含<code>g</code>，<code>S</code>包含<code>g</code>，两者相合包含<code>g</code>，准确</li>
</ul>
<p>这样<code>S-&#123;g&#125;</code>就会更加准确</p>
</li>
<li><p><code>e_p -&gt; Ret_p</code> : 发生了函数返回，需要减去本地变量，即为<code>λ S.S-&#123;a&#125;</code></p>
</li>
</ul>

        <h3 id="Exploded-Supergraph"   >
          <a href="#Exploded-Supergraph" class="heading-link"><i class="fas fa-link"></i></a><a href="#Exploded-Supergraph" class="headerlink" title="Exploded Supergraph"></a>Exploded Supergraph</h3>
      
        <h4 id="概念-2"   >
          <a href="#概念-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316113507233.png" alt="image-20230316113507233"></p>
<ul>
<li>需要建立一个<code>representation relations (graphs)</code></li>
<li>每一个<code>flow function</code>都可以被表示成<code>2(D+1)</code>个节点的关系连边，<code>D</code>是<code>dataflow facts</code>的集合</li>
</ul>

        <h4 id="Rule规则"   >
          <a href="#Rule规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rule规则" class="headerlink" title="Rule规则"></a>Rule规则</h4>
      <ul>
<li><code>0-&gt;0</code> : 无条件存在</li>
<li><code>0-&gt;x</code> : 即无条件产生了<code>x</code></li>
<li><code>x-&gt;y</code> : 即在有<code>x</code>的情况下，会产生<code>y</code></li>
</ul>
<p>大概依据上图可以判断一下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316114330648.png" alt="image-20230316114330648"></p>
<p>最终需要依据规则，将<code>G*</code>转化为<code>G#</code></p>

        <h4 id="Why-We-Need-Edge-0-⟶-0"   >
          <a href="#Why-We-Need-Edge-0-⟶-0" class="heading-link"><i class="fas fa-link"></i></a><a href="#Why-We-Need-Edge-0-⟶-0" class="headerlink" title="Why We Need Edge 0 ⟶ 0?"></a>Why We Need Edge 0 ⟶ 0?</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316121445007.png" alt="image-20230316121445007"></p>
<p>即需要<code>0-&gt;0</code>的边来在某点产生新的变量，使得传递<code>reach</code>成立，否则就没办法表达能够<code>reach</code>的概念，那么加入<code>0-&gt;0</code>如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316121607565.png" alt="image-20230316121607565"></p>

        <h4 id="例子-7"   >
          <a href="#例子-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子-7" class="headerlink" title="例子"></a>例子</h4>
      <p>依据相关规则得到如下结果</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316121704079.png" alt="image-20230316121704079"></p>
<p>这个应该不难得到，通过这个图即可判断一些变量是否可达，比如下图画圈的<code>g</code>点就在<code>realizable paths</code>中可达</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316154149995.png" alt="image-20230316154149995"></p>
<p>而下图画圈的<code>g</code>点只会在<code>non-realizable paths</code>中可达，因为该路径括号其实是不匹配的。</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20230316154211337.png" alt="image-20230316154211337"></p>

        <h3 id="Tabulation-Algorithm"   >
          <a href="#Tabulation-Algorithm" class="heading-link"><i class="fas fa-link"></i></a><a href="#Tabulation-Algorithm" class="headerlink" title="Tabulation Algorithm"></a>Tabulation Algorithm</h3>
      <p>依据<code>G#</code>，通过该算法寻找<code>realizable paths</code>寻找变量可达路径。该算法比较复杂，课程进行了简单介绍。具体算法如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316193520580.png" alt="image-20230316193520580"></p>
<p>看到<code>bsauce</code>师傅写的真好：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/148255285" >【课程笔记】南大软件分析课程11——CFL可达性&amp;IFDS（课时15） - 知乎 (zhihu.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>时间复杂度O(ED^3)</li>
</ul>

        <h4 id="Core-Working-Mechanism-of-Tabulation-Algorithm"   >
          <a href="#Core-Working-Mechanism-of-Tabulation-Algorithm" class="heading-link"><i class="fas fa-link"></i></a><a href="#Core-Working-Mechanism-of-Tabulation-Algorithm" class="headerlink" title="Core Working Mechanism of Tabulation Algorithm"></a>Core Working Mechanism of Tabulation Algorithm</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230316192306135.png" alt="image-20230316192306135"></p>
<p>即依照给的顺序依次进行<code>reach</code>可达探测，但是完成<code>Four</code>之后，再碰到<code>Five</code>，就直接进行连边了，因为<code>Two</code>已经进行探测了，不需要再计算一遍了。</p>

        <h2 id="4-Understanding-the-Distributivity-of-IFDS"   >
          <a href="#4-Understanding-the-Distributivity-of-IFDS" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Understanding-the-Distributivity-of-IFDS" class="headerlink" title="4.Understanding the Distributivity of IFDS"></a>4.Understanding the Distributivity of IFDS</h2>
      <p>帮助判断该问题是否可用<code>IFDS</code>来解决</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317100320870.png" alt="image-20230317100320870"></p>
<p>不可以用标准的<code>IFDS</code>来解决这两个问题</p>

        <h3 id="Distributivity"   >
          <a href="#Distributivity" class="heading-link"><i class="fas fa-link"></i></a><a href="#Distributivity" class="headerlink" title="Distributivity"></a>Distributivity</h3>
      <p>常见的分配律</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317100927589.png" alt="image-20230317100927589"></p>

        <h3 id="Constant-Propagation"   >
          <a href="#Constant-Propagation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Constant-Propagation" class="headerlink" title="Constant Propagation"></a>Constant Propagation</h3>
      <p>但是对于<code>Constant Propagation</code>，该语句中的<code>z</code>的结果依赖于<code>x/y</code>共同的结果，并不能单独处理之后得到结果，无法满足分配律。这里其实就有点不懂了，比如之前提到的如下情况，不也是处理两个输入吗</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317105418025.png" alt="image-20230317105418025"></p>
<p>有点不太理解，mark一下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317101652497.png" alt="image-20230317101652497"></p>
<ul>
<li>当一个语句需要考虑多种输入数据才能得到正确结果时，就不是<code>distributive</code>可分配的，不能用<code>IFDS</code></li>
<li>在<code>IFDS</code>中，所有的数据以及传播都需可以被单独处理，这些单独处理并不会导致最终结果的正确性发生改变。</li>
<li><code>IFDS</code>一次<code>f</code>只能处理一个<code>data input</code></li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317102104425.png" alt="image-20230317102104425"></p>
<p>比如上述语句<code>y = 2x + 3</code>可以用<code>IFDS</code>来进行常量传播分析</p>

        <h3 id="Pointer-Analysis"   >
          <a href="#Pointer-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#Pointer-Analysis" class="headerlink" title="Pointer Analysis"></a>Pointer Analysis</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317102902311.png" alt="image-20230317102902311"></p>
<p>这个分析中，最开始分析没有图中红线部分，需要添加一个别名信息才可以<code>alias</code>，即<code>y=x</code>这个情况，但是需要别名信息的话，又要处理多个输入<code>x/y</code>，所以不能用<code>IFDS</code></p>

        <h2 id="总结-9"   >
          <a href="#总结-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317110045113.png" alt="image-20230317110045113"></p>
<p>理解<code>CFL-Reachability</code>(括号匹配问题)，基础的<code>IFDS</code>，以及什么问题可以用<code>IFDS</code>进行解决</p>

        <h1 id="十五、Soundness-and-Soundiness"   >
          <a href="#十五、Soundness-and-Soundiness" class="heading-link"><i class="fas fa-link"></i></a><a href="#十五、Soundness-and-Soundiness" class="headerlink" title="十五、Soundness and Soundiness"></a>十五、Soundness and Soundiness</h1>
      
        <h2 id="1-Soundness-and-Soundiness"   >
          <a href="#1-Soundness-and-Soundiness" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Soundness-and-Soundiness" class="headerlink" title="1.Soundness and Soundiness"></a>1.Soundness and Soundiness</h2>
      
        <h3 id="Soundness"   >
          <a href="#Soundness" class="heading-link"><i class="fas fa-link"></i></a><a href="#Soundness" class="headerlink" title="Soundness"></a>Soundness</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230317115113287.png" alt="image-20230317115113287"></p>
<p>可以分析程序所有可能的执行结果，包括动态运行的，称为<code>Sound</code>。但是无论学术界还是工业界中，基本都是<code>UnSound</code>，即无法分析到程序所有可能的执行结果。</p>

        <h3 id="Hard-Language-Features-for-Static-Analysis"   >
          <a href="#Hard-Language-Features-for-Static-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#Hard-Language-Features-for-Static-Analysis" class="headerlink" title="Hard Language Features for Static Analysis"></a>Hard Language Features for Static Analysis</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318104624160.png" alt="image-20230318104624160"></p>
<p>即一些比较难以进行程序分析的语言。</p>
<p>有的分析研究希望能够寻找到一个保守估计的结果进行分析，比如<code>C/C++</code>里面的<code>Point</code>的地址进行加减的时候，就将该整个块当作指针可能的结果进行分析，但是也会相当不准确。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318104906691.png" alt="image-20230318104906691"></p>
<p>大部分的研究说分析是<code>Sound</code>的，其实都不是<code>Sound</code>，这些都会造成一些误导，导致过分依赖这个分析。</p>

        <h3 id="Soundiness"   >
          <a href="#Soundiness" class="heading-link"><i class="fas fa-link"></i></a><a href="#Soundiness" class="headerlink" title="Soundiness"></a>Soundiness</h3>
      <p>2015年是一些学者出来呼吁说程序分析的研究要标注<code>Soundiness</code>。即在发表的研究结果中，某些难以分析的部分需要充分说明，并且标注<code>Soundy</code>，表示告诉读者这部分在努力实现<code>Sound</code>，但是也不一定能够达到<code>Sound</code>。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318110806642.png" alt="image-20230318110806642"></p>

        <h3 id="对比"   >
          <a href="#对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#对比" class="headerlink" title="对比"></a>对比</h3>
      <p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20230318110826465.png" alt="image-20230318110826465"></p>
<ul>
<li><code>Sound</code> : 比较理想化，能够处理程序所有可能的运行结果</li>
<li><code>Soundy</code> : 企图处理程序所有可能的运行结果，但在<code>hard language features</code>可以是<code>unsound</code>的，进行大概处理。</li>
<li><code>Unsound</code> : 为了相关的精度、效率等故意不处理某些部分。</li>
</ul>

        <h2 id="2-Hard-Language-Feature-Java-Reflection"   >
          <a href="#2-Hard-Language-Feature-Java-Reflection" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Hard-Language-Feature-Java-Reflection" class="headerlink" title="2.Hard Language Feature: Java Reflection"></a>2.Hard Language Feature: Java Reflection</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318111512158.png" alt="image-20230318111512158"></p>
<p>对于程序分析而言，<code>JAVA reflection</code>使得分析<code>JAVA</code>变得很困难</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318111619066.png" alt="image-20230318111619066"></p>

        <h3 id="Java-Reflection"   >
          <a href="#Java-Reflection" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-Reflection" class="headerlink" title="Java Reflection"></a>Java Reflection</h3>
      <p>这个可以参考一下<code>p</code>神讲的</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/phith0n/JavaThings" >GitHub - phith0n/JavaThings: Share Things Related to Java - Java安全漫谈笔记相关内容</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318111949117.png" alt="image-20230318111949117"></p>
<p>即利用反射相关<code>API</code>来获取<code>JAVA</code>中类，然后通过类创建对象，获取属性，修改属性等，这里讲得听清楚的。</p>

        <h3 id="Why-We-Need-to-Analyze-Java-Reflection"   >
          <a href="#Why-We-Need-to-Analyze-Java-Reflection" class="heading-link"><i class="fas fa-link"></i></a><a href="#Why-We-Need-to-Analyze-Java-Reflection" class="headerlink" title="Why We Need to Analyze Java Reflection?"></a>Why We Need to Analyze Java Reflection?</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318112836799.png" alt="image-20230318112836799"></p>
<p>依据之前学到的指针分析，其实在分析的时候，不一定能检测出来该指针指向的是哪个对象，也可能分析出来指向多个对象。那么当调用到<code>m.invoke</code>这种反射里面常见的<code>API</code>时，由于<code>m</code>解析不正确，那么就会导致<code>m.invoke</code>没办法正常调用，就会出现<code>bug</code>。</p>
<p>或者在另一个例子中，两条流向会使得<code>a.fld</code>指向两个对象，那么就会导致<code>B b’ = (B) a.fld;</code>的<code>cast</code>发生错误。</p>

        <h3 id="How-to-Analyze-Java-Reflection"   >
          <a href="#How-to-Analyze-Java-Reflection" class="heading-link"><i class="fas fa-link"></i></a><a href="#How-to-Analyze-Java-Reflection" class="headerlink" title="How to Analyze Java Reflection?"></a>How to Analyze Java Reflection?</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318113227337.png" alt="image-20230318113227337"></p>

        <h4 id="String-Constant-Analysis-Pointer-Analysis"   >
          <a href="#String-Constant-Analysis-Pointer-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#String-Constant-Analysis-Pointer-Analysis" class="headerlink" title="String Constant Analysis/Pointer Analysis"></a>String Constant Analysis/Pointer Analysis</h4>
      <p>从<code>05</code>年开始出现一种方法。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318113708808.png" alt="image-20230318113708808"></p>
<p>如果在反射中，相关的字符串通过<code>String Constant Analysis</code>可以求得，那么即可进行相关解析。但是如果没办法求得的时候，比如旁边黄色框列出来的部分，就没办法进行反射解析了。</p>

        <h4 id="Type-Inference-String-analysis-Pointer-Analysis"   >
          <a href="#Type-Inference-String-analysis-Pointer-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#Type-Inference-String-analysis-Pointer-Analysis" class="headerlink" title="Type Inference/String analysis/Pointer Analysis"></a>Type Inference/String analysis/Pointer Analysis</h4>
      <p>14年出现另一个方法，即老师们提出的</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318114007467.png" alt="image-20230318114007467"></p>
<p>概括如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318114151787.png" alt="image-20230318114151787"></p>
<p>即使用该反射的时候可进行解析</p>
<p><img src="../../AppData/Roaming/Typora/typora-user-images/image-20230318115246794.png" alt="image-20230318115246794"></p>
<p>在该例子中，由于函数名是<code>_</code>加上<code>CMD</code>确定的，所以无法准确解析到对应的函数。</p>
<p>观察函数调用点<code>175</code>行，可以看到其<code>parameters</code>是个<code>Object[]</code>数组，那么这里创建的<code>Object[]</code>数组其类型必定在<code>JAVA</code>导入包中某些类，比如这里的<code>FrameworkCommandInterpreter</code>，是其<code>sub/supertypes</code>子类或者父类。</p>
<p>依据这个信息，在<code>JAVA</code>类型系统中寻找匹配相关的函数，会找出来很多函数，在该例子中，有50个函数被找到，其中48个函数都是可能会被调用的，即<code>true</code>。</p>
<p>这方面的最新研究也是老师们的研究最前沿</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318115926089.png" alt="image-20230318115926089"></p>
<p>求解到的反射对象更准确更多，并且可以说出哪里解的不准。</p>

        <h4 id="Assisted-by-Dynamic-Analysis"   >
          <a href="#Assisted-by-Dynamic-Analysis" class="heading-link"><i class="fas fa-link"></i></a><a href="#Assisted-by-Dynamic-Analysis" class="headerlink" title="Assisted by Dynamic Analysis"></a>Assisted by Dynamic Analysis</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318120030439.png" alt="image-20230318120030439"></p>
<p>利用动态分析来求解，比如上面的<code>cmd</code>，将之用一个模糊用例进行动态执行，类似现今很流行的模糊测试，当匹配用例上证明就可能会调用到。</p>
<p>优点是求解出来的一定是准确的，因为必定是可能调用到的。</p>
<p>缺点就是常见的模糊测试的缺点，覆盖路径有限，比较慢。</p>

        <h2 id="3-Hard-Language-Feature-Native-Code"   >
          <a href="#3-Hard-Language-Feature-Native-Code" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Hard-Language-Feature-Native-Code" class="headerlink" title="3.Hard Language Feature: Native Code"></a>3.Hard Language Feature: Native Code</h2>
      
        <h3 id="Native-Code"   >
          <a href="#Native-Code" class="heading-link"><i class="fas fa-link"></i></a><a href="#Native-Code" class="headerlink" title="Native Code"></a>Native Code</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318155627496.png" alt="image-20230318155627496"></p>
<p><code>JAVA</code>代码从头往下的相关函数调用，其中相关的动态链接库中的代码就是<code>Native Code</code>，用<code>IDA</code>打开即为相关的汇编代码，可以直接运行在对应的操作系统<code>CPU</code>上的。但是在下面的分析中，还是看它的源代码形式，比如<code>C/C++</code>形式。</p>

        <h3 id="Java-Native-Interface-JNI"   >
          <a href="#Java-Native-Interface-JNI" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-Native-Interface-JNI" class="headerlink" title="Java Native Interface (JNI)"></a>Java Native Interface (JNI)</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318160018163.png" alt="image-20230318160018163"></p>
<p>用来和相关动态链接库进行交互的编程框架，比如<code>JAVA</code>就可以调用到<code>C/C++</code>编写的动态链接库，即为<code>JNI</code>框架</p>

        <h3 id="Why-Native-Code-is-Hard-to-Analyze"   >
          <a href="#Why-Native-Code-is-Hard-to-Analyze" class="heading-link"><i class="fas fa-link"></i></a><a href="#Why-Native-Code-is-Hard-to-Analyze" class="headerlink" title="Why Native Code is Hard to Analyze?"></a>Why Native Code is Hard to Analyze?</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318162255276.png" alt="image-20230318162255276"></p>
<p>在<code>JNI</code>例子中，首先加载动态链接库，声明函数。其中<code>*env</code>变量用来传递<code>JAVA</code>中相关的一些信息，可以在<code>Native Code</code>中创建对象、属性、调用<code>JAVA</code>中的方法等。主要问题是跨语言之后，如何静态分析<code>je.guessMe()</code>这个调用?</p>
<p>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/1ca6e11b1e72" >【课程笔记】南大软件分析课程12——Soundiness（课时16） - 简书 (jianshu.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>因为<code>Native Code</code>是在库里面了，其源代码基本没有，只有一个接口库文件<code>.so/.dll</code>，那么就比较难进行分析了。</p>

        <h3 id="How-to-Handle-Native-Code"   >
          <a href="#How-to-Handle-Native-Code" class="heading-link"><i class="fas fa-link"></i></a><a href="#How-to-Handle-Native-Code" class="headerlink" title="How to Handle Native Code?"></a>How to Handle Native Code?</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318162203276.png" alt="image-20230318162203276"></p>
<p>手动建模分析</p>

        <h4 id="Native-Code-Modeling-Example"   >
          <a href="#Native-Code-Modeling-Example" class="heading-link"><i class="fas fa-link"></i></a><a href="#Native-Code-Modeling-Example" class="headerlink" title="Native Code Modeling (Example)"></a>Native Code Modeling (Example)</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318163010673.png" alt="image-20230318163010673"></p>
<p>直接将对应的函数简化成<code>JAVA</code>代码来进行分析，相当于<code>hook</code>掉相关的<code>API</code>，然后用类似功能的<code>JAVA</code>代码来替换掉。</p>

        <h4 id="前沿"   >
          <a href="#前沿" class="heading-link"><i class="fas fa-link"></i></a><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h4>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318163145075.png" alt="image-20230318163145075"></p>
<p>前沿的一些分析，此外可以参考<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://soundiness.org进行深入研究./" >http://soundiness.org进行深入研究。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="总结-10"   >
          <a href="#总结-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230318163231858.png" alt="image-20230318163231858"></p>
<p>理解<code>Soundiness</code>的大概概念，以及<code>JAVA</code>反射机制和<code>Native Code</code>为什么比较难分析。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://PIG-007.github.io">PIG-007</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://pig-007.github.io/2023/02/01/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/">http://pig-007.github.io/2023/02/01/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://pig-007.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/">软件分析</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2023/03/07/VulHub%E5%88%B7%E9%A2%98/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Vulhub刷题</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2023/01/05/IOT%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"><span class="paginator-prev__text">IOT环境搭建</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">
          前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Intermediate-Representation"><span class="toc-text">
          一、Intermediate Representation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91"><span class="toc-text">
          1.中间语言编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%87%E7%A8%8B"><span class="toc-text">
          (1)过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AST%E5%92%8CIR"><span class="toc-text">
          (2)AST和IR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Soot%E5%B8%B8%E8%A7%81%E5%88%86%E6%9E%90"><span class="toc-text">
          2.Soot常见分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#For%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%AD%90"><span class="toc-text">
          For循环例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-while%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84%E4%BE%8B%E5%AD%90"><span class="toc-text">
          do-while以及数组例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-text">
          函数调用例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB"><span class="toc-text">
          静态变量和类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SSA-Static-Single-Assignment"><span class="toc-text">
          3.SSA(Static Single Assignment)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9F%BA%E7%A1%80%E5%9D%97-Basic-Block"><span class="toc-text">
          4.基础块(Basic Block)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">
          定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">
          方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-CFG-Control-Flow-Graph"><span class="toc-text">
          5.CFG(Control Flow Graph)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-1"><span class="toc-text">
          定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A-1"><span class="toc-text">
          方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Data-Flow-Analysis-I"><span class="toc-text">
          二、Data Flow Analysis I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">
          1.基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AC%A6%E5%8F%B7"><span class="toc-text">
          常见符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IN-S-%E5%92%8COUT-S"><span class="toc-text">
          IN[S]和OUT[S]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%96%B9%E5%90%91"><span class="toc-text">
          分析方向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-text">
          2.BB之间的分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Reaching-Definition"><span class="toc-text">
          3.Reaching Definition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Flow-Facts"><span class="toc-text">
          Data Flow Facts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Control-Flow"><span class="toc-text">
          Control Flow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transfer-Function"><span class="toc-text">
          Transfer Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithm"><span class="toc-text">
          Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">
          例子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-text">
          第一次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-text">
          第二次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-text">
          第三次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E5%90%AB%E4%B9%89"><span class="toc-text">
          最终含义</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Data-Flow-Analysis-Applications-II"><span class="toc-text">
          三、Data Flow Analysis - Applications II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Live-Variables-Analysis"><span class="toc-text">
          1.Live Variables Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Flow-Facts-1"><span class="toc-text">
          Data Flow Facts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Control-Flow-1"><span class="toc-text">
          Control Flow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transfer-Function-1"><span class="toc-text">
          Transfer Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithm-1"><span class="toc-text">
          Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-text">
          例子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">
          第一次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">
          第二次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">
          第三次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E5%90%AB%E4%B9%89-1"><span class="toc-text">
          最终含义</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Available-Expressions-Analysis"><span class="toc-text">
          2.Available Expressions Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Flow-Facts-2"><span class="toc-text">
          Data Flow Facts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Control-Flow-2"><span class="toc-text">
          Control Flow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transfer-Function-2"><span class="toc-text">
          Transfer Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithm-2"><span class="toc-text">
          Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-text">
          例子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%AD%E4%BB%A3-2"><span class="toc-text">
          第一次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BF%AD%E4%BB%A3-2"><span class="toc-text">
          第二次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E5%90%AB%E4%B9%89-2"><span class="toc-text">
          最终含义</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Data-Flow-Analysis%E6%80%BB%E7%BB%93"><span class="toc-text">
          3.Data Flow Analysis总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%90%8C"><span class="toc-text">
          异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84"><span class="toc-text">
          需要掌握的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Data-Flow-Analysis-Foundations-I"><span class="toc-text">
          四、Data Flow Analysis - Foundations I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%81%8F%E5%BA%8F-Partial-Order"><span class="toc-text">
          1.偏序(Partial Order)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Upper-and-Lower-Bounds"><span class="toc-text">
          2.Upper and Lower Bounds</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Lattice"><span class="toc-text">
          3.Lattice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lattice-%E6%A0%BC"><span class="toc-text">
          Lattice(格)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semilattice-%E5%8D%8A%E6%A0%BC"><span class="toc-text">
          Semilattice(半格)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Complete-Lattic-%E5%85%A8%E6%A0%BC"><span class="toc-text">
          Complete Lattic(全格)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-2"><span class="toc-text">
          定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8%EF%BC%9A"><span class="toc-text">
          性质：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Product-Lattice"><span class="toc-text">
          Product Lattice</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Fixed-Point"><span class="toc-text">
          4.Fixed-Point</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Monotonicity-%E5%8D%95%E8%B0%83"><span class="toc-text">
          Monotonicity(单调)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fixed-Point-Theorem-%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%90%86%E8%AE%BA"><span class="toc-text">
          Fixed-Point Theorem(不动点理论)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%8A%A8%E7%82%B9"><span class="toc-text">
          最小不动点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AB%E4%B9%89"><span class="toc-text">
          含义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%81%E6%98%8E"><span class="toc-text">
          证明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%B8%8D%E5%8A%A8%E7%82%B9"><span class="toc-text">
          最大不动点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AB%E4%B9%89-1"><span class="toc-text">
          含义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%81%E6%98%8E-1"><span class="toc-text">
          证明</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BA%94%E7%94%A8"><span class="toc-text">
          5.应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%BA%94%E7%94%A8"><span class="toc-text">
          理论应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-text">
          问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Data-Flow-Analysis-Foundations-II"><span class="toc-text">
          五、Data Flow Analysis - Foundations II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Prove-Function-F-is-Monotonic"><span class="toc-text">
          1.Prove Function F is Monotonic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-text">
          分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%81%E6%98%8E%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">
          证明如下：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Time-Complexity"><span class="toc-text">
          2.Time Complexity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-May-and-Must-Analyses-a-Lattice-View"><span class="toc-text">
          3.May and Must Analyses,a Lattice View</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-How-Precise-Is-Our-Solution"><span class="toc-text">
          4.How Precise Is Our Solution</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Meet-Over-All-Paths-Solution-MOP"><span class="toc-text">
          Meet-Over-All-Paths Solution(MOP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MOP-vs-Ours-Iterative-Algorithm"><span class="toc-text">
          MOP vs Ours(Iterative Algorithm)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Constant-Propagation"><span class="toc-text">
          5.Constant Propagation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Flow-Facts-3"><span class="toc-text">
          Data Flow Facts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Control-Flow-3"><span class="toc-text">
          Control Flow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transfer-Function-3"><span class="toc-text">
          Transfer Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Worklist-Algorithm"><span class="toc-text">
          Worklist Algorithm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Foundations%E6%80%BB%E7%BB%93"><span class="toc-text">
          Foundations总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81Interprocedural-Analysis"><span class="toc-text">
          六、Interprocedural Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Motivation"><span class="toc-text">
          1.Motivation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">
          一些定义：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Call-Graph-Construction"><span class="toc-text">
          2.Call Graph Construction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">
          定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8%E5%9B%BE%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-text">
          面向对象语言调用图常见算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Method-Calls-Invocations-in-Java"><span class="toc-text">
          3.Method Calls (Invocations) in Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-Dispatch-of-Vitual-Calls"><span class="toc-text">
          Method Dispatch of Vitual Calls</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">
          定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dispatch-Function-Defination"><span class="toc-text">
          Dispatch Function Defination</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-3"><span class="toc-text">
          例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Class-Hierarchy-Analysis-CHA"><span class="toc-text">
          4.Class Hierarchy Analysis(CHA)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Call-Resolution-of-CHA"><span class="toc-text">
          Call Resolution of CHA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static-call"><span class="toc-text">
          static call</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#speciall-call"><span class="toc-text">
          speciall call</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#superclass-instance-methods"><span class="toc-text">
          superclass instance methods</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Constructors-Private-instance-mthods"><span class="toc-text">
          Constructors&#x2F;Private instance mthods</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vitural-call"><span class="toc-text">
          vitural call</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90"><span class="toc-text">
          实际例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Features-of-CHA"><span class="toc-text">
          Features of CHA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Advantage"><span class="toc-text">
          Advantage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Disadvantage"><span class="toc-text">
          Disadvantage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithm-3"><span class="toc-text">
          Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-4"><span class="toc-text">
          例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Interprocedural-Control-Flow-Graph"><span class="toc-text">
          5.Interprocedural Control-Flow Graph</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Interprocedural-Data-Flow-Analysis"><span class="toc-text">
          6.Interprocedural Data-Flow Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Interprocedural-Constant-Propagation"><span class="toc-text">
          Interprocedural Constant Propagation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-text">
          实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94Intraprocedural-Constant-Propagation"><span class="toc-text">
          类比Intraprocedural Constant Propagation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Pointer-Analysis"><span class="toc-text">
          七、Pointer Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Motivation-1"><span class="toc-text">
          1.Motivation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Introduction-to-Pointer-Analysis"><span class="toc-text">
          2.Introduction to Pointer Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-5"><span class="toc-text">
          例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">
          应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Key-Factors-of-Pointer-Analysis"><span class="toc-text">
          3.Key Factors of Pointer Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-Abstraction"><span class="toc-text">
          Heap Abstraction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Allocation-Site-Abstraction"><span class="toc-text">
          Allocation-Site Abstraction</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-sentivity"><span class="toc-text">
          Context sentivity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flow-Insentivity"><span class="toc-text">
          Flow Insentivity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analysis-Scope"><span class="toc-text">
          Analysis Scope</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Pointers-in-Java"><span class="toc-text">
          4.Pointers in Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E7%9A%84%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">
          关注的指针类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E7%9A%84%E6%8C%87%E9%92%88%E8%AF%AD%E5%8F%A5"><span class="toc-text">
          关注的指针语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81Pointer-Analysis-Foundations-I"><span class="toc-text">
          八、Pointer Analysis Foundations (I)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89"><span class="toc-text">
          相关概念定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Rules"><span class="toc-text">
          1.Rules</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Rule-New"><span class="toc-text">
          Rule : New</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rule-Assign"><span class="toc-text">
          Rule : Assign</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rule-Store"><span class="toc-text">
          Rule : Store</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rule-Load"><span class="toc-text">
          Rule : Load</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-How-to-Implement-Pointer-Analysis"><span class="toc-text">
          2.How to Implement Pointer Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pointer-Flow-Graph-PFG"><span class="toc-text">
          Pointer Flow Graph(PFG)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">
          概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-text">
          实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Propagate-points-to-information-on-PFG"><span class="toc-text">
          Propagate points-to information on PFG</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Pointer-Analysis-Algorithms"><span class="toc-text">
          3.Pointer Analysis: Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Handling-of-New-and-Assign"><span class="toc-text">
          Handling of New and Assign</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Initialize"><span class="toc-text">
          Initialize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Propagate"><span class="toc-text">
          Propagate</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Differential-Propagation"><span class="toc-text">
          Differential Propagation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handling-of-Store-and-Load"><span class="toc-text">
          Handling of Store and Load</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="toc-text">
          实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#New%E5%A4%84%E7%90%86"><span class="toc-text">
          New处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Assign%E5%A4%84%E7%90%86"><span class="toc-text">
          Assign处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WL%E5%A4%84%E7%90%86"><span class="toc-text">
          WL处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%AD%E4%BB%A3-3"><span class="toc-text">
          第一次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BF%AD%E4%BB%A3-3"><span class="toc-text">
          第二次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%BF%AD%E4%BB%A3-2"><span class="toc-text">
          第三次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-text">
          第四次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-text">
          第五次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-text">
          第六次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-text">
          第七次迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E6%AC%A1%E8%BF%AD%E4%BB%A3"><span class="toc-text">
          第八次迭代</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Pointer-Analysis-Foundations-II"><span class="toc-text">
          九、Pointer Analysis Foundations (II)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Pointer-Analysis-with-Method-Calls"><span class="toc-text">
          4.Pointer Analysis with Method Calls</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Rule-Call"><span class="toc-text">
          Rule : Call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithms"><span class="toc-text">
          Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AddReachable-%F0%9D%91%9A"><span class="toc-text">
          AddReachable(𝑚)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProcessCall-%F0%9D%91%A5-O%F0%9D%91%96"><span class="toc-text">
          ProcessCall(𝑥, O𝑖)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Output"><span class="toc-text">
          Output</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-3"><span class="toc-text">
          实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">
          初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WL%E5%A4%84%E7%90%86-1"><span class="toc-text">
          WL处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%AD%E4%BB%A3-4"><span class="toc-text">
          第一次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BF%AD%E4%BB%A3-4"><span class="toc-text">
          第二次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%BF%AD%E4%BB%A3-3"><span class="toc-text">
          第三次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">
          第四次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AC%A1%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">
          第五次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E6%AC%A1%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">
          第六次迭代</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81Pointer-Analysis-Context-Sensitivity-I"><span class="toc-text">
          十、Pointer Analysis Context Sensitivity (I)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Problem-of-Context-Insensitive-Pointer-Analysis"><span class="toc-text">
          Problem of Context-Insensitive  Pointer Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Introduction"><span class="toc-text">
          1.Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Imprecision-of-Context-Insensitivity-C-I"><span class="toc-text">
          Imprecision of Context Insensitivity (C.I.)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-Sensitivity-C-S"><span class="toc-text">
          Context Sensitivity (C.S.)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call-site-sensitivity-call-string"><span class="toc-text">
          call-site  sensitivity (call-string)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-Sensitive-Heap"><span class="toc-text">
          Context-Sensitive Heap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90-1"><span class="toc-text">
          实际例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Context-Sensitive-Pointer-Analysis-Rules"><span class="toc-text">
          2.Context Sensitive Pointer Analysis: Rules</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Domain"><span class="toc-text">
          Domain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rules"><span class="toc-text">
          Rules</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rule-New-1"><span class="toc-text">
          Rule: New</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rule-Assign-1"><span class="toc-text">
          Rule: Assign</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rule-Store-1"><span class="toc-text">
          Rule: Store</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rule-Load-1"><span class="toc-text">
          Rule: Load</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-text">
          小总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rule-Call-1"><span class="toc-text">
          Rule: Call</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Pointer-Analysis-Context-Sensitivity-II"><span class="toc-text">
          十一、Pointer Analysis Context Sensitivity (II)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Context-Sensitive-Pointer-Analysis-Algorithms"><span class="toc-text">
          3.Context Sensitive Pointer Analysis: Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AddReachable-%F0%9D%91%90-%F0%9D%91%9A"><span class="toc-text">
          AddReachable(𝑐:𝑚)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AddEdge-Propagate"><span class="toc-text">
          AddEdge&#x2F;Propagate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Load-Store"><span class="toc-text">
          Load&#x2F;Store</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ProcessCall-%F0%9D%91%90-%F0%9D%91%A5-%F0%9D%91%90%E2%80%B2-O%F0%9D%91%96"><span class="toc-text">
          ProcessCall(𝑐:𝑥, 𝑐′:O𝑖)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Context-Sensitivity-Variants"><span class="toc-text">
          4.Context Sensitivity Variants</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Context-Insensitivity"><span class="toc-text">
          Context Insensitivity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Call-Site-Sensitivity"><span class="toc-text">
          Call-Site Sensitivity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k-Call-Site-Sensitivity-k-CFA"><span class="toc-text">
          k-Call-Site Sensitivity&#x2F;k-CFA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-4"><span class="toc-text">
          实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-text">
          初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WL%E5%A4%84%E7%90%86-2"><span class="toc-text">
          WL处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%AD%E4%BB%A3-5"><span class="toc-text">
          第一次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BF%AD%E4%BB%A3-5"><span class="toc-text">
          第二次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%BF%AD%E4%BB%A3-4"><span class="toc-text">
          第三次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E8%BF%AD%E4%BB%A3-2"><span class="toc-text">
          第四次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AC%A1%E8%BF%AD%E4%BB%A3-2"><span class="toc-text">
          第五次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E6%AC%A1%E8%BF%AD%E4%BB%A3-2"><span class="toc-text">
          第六次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E6%AC%A1%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">
          第七次迭代</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E6%AC%A1%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">
          第八次迭代</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-Sensitivity"><span class="toc-text">
          Object Sensitivity</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-5"><span class="toc-text">
          实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Call-Site%E5%92%8CObject-Sensitivity%E5%AF%B9%E6%AF%94"><span class="toc-text">
          Call-Site和Object-Sensitivity对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Type-Sensitivity"><span class="toc-text">
          Type Sensitivity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="toc-text">
          总结对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81Static-Program-Analysis"><span class="toc-text">
          十二、Static Program Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Information-Flow-Security"><span class="toc-text">
          1.Information Flow Security</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Information-Flow"><span class="toc-text">
          Information Flow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Security-levels-Classes"><span class="toc-text">
          Security levels(Classes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Information-Flow-Policy"><span class="toc-text">
          Information Flow Policy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Noninterference"><span class="toc-text">
          Noninterference</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Confidentiality-and-Integrity"><span class="toc-text">
          2.Confidentiality and Integrity</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Integrity"><span class="toc-text">
          Integrity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Confidentialityt"><span class="toc-text">
          Confidentialityt</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Explicit-Flows-and-Covert-Channels"><span class="toc-text">
          3.Explicit Flows and Covert Channels</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Implicit-Flows"><span class="toc-text">
          Implicit Flows</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E4%BE%8B%E5%AD%90"><span class="toc-text">
          更多例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Covert-Hidden-Channels"><span class="toc-text">
          Covert&#x2F;Hidden Channels</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Explicit-Flows"><span class="toc-text">
          Explicit Flows</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Taint-Analysis"><span class="toc-text">
          4.Taint Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Taint-and-Pointer-Analysis"><span class="toc-text">
          Taint and Pointer Analysis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Domains-and-Notations"><span class="toc-text">
          Domains and Notations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rules-1"><span class="toc-text">
          Rules</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rules-Sources"><span class="toc-text">
          Rules:Sources</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rules-Propagate"><span class="toc-text">
          Rules:Propagate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rules-sink"><span class="toc-text">
          Rules:sink</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-6"><span class="toc-text">
          实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81Datalog-Based-Program-Analysis"><span class="toc-text">
          十三、Datalog-Based Program Analysis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Motivation-2"><span class="toc-text">
          1.Motivation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pointer-Analysis-Imperative-Implementation"><span class="toc-text">
          Pointer Analysis, Imperative  Implementation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pointer-Analysis-Declarative-Implementation-via-Datalog"><span class="toc-text">
          Pointer Analysis, Declarative  Implementation (via Datalog)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Introduction-to-Datalog"><span class="toc-text">
          2.Introduction to Datalog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicates-Data"><span class="toc-text">
          Predicates(Data)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atoms"><span class="toc-text">
          Atoms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#relational-atom"><span class="toc-text">
          relational atom</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rules-2"><span class="toc-text">
          Rules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EDB-and-IDB-Predicates"><span class="toc-text">
          EDB and IDB Predicates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logical-Or"><span class="toc-text">
          Logical Or</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Negation"><span class="toc-text">
          Negation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recursion"><span class="toc-text">
          Recursion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rule-Safety"><span class="toc-text">
          Rule Safety</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recursion-and-Negation"><span class="toc-text">
          Recursion and Negation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Execution-of-Datalog-Programs"><span class="toc-text">
          Execution of Datalog Programs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Pointer-Analysis-via-Datalog"><span class="toc-text">
          3.Pointer Analysis via Datalog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">
          相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EDB"><span class="toc-text">
          EDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rules-3"><span class="toc-text">
          Rules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Call"><span class="toc-text">
          Call</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#one"><span class="toc-text">
          one</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#two"><span class="toc-text">
          two</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#three"><span class="toc-text">
          three</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-7"><span class="toc-text">
          实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EDB-1"><span class="toc-text">
          EDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rules-4"><span class="toc-text">
          Rules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Whole-Program-Pointer-Analysis"><span class="toc-text">
          Whole-Program Pointer Analysis</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Taint-Analysis-via-Datalog"><span class="toc-text">
          4.Taint Analysis via Datalog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-1"><span class="toc-text">
          相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#source-sink"><span class="toc-text">
          source&#x2F;sink</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">
          优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9Pros"><span class="toc-text">
          优点Pros</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9Cons"><span class="toc-text">
          缺点Cons</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81CFL-Reachability-and-IFDS"><span class="toc-text">
          十四、CFL-Reachability and IFDS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Feasible-and-Realizable-Paths"><span class="toc-text">
          1.Feasible and Realizable Paths</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Infeasible-Paths"><span class="toc-text">
          Infeasible Paths:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Realizable-Paths"><span class="toc-text">
          Realizable Paths:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CFL-Reachability"><span class="toc-text">
          2.CFL-Reachability</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Overview-of-IFDS"><span class="toc-text">
          3.Overview of IFDS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-text">
          概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Meet-Over-All-Realizable-Paths-MRP"><span class="toc-text">
          Meet-Over-All-Realizable-Paths (MRP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Supergraph"><span class="toc-text">
          Supergraph</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#G"><span class="toc-text">
          G*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Design-Flow-Functions"><span class="toc-text">
          Design Flow Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-6"><span class="toc-text">
          例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exploded-Supergraph"><span class="toc-text">
          Exploded Supergraph</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-text">
          概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rule%E8%A7%84%E5%88%99"><span class="toc-text">
          Rule规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Why-We-Need-Edge-0-%E2%9F%B6-0"><span class="toc-text">
          Why We Need Edge 0 ⟶ 0?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-7"><span class="toc-text">
          例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tabulation-Algorithm"><span class="toc-text">
          Tabulation Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Core-Working-Mechanism-of-Tabulation-Algorithm"><span class="toc-text">
          Core Working Mechanism of Tabulation Algorithm</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Understanding-the-Distributivity-of-IFDS"><span class="toc-text">
          4.Understanding the Distributivity of IFDS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Distributivity"><span class="toc-text">
          Distributivity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constant-Propagation"><span class="toc-text">
          Constant Propagation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pointer-Analysis"><span class="toc-text">
          Pointer Analysis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81Soundness-and-Soundiness"><span class="toc-text">
          十五、Soundness and Soundiness</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Soundness-and-Soundiness"><span class="toc-text">
          1.Soundness and Soundiness</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Soundness"><span class="toc-text">
          Soundness</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hard-Language-Features-for-Static-Analysis"><span class="toc-text">
          Hard Language Features for Static Analysis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Soundiness"><span class="toc-text">
          Soundiness</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">
          对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Hard-Language-Feature-Java-Reflection"><span class="toc-text">
          2.Hard Language Feature: Java Reflection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Reflection"><span class="toc-text">
          Java Reflection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-We-Need-to-Analyze-Java-Reflection"><span class="toc-text">
          Why We Need to Analyze Java Reflection?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-Analyze-Java-Reflection"><span class="toc-text">
          How to Analyze Java Reflection?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-Constant-Analysis-Pointer-Analysis"><span class="toc-text">
          String Constant Analysis&#x2F;Pointer Analysis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Type-Inference-String-analysis-Pointer-Analysis"><span class="toc-text">
          Type Inference&#x2F;String analysis&#x2F;Pointer Analysis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Assisted-by-Dynamic-Analysis"><span class="toc-text">
          Assisted by Dynamic Analysis</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Hard-Language-Feature-Native-Code"><span class="toc-text">
          3.Hard Language Feature: Native Code</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Native-Code"><span class="toc-text">
          Native Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-Native-Interface-JNI"><span class="toc-text">
          Java Native Interface (JNI)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-Native-Code-is-Hard-to-Analyze"><span class="toc-text">
          Why Native Code is Hard to Analyze?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-Handle-Native-Code"><span class="toc-text">
          How to Handle Native Code?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Native-Code-Modeling-Example"><span class="toc-text">
          Native Code Modeling (Example)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%B2%BF"><span class="toc-text">
          前沿</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-text">
          总结</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsauthor.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">The way forward</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">139</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">93</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">79</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2024</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>PIG-007</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.4.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="Search for Posts (Support multiple keywords)"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ Untitled ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', 'Please enter characters');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/wanko.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-80},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>